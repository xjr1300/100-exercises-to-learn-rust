<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>100 Exercises To Learn Rust</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="01_intro/00_welcome.html"><strong aria-hidden="true">1.</strong> Welcome</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="01_intro/01_syntax.html"><strong aria-hidden="true">1.1.</strong> Syntax</a></li></ol></li><li class="chapter-item expanded "><a href="02_basic_calculator/00_intro.html"><strong aria-hidden="true">2.</strong> A Basic Calculator</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="02_basic_calculator/01_integers.html"><strong aria-hidden="true">2.1.</strong> Integers</a></li><li class="chapter-item expanded "><a href="02_basic_calculator/02_variables.html"><strong aria-hidden="true">2.2.</strong> Variables</a></li><li class="chapter-item expanded "><a href="02_basic_calculator/03_if_else.html"><strong aria-hidden="true">2.3.</strong> Branching: if/else</a></li><li class="chapter-item expanded "><a href="02_basic_calculator/04_panics.html"><strong aria-hidden="true">2.4.</strong> Panics</a></li><li class="chapter-item expanded "><a href="02_basic_calculator/05_factorial.html"><strong aria-hidden="true">2.5.</strong> Factorial</a></li><li class="chapter-item expanded "><a href="02_basic_calculator/06_while.html"><strong aria-hidden="true">2.6.</strong> Loops: while</a></li><li class="chapter-item expanded "><a href="02_basic_calculator/07_for.html"><strong aria-hidden="true">2.7.</strong> Loops: for</a></li><li class="chapter-item expanded "><a href="02_basic_calculator/08_overflow.html"><strong aria-hidden="true">2.8.</strong> Overflow and underflow</a></li><li class="chapter-item expanded "><a href="02_basic_calculator/09_saturating.html"><strong aria-hidden="true">2.9.</strong> Saturating arithmetic</a></li><li class="chapter-item expanded "><a href="02_basic_calculator/10_as_casting.html"><strong aria-hidden="true">2.10.</strong> Conversions: as casting</a></li></ol></li><li class="chapter-item expanded "><a href="03_ticket_v1/00_intro.html"><strong aria-hidden="true">3.</strong> Ticket v1</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="03_ticket_v1/01_struct.html"><strong aria-hidden="true">3.1.</strong> Structs</a></li><li class="chapter-item expanded "><a href="03_ticket_v1/02_validation.html"><strong aria-hidden="true">3.2.</strong> Validation</a></li><li class="chapter-item expanded "><a href="03_ticket_v1/03_modules.html"><strong aria-hidden="true">3.3.</strong> Modules</a></li><li class="chapter-item expanded "><a href="03_ticket_v1/04_visibility.html"><strong aria-hidden="true">3.4.</strong> Visibility</a></li><li class="chapter-item expanded "><a href="03_ticket_v1/05_encapsulation.html"><strong aria-hidden="true">3.5.</strong> Encapsulation</a></li><li class="chapter-item expanded "><a href="03_ticket_v1/06_ownership.html"><strong aria-hidden="true">3.6.</strong> Ownership</a></li><li class="chapter-item expanded "><a href="03_ticket_v1/07_setters.html"><strong aria-hidden="true">3.7.</strong> Setters</a></li><li class="chapter-item expanded "><a href="03_ticket_v1/08_stack.html"><strong aria-hidden="true">3.8.</strong> Stack</a></li><li class="chapter-item expanded "><a href="03_ticket_v1/09_heap.html"><strong aria-hidden="true">3.9.</strong> Heap</a></li><li class="chapter-item expanded "><a href="03_ticket_v1/10_references_in_memory.html"><strong aria-hidden="true">3.10.</strong> References in memory</a></li><li class="chapter-item expanded "><a href="03_ticket_v1/11_destructor.html"><strong aria-hidden="true">3.11.</strong> Destructors</a></li><li class="chapter-item expanded "><a href="03_ticket_v1/12_outro.html"><strong aria-hidden="true">3.12.</strong> Outro</a></li></ol></li><li class="chapter-item expanded "><a href="04_traits/00_intro.html"><strong aria-hidden="true">4.</strong> Traits</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="04_traits/01_trait.html"><strong aria-hidden="true">4.1.</strong> Trait</a></li><li class="chapter-item expanded "><a href="04_traits/02_orphan_rule.html"><strong aria-hidden="true">4.2.</strong> Orphan rule</a></li><li class="chapter-item expanded "><a href="04_traits/03_operator_overloading.html"><strong aria-hidden="true">4.3.</strong> Operator overloading</a></li><li class="chapter-item expanded "><a href="04_traits/04_derive.html"><strong aria-hidden="true">4.4.</strong> Derive macros</a></li><li class="chapter-item expanded "><a href="04_traits/05_trait_bounds.html"><strong aria-hidden="true">4.5.</strong> Trait bounds</a></li><li class="chapter-item expanded "><a href="04_traits/06_str_slice.html"><strong aria-hidden="true">4.6.</strong> String slices</a></li><li class="chapter-item expanded "><a href="04_traits/07_deref.html"><strong aria-hidden="true">4.7.</strong> Deref trait</a></li><li class="chapter-item expanded "><a href="04_traits/08_sized.html"><strong aria-hidden="true">4.8.</strong> Sized trait</a></li><li class="chapter-item expanded "><a href="04_traits/09_from.html"><strong aria-hidden="true">4.9.</strong> From trait</a></li><li class="chapter-item expanded "><a href="04_traits/10_assoc_vs_generic.html"><strong aria-hidden="true">4.10.</strong> Associated vs generic types</a></li><li class="chapter-item expanded "><a href="04_traits/11_clone.html"><strong aria-hidden="true">4.11.</strong> Clone trait</a></li><li class="chapter-item expanded "><a href="04_traits/12_copy.html"><strong aria-hidden="true">4.12.</strong> Copy trait</a></li><li class="chapter-item expanded "><a href="04_traits/13_drop.html"><strong aria-hidden="true">4.13.</strong> Drop trait</a></li><li class="chapter-item expanded "><a href="04_traits/14_outro.html"><strong aria-hidden="true">4.14.</strong> Outro</a></li></ol></li><li class="chapter-item expanded "><a href="05_ticket_v2/00_intro.html"><strong aria-hidden="true">5.</strong> Ticket v2</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="05_ticket_v2/01_enum.html"><strong aria-hidden="true">5.1.</strong> Enums</a></li><li class="chapter-item expanded "><a href="05_ticket_v2/02_match.html"><strong aria-hidden="true">5.2.</strong> Branching: match</a></li><li class="chapter-item expanded "><a href="05_ticket_v2/03_variants_with_data.html"><strong aria-hidden="true">5.3.</strong> Variants with data</a></li><li class="chapter-item expanded "><a href="05_ticket_v2/04_if_let.html"><strong aria-hidden="true">5.4.</strong> Branching: if let and let/else</a></li><li class="chapter-item expanded "><a href="05_ticket_v2/05_nullability.html"><strong aria-hidden="true">5.5.</strong> Nullability</a></li><li class="chapter-item expanded "><a href="05_ticket_v2/06_fallibility.html"><strong aria-hidden="true">5.6.</strong> Fallibility</a></li><li class="chapter-item expanded "><a href="05_ticket_v2/07_unwrap.html"><strong aria-hidden="true">5.7.</strong> Unwrap</a></li><li class="chapter-item expanded "><a href="05_ticket_v2/08_error_enums.html"><strong aria-hidden="true">5.8.</strong> Error enums</a></li><li class="chapter-item expanded "><a href="05_ticket_v2/09_error_trait.html"><strong aria-hidden="true">5.9.</strong> Error trait</a></li><li class="chapter-item expanded "><a href="05_ticket_v2/10_packages.html"><strong aria-hidden="true">5.10.</strong> Packages</a></li><li class="chapter-item expanded "><a href="05_ticket_v2/11_dependencies.html"><strong aria-hidden="true">5.11.</strong> Dependencies</a></li><li class="chapter-item expanded "><a href="05_ticket_v2/12_thiserror.html"><strong aria-hidden="true">5.12.</strong> thiserror</a></li><li class="chapter-item expanded "><a href="05_ticket_v2/13_try_from.html"><strong aria-hidden="true">5.13.</strong> TryFrom trait</a></li><li class="chapter-item expanded "><a href="05_ticket_v2/14_source.html"><strong aria-hidden="true">5.14.</strong> Error::source</a></li><li class="chapter-item expanded "><a href="05_ticket_v2/15_outro.html"><strong aria-hidden="true">5.15.</strong> Outro</a></li></ol></li><li class="chapter-item expanded "><a href="06_ticket_management/00_intro.html"><strong aria-hidden="true">6.</strong> Ticket Management</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="06_ticket_management/01_arrays.html"><strong aria-hidden="true">6.1.</strong> Arrays</a></li><li class="chapter-item expanded "><a href="06_ticket_management/02_vec.html"><strong aria-hidden="true">6.2.</strong> Vectors</a></li><li class="chapter-item expanded "><a href="06_ticket_management/03_resizing.html"><strong aria-hidden="true">6.3.</strong> Resizing</a></li><li class="chapter-item expanded "><a href="06_ticket_management/04_iterators.html"><strong aria-hidden="true">6.4.</strong> Iterators</a></li><li class="chapter-item expanded "><a href="06_ticket_management/05_iter.html"><strong aria-hidden="true">6.5.</strong> Iter</a></li><li class="chapter-item expanded "><a href="06_ticket_management/06_lifetimes.html"><strong aria-hidden="true">6.6.</strong> Lifetimes</a></li><li class="chapter-item expanded "><a href="06_ticket_management/07_combinators.html"><strong aria-hidden="true">6.7.</strong> Combinators</a></li><li class="chapter-item expanded "><a href="06_ticket_management/08_impl_trait.html"><strong aria-hidden="true">6.8.</strong> impl Trait</a></li><li class="chapter-item expanded "><a href="06_ticket_management/09_impl_trait_2.html"><strong aria-hidden="true">6.9.</strong> impl Trait, pt.2</a></li><li class="chapter-item expanded "><a href="06_ticket_management/10_slices.html"><strong aria-hidden="true">6.10.</strong> Slices</a></li><li class="chapter-item expanded "><a href="06_ticket_management/11_mutable_slices.html"><strong aria-hidden="true">6.11.</strong> Mutable slices</a></li><li class="chapter-item expanded "><a href="06_ticket_management/12_two_states.html"><strong aria-hidden="true">6.12.</strong> Two states</a></li><li class="chapter-item expanded "><a href="06_ticket_management/13_index.html"><strong aria-hidden="true">6.13.</strong> Index trait</a></li><li class="chapter-item expanded "><a href="06_ticket_management/14_index_mut.html"><strong aria-hidden="true">6.14.</strong> IndexMut trait</a></li><li class="chapter-item expanded "><a href="06_ticket_management/15_hashmap.html"><strong aria-hidden="true">6.15.</strong> HashMap</a></li><li class="chapter-item expanded "><a href="06_ticket_management/16_btreemap.html"><strong aria-hidden="true">6.16.</strong> BTreeMap</a></li></ol></li><li class="chapter-item expanded "><a href="07_threads/00_intro.html"><strong aria-hidden="true">7.</strong> Threads</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="07_threads/01_threads.html"><strong aria-hidden="true">7.1.</strong> Threads</a></li><li class="chapter-item expanded "><a href="07_threads/02_static.html"><strong aria-hidden="true">7.2.</strong> 'static lifetime</a></li><li class="chapter-item expanded "><a href="07_threads/03_leak.html"><strong aria-hidden="true">7.3.</strong> Leaking memory</a></li><li class="chapter-item expanded "><a href="07_threads/04_scoped_threads.html"><strong aria-hidden="true">7.4.</strong> Scoped threads</a></li><li class="chapter-item expanded "><a href="07_threads/05_channels.html"><strong aria-hidden="true">7.5.</strong> Channels</a></li><li class="chapter-item expanded "><a href="07_threads/06_interior_mutability.html"><strong aria-hidden="true">7.6.</strong> Interior mutability</a></li><li class="chapter-item expanded "><a href="07_threads/07_ack.html"><strong aria-hidden="true">7.7.</strong> Ack pattern</a></li><li class="chapter-item expanded "><a href="07_threads/08_client.html"><strong aria-hidden="true">7.8.</strong> Client</a></li><li class="chapter-item expanded "><a href="07_threads/09_bounded.html"><strong aria-hidden="true">7.9.</strong> Bounded channels</a></li><li class="chapter-item expanded "><a href="07_threads/10_patch.html"><strong aria-hidden="true">7.10.</strong> Patching</a></li><li class="chapter-item expanded "><a href="07_threads/11_locks.html"><strong aria-hidden="true">7.11.</strong> Mutex, Send and Arc</a></li><li class="chapter-item expanded "><a href="07_threads/12_rw_lock.html"><strong aria-hidden="true">7.12.</strong> RwLock</a></li><li class="chapter-item expanded "><a href="07_threads/13_without_channels.html"><strong aria-hidden="true">7.13.</strong> Without channels</a></li><li class="chapter-item expanded "><a href="07_threads/14_sync.html"><strong aria-hidden="true">7.14.</strong> Sync trait</a></li></ol></li><li class="chapter-item expanded "><a href="08_futures/00_intro.html"><strong aria-hidden="true">8.</strong> Futures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="08_futures/01_async_fn.html"><strong aria-hidden="true">8.1.</strong> Asynchronous functions</a></li><li class="chapter-item expanded "><a href="08_futures/02_spawn.html"><strong aria-hidden="true">8.2.</strong> Spawning tasks</a></li><li class="chapter-item expanded "><a href="08_futures/03_runtime.html"><strong aria-hidden="true">8.3.</strong> Runtime</a></li><li class="chapter-item expanded "><a href="08_futures/04_future.html"><strong aria-hidden="true">8.4.</strong> Future trait</a></li><li class="chapter-item expanded "><a href="08_futures/05_blocking.html"><strong aria-hidden="true">8.5.</strong> Blocking the runtime</a></li><li class="chapter-item expanded "><a href="08_futures/06_async_aware_primitives.html"><strong aria-hidden="true">8.6.</strong> Async-aware primitives</a></li><li class="chapter-item expanded "><a href="08_futures/07_cancellation.html"><strong aria-hidden="true">8.7.</strong> Cancellation</a></li><li class="chapter-item expanded "><a href="08_futures/08_outro.html"><strong aria-hidden="true">8.8.</strong> Outro</a></li></ol></li><li class="chapter-item expanded "><a href="going_further.html"><strong aria-hidden="true">9.</strong> Going further</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">100 Exercises To Learn Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/mainmatter/100-exercises-to-learn-rust" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="welcomeã‚ˆã†ã“ã"><a class="header" href="#welcomeã‚ˆã†ã“ã">Welcomeï¼ˆã‚ˆã†ã“ãï¼‰</a></h1>
<p>Welcome to <strong>"100 Exercises To Learn Rust"</strong>!</p>
<blockquote>
<p>ã‚ˆã†ã“ãã€<strong>"Rustã‚’å­¦ã¶ãŸã‚ã®100å€‹ã®æ¼”ç¿’</strong>ã¸!</p>
</blockquote>
<p>This course will teach you Rust's core concepts, one exercise at a time.<br />
You'll learn about Rust's syntax, its type system, its standard library, and its ecosystem.</p>
<blockquote>
<p>ã“ã®ã‚³ãƒ¼ã‚¹ã¯ã€1å›ã§1ã¤ã®æ¼”ç¿’ã«ã‚ˆã£ã¦ã€Rustã®æ ¸ã¨ãªã‚‹æ¦‚å¿µã‚’æ•™ãˆã¾ã™ã€‚
Rustã®æ§‹æ–‡ã€ãã®å‹ã‚·ã‚¹ãƒ†ãƒ ã€ãã®æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã€ãã—ã¦ãã®ã‚¨ã‚³ã‚·ã‚¹ãƒ†ãƒ ã«ã¤ã„ã¦å­¦ã³ã¾ã™ã€‚</p>
</blockquote>
<p>We don't assume any prior knowledge of Rust, but we assume you know at least
another programming language.
We also don't assume any prior knowledge of systems programming or memory management. Those
topics will be covered in the course.</p>
<blockquote>
<p>Rustã®äº‹å‰çŸ¥è­˜ã‚’å‰æã¨ã—ã¦ã„ã¾ã›ã‚“ãŒã€å°‘ãªãã¨ã‚‚ä»–ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°è¨€èªã«ã¤ã„ã¦ã®çŸ¥è­˜ãŒã‚ã‚‹ã“ã¨ã‚’æƒ³å®šã—ã¦ã„ã¾ã™ã€‚
ã¾ãŸã€ã‚·ã‚¹ãƒ†ãƒ ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã¾ãŸã¯ãƒ¡ãƒ¢ãƒªç®¡ç†ã®å‰æçŸ¥è­˜ã‚’æƒ³å®šã—ã¦ã„ã¾ã›ã‚“ã€‚
ã“ã‚Œã‚‰ã®ãƒˆãƒ”ãƒƒã‚¯ã¯ã€ã‚³ãƒ¼ã‚¹å†…ã§ã‚«ãƒãƒ¼ã—ã¾ã™ã€‚</p>
</blockquote>
<p>In other words, we'll be starting from scratch!<br />
You'll build up your Rust knowledge in small, manageable steps.
By the end of the course, you will have solved ~100 exercises, enough to
feel comfortable working on small to medium-sized Rust projects.</p>
<blockquote>
<p>ã¤ã¾ã‚Šã€ã‚¹ã‚¯ãƒ©ãƒƒãƒã‹ã‚‰å§‹ã‚ã¾ã™ï¼
å°ã•ãã€ãã—ã¦ç®¡ç†å¯èƒ½ãªã‚¹ãƒ†ãƒƒãƒ—ã‚’è¸ã‚“ã§ã€Rustã®çŸ¥è­˜ã‚’æ§‹ç¯‰ã—ã¾ã™ã€‚
ã‚³ãƒ¼ã‚¹ã®æœ€å¾Œã§ã¯ã€å°è¦æ¨¡ã‹ã‚‰ä¸­è¦æ¨¡ã®Rustãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã§æ°—æŒã¡ã‚ˆãä½œæ¥­ã™ã‚‹ãŸã‚ã«ååˆ†ãªã€100å€‹ã¾ã§ã®æ¼”ç¿’ã‚’è§£æ±ºã™ã‚‹ã§ã—ã‚‡ã†ã€‚</p>
</blockquote>
<h2 id="methodologyæ–¹æ³•è«–"><a class="header" href="#methodologyæ–¹æ³•è«–">Methodologyï¼ˆæ–¹æ³•è«–ï¼‰</a></h2>
<p>This course is based on the "learn by doing" principle.<br />
It has been designed to be interactive and hands-on.</p>
<blockquote>
<p>ã“ã®ã‚³ãƒ¼ã‚¹ã¯ã€ã€Œå®Ÿè·µã§å­¦ã¶ã€ã¨ã„ã†åŸå‰‡ã«åŸºã¥ã„ã¦ã„ã¾ã™ã€‚
ãã‚Œã¯ã€å¯¾è©±çš„ã§å®Ÿè·µçš„ã«ãªã‚‹ã‚ˆã†ã«è¨­è¨ˆã•ã‚Œã¦ã„ã¾ã™ã€‚</p>
</blockquote>
<p><a href="https://mainmatter.com/rust-consulting/">Mainmatter</a> developed this course
to be delivered in a classroom setting, over 4 days: each attendee advances
through the lessons at their own pace, with an experienced instructor providing
guidance, answering questions and diving deeper into the topics as needed.<br />
If you're interested in attending one of our training sessions, or if you'd like to
bring this course to your company, please <a href="https://mainmatter.com/contact/">get in touch</a>.</p>
<blockquote>
<p>Mainmatterã¯ã€ã‚¯ãƒ©ã‚¹ãƒ«ãƒ¼ãƒ ã§4æ—¥é–“ã«ã‚ãŸã£ã¦æä¾›ã•ã‚Œã‚‹ã‚ˆã†ã«ã“ã®ã‚³ãƒ¼ã‚¹ã‚’è¨­è¨ˆã—ã¾ã—ãŸã€‚
ãã‚Œãã‚Œã®å‚åŠ è€…ã¯ã€è‡ªåˆ†ã®ãƒšãƒ¼ã‚¹ã§ãƒ¬ãƒƒã‚¹ãƒ³ã‚’é€²ã‚ã€å¿…è¦ã«å¿œã˜ã¦çµŒé¨“è±Šå¯Œãªã‚¤ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãƒ¼ãŒã‚¬ã‚¤ãƒ€ãƒ³ã‚¹ã‚’æä¾›ã—ã¦ã€è³ªå•ã«å›ç­”ã—ã¦ã€ãƒˆãƒ”ãƒƒã‚¯ã«æ·±å…¥ã‚Šã—ã¾ã™ã€‚
ãƒˆãƒ¬ãƒ¼ãƒ‹ãƒ³ã‚°ã‚»ãƒƒã‚·ãƒ§ãƒ³ã«å‚åŠ ã™ã‚‹èˆˆå‘³ãŒã‚ã‚‹å ´åˆã€ã¾ãŸã¯ã“ã®ã‚³ãƒ¼ã‚¹ã‚’ä¼šç¤¾ã«æŒã¡è¾¼ã¿ãŸã„å ´åˆã¯ã€é€£çµ¡ã‚’å–ã£ã¦ãã ã•ã„ã€‚</p>
</blockquote>
<p>You can also follow the course on your own, but we recommend you find a friend or
a mentor to help you along the way should you get stuck. You can
also find solutions to all exercises in the
<a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/solutions"><code>solutions</code> branch of the GitHub repository</a>.</p>
<blockquote>
<p>ã¾ãŸã€ç‹¬è‡ªã§ã‚³ãƒ¼ã‚¹ã‚’ãƒ•ã‚©ãƒ­ãƒ¼ã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ãŒã€è¡Œãè©°ã¾ã£ãŸå ´åˆã«åŠ©ã‘ã¦ãã‚Œã‚‹å‹äººã‚„ãƒ¡ãƒ³ã‚¿ãƒ¼ã‚’æ¢ã™ã“ã¨ã‚’ãŠå‹§ã‚ã—ã¾ã™ã€‚
ã¾ãŸã€GitHubãƒªãƒã‚¸ãƒˆãƒªã®<code>solutions</code>ãƒ–ãƒ©ãƒ³ãƒã«ã€ã™ã¹ã¦ã®æ¼”ç¿’ã®è§£ç­”ã‚’è¦‹ã¤ã‘ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ã€‚</p>
</blockquote>
<h2 id="structureæ§‹é€ "><a class="header" href="#structureæ§‹é€ ">Structureï¼ˆæ§‹é€ ï¼‰</a></h2>
<p>On the left side of the screen, you can see that the course is divided into sections.
Each section introduces a new concept or feature of the Rust language.<br />
To verify your understanding, each section is paired with an exercise that you need to solve.</p>
<blockquote>
<p>ç”»é¢ã®å·¦å´ã§ã€ã‚³ãƒ¼ã‚¹ãŒç¯€ã«åˆ†å‰²ã•ã‚Œã¦ã„ã‚‹ã“ã¨ã‚’ç¢ºèªã§ãã¾ã™ã€‚
ãã‚Œãã‚Œã®ç¯€ã¯ã€Rustè¨€èªã®æ–°ã—ã„æ¦‚å¿µã¾ãŸã¯æ©Ÿèƒ½ã‚’å°å…¥ã—ã¾ã™ã€‚
ç†è§£ã‚’ç¢ºèªã™ã‚‹ãŸã‚ã«ã€ãã‚Œãã‚Œã®ç¯€ã¯ã€è§£æ±ºã—ãªãã¦ã¯ãªã‚‰ãªã„æ¼”ç¿’ã¨ãƒšã‚¢ã«ãªã£ã¦ã„ã¾ã™ã€‚</p>
</blockquote>
<p>You can find the exercises in the
<a href="https://github.com/mainmatter/100-exercises-to-learn-rust">companion GitHub repository</a>.<br />
Before starting the course, make sure to clone the repository to your local machine:</p>
<blockquote>
<p>GitHubãƒªãƒã‚¸ãƒˆãƒªã®æ‰‹å¼•æ›¸ã®ä¸­ã«æ¼”ç¿’ã‚’è¦‹ã¤ã‘ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚
ã‚³ãƒ¼ã‚¹ã‚’é–‹å§‹ã™ã‚‹å‰ã«ã€ãƒ­ãƒ¼ã‚«ãƒ«ãƒã‚·ãƒ³ã«ãƒªãƒã‚¸ãƒˆãƒªã‚’ã‚¯ãƒ­ãƒ¼ãƒ³ã—ã¦ãã ã•ã„ã€‚</p>
</blockquote>
<pre><code class="language-bash"># If you have an SSH key set up with GitHub
git clone git@github.com:mainmatter/100-exercises-to-learn-rust.git
# Otherwise, use the HTTPS URL:
#
#   git clone https://github.com/mainmatter/100-exercises-to-learn-rust.git
</code></pre>
<p>We also recommend you work on a branch, so you can easily track your progress and pull
in updates from the main repository, if needed:</p>
<blockquote>
<p>ã¾ãŸã€å¿…è¦ã«å¿œã˜ã¦ã€<code>main</code>ãƒªãƒã‚¸ãƒˆãƒªã‹ã‚‰å®¹æ˜“ã«æ›´æ–°ã‚’è¿½è·¡ã§ãã‚‹ã‚ˆã†ã«ã€ãƒ–ãƒ©ãƒ³ãƒã§ä½œæ¥­ã™ã‚‹ã“ã¨ã‚’ãŠã™ã™ã‚ã—ã¾ã™ã€‚</p>
</blockquote>
<pre><code class="language-bash">cd 100-exercises-to-learn-rust
git checkout -b my-solutions
</code></pre>
<p>All exercises are located in the <code>exercises</code> folder.
Each exercise is structured as a Rust package.
The package contains the exercise itself, instructions on what to do (in <code>src/lib.rs</code>), and a test suite to
automatically verify your solution.</p>
<blockquote>
<p>ã™ã¹ã¦ã®æ¼”ç¿’ã¯ã€<code>exercises</code>ãƒ•ã‚©ãƒ«ãƒ€ã«é…ç½®ã•ã‚Œã¦ã„ã¾ã™ã€‚
ãã‚Œãã‚Œã®æ¼”ç¿’ã¯ã€Rustãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã¨ã—ã¦æ§‹æˆã•ã‚Œã¦ã„ã¾ã™ã€‚
ãã®ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã¯ã€æ¼”ç¿’è‡ªä½“ã€ä½•ã‚’ã™ã‚‹ã¹ãã‹ã®æŒ‡ç¤ºï¼ˆ<code>src/lib.rs</code>å†…ï¼‰ã¨ã€è§£ç­”ã‚’è‡ªå‹•ç¢ºèªã™ã‚‹ãƒ†ã‚¹ãƒˆã‚¹ã‚¤ãƒ¼ãƒˆã‚’å«ã‚“ã§ã„ã¾ã™ã€‚</p>
</blockquote>
<h3 id="wr-the-workshop-runnerwrãƒ¯ãƒ¼ã‚¯ã‚·ãƒ§ãƒƒãƒ—ãƒ©ãƒ³ãƒŠãƒ¼"><a class="header" href="#wr-the-workshop-runnerwrãƒ¯ãƒ¼ã‚¯ã‚·ãƒ§ãƒƒãƒ—ãƒ©ãƒ³ãƒŠãƒ¼"><code>wr</code>, the workshop runnerï¼ˆ<code>wr</code>ã€ãƒ¯ãƒ¼ã‚¯ã‚·ãƒ§ãƒƒãƒ—ãƒ©ãƒ³ãƒŠãƒ¼ï¼‰</a></h3>
<p>To verify your solutions, we've provided a tool that will guide you through the course.
It is the <code>wr</code> CLI (short for "workshop runner").
Install it with:</p>
<blockquote>
<p>è§£ç­”ã‚’ç¢ºèªã™ã‚‹ãŸã‚ã«ã€ã‚³ãƒ¼ã‚¹ã‚’ã‚¬ã‚¤ãƒ‰ã™ã‚‹ãƒ„ãƒ¼ãƒ«ã‚’æä¾›ã—ã¦ã„ã¾ã™ã€‚
ãã‚Œã¯ã€<code>wr</code>CLIï¼ˆã€Œworkshop runnerã€ã®ç•¥ï¼‰ã§ã™ã€‚
ãã‚Œã‚’æ¬¡ã®é€šã‚Šã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã—ã¦ãã ã•ã„ã€‚</p>
</blockquote>
<pre><code class="language-bash">cargo install --locked workshop-runner
</code></pre>
<p>In a new terminal, navigate back to the top-level folder of the repository.
Run the <code>wr</code> command to start the course:</p>
<blockquote>
<p>æ–°ã—ã„ã‚¿ãƒ¼ãƒŸãƒŠãƒ«ã§ã€ãƒªãƒã‚¸ãƒˆãƒªã®æœ€ä¸Šä½ãƒ•ã‚©ãƒ«ãƒ€ãƒ¼ã«ç§»å‹•ã—ã¦ãã ã•ã„ã€‚
ãã—ã¦ã€ã‚³ãƒ¼ã‚¹ã‚’é–‹å§‹ã™ã‚‹ãŸã‚ã«<code>wr</code>ã‚³ãƒãƒ³ãƒ‰ã‚’å®Ÿè¡Œã—ã¦ãã ã•ã„ã€‚</p>
</blockquote>
<pre><code class="language-bash">wr
</code></pre>
<p><code>wr</code> will verify the solution to the current exercise.<br />
Don't move on to the next section until you've solved the exercise for the current one.</p>
<blockquote>
<p><code>wr</code>ã¯ç¾åœ¨ã®æ¼”ç¿’ã®è§£ç­”ã‚’æ¤œè¨¼ã—ã¾ã™ã€‚
ç¾åœ¨ã®æ¼”ç¿’ã‚’è§£æ±ºã™ã‚‹ã¾ã§ã€æ¬¡ã®ç¯€ã«é€²ã¾ãªã„ã§ãã ã•ã„ã€‚</p>
</blockquote>
<blockquote>
<p>We recommend committing your solutions to Git as you progress through the course,
so you can easily track your progress and "restart" from a known point if needed.</p>
</blockquote>
<blockquote>
<p>å¿…è¦ã«å¿œã˜ã¦ã€å®¹æ˜“ã«é€²æ—ã‚’è¿½è·¡ã—ãŸã‚Šã€ç†è§£ã—ã¦ã„ã‚‹å ´æ‰€ã‹ã‚‰ã€Œå†é–‹ã€ã§ãã‚‹ã‚ˆã†ã«ã€ã‚³ãƒ¼ã‚¹ã‚’é€²ã‚ã‚‹ã«ã¤ã‚Œã¦ã€è§£ç­”ã‚’ã‚³ãƒŸãƒƒãƒˆã™ã‚‹ã“ã¨ã‚’ãŠã™ã™ã‚ã—ã¾ã™ã€‚</p>
</blockquote>
<p>Enjoy the course!</p>
<blockquote>
<p>ã‚³ãƒ¼ã‚¹ã‚’æ¥½ã—ã‚“ã§ãã ã•ã„ï¼</p>
</blockquote>
<h2 id="authorè‘—è€…"><a class="header" href="#authorè‘—è€…">Authorï¼ˆè‘—è€…ï¼‰</a></h2>
<p>This course was written by <a href="https://www.lpalmieri.com/">Luca Palmieri</a>, Principal Engineering
Consultant at <a href="https://mainmatter.com/rust-consulting/">Mainmatter</a>.<br />
Luca has been working with Rust since 2018, initially at TrueLayer and then at AWS.<br />
Luca is the author of <a href="https://zero2prod.com">"Zero to Production in Rust"</a>,
the go-to resource for learning how to build backend applications in Rust.<br />
He is also the author and maintainer of a variety of open-source Rust projects, including
<a href="https://github.com/LukeMathWalker/cargo-chef"><code>cargo-chef</code></a>,
<a href="https://pavex.dev">Pavex</a> and <a href="https://github.com/LukeMathWalker/wiremock-rs"><code>wiremock</code></a>.</p>
<blockquote>
<p>ã“ã®ã‚³ãƒ¼ã‚¹ã¯ã€<code>Mainmatter</code>ã®ä¸»ä»»ã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢ã‚³ãƒ³ã‚µãƒ«ã‚¿ãƒ³ãƒˆã®<code>Luca Palmieri</code>ã«ã‚ˆã£ã¦è¨˜è¿°ã•ã‚Œã¾ã—ãŸã€‚
Lucaã¯2018å¹´ã‹ã‚‰Rustã§ä½œæ¥­ã—ã¦ãŠã‚Šã€æœ€åˆã¯TrueLayerã§ã€ãã®å¾Œã¯AWSã§åƒã„ã¦ã„ã¾ã™ã€‚
Lucaã¯ã€Rustã§ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’æ§‹ç¯‰ã™ã‚‹æ–¹æ³•ã‚’å­¦ã¶ãŸã‚ã®ãƒªã‚½ãƒ¼ã‚¹ã§ã‚ã‚‹<code>Zero to Production in Rust</code>ã®è‘—è€…ã§ã™ã€‚
ã¾ãŸã€å½¼ã¯ã€<code>cargo-chef</code>ã€<code>Pavex</code>ã€<code>wiremock</code>ãªã©ã®ã•ã¾ã–ã¾ãªã‚ªãƒ¼ãƒ—ãƒ³ã‚½ãƒ¼ã‚¹ã®Rustãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®è‘—è€…ãŠã‚ˆã³ãƒ¡ãƒ³ãƒ†ãƒŠãƒ¼ã§ã‚‚ã‚ã‚Šã¾ã™ã€‚</p>
</blockquote>
<h2 id="exercise"><a class="header" href="#exercise">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/01_intro/00_welcome"><code>01_intro/00_welcome</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="syntaxæ§‹æ–‡"><a class="header" href="#syntaxæ§‹æ–‡">Syntaxï¼ˆæ§‹æ–‡ï¼‰</a></h1>
<div class="warning">
<p>Don't jump ahead!<br />
Complete the exercise for the previous section before you start this one.<br />
It's located in <code>exercises/01_intro/00_welcome</code>, in the <a href="https://github.com/mainmatter/100-exercises-to-learn-rust">course GitHub's repository</a>.<br />
Use <a href="01_intro/00_welcome.html#wr-the-workshop-runner"><code>wr</code></a> to start the course and verify your solutions.</p>
<blockquote>
<p>é€²ã¿ã™ããªã„ã§ãã ã•ã„ï¼
ã“ã‚Œã‚’å§‹ã‚ã‚‹å‰ã«ã€å‰ã®ç¯€ã®æ¼”ç¿’ã‚’å®Œæˆã—ã¦ãã ã•ã„ã€‚
ãã‚Œã¯ã€GitHubãƒªãƒã‚¸ãƒˆãƒªã®ã‚³ãƒ¼ã‚¹å†…ã®<code>exercises/01_intro/00_welcome</code>ã«ã‚ã‚Šã¾ã™ã€‚
ã‚³ãƒ¼ã‚¹ã‚’é–‹å§‹ã—ã¦è§£ç­”ã‚’ç¢ºèªã™ã‚‹ãŸã‚ã«<code>wr</code>ã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„ã€‚</p>
</blockquote>
</div>
<p>The previous task doesn't even qualify as an exercise, but it already exposed you to quite a bit of Rust <strong>syntax</strong>.
We won't cover every single detail of Rust's syntax used in the previous exercise.
Instead, we'll cover <em>just enough</em> to keep going without getting stuck in the details.<br />
One step at a time!</p>
<blockquote>
<p>å‰ã®ã‚¿ã‚¹ã‚¯ã¯æ¼”ç¿’ã¨ã—ã¦ã®è³‡æ ¼ã™ã‚‰ã‚ã‚Šã¾ã›ã‚“ãŒã€ã™ã§ã«ãã‚Œã¯Rust<strong>æ§‹æ–‡</strong>ã®ã‹ãªã‚Šã®éƒ¨åˆ†ã‚’å…¬é–‹ã—ã¦ã„ã¾ã™ã€‚
å‰ã®æ¼”ç¿’ã§ä½¿ç”¨ã•ã‚ŒãŸRustã®æ§‹æ–‡ã®ã™ã¹ã¦ã®è©³ç´°ã‚’ã‚«ãƒãƒ¼ã—ã¾ã›ã‚“ã€‚
ä»£ã‚ã‚Šã«ã€è©³ç´°ã«è¡Œãè©°ã¾ã‚‹ã“ã¨ãªã—ã«é€²ã¿ç¶šã‘ã‚‹ãŸã‚ã«_ã¡ã‚‡ã†ã©ååˆ†ãª_èª¬æ˜ã‚’ã™ã‚‹äºˆå®šã§ã™ã€‚
1åº¦ã«1ã¤ãšã¤ï¼</p>
</blockquote>
<h2 id="commentsã‚³ãƒ¡ãƒ³ãƒˆ"><a class="header" href="#commentsã‚³ãƒ¡ãƒ³ãƒˆ">Commentsï¼ˆã‚³ãƒ¡ãƒ³ãƒˆï¼‰</a></h2>
<p>You can use <code>//</code> for single-line comments:</p>
<blockquote>
<p>1è¡Œã‚³ãƒ¡ãƒ³ãƒˆã«ã¯<code>//</code>ã‚’ä½¿ç”¨ã§ãã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// This is a single-line comment
// Followed by another single-line comment
<span class="boring">}</span></code></pre></pre>
<h2 id="functionsé–¢æ•°"><a class="header" href="#functionsé–¢æ•°">Functionsï¼ˆé–¢æ•°ï¼‰</a></h2>
<p>Functions in Rust are defined using the <code>fn</code> keyword, followed by the function's name, its input parameters, and its
return type.
The function's body is enclosed in curly braces <code>{}</code>.</p>
<blockquote>
<p>Rustã«ãŠã‘ã‚‹é–¢æ•°ã¯ã€<code>fn</code>ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’ä½¿ç”¨ã—ã¦å®šç¾©ã•ã‚Œã€é–¢æ•°ã®åå‰ã€ãã®å…¥åŠ›ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ã€ãã—ã¦æˆ»ã‚Šå€¤ã®å‹ãŒç¶šãã¾ã™ã€‚
é–¢æ•°ã®æœ¬ä½“ã¯ã€æ³¢æ‹¬å¼§<code>{}</code>ã§å›²ã¾ã‚Œã¦ã„ã¾ã™ã€‚</p>
</blockquote>
<p>In previous exercise, you saw the <code>greeting</code> function:</p>
<blockquote>
<p>å‰ã®æ¼”ç¿’ã«ãŠã„ã¦ã€<code>greeting</code>é–¢æ•°ã‚’ç¢ºèªã—ã¾ã—ãŸã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// `fn` &lt;function_name&gt; ( &lt;input parameters&gt; ) -&gt; &lt;return_type&gt; { &lt;body&gt; }
fn greeting() -&gt; &amp;'static str {
    // TODO: fix me ğŸ‘‡
    "I'm ready to __!"
}
<span class="boring">}</span></code></pre></pre>
<p><code>greeting</code> has no input parameters and returns a reference to a string slice (<code>&amp;'static str</code>).</p>
<blockquote>
<p><code>greeting</code>ã¯å…¥åŠ›ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ã‚’æŒãŸãšã€æ–‡å­—åˆ—ã‚¹ãƒ©ã‚¤ã‚¹ã¸ã®å‚ç…§ï¼ˆ<code>&amp;'static str</code>ï¼‰ã‚’è¿”ã—ã¾ã™ã€‚</p>
</blockquote>
<h3 id="return-typeæˆ»ã‚Šå€¤ã®å‹"><a class="header" href="#return-typeæˆ»ã‚Šå€¤ã®å‹">Return typeï¼ˆæˆ»ã‚Šå€¤ã®å‹ï¼‰</a></h3>
<p>The return type can be omitted from the signature if the function doesn't return anything (i.e. if it returns <code>()</code>,
Rust's unit type).
That's what happened with the <code>test_welcome</code> function:</p>
<blockquote>
<p>æˆ»ã‚Šå€¤ã®å‹ã¯ã€ä¾‹ãˆã°ã€Rustã®ãƒ¦ãƒ‹ãƒƒãƒˆå‹ã§ã‚ã‚‹<code>()</code>ã‚’è¿”ã™å ´åˆãªã©ã€é–¢æ•°ãŒä½•ã‚‚è¿”ã•ãªã„ã¨ãã€ãã®ã‚·ã‚°ãƒãƒãƒ£ãƒ¼ã‹ã‚‰çœç•¥ã§ãã¾ã™ã€‚
ãã‚ŒãŒã€<code>test_welcome</code>é–¢æ•°ã§ç™ºç”Ÿã—ãŸã“ã¨ã§ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn test_welcome() {
    assert_eq!(greeting(), "I'm ready to learn Rust!");
}
<span class="boring">}</span></code></pre></pre>
<p>The above is equivalent to:</p>
<blockquote>
<p>ä¸Šè¨˜ã¯ã€æ¬¡ã¨åŒç­‰ã§ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Spelling out the unit return type explicitly
//                   ğŸ‘‡
fn test_welcome() -&gt; () {
    assert_eq!(greeting(), "I'm ready to learn Rust!");
}
<span class="boring">}</span></code></pre></pre>
<h3 id="returning-valuesæˆ»ã‚Šå€¤"><a class="header" href="#returning-valuesæˆ»ã‚Šå€¤">Returning valuesï¼ˆæˆ»ã‚Šå€¤ï¼‰</a></h3>
<p>The last expression in a function is implicitly returned:</p>
<blockquote>
<p>é–¢æ•°ã®æœ€å¾Œã®å¼ã¯æš—é»™çš„ã«è¿”ã•ã‚Œã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn greeting() -&gt; &amp;'static str {
    // This is the last expression in the function
    // Therefore its value is returned by `greeting`
    "I'm ready to learn Rust!"
}
<span class="boring">}</span></code></pre></pre>
<p>You can also use the <code>return</code> keyword to return a value early:</p>
<blockquote>
<p>ã¾ãŸã€æ—©æœŸã«å€¤ã‚’è¿”ã™ãŸã‚ã«<code>return</code>ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’ä½¿ç”¨ã§ãã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn greeting() -&gt; &amp;'static str {
    // Notice the semicolon at the end of the line!
    return "I'm ready to learn Rust!";
}
<span class="boring">}</span></code></pre></pre>
<p>It is considered idiomatic to omit the <code>return</code> keyword when possible.</p>
<blockquote>
<p>å¯èƒ½ãªã¨ã<code>return</code>ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’çœç•¥ã™ã‚‹ã“ã¨ã¯ã€æ…£ç”¨çš„ã§ã‚ã‚‹è€ƒãˆã‚‰ã‚Œã¦ã„ã¾ã™ã€‚</p>
</blockquote>
<h3 id="input-parameterså…¥åŠ›ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼"><a class="header" href="#input-parameterså…¥åŠ›ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼">Input parametersï¼ˆå…¥åŠ›ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ï¼‰</a></h3>
<p>Input parameters are declared inside the parentheses <code>()</code> that follow the function's name.<br />
Each parameter is declared with its name, followed by a colon <code>:</code>, followed by its type.</p>
<blockquote>
<p>å…¥åŠ›ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ã¯ã€é–¢æ•°åã®å¾Œã«ç¶šãæ‹¬å¼§<code>()</code>å†…ã§å®£è¨€ã•ã‚Œã¾ã™ã€‚
ãã‚Œãã‚Œã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ã¯ã€ãã®åå‰ã€ã‚³ãƒ­ãƒ³<code>:</code>ã€ãã®å‹ã‚’ç¶šã‘ã¦å®£è¨€ã•ã‚Œã¾ã™ã€‚</p>
</blockquote>
<p>For example, the <code>greet</code> function below takes a <code>name</code> parameter of type <code>&amp;str</code> (a "string slice"):</p>
<blockquote>
<p>ä¾‹ãˆã°ã€ä¸‹ã®<code>greet</code>é–¢æ•°ã¯ã€<code>&amp;str</code>å‹ï¼ˆã€Œæ–‡å­—åˆ—ã‚¹ãƒ©ã‚¤ã‚¹ã€ï¼‰ã®<code>name</code>ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ã‚’å—ã‘å–ã‚Šã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// An input parameter
//        ğŸ‘‡
fn greet(name: &amp;str) -&gt; String {
    format!("Hello, {}!", name)
}
<span class="boring">}</span></code></pre></pre>
<p>If there are multiple input parameters, they must be separated with commas.</p>
<blockquote>
<p>è¤‡æ•°ã®å…¥åŠ›ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ãŒã‚ã‚‹å ´åˆã€ãã‚Œã‚‰ã¯ã‚«ãƒ³ãƒã§åŒºåˆ‡ã‚‰ã‚Œãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚</p>
</blockquote>
<h3 id="type-annotationså‹æ³¨é‡ˆ"><a class="header" href="#type-annotationså‹æ³¨é‡ˆ">Type annotationsï¼ˆå‹æ³¨é‡ˆï¼‰</a></h3>
<p>Since we've been mentioned "types" a few times, let's state it clearly: Rust is a <strong>statically typed language</strong>.<br />
Every single value in Rust has a type and that type must be known to the compiler at compile-time.</p>
<blockquote>
<p>æ•°å›ã€Œå‹ã€ã«ã¤ã„ã¦è¨€åŠã—ãŸãŸã‚ã€ãã‚Œã‚’æ˜ç¢ºã«è¿°ã¹ã¾ã—ã‚‡ã†ã€‚
Rustã¯<strong>é™çš„å‹ä»˜ã‘è¨€èª</strong>ã§ã™ã€‚
Rustã«ãŠã‘ã‚‹ã™ã¹ã¦ã®å˜ç‹¬ã®å€¤ã¯å‹ã‚’æŒã¡ã€ãã®å‹ã¯ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã«ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ¼ã«ã‚ˆã£ã¦ç†è§£ã•ã‚Œãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚</p>
</blockquote>
<p>Types are a form of <strong>static analysis</strong>.<br />
You can think of a type as a <strong>tag</strong> that the compiler attaches to every value in your program. Depending on the
tag, the compiler can enforce different rulesâ€”e.g. you can't add a string to a number, but you can add two numbers
together.
If leveraged correctly, types can prevent whole classes of runtime bugs.</p>
<blockquote>
<p>å‹ã¯<strong>é™çš„è§£æ</strong>ã®1ã¤ã®å½¢æ…‹ã§ã™ã€‚
å‹ã‚’ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ¼ãŒãƒ—ãƒ­ã‚°ãƒ©ãƒ å†…ã®ã™ã¹ã¦ã®å€¤ã«æ·»ä»˜ã™ã‚‹<strong>ã‚¿ã‚°</strong>ã¨è€ƒãˆã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚
ã‚¿ã‚°ã«ä¾å­˜ã—ã¦ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã¯ç•°ãªã‚‹ãƒ«ãƒ¼ãƒ«ã‚’å¼·åˆ¶ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚
ä¾‹ãˆã°ã€æ–‡å­—åˆ—ã¨æ•°å€¤ã‚’è¶³ã™ã“ã¨ã¯ã§ãã¾ã›ã‚“ãŒã€2ã¤ã®æ•°å€¤åŒå£«ã§ã‚ã‚Œã°è¶³ã›ã‚Œã¾ã™ã€‚
æ­£ç¢ºã«åˆ©ç”¨ã•ã‚Œã‚Œã°ã€å‹ã¯ãƒ©ãƒ³ã‚¿ã‚¤ãƒ ã§ç™ºç”Ÿã™ã‚‹ãƒã‚°ã®ç¨®é¡ã®å…¨ä½“ã‚’é¿ã‘ã‚Œã¾ã™ã€‚</p>
</blockquote>
<h2 id="exercise-1"><a class="header" href="#exercise-1">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/01_intro/01_syntax"><code>01_intro/01_syntax</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a-basic-calculatoråŸºæœ¬çš„ãªè¨ˆç®—æ©Ÿ"><a class="header" href="#a-basic-calculatoråŸºæœ¬çš„ãªè¨ˆç®—æ©Ÿ">A Basic Calculatorï¼ˆåŸºæœ¬çš„ãªè¨ˆç®—æ©Ÿï¼‰</a></h1>
<p>In this chapter we'll learn how to use Rust as a <strong>calculator</strong>.<br />
It might not sound like much, but it'll give us a chance to cover a lot of Rust's basics, such as:</p>
<blockquote>
<p>ã“ã®ç« ã§ã¯ã€<strong>è¨ˆç®—æ©Ÿ</strong>ã¨ã—ã¦Rustã‚’ä½¿ç”¨ã™ã‚‹æ–¹æ³•ã‚’å­¦ã³ã¾ã™ã€‚
ãã‚Œã¯å¤§ã’ã•ã«èã“ãˆã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ãŒã€æ¬¡ã®ã‚ˆã†ãªRustã®åŸºæœ¬ã®å¤šãã‚’èª¬æ˜ã™ã‚‹æ©Ÿä¼šã‚’ä¸ãˆã¦ãã‚Œã¾ã™ã€‚</p>
</blockquote>
<ul>
<li>How to define and call functions</li>
<li>How to declare and use variables</li>
<li>Primitive types (integers and booleans)</li>
<li>Arithmetic operators (including overflow and underflow behavior)</li>
<li>Comparison operators</li>
<li>Control flow</li>
<li>Panics</li>
</ul>
<blockquote>
<ul>
<li>é–¢æ•°ã‚’å®šç¾©ãã—ã¦å‘¼ã³å‡ºã™æ–¹æ³•</li>
<li>å¤‰æ•°ã‚’å®£è¨€ã—ã¦ä½¿ç”¨ã™ã‚‹æ–¹æ³•</li>
<li>ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–å‹ï¼ˆæ•´æ•°ã¨ãƒ–ãƒ¼ãƒ«å€¤ï¼‰</li>
<li>ç®—è¡“æ¼”ç®—å­ï¼ˆã‚ªãƒ¼ãƒãƒ¼ãƒ•ãƒ­ãƒ¼ã¨ã‚¢ãƒ³ãƒ€ãƒ¼ãƒ•ãƒ­ãƒ¼ã®æŒ™å‹•ã‚’å«ã‚€ï¼‰</li>
<li>æ¯”è¼ƒæ¼”ç®—å­</li>
<li>åˆ¶å¾¡ãƒ•ãƒ­ãƒ¼</li>
<li>ãƒ‘ãƒ‹ãƒƒã‚¯</li>
</ul>
</blockquote>
<p>Nailing the basics with a few exercises will get the language flowing under your fingers.
When we move on to more complex topics, such as traits and ownership, you'll be able to focus on the new concepts
without getting bogged down by the syntax or other trivial details.</p>
<blockquote>
<p>ã„ãã¤ã‹ã®æ¼”ç¿’ã§åŸºæœ¬ã‚’ç¢ºå®Ÿã«ç‰©ã«ã™ã‚‹ã“ã¨ã§ã€è¨€èªãŒæŒ‡å…ˆã§æµã‚Œã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚
ãƒˆãƒ¬ã‚¤ãƒˆã‚„æ‰€æœ‰æ¨©ã®ã‚ˆã†ãªã€ã‚ˆã‚Šè¤‡é›‘ãªãƒˆãƒ”ãƒƒã‚¯ã«é€²ã‚€ã¨ãã€æ§‹æ–‡ã¾ãŸã¯ä»–ã®äº›ç´°ãªè©³ç´°ã®æ²¼ã«é™¥ã‚‹ã“ã¨ãªãã€æ–°ã—ã„æ¦‚å¿µã«ç„¦ç‚¹ã‚’å½“ã¦ã‚Œã¾ã™ã€‚</p>
</blockquote>
<h2 id="exercise-2"><a class="header" href="#exercise-2">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/02_basic_calculator/00_intro"><code>02_basic_calculator/00_intro</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="types-part-1å‹ãã®1"><a class="header" href="#types-part-1å‹ãã®1">Types, part 1ï¼ˆå‹ã€ãã®1ï¼‰</a></h1>
<p>In the <a href="02_basic_calculator/../01_intro/01_syntax.html">"Syntax" section</a> <code>compute</code>'s input parameters were of type <code>u32</code>.<br />
Let's unpack what that <em>means</em>.</p>
<blockquote>
<p>ã€Œæ§‹æ–‡ã€ç¯€ã«ãŠã„ã¦ã€<code>compute</code>ã®å…¥åŠ›ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ã¯<code>u32</code>å‹ã§ã—ãŸã€‚
ãã‚ŒãŒä½•ã‚’æ„å‘³ã™ã‚‹ã‹è§£èª¬ã—ã¾ã—ã‚‡ã†ã€‚</p>
</blockquote>
<h2 id="primitive-typesãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–å‹"><a class="header" href="#primitive-typesãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–å‹">Primitive typesï¼ˆãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–å‹ï¼‰</a></h2>
<p><code>u32</code> is one of Rust's <strong>primitive types</strong>. Primitive types are the most basic building blocks of a language.
They're built into the language itselfâ€”i.e. they are not defined in terms of other types.</p>
<blockquote>
<p><code>u32</code>ã¯Rustã®<strong>ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–å‹</strong>ã®1ã¤ã§ã™ã€‚
ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–å‹ã¯è¨€èªã®æœ€ã‚‚åŸºæœ¬çš„ãªæ§‹æˆè¦ç´ ã§ã™ã€‚
ãã‚Œã‚‰ã¯ã€è¨€èªè‡ªä½“ã«çµ„ã¿è¾¼ã¾ã‚Œã¦ãŠã‚Šã€ã¤ã¾ã‚Šä»–ã®å‹ã«åŸºã¥ã„ã¦å®šç¾©ã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚</p>
</blockquote>
<p>You can combine these primitive types to create more complex types. We'll see how soon enough.</p>
<blockquote>
<p>ã‚ˆã‚Šè¤‡é›‘ãªå‹ã‚’ä½œæˆã™ã‚‹ãŸã‚ã«ã€ã“ã‚Œã‚‰ã®ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–å‹ã‚’çµ„ã¿åˆã‚ã›ã‚Œã¾ã™ã€‚
ã™ãã«ãã®æ–¹æ³•ã‚’ç¢ºèªã—ã¾ã™ã€‚</p>
</blockquote>
<h2 id="integersæ•´æ•°"><a class="header" href="#integersæ•´æ•°">Integersï¼ˆæ•´æ•°ï¼‰</a></h2>
<p><code>u32</code>, in particular, is an <strong>unsigned 32-bit integer</strong>.</p>
<blockquote>
<p>ç‰¹ã«<code>u32</code>ã¯<strong>ç¬¦å·ãªã—32ãƒ“ãƒƒãƒˆæ•´æ•°</strong>ã§ã™ã€‚</p>
</blockquote>
<p>An integer is a number that can be written without a fractional component. E.g. <code>1</code> is an integer, while <code>1.2</code> is not.</p>
<blockquote>
<p>æ•´æ•°ã¯ã€å°æ•°éƒ¨åˆ†ãªã—ã§è¨˜è¿°ã§ãã‚‹æ•°å€¤ã§ã™ã€‚
ä¾‹ãˆã°ã€<code>1</code>ã¯æ•´æ•°ã§ã™ãŒã€<code>1.2</code>ã¯æ•´æ•°ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚</p>
</blockquote>
<h3 id="signed-vs-unsignedç¬¦å·ä»˜ãã¨ç¬¦å·ãªã—"><a class="header" href="#signed-vs-unsignedç¬¦å·ä»˜ãã¨ç¬¦å·ãªã—">Signed vs. unsignedï¼ˆç¬¦å·ä»˜ãã¨ç¬¦å·ãªã—ï¼‰</a></h3>
<p>An integer can be <strong>signed</strong> or <strong>unsigned</strong>.<br />
An unsigned integer can only represent non-negative numbers (i.e. <code>0</code> or greater).
A signed integer can represent both positive and negative numbers (e.g. <code>-1</code>, <code>12</code>, etc.).</p>
<blockquote>
<p>æ•´æ•°ã¯<strong>ç¬¦å·ä»˜ã</strong>ã¾ãŸã¯<strong>ç¬¦å·ãªã—</strong>ã«ãªã‚Šã¾ã™ã€‚
ç¬¦å·ãªã—æ•´æ•°ã¯ã€ä¾‹ãˆã°0ã¾ãŸã¯ãã‚Œã‚ˆã‚Šå¤§ãã„éè² æ•°ã®ã¿ã‚’è¡¨ç¾ã§ãã¾ã™ã€‚
ç¬¦å·ä»˜ãæ•´æ•°ã¯ã€æ­£ã¨è² ã®æ•°ã®ä¸¡æ–¹ã‚’è¡¨ç¾ã§ãã¾ã™ã€‚</p>
</blockquote>
<p>The <code>u</code> in <code>u32</code> stands for <strong>unsigned</strong>.<br />
The equivalent type for signed integer is <code>i32</code>, where the <code>i</code> stands for integer (i.e. any integer, positive or
negative).</p>
<blockquote>
<p><code>u32</code>ã®<code>u</code>ã¯<strong>ç¬¦å·ãªã—</strong>ã«ç”±æ¥ã—ã¾ã™ã€‚
ç¬¦å·ä»˜ãæ•´æ•°ã¨åŒç­‰ã®å‹ã¯<code>i32</code>ã§ã€<code>i</code>ã¯æ•´æ•°ï¼ˆä¾‹ãˆã°ã€æ­£ã¾ãŸã¯è² ã®ä»»æ„ã®æ•´æ•°ï¼‰ã«ç”±æ¥ã—ã¾ã™ã€‚</p>
</blockquote>
<h3 id="bit-widthãƒ“ãƒƒãƒˆå¹…"><a class="header" href="#bit-widthãƒ“ãƒƒãƒˆå¹…">Bit widthï¼ˆãƒ“ãƒƒãƒˆå¹…ï¼‰</a></h3>
<p>The <code>32</code> in <code>u32</code> refers to the <strong>number of bits<sup class="footnote-reference"><a href="#bit">1</a></sup></strong> used to represent the number in memory.<br />
The more bits, the larger the range of numbers that can be represented.</p>
<blockquote>
<p><code>u32</code>ã®<code>32</code>ã¯ã€ãƒ¡ãƒ¢ãƒªå†…ã§ãã®æ•°ã‚’è¡¨ç¾ã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã‚‹<strong>ãƒ“ãƒƒãƒˆæ•°</strong>ã‚’æŒ‡ã—ã¾ã™ã€‚
ãƒ“ãƒƒãƒˆæ•°ãŒå¤šã„ã»ã©ã€è¡¨ç¾ã§ãã‚‹æ•°å€¤ã®ç¯„å›²ãŒåºƒãŒã‚Šã¾ã™ã€‚</p>
</blockquote>
<p>Rust supports multiple bit widths for integers: <code>8</code>, <code>16</code>, <code>32</code>, <code>64</code>, <code>128</code>.</p>
<blockquote>
<p>Rustã¯ã€æ•´æ•°ã«å¯¾ã—ã¦<code>8</code>ã€<code>16</code>ã€<code>32</code>ã€<code>64</code>ã€<code>128</code>ã®è¤‡æ•°ã®ãƒ“ãƒƒãƒˆå¹…ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã™ã€‚</p>
</blockquote>
<p>With 32 bits, <code>u32</code> can represent numbers from <code>0</code> to <code>2^32 - 1</code> (a.k.a. <a href="https://doc.rust-lang.org/std/primitive.u32.html#associatedconstant.MAX"><code>u32::MAX</code></a>).<br />
With the same number of bits, a signed integer (<code>i32</code>) can represent numbers from <code>-2^31</code> to <code>2^31 - 1</code>
(i.e. from <a href="https://doc.rust-lang.org/std/primitive.i32.html#associatedconstant.MIN"><code>i32::MIN</code></a>
to <a href="https://doc.rust-lang.org/std/primitive.i32.html#associatedconstant.MAX"><code>i32::MAX</code></a>).<br />
The maximum value for <code>i32</code> is smaller than the maximum value for <code>u32</code> because one bit is used to represent
the sign of the number. Check out the <a href="https://en.wikipedia.org/wiki/Two%27s_complement">two's complement</a>
representation for more details on how signed integers are represented in memory.</p>
<blockquote>
<p>32ãƒ“ãƒƒãƒˆå¹…ã®å ´åˆã€<code>u32</code>ã¯<code>0</code>ã‹ã‚‰<code>2^32 - 1</code>ï¼ˆ<code>u32::MAX</code>ã¨ã—ã¦çŸ¥ã‚‰ã‚Œã‚‹ï¼‰ã¾ã§ã®æ•°å€¤ã‚’è¡¨ç¾ã§ãã¾ã™ã€‚
åŒã˜ãƒ“ãƒƒãƒˆæ•°ã®å ´åˆã€ç¬¦å·ä»˜ãæ•´æ•°ï¼ˆ<code>i32</code>ï¼‰ã¯<code>-2^31</code>ã‹ã‚‰<code>2^31 - 1</code>ï¼ˆ<code>i32::MIN</code>ã‹ã‚‰<code>i32::MAX</code>ï¼‰ã¾ã§ã®æ•°å€¤ã‚’è¡¨ç¾ã§ãã¾ã™ã€‚
<code>i32</code>ã®æœ€å¤§å€¤ã¯<code>u32</code>ã®æœ€å¤§å€¤ã‚ˆã‚Šã‚‚å°ã•ã„ã§ã™ã€‚ãªãœãªã‚‰ã€1ãƒ“ãƒƒãƒˆãŒæ•°å€¤ã®ç¬¦å·ã‚’è¡¨ç¾ã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã‚‹ã‹ã‚‰ã§ã™ã€‚
ãƒ¡ãƒ¢ãƒªå†…ã§ç¬¦å·ä»˜ãæ•´æ•°ã‚’è¡¨ç¾ã™ã‚‹æ–¹æ³•ã®è©³ç´°ã¯ã€<code>2ã®è£œæ•°</code>è¡¨ç¾ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚</p>
</blockquote>
<h3 id="summaryã¾ã¨ã‚"><a class="header" href="#summaryã¾ã¨ã‚">Summaryï¼ˆã¾ã¨ã‚ï¼‰</a></h3>
<p>Combining the two variables (signed/unsigned and bit width), we get the following integer types:</p>
<blockquote>
<p>ç¬¦å·ä»˜ãï¼ç¬¦å·ãªã—ã¨ãƒ“ãƒƒãƒˆå¹…ã®2ã¤ã®å¤‰æ•°ã®çµ„ã¿åˆã‚ã›ã§ã€æ¬¡ã®æ•´æ•°å‹ãŒå¾—ã‚‰ã‚Œã¾ã™ã€‚</p>
</blockquote>
<div class="table-wrapper"><table><thead><tr><th>Bit width</th><th>Signed</th><th>Unsigned</th></tr></thead><tbody>
<tr><td>8-bit</td><td><code>i8</code></td><td><code>u8</code></td></tr>
<tr><td>16-bit</td><td><code>i16</code></td><td><code>u16</code></td></tr>
<tr><td>32-bit</td><td><code>i32</code></td><td><code>u32</code></td></tr>
<tr><td>64-bit</td><td><code>i64</code></td><td><code>u64</code></td></tr>
<tr><td>128-bit</td><td><code>i128</code></td><td><code>u128</code></td></tr>
</tbody></table>
</div>
<h2 id="literalsãƒªãƒ†ãƒ©ãƒ«"><a class="header" href="#literalsãƒªãƒ†ãƒ©ãƒ«">Literalsï¼ˆãƒªãƒ†ãƒ©ãƒ«ï¼‰</a></h2>
<p>A <strong>literal</strong> is a notation for representing a fixed value in source code.<br />
For example, <code>42</code> is a Rust literal for the number forty-two.</p>
<blockquote>
<p><strong>ãƒªãƒ†ãƒ©ãƒ«</strong>ã¯ã€ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰å†…ã§å›ºå®šã•ã‚ŒãŸå€¤ã‚’è¡¨ç¾ã™ã‚‹ãŸã‚ã®è¡¨è¨˜æ³•ã§ã™ã€‚
ä¾‹ãˆã°ã€<code>42</code>ã¯æ•°å€¤42ã®Rustã®ãƒªãƒ†ãƒ©ãƒ«ã§ã™ã€‚</p>
</blockquote>
<h3 id="type-annotations-for-literalsãƒªãƒ†ãƒ©ãƒ«ã®å‹æ³¨é‡ˆ"><a class="header" href="#type-annotations-for-literalsãƒªãƒ†ãƒ©ãƒ«ã®å‹æ³¨é‡ˆ">Type annotations for literalsï¼ˆãƒªãƒ†ãƒ©ãƒ«ã®å‹æ³¨é‡ˆï¼‰</a></h3>
<p>But all values in Rust have a type, so... what's the type of <code>42</code>?</p>
<blockquote>
<p>ã—ã‹ã—ã€Rustã«ãŠã‘ã‚‹ã™ã¹ã¦ã®å€¤ã¯å‹ã‚’æŒã¤ãŸã‚ã€<code>42</code>ã®å‹ã¯ä½•ã§ã—ã‚‡ã†ã‹ï¼Ÿ</p>
</blockquote>
<p>The Rust compiler will try to infer the type of a literal based on how it's used.<br />
If you don't provide any context, the compiler will default to <code>i32</code> for integer literals.<br />
If you want to use a different type, you can add the desired integer type as a suffixâ€”e.g. <code>2u64</code> is a 2 that's
explicitly typed as a <code>u64</code>.</p>
<blockquote>
<p>Rustã®ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ¼ã¯ã€ãã‚ŒãŒä½¿ç”¨ã•ã‚Œã‚‹æ–¹æ³•ã«åŸºã¥ã„ã¦ãƒªãƒ†ãƒ©ãƒ«ã®å‹ã‚’æ¨è«–ã™ã‚‹ã“ã¨ã‚’è©¦ã¿ã¾ã™ã€‚
ä½•ã‚‰ã‹ã®æ–‡è„ˆã‚’æä¾›ã—ãªã„å ´åˆã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ¼ã¯æ•´æ•°ãƒªãƒ†ãƒ©ãƒ«ã«å¯¾ã—ã¦ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§<code>i32</code>ã‚’ä¸ãˆã¾ã™ã€‚
ç•°ãªã‚‹å‹ã‚’ä½¿ç”¨ã—ãŸã„å ´åˆã€æ¥å°¾è¾ã¨ã—ã¦æœ›ã¾ã—ã„æ•´æ•°å‹ã‚’è¿½åŠ ã§ãã¾ã™ã€‚
ä¾‹ãˆã°ã€<code>2u64</code>ã¯ã€<code>u64</code>ã¨ã—ã¦æ˜ç¤ºçš„ã«å‹ä»˜ã‘ã‚‰ã‚ŒãŸ2ã§ã™ã€‚</p>
</blockquote>
<h3 id="underscores-in-literalsãƒªãƒ†ãƒ©ãƒ«å†…ã®ã‚¢ãƒ³ãƒ€ãƒ¼ã‚¹ã‚³ã‚¢"><a class="header" href="#underscores-in-literalsãƒªãƒ†ãƒ©ãƒ«å†…ã®ã‚¢ãƒ³ãƒ€ãƒ¼ã‚¹ã‚³ã‚¢">Underscores in literalsï¼ˆãƒªãƒ†ãƒ©ãƒ«å†…ã®ã‚¢ãƒ³ãƒ€ãƒ¼ã‚¹ã‚³ã‚¢ï¼‰</a></h3>
<p>You can use underscores <code>_</code> to improve the readability of large numbers.<br />
For example, <code>1_000_000</code> is the same as <code>1000000</code>.</p>
<blockquote>
<p>å¤§ããªæ•°ã®å¯èª­æ€§ã‚’æ”¹å–„ã™ã‚‹ãŸã‚ã«ã€ã‚¢ãƒ³ãƒ€ãƒ¼ã‚¹ã‚³ã‚¢<code>_</code>ã‚’ä½¿ç”¨ã§ãã¾ã™ã€‚
ä¾‹ãˆã°ã€<code>1_000_000</code>ã¯<code>1000000</code>ã¨åŒã˜ã§ã™ã€‚</p>
</blockquote>
<h2 id="arithmetic-operatorsç®—è¡“æ¼”ç®—å­"><a class="header" href="#arithmetic-operatorsç®—è¡“æ¼”ç®—å­">Arithmetic operatorsï¼ˆç®—è¡“æ¼”ç®—å­ï¼‰</a></h2>
<p>Rust supports the following arithmetic operators<sup class="footnote-reference"><a href="#traits">2</a></sup> for integers:</p>
<ul>
<li><code>+</code> for addition</li>
<li><code>-</code> for subtraction</li>
<li><code>*</code> for multiplication</li>
<li><code>/</code> for division</li>
<li><code>%</code> for remainder</li>
</ul>
<blockquote>
<p>Rustã¯æ•´æ•°ã®ãŸã‚ã«æ¬¡ã®ç®—è¡“æ¼”ç®—å­ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã™ã€‚</p>
<ul>
<li><code>+</code>: åŠ ç®—</li>
<li><code>-</code>: æ¸›ç®—</li>
<li><code>*</code>: ä¹—ç®—</li>
<li><code>/</code>: é™¤ç®—</li>
<li><code>%</code>: å‰°ä½™</li>
</ul>
</blockquote>
<p>Precedence and associativity rules for these operators are the same as in mathematics.<br />
You can use parentheses to override the default precedence. E.g. <code>2 * (3 + 4)</code>.</p>
<blockquote>
<p>ã“ã‚Œã‚‰ã®æ¼”ç®—å­ã®å„ªå…ˆé †ä½ã¨çµåˆæ€§ã®ãƒ«ãƒ¼ãƒ«ã¯ã€æ•°å­¦ã¨åŒã˜ã§ã™ã€‚
ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®å„ªå…ˆé †ä½ã‚’ä¸Šæ›¸ãã™ã‚‹ãŸã‚ã«ã‚«ãƒƒã‚³ã‚’ä½¿ç”¨ã§ãã¾ã™ã€‚
ä¾‹ãˆã°ã€<code>2 * (3 + 4)</code>ã€‚</p>
</blockquote>
<blockquote>
<p>âš ï¸ <strong>Warning</strong></p>
<p>The division operator <code>/</code> performs integer division when used with integer types.
I.e. the result is truncated towards zero. For example, <code>5 / 2</code> is <code>2</code>, not <code>2.5</code>.</p>
</blockquote>
<blockquote>
<p>âš ï¸ <strong>è­¦å‘Š</strong>
é™¤ç®—æ¼”ç®—å­<code>/</code>ã¯ã€æ•´æ•°å‹ã¨ä½¿ç”¨ã™ã‚‹ã¨æ•´æ•°é™¤ç®—ã‚’è¡Œã„ã¾ã™ã€‚
ã¤ã¾ã‚Šã€çµæœã¯ã‚¼ãƒ­ã«å‘ã‹ã£ã¦åˆ‡ã‚Šæ¨ã¦ã‚‰ã‚Œã¾ã™ã€‚
ä¾‹ãˆã°ã€<code>5 / 2</code>ã¯<code>2</code>ã§ã‚ã‚Šã€<code>2.5</code>ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚</p>
</blockquote>
<h2 id="no-automatic-type-coercionè‡ªå‹•å‹å¼·åˆ¶ãªã—"><a class="header" href="#no-automatic-type-coercionè‡ªå‹•å‹å¼·åˆ¶ãªã—">No automatic type coercionï¼ˆè‡ªå‹•å‹å¼·åˆ¶ãªã—ï¼‰</a></h2>
<p>As we discussed in the previous exercise, Rust is a statically typed language.<br />
In particular, Rust is quite strict about type coercion. It won't automatically convert a value from one type to
another<sup class="footnote-reference"><a href="#coercion">3</a></sup>,
even if the conversion is lossless. You have to do it explicitly.</p>
<blockquote>
<p>å‰ã®æ¼”ç¿’ã§è­°è«–ã—ãŸã‚ˆã†ã«ã€Rustã¯é™çš„å‹ä»˜ã‘è¨€èªã§ã™ã€‚
ç‰¹ã«ã€Rustã¯ã€å‹å¼·åˆ¶ã«ã¤ã„ã¦ã‹ãªã‚Šå³æ ¼ã§ã™ã€‚
ãã‚Œã¯ã€å¤‰æ›ãŒæå¤±ãªã—ã§ã‚‚ã€å€¤ã‚’ã‚ã‚‹å‹ã‹ã‚‰ä»–ã®å‹ã«è‡ªå‹•ã§å¤‰æ›ã—ã¾ã›ã‚“ã€‚
æ˜ç¤ºçš„ã«ãã‚Œã‚’è¡Œã‚ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚</p>
</blockquote>
<p>For example, you can't assign a <code>u8</code> value to a variable with type <code>u32</code>, even though all <code>u8</code> values are valid <code>u32</code>
values:</p>
<blockquote>
<p>ä¾‹ãˆã°ã€ã™ã¹ã¦ã®<code>u8</code>å€¤ã¯æœ‰åŠ¹ãª<code>u32</code>å€¤ã«ã‚‚é–¢ã‚ã‚‰ãšã€<code>u32</code>å‹ã§ã‚ã‚‹å¤‰æ•°ã«<code>u8</code>å€¤ã‚’å‰²ã‚Šå½“ã¦ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let b: u8 = 100;
let a: u32 = b;
<span class="boring">}</span></code></pre></pre>
<p>It'll throw a compilation error:</p>
<blockquote>
<p>ãã‚Œã¯ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚¨ãƒ©ãƒ¼ã‚’æŠ•ã’ã¾ã™ã€‚</p>
</blockquote>
<pre><code class="language-text">error[E0308]: mismatched types
  |
3 |     let a: u32 = b;
  |            ---   ^ expected `u32`, found `u8`
  |            |
  |            expected due to this
  |
</code></pre>
<p>We'll see how to convert between types <a href="02_basic_calculator/../04_traits/09_from.html">later in this course</a>.</p>
<blockquote>
<p>å‹ã®å¤‰æ›æ–¹æ³•ã¯ã“ã®ã‚³ãƒ¼ã‚¹ã®å¾ŒåŠã§ç¢ºèªã—ã¾ã™ã€‚</p>
</blockquote>
<h2 id="further-readingå‚è€ƒæ–‡çŒ®"><a class="header" href="#further-readingå‚è€ƒæ–‡çŒ®">Further readingï¼ˆå‚è€ƒæ–‡çŒ®ï¼‰</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch03-02-data-types.html#integer-types">The integer types section</a> in the official Rust book</li>
</ul>
<blockquote>
<ul>
<li>æ•´æ•°å‹ç¯€: å…¬å¼Rustãƒ–ãƒƒã‚¯</li>
</ul>
</blockquote>
<div class="footnote-definition" id="bit"><sup class="footnote-definition-label">1</sup>
<p>A bit is the smallest unit of data in a computer. It can only have two values: <code>0</code> or <code>1</code>.ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ãƒ¼å†…ã®æœ€ã‚‚å°ã•ãªãƒ‡ãƒ¼ã‚¿å˜ä½ã§ã™ã€‚ãã‚Œã¯<code>0</code>ã¾ãŸã¯<code>1</code>ã®2ã¤ã®å€¤ã—ã‹æŒã¤ã“ã¨ãŒã§ãã¾ã›ã‚“ã€‚</p>
</div>
<div class="footnote-definition" id="traits"><sup class="footnote-definition-label">2</sup>
<p>Rust doesn't let you define custom operators, but it puts you in control of how the built-in operators
behave.
We'll talk about operator overloading <a href="02_basic_calculator/../04_traits/03_operator_overloading.html">later in the course</a>, after we've covered traits.
Rustã¯ç‹¬è‡ªã®æ¼”ç®—å­ã‚’å®šç¾©ã™ã‚‹ã“ã¨ã‚’è¨±å¯ã—ã¾ã›ã‚“ãŒã€çµ„ã¿è¾¼ã¿æ¼”ç®—å­ã®æŒ¯ã‚‹èˆã„ã‚’åˆ¶å¾¡ã™ã‚‹äº‹ãŒã§ãã¾ã™ã€‚
ã‚³ãƒ¼ã‚¹ã®å¾ŒåŠã§ãƒˆãƒ¬ã‚¤ãƒˆã‚’èª¬æ˜ã—ãŸå¾Œã€æ¼”ç®—å­ã®ã‚ªãƒ¼ãƒãƒ¼ãƒ­ãƒ¼ãƒ‰ã«ã¤ã„ã¦è©±ã—ã¾ã™ã€‚</p>
</div>
<div class="footnote-definition" id="coercion"><sup class="footnote-definition-label">3</sup>
<p>There are some exceptions to this rule, mostly related to references, smart pointers and ergonomics. We'll
cover those <a href="02_basic_calculator/../04_traits/07_deref.html">later on</a>.
A mental model of "all conversions are explicit" will serve you well in the meantime.
ã“ã®ãƒ«ãƒ¼ãƒ«ã«ã¯ã„ãã¤ã‹ã®ä¾‹å¤–ãŒã‚ã‚Šã€å¤šãã¯å‚ç…§ã€ã‚¹ãƒãƒ¼ãƒˆãƒã‚¤ãƒ³ã‚¿ãƒ¼ãã—ã¦äººé–“å·¥å­¦ã«é–¢é€£ã—ã¾ã™ã€‚ãã‚Œã‚‰ã¯å¾Œã§èª¬æ˜ã—ã¾ã™ã€‚
ã€Œã™ã¹ã¦ã®å¤‰æ›ã¯æ˜ç¤ºçš„ã§ã‚ã‚‹ã€ã¨ã„ã†ãƒ¡ãƒ³ã‚¿ãƒ«ãƒ¢ãƒ‡ãƒ«ã¯ã€ãã‚Œã¾ã§ã®é–“ã«å½¹ç«‹ã¡ã¾ã™ã€‚</p>
</div>
<h2 id="exercise-3"><a class="header" href="#exercise-3">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/02_basic_calculator/01_integers"><code>02_basic_calculator/01_integers</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="variableså¤‰æ•°"><a class="header" href="#variableså¤‰æ•°">Variablesï¼ˆå¤‰æ•°ï¼‰</a></h1>
<p>In Rust, you can use the <code>let</code> keyword to declare <strong>variables</strong>.<br />
For example:</p>
<blockquote>
<p>Rustã«ãŠã„ã¦ã€<strong>å¤‰æ•°</strong>ã‚’å®£è¨€ã™ã‚‹ãŸã‚ã«<code>let</code>ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’ä½¿ç”¨ã§ãã¾ã™ã€‚
ä¾‹ãˆã°ãƒ»ãƒ»ãƒ»</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 42;
<span class="boring">}</span></code></pre></pre>
<p>Above we defined a variable <code>x</code> and assigned it the value <code>42</code>.</p>
<blockquote>
<p>ä¸Šè¨˜ã§å¤‰æ•°<code>x</code>ã‚’å®šç¾©ã—ã¦ã€ãã®å€¤ã«<code>42</code>ã‚’å‰²ã‚Šå½“ã¦ã¾ã—ãŸã€‚</p>
</blockquote>
<h2 id="typeå‹"><a class="header" href="#typeå‹">Typeï¼ˆå‹ï¼‰</a></h2>
<p>Every variable in Rust must have a type. It can either be inferred by the compiler or explicitly specified by the
developer.</p>
<blockquote>
<p>Rustã«ãŠã„ã¦ã€ã™ã¹ã¦ã®å¤‰æ•°ã¯å‹ã‚’æŒãŸãªãã¦ã¯ãªã‚Šã¾ã›ã‚“ã€‚
å‹ã¯ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ¼ã«ã‚ˆã£ã¦æ¨è«–ã•ã‚Œã‚‹ã‹ã€é–‹ç™ºè€…ã«ã‚ˆã£ã¦æ˜ç¤ºçš„ã«æŒ‡å®šã•ã‚Œã‚‹ã‹ã®ã©ã¡ã‚‰ã‹ã§ã™ã€‚</p>
</blockquote>
<h3 id="explicit-type-annotationæ˜ç¤ºçš„ãªå‹æ³¨é‡ˆ"><a class="header" href="#explicit-type-annotationæ˜ç¤ºçš„ãªå‹æ³¨é‡ˆ">Explicit type annotationï¼ˆæ˜ç¤ºçš„ãªå‹æ³¨é‡ˆï¼‰</a></h3>
<p>You can specify the variable type by adding a colon <code>:</code> followed by the type after the variable name. For example:</p>
<blockquote>
<p>å¤‰æ•°åã®å¾Œã«ã€ã‚³ãƒ­ãƒ³<code>:</code>ã¨å‹ã‚’è¿½åŠ ã™ã‚‹ã“ã¨ã§ã€å¤‰æ•°ã®å‹ã‚’æŒ‡å®šã§ãã¾ã™ã€‚
ä¾‹ãˆã°ãƒ»ãƒ»ãƒ»</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// let &lt;variable_name&gt;: &lt;type&gt; = &lt;expression&gt;;
let x: u32 = 42;
<span class="boring">}</span></code></pre></pre>
<p>In the example above, we explicitly constrained the type of <code>x</code> to be <code>u32</code>.</p>
<blockquote>
<p>ä¸Šè¨˜ã®ä¾‹ã§ã€<code>u32</code>ã§<code>x</code>ã®å‹ã‚’æ˜ç¤ºçš„ã«åˆ¶ç´„ã—ã¾ã—ãŸã€‚</p>
</blockquote>
<h3 id="type-inferenceå‹æ¨è«–"><a class="header" href="#type-inferenceå‹æ¨è«–">Type inferenceï¼ˆå‹æ¨è«–ï¼‰</a></h3>
<p>If we don't specify the type of a variable, the compiler will try to infer it based on the context in which the variable
is used.</p>
<blockquote>
<p>å¤‰æ•°ã®å‹ã‚’æŒ‡å®šã—ãªã„å ´åˆã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ¼ã¯å¤‰æ•°ãŒä½¿ç”¨ã•ã‚Œã‚‹æ–‡è„ˆã«åŸºã¥ã„ã¦æ¨è«–ã‚’è©¦ã¿ã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 42;
let y: u32 = x;
<span class="boring">}</span></code></pre></pre>
<p>In the example above, we didn't specify the type of <code>x</code>.<br />
<code>x</code> is later assigned to <code>y</code>, which is explicitly typed as <code>u32</code>. Since Rust doesn't perform automatic type coercion,
the compiler infers the type of <code>x</code> to be <code>u32</code>â€”the same as <code>y</code> and the only type that will allow the program to compile
without errors.</p>
<blockquote>
<p>ä¸Šè¨˜ã®ä¾‹ã§ã€<code>x</code>ã®å‹ã‚’æŒ‡å®šã—ã¦ã„ã¾ã›ã‚“ã€‚
<code>x</code>ã¯ã€å¾Œã§<code>y</code>ã«å‰²ã‚Šå½“ã¦ã‚Œã‚Œã€ãã‚Œã¯æ˜ç¤ºçš„ã«<code>u32</code>å‹ã¨ã—ã¦å‹ä»˜ã‘ã‚‰ã‚Œã¦ã„ã¾ã™ã€‚
Rustã¯è‡ªå‹•çš„ã«å‹å¼·åˆ¶ã‚’ã—ãªã„ãŸã‚ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ¼ã¯<code>x</code>ã®å‹ã«<code>u32</code>ã‚’æ¨è«–ã—ã¾ã™ã€‚
<code>u32</code>ã¯ã€<code>y</code>ã¨ã‚¨ãƒ©ãƒ¼ãªã—ã§ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã§ãã‚‹å”¯ä¸€ã®å‹ã§ã™ã€‚</p>
</blockquote>
<h3 id="inference-limitationsæ¨è«–ã®åˆ¶é™"><a class="header" href="#inference-limitationsæ¨è«–ã®åˆ¶é™">Inference limitationsï¼ˆæ¨è«–ã®åˆ¶é™ï¼‰</a></h3>
<p>The compiler sometimes needs a little help to infer the correct variable type based on its usage.<br />
In those cases you'll get a compilation error and the compiler will ask you to provide an explicit type hint to
disambiguate the situation.</p>
<blockquote>
<p>æ™‚ã€…ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ¼ã¯ã€å¤‰æ•°ã®ä½¿ç”¨ã«åŸºã¥ã„ã¦æ­£ç¢ºã«å¤‰æ•°ã®å‹ã‚’æ¨è«–ã™ã‚‹ãŸã‚ã«å°‘ã—åŠ©ã‘ãŒå¿…è¦ã§ã™ã€‚
ãã®ã‚ˆã†ãªå ´é¢ã§ã¯ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¦ã€çŠ¶æ³ã®æ›–æ˜§ã•ã‚’ãªãã™ãŸã‚ã«ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ¼ã¯æ˜ç¤ºçš„ãªãƒ’ãƒ³ãƒˆã‚’æä¾›ã™ã‚‹ã‚ˆã†ã«è¦æ±‚ã—ã¾ã™ã€‚</p>
</blockquote>
<h2 id="function-arguments-are-variablesé–¢æ•°ã®å¼•æ•°ã¨å¤‰æ•°"><a class="header" href="#function-arguments-are-variablesé–¢æ•°ã®å¼•æ•°ã¨å¤‰æ•°">Function arguments are variablesï¼ˆé–¢æ•°ã®å¼•æ•°ã¨å¤‰æ•°ï¼‰</a></h2>
<p>Not all heroes wear capes, not all variables are declared with <code>let</code>.<br />
Function arguments are variables too!</p>
<blockquote>
<p>ã™ã¹ã¦ã®ãƒ’ãƒ¼ãƒ­ãƒ¼ãŒãƒãƒ³ãƒˆã‚’ä»˜ã‘ã¦ã„ã‚‹ã‚ã‘ã§ãªãªãã€ã™ã¹ã¦ã®å¤‰æ•°ã¯<code>let</code>ã§å®£è¨€ã•ã‚Œã‚‹ã‚ã‘ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚
é–¢æ•°å¼•æ•°ã‚‚å¤‰æ•°ã§ã™ï¼</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn add_one(x: u32) -&gt; u32 {
    x + 1
}
<span class="boring">}</span></code></pre></pre>
<p>In the example above, <code>x</code> is a variable of type <code>u32</code>.<br />
The only difference between <code>x</code> and a variable declared with <code>let</code> is that functions arguments <strong>must</strong> have their type
explicitly declared. The compiler won't infer it for you.<br />
This constraint allows the Rust compiler (and us humans!) to understand the function's signature without having to look
at its implementation. That's a big boost for compilation speed<sup class="footnote-reference"><a href="#speed">1</a></sup>!</p>
<blockquote>
<p>ä¸Šè¨˜ä¾‹ã§ã€<code>x</code>ã¯<code>u32</code>å‹ã®å¤‰æ•°ã§ã™ã€‚
<code>x</code>ã¨<code>let</code>ã§å®£è¨€ã•ã‚ŒãŸå¤‰æ•°ã®å”¯ä¸€ã®é•ã„ã¯ã€é–¢æ•°ã®å¼•æ•°ã¯ãã‚Œã‚‰ã®å‹ã‚’æ˜ç¤ºçš„ã«å®£è¨€ã•ã‚Œãªã‘ã‚Œã°ãªã‚‰ãªã„ã“ã¨ã§ã™ã€‚
ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ¼ã¯ãã‚Œã‚’æ¨è«–ã—ã¾ã›ã‚“ã€‚
ã“ã®åˆ¶ç´„ã¯ã€Rustã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ¼ï¼ˆãã—ã¦ç§ãŸã¡äººé–“ï¼ï¼‰ãŒå®Ÿè£…ã‚’ç¢ºèªã—ãªãã¦ã‚‚é–¢æ•°ã®ã‚·ã‚°ãƒãƒãƒ£ã‚’ç†è§£ã§ãã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚
ãã‚Œã¯ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«é€Ÿåº¦ã‚’å¤§ããå‘ä¸Šã•ã›ã¾ã™ã€‚</p>
</blockquote>
<h2 id="initializationåˆæœŸåŒ–"><a class="header" href="#initializationåˆæœŸåŒ–">Initializationï¼ˆåˆæœŸåŒ–ï¼‰</a></h2>
<p>You don't have to initialize a variable when you declare it.<br />
For example</p>
<blockquote>
<p>å¤‰æ•°ã‚’å®£è¨€ã—ãŸã¨ãã€å¤‰æ•°ã‚’åˆæœŸåŒ–ã™ã‚‹å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: u32;
<span class="boring">}</span></code></pre></pre>
<p>is a valid variable declaration.<br />
However, you must initialize the variable before using it. The compiler will throw an error if you don't:</p>
<blockquote>
<p>ä¸Šè¨˜ã¯ã€å¦¥å½“ãªå¤‰æ•°å®£è¨€ã§ã™ã€‚
ã—ã‹ã—ã€ãã‚Œã‚’ä½¿ç”¨ã™ã‚‹å‰ã«å¤‰æ•°ã‚’åˆæœŸåŒ–ã—ãªãã¦ã¯ãªã‚Šã¾ã›ã‚“ã€‚
ãã‚Œã‚’ã—ãªã„å ´åˆã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ¼ã¯ã‚¨ãƒ©ãƒ¼ã‚’æŠ•ã’ã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: u32;
let y = x + 1;
<span class="boring">}</span></code></pre></pre>
<p>will throw a compilation error:</p>
<blockquote>
<p>ä¸Šè¨˜ã¯ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚¨ãƒ©ãƒ¼ã‚’æŠ•ã’ã¾ã™ã€‚</p>
</blockquote>
<pre><code class="language-text">error[E0381]: used binding `x` isn't initialized
 --&gt; src/main.rs:3:9
  |
2 | let x: u32;
  |     - binding declared here but left uninitialized
3 | let y = x + 1;
  |         ^ `x` used here but it isn't initialized
  |
help: consider assigning a value
  |
2 | let x: u32 = 0;
  |            +++
</code></pre>
<div class="footnote-definition" id="speed"><sup class="footnote-definition-label">1</sup>
<p>The Rust compiler needs all the help it can get when it comes to compilation speed.
Rustã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ¼ã¯ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«é€Ÿåº¦ã«é–¢ã—ã¦ã€å¯èƒ½ãªé™ã‚Šã®åŠ©ã‘ã‚’å¿…è¦ã¨ã—ã¦ã„ã¾ã™ã€‚</p>
</div>
<h2 id="exercise-4"><a class="header" href="#exercise-4">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/02_basic_calculator/02_variables"><code>02_basic_calculator/02_variables</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="control-flow-part-1åˆ¶å¾¡ãƒ•ãƒ­ãƒ¼ãã®1"><a class="header" href="#control-flow-part-1åˆ¶å¾¡ãƒ•ãƒ­ãƒ¼ãã®1">Control flow, part 1ï¼ˆåˆ¶å¾¡ãƒ•ãƒ­ãƒ¼ã€ãã®1ï¼‰</a></h1>
<p>All our programs so far have been pretty straightforward.<br />
A sequence of instructions is executed from top to bottom, and that's it.</p>
<blockquote>
<p>ã“ã‚Œã¾ã§ã€ã™ã¹ã¦ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯ã€ã¨ã¦ã‚‚å˜ç´”ã§ã—ãŸã€‚
å‘½ä»¤ã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã¯ã€ä¸Šã‹ã‚‰ä¸‹ã«å®Ÿè¡Œã•ã‚Œã€ãã‚Œã ã‘ã§ã™ã€‚</p>
</blockquote>
<p>It's time to introduce some <strong>branching</strong>.</p>
<blockquote>
<p><strong>åˆ†å²</strong>ã‚’å°å…¥ã™ã‚‹æ™‚ã§ã™ã€‚</p>
</blockquote>
<h2 id="if-clausesifç¯€"><a class="header" href="#if-clausesifç¯€"><code>if</code> clausesï¼ˆifç¯€ï¼‰</a></h2>
<p>The <code>if</code> keyword is used to execute a block of code only if a condition is true.
Here's a simple example:</p>
<blockquote>
<p><code>if</code>ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã¯ã€<code>if</code>æ¡ä»¶ãŒtrueã®å ´åˆã®ã¿ã€ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯ã‚’å®Ÿè¡Œã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚
ã“ã“ã«å˜ç´”ãªä¾‹ã‚’ç¤ºã—ã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let number = 3;
if number &lt; 5 {
    println!("`number` is smaller than 5");
}
<span class="boring">}</span></code></pre></pre>
<p>This program will print <code>number is smaller than 5</code> because the condition <code>number &lt; 5</code> is true.</p>
<blockquote>
<p>ã“ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯ã€æ¡ä»¶<code>number &lt; 5</code>ã¯trueã§ã‚ã‚‹ãŸã‚ã€<code>number is smaller than 5</code>ã‚’è¡¨ç¤ºã—ã¾ã™ã€‚</p>
</blockquote>
<h3 id="else-clauseselseç¯€"><a class="header" href="#else-clauseselseç¯€"><code>else</code> clausesï¼ˆelseç¯€ï¼‰</a></h3>
<p>Like most programming languages, Rust supports an optional <code>else</code> branch to execute a block of code when the condition in an
<code>if</code> expression is false.<br />
For example:</p>
<blockquote>
<p>ã»ã¨ã‚“ã©ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°è¨€èªã¨åŒæ§˜ã«ã€Rustã¯<code>if</code>å¼å†…ã®æ¡ä»¶ãŒfalseã®ã¨ãã«ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯ã‚’å®Ÿè¡Œã™ã‚‹ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®<code>else</code>åˆ†å²ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã™ã€‚
ä¾‹ãˆã°ãƒ»ãƒ»ãƒ»</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let number = 3;

if number &lt; 5 {
    println!("`number` is smaller than 5");
} else {
    println!("`number` is greater than or equal to 5");
}
<span class="boring">}</span></code></pre></pre>
<h2 id="booleansãƒ–ãƒ¼ãƒªã‚¢ãƒ³"><a class="header" href="#booleansãƒ–ãƒ¼ãƒªã‚¢ãƒ³">Booleansï¼ˆãƒ–ãƒ¼ãƒªã‚¢ãƒ³ï¼‰</a></h2>
<p>The condition in an <code>if</code> expression must be of type <code>bool</code>, a <strong>boolean</strong>.<br />
Booleans, just like integers, are a primitive type in Rust.</p>
<blockquote>
<p><code>if</code>å¼å†…ã®æ¡ä»¶ã¯<strong>ãƒ–ãƒ¼ãƒªã‚¢ãƒ³</strong>ã§ã‚ã‚‹<code>bool</code>å‹ã«ãªã‚‰ãªãã¦ã¯ãªã‚Šã¾ã›ã‚“ã€‚
ã¡ã‚‡ã†ã©æ•´æ•°ã®ã‚ˆã†ã«ã€ãƒ–ãƒ¼ãƒªã‚¢ãƒ³ã¯Rustã«ãŠã‘ã‚‹ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–å‹ã§ã™ã€‚</p>
</blockquote>
<p>A boolean can have one of two values: <code>true</code> or <code>false</code>.</p>
<blockquote>
<p>ãƒ–ãƒ¼ãƒªã‚¢ãƒ³ã¯ã€<code>true</code>ã¾ãŸã¯<code>false</code>ã®2ã¤ã®å€¤ã®ã†ã¡ã®1ã¤ã«ãªã‚Šã¾ã™ã€‚</p>
</blockquote>
<h3 id="no-truthy-or-falsy-valuesçœŸã®ã‚ˆã†ãªã¾ãŸå½ã®ã‚ˆã†ãªå€¤ãŒãªã„"><a class="header" href="#no-truthy-or-falsy-valuesçœŸã®ã‚ˆã†ãªã¾ãŸå½ã®ã‚ˆã†ãªå€¤ãŒãªã„">No truthy or falsy valuesï¼ˆçœŸã®ã‚ˆã†ãªã€ã¾ãŸå½ã®ã‚ˆã†ãªå€¤ãŒãªã„ï¼‰</a></h3>
<p>If the condition in an <code>if</code> expression is not a boolean, you'll get a compilation error.
For example, the following code will not compile:</p>
<blockquote>
<p><code>if</code>å¼å†…ã®æ¡ä»¶ãŒãƒ–ãƒ¼ãƒªã‚¢ãƒ³ã§ãªã„å ´åˆã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã™ã€‚
ä¾‹ãˆã°ã€æ¬¡ã®ã‚³ãƒ¼ãƒ‰ã¯ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã‚Œã¾ã›ã‚“ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let number = 3;
if number {
    println!("`number` is not zero");
}
<span class="boring">}</span></code></pre></pre>
<p>You'll get the following compilation error:</p>
<blockquote>
<p>æ¬¡ã®ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã™ã€‚</p>
</blockquote>
<pre><code class="language-text">error[E0308]: mismatched types
 --&gt; src/main.rs:3:8
  |
3 |     if number {
  |        ^^^^^^ expected `bool`, found integer
</code></pre>
<p>This follows from Rust's philosophy around type coercion: there's no automatic conversion from non-boolean types to booleans.
Rust doesn't have the concept of <strong>truthy</strong> or <strong>falsy</strong> values, like JavaScript or Python.<br />
You have to be explicit about the condition you want to check.</p>
<blockquote>
<p>ã“ã‚Œã¯ã€Rustã®å‹å¼·åˆ¶ã¾ã‚ã‚Šã®å“²å­¦ã«å¾“ã£ã¦ã„ã¾ã™ã€‚
éãƒ–ãƒ¼ãƒªã‚¢ãƒ³å‹ã‹ã‚‰ãƒ–ãƒ¼ãƒªã‚¢ãƒ³ã¸ã®è‡ªå‹•å¤‰æ›ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚
JavaScriptã¾ãŸã¯Pythonã®ã‚ˆã†ã«ã€Rustã¯<strong>çœŸã®ã‚ˆã†ãª</strong>ã¾ãŸã¯<strong>å½ã®ã‚ˆã†ãª</strong>å€¤ã®æ¦‚å¿µãŒã‚ã‚Šã¾ã›ã‚“ã€‚
ç¢ºèªã—ãŸã„æ¡ä»¶ã«ã¤ã„ã¦æ˜ç¤ºçš„ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚</p>
</blockquote>
<h3 id="comparison-operatorsæ¯”è¼ƒæ¼”ç®—å­"><a class="header" href="#comparison-operatorsæ¯”è¼ƒæ¼”ç®—å­">Comparison operatorsï¼ˆæ¯”è¼ƒæ¼”ç®—å­ï¼‰</a></h3>
<p>It's quite common to use comparison operators to build conditions for <code>if</code> expressions.<br />
Here are the comparison operators available in Rust when working with integers:</p>
<ul>
<li><code>==</code>: equal to</li>
<li><code>!=</code>: not equal to</li>
<li><code>&lt;</code>: less than</li>
<li><code>&gt;</code>: greater than</li>
<li><code>&lt;=</code>: less than or equal to</li>
<li><code>&gt;=</code>: greater than or equal to</li>
</ul>
<blockquote>
<p><code>if</code>å¼ã®æ¡ä»¶ã‚’æ§‹ç¯‰ã™ã‚‹ãŸã‚ã«æ¯”è¼ƒæ¼”ç®—å­ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã¯ã€ã¨ã¦ã‚‚ä¸€èˆ¬çš„ã§ã™ã€‚
ã“ã“ã«ã€æ•´æ•°ã¨ä¸€ç·’ã«æ©Ÿèƒ½ã™ã‚‹ã€Rustã§åˆ©ç”¨ã§ãã‚‹æ¯”è¼ƒæ¼”ç®—å­ã‚’ç¤ºã—ã¾ã™ã€‚</p>
<ul>
<li><code>==</code>: ç­‰ã—ã„</li>
<li><code>!=</code>: ç­‰ã—ããªã„</li>
<li><code>&lt;</code>: ã‚ˆã‚Šå°ã•ã„</li>
<li><code>&gt;</code>: ã‚ˆã‚Šå¤§ãã„</li>
<li><code>&lt;=</code>: ä»¥ä¸‹</li>
<li><code>&gt;=</code>: ä»¥ä¸Š</li>
</ul>
</blockquote>
<h2 id="ifelse-is-an-expressionifelseã¯å¼"><a class="header" href="#ifelse-is-an-expressionifelseã¯å¼"><code>if/else</code> is an expressionï¼ˆif/elseã¯å¼ï¼‰</a></h2>
<p>In Rust, <code>if</code> expressions are <strong>expressions</strong>, not statements: they return a value.<br />
That value can be assigned to a variable or used in other expressions. For example:</p>
<blockquote>
<p>Rustã§ã€<code>if</code>å¼ã¯<strong>å¼</strong>ã§ã€æ–‡ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ãã‚Œã‚‰ã¯å€¤ã‚’è¿”ã—ã¾ã™ã€‚
ãã®å€¤ã¯å¤‰æ•°ã«å‰²ã‚Šå½“ã¦ã‚‹ã€ã¾ãŸã¯ä»–ã®å¼ã®ä¸­ã§ä½¿ç”¨ã§ãã¾ã™ã€‚
ä¾‹ãˆã°ãƒ»ãƒ»ãƒ»</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let number = 3;
let message = if number &lt; 5 {
    "smaller than 5"
} else {
    "greater than or equal to 5"
};
<span class="boring">}</span></code></pre></pre>
<p>In the example above, each branch of the <code>if</code> evaluates to a string literal,
which is then assigned to the <code>message</code> variable.<br />
The only requirement is that both <code>if</code> branches return the same type.</p>
<blockquote>
<p>ä¸Šè¨˜ä¾‹ã§ã€<code>if</code>ã®ãã‚Œãã‚Œã®ãƒ–ãƒ©ãƒ³ãƒã¯ã€æ–‡å­—åˆ—ãƒªãƒ†ãƒ©ãƒ«ã«è©•ä¾¡ã•ã‚Œã€ãã‚Œã¯<code>message</code>å¤‰æ•°ã«å‰²ã‚Šå½“ã¦ã‚‰ã‚Œã¾ã™ã€‚
å”¯ä¸€ã®è¦æ±‚äº‹é …ã¯ã€ä¸¡æ–¹ã®<code>if</code>ãƒ–ãƒ©ãƒ³ãƒãŒåŒã˜å‹ã‚’è¿”ã™ã“ã¨ã§ã™ã€‚</p>
</blockquote>
<h2 id="exercise-5"><a class="header" href="#exercise-5">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/02_basic_calculator/03_if_else"><code>02_basic_calculator/03_if_else</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="panicsãƒ‘ãƒ‹ãƒƒã‚¯"><a class="header" href="#panicsãƒ‘ãƒ‹ãƒƒã‚¯">Panicsï¼ˆãƒ‘ãƒ‹ãƒƒã‚¯ï¼‰</a></h1>
<p>Let's go back to the <code>speed</code> function you wrote for the <a href="02_basic_calculator/02_variables.html">"Variables" section</a>.
It probably looked something like this:</p>
<blockquote>
<p>ã€Œå¤‰æ•°ã€ç¯€ã§è¨˜è¿°ã—ãŸ<code>speed</code>é–¢æ•°ã«æˆ»ã‚Šã¾ã—ã‚‡ã†ã€‚
ãã‚Œã¯ãŠãã‚‰ãæ¬¡ã®ã‚ˆã†ã«è¦‹ãˆãŸã§ã—ã‚‡ã†ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn speed(start: u32, end: u32, time_elapsed: u32) -&gt; u32 {
    let distance = end - start;
    distance / time_elapsed
}
<span class="boring">}</span></code></pre></pre>
<p>If you have a keen eye, you might have spotted one issue<sup class="footnote-reference"><a href="#one">1</a></sup>: what happens if <code>time_elapsed</code> is zero?</p>
<blockquote>
<p>ã‚‚ã—æ³¨æ„æ·±ã„ç›®ã‚’æŒã£ã¦ã„ã‚‹å ´åˆã€1ã¤ã®å•é¡Œç‚¹ãŒã‚ã‚‹ã“ã¨ã«æ°—ã¥ã„ãŸã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚<code>time_elapses</code>ãŒã‚¼ãƒ­ã®å ´åˆã€ä½•ãŒèµ·ã“ã‚‹ã§ã—ã‚‡ã†ã‹ï¼Ÿ</p>
</blockquote>
<p>You can try it
out <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=36e5ddbe3b3f741dfa9f74c956622bac">on the Rust playground</a>!<br />
The program will exit with the following error message:</p>
<blockquote>
<p><code>Rust playground</code>ã§è©¦ã™ã“ã¨ãŒã§ãã¾ã™ï¼
ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯ã€æ¬¡ã®ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã§çµ‚äº†ã—ã¾ã™ã€‚</p>
</blockquote>
<pre><code class="language-text">thread 'main' panicked at src/main.rs:3:5:
attempt to divide by zero
</code></pre>
<blockquote>
<pre><code class="language-text">`main`ã‚¹ãƒ¬ãƒƒãƒ‰ã¯ã€src/main.rs:3:5ã§ãƒ‘ãƒ‹ãƒƒã‚¯ã—ã¾ã—ãŸï¼š
ã‚¼ãƒ­ã§å‰²ã‚ã†ã¨è©¦ã¿ã¦ã„ã¾ã™
</code></pre>
</blockquote>
<p>This is known as a <strong>panic</strong>.<br />
A panic is Rust's way to signal that something went so wrong that
the program can't continue executing, it's an <strong>unrecoverable error</strong><sup class="footnote-reference"><a href="#catching">2</a></sup>. Division by zero classifies as such an
error.</p>
<blockquote>
<p>ã“ã‚Œã¯<strong>ãƒ‘ãƒ‹ãƒƒã‚¯</strong>ã¨ã—ã¦çŸ¥ã‚‰ã‚Œã¦ã„ã¾ã™ã€‚
ãƒ‘ãƒ‹ãƒƒã‚¯ã¯ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒå®Ÿè¡Œã‚’ç¶™ç¶šã§ããªã„ä½•ã‹æ‚ªã„çŠ¶æ…‹ã«ãªã£ãŸã“ã¨ã‚’ç¤ºã™Rustã®æ–¹æ³•ã§ã™ã€‚
ãã‚Œã¯<strong>å›å¾©ä¸èƒ½ãªã‚¨ãƒ©ãƒ¼</strong>ã§ã™ã€‚
ã‚¼ãƒ­å‰²ã‚Šã¯ãã®ã‚ˆã†ãªã‚¨ãƒ©ãƒ¼ã«åˆ†é¡ã•ã‚Œã¾ã™ã€‚</p>
</blockquote>
<h2 id="the-panic-macropanicãƒã‚¯ãƒ­"><a class="header" href="#the-panic-macropanicãƒã‚¯ãƒ­">The panic! macroï¼ˆpanic!ãƒã‚¯ãƒ­ï¼‰</a></h2>
<p>You can intentionally trigger a panic by calling the <code>panic!</code> macro<sup class="footnote-reference"><a href="#macro">3</a></sup>:</p>
<blockquote>
<p><code>panic!</code>ãƒã‚¯ãƒ­ã‚’å‘¼ã³å‡ºã™ã“ã¨ã§ã€æ„å›³çš„ã«ãƒ‘ãƒ‹ãƒƒã‚¯ã‚’èµ·ã“ã›ã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">fn main() {
    panic!("This is a panic!");
    // The line below will never be executed
    // ä¸‹ã®è¡Œã¯æ±ºã—ã¦å®Ÿè¡Œã•ã‚Œã¾ã›ã‚“
    let x = 1 + 2;
}</code></pre></pre>
<p>There are other mechanisms to work with recoverable errors in Rust, which <a href="02_basic_calculator/../05_ticket_v2/06_fallibility.html">we'll cover later</a>.
For the time being we'll stick with panics as a brutal but simple stopgap solution.</p>
<blockquote>
<p>Rustã«ã¯å›å¾©å¯èƒ½ãªã‚¨ãƒ©ãƒ¼ã¨ä¸€ç·’ã«æ©Ÿèƒ½ã™ã‚‹ä»–ã®ãƒ¡ã‚«ãƒ‹ã‚ºãƒ ãŒã‚ã‚Šã€ãã‚Œã¯å¾Œã§èª¬æ˜ã—ã¾ã™ã€‚
å½“åˆ†ã¯ã€é‡è›®ã§ã™ãŒå˜ç´”ãªä¸€æ™‚ã—ã®ãã®è§£æ±ºç­–ã¨ã—ã¦ãƒ‘ãƒ‹ãƒƒã‚¯ã«å›ºåŸ·ã—ã¾ã™ã€‚</p>
</blockquote>
<h2 id="further-readingå‚è€ƒè³‡æ–™"><a class="header" href="#further-readingå‚è€ƒè³‡æ–™">Further readingï¼ˆå‚è€ƒè³‡æ–™ï¼‰</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/std/macro.panic.html">The panic! macro documentation</a></li>
</ul>
<div class="footnote-definition" id="one"><sup class="footnote-definition-label">1</sup>
<p>There's another issue with <code>speed</code> that we'll address soon enough. Can you spot it?
<code>speed</code>ã«ã¯ååˆ†ã™ãã«å¯¾å‡¦ã§ãã‚‹åˆ¥ã®å•é¡ŒãŒã‚ã‚Šã¾ã™ã€‚ãã‚Œã‚’è¦‹ã¤ã‘ã‚‹ã“ã¨ã¯ã§ãã¾ã™ã‹ï¼Ÿ</p>
</div>
<div class="footnote-definition" id="catching"><sup class="footnote-definition-label">2</sup>
<p>You can try to catch a panic, but it should be a last resort attempt reserved for very specific
circumstances.
ãƒ‘ãƒ‹ãƒƒã‚¯ã‚’ã‚­ãƒ£ãƒƒãƒã™ã‚‹ã“ã¨ã‚’è©¦ã¿ã‚‹ã“ã¨ãŒã§ãã¾ã™ãŒã€ãã‚Œã¯ã¨ã¦ã‚‚ç‰¹å®šãªçŠ¶æ³ã«äºˆç´„ã•ã‚ŒãŸæœ€å¾Œã®æ‰‹æ®µã§ã‚ã‚‹ã¹ãã§ã™ã€‚</p>
</div>
<div class="footnote-definition" id="macro"><sup class="footnote-definition-label">3</sup>
<p>If it's followed by a <code>!</code>, it's a macro invocation. Think of macros as spicy functions for now. We'll
cover them in more detail later in the course.
ãã‚Œã«<code>!</code>ãŒç¶šãå ´åˆã€ãã‚Œã¯ãƒã‚¯ãƒ­å‘¼ã³å‡ºã—ã§ã™ã€‚
ç¾æ®µéšã§ã¯ã€ã‚¹ãƒ‘ã‚¤ã‚·ãƒ¼ãªé–¢æ•°ã¨ã—ã¦ãƒã‚¯ãƒ­ã‚’è€ƒãˆã¦ãã ã•ã„ã€‚
ã‚³ãƒ¼ã‚¹ã®å¾ŒåŠã§è©³ç´°ã«ãã‚Œã‚‰ã‚’èª¬æ˜ã—ã¾ã™ã€‚</p>
</div>
<h2 id="exercise-6"><a class="header" href="#exercise-6">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/02_basic_calculator/04_panics"><code>02_basic_calculator/04_panics</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="factorialéšä¹—"><a class="header" href="#factorialéšä¹—">Factorialï¼ˆéšä¹—ï¼‰</a></h1>
<p>So far you've learned:</p>
<ul>
<li>How to define a function</li>
<li>How to call a function</li>
<li>Which integer types are available in Rust</li>
<li>Which arithmetic operators are available for integers</li>
<li>How to execute conditional logic via comparisons and <code>if</code>/<code>else</code> expressions</li>
</ul>
<p>It looks like you're ready to tackle factorials!</p>
<blockquote>
<p>ã“ã‚Œã¾ã§ã€æ¬¡ã‚’å­¦ã³ã¾ã—ãŸã€‚</p>
<ul>
<li>é–¢æ•°ã‚’å®šç¾©ã™ã‚‹æ–¹æ³•</li>
<li>é–¢æ•°ã‚’å‘¼ã³å‡ºã™æ–¹æ³•</li>
<li>Rustã§åˆ©ç”¨å¯èƒ½ãªæ•´æ•°å‹</li>
<li>æ•´æ•°ã®ãŸã‚ã«åˆ©ç”¨ã§ãã‚‹ç®—è¡“æ¼”ç®—å­</li>
<li>æ¯”è¼ƒã¨<code>if</code>/<code>else</code>å¼ã‚’ä»‹ã—ã¦æ¡ä»¶çš„ãªãƒ­ã‚¸ãƒƒã‚¯ã‚’å®Ÿè¡Œã™ã‚‹æ–¹æ³•</li>
</ul>
<p>éšä¹—ã«å–ã‚Šçµ„ã‚€æº–å‚™ãŒã§ããŸã‚ˆã†ã§ã™ï¼</p>
</blockquote>
<h2 id="exercise-7"><a class="header" href="#exercise-7">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/02_basic_calculator/05_factorial"><code>02_basic_calculator/05_factorial</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="loops-part-1-whileãƒ«ãƒ¼ãƒ—ãã®1-while"><a class="header" href="#loops-part-1-whileãƒ«ãƒ¼ãƒ—ãã®1-while">Loops, part 1: <code>while</code>ï¼ˆãƒ«ãƒ¼ãƒ—ã€ãã®1: whileï¼‰</a></h1>
<p>Your implementation of <code>factorial</code> has been forced to use recursion.<br />
This may feel natural to you, especially if you're coming from a functional programming background.
Or it may feel strange, if you're used to more imperative languages like C or Python.</p>
<blockquote>
<p><code>factorial</code>ã®å®Ÿè£…ã¯ã€å†å¸°ã‚’ä½¿ç”¨ã™ã‚‹ã‚ˆã†ã«å¼·åˆ¶ã•ã‚Œã¾ã—ãŸã€‚
ç‰¹ã«é–¢æ•°ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã‚’ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã«æŒã£ã¦ã„ã‚‹å ´åˆã€ã“ã‚Œã¯è‡ªç„¶ã«æ„Ÿã˜ã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚
ã¾ãŸã€Cã‚„Pythonã®ã‚ˆã†ãªå‘½ä»¤çš„ãªè¨€èªã‚’ä½¿ç”¨ã—ã¦ããŸå ´åˆã€å¥‡å¦™ã«æ„Ÿã˜ãŸã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚</p>
</blockquote>
<p>Let's see how you can implement the same functionality using a <strong>loop</strong> instead.</p>
<blockquote>
<p>ä»£ã‚ã‚Šã«<strong>ãƒ«ãƒ¼ãƒ—</strong>ã‚’ä½¿ç”¨ã—ã¦åŒã˜æ©Ÿèƒ½ã‚’å®Ÿè£…ã™ã‚‹æ–¹æ³•ã‚’ç¢ºèªã—ã¾ã—ã‚‡ã†ã€‚</p>
</blockquote>
<h2 id="the-while-loopwhileãƒ«ãƒ¼ãƒ—"><a class="header" href="#the-while-loopwhileãƒ«ãƒ¼ãƒ—">The <code>while</code> loopï¼ˆwhileãƒ«ãƒ¼ãƒ—ï¼‰</a></h2>
<p>A <code>while</code> loop is a way to execute a block of code as long as a <strong>condition</strong> is true.<br />
Here's the general syntax:</p>
<blockquote>
<p><code>while</code>ãƒ«ãƒ¼ãƒ—ã¯ã€<strong>æ¡ä»¶</strong>ãŒtrueã§ã‚ã‚‹é™ã‚Šã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯ã‚’å®Ÿè¡Œã™ã‚‹æ–¹æ³•ã§ã™ã€‚
ã“ã“ã«ä¸€èˆ¬çš„ãªæ§‹æ–‡ã‚’ç¤ºã—ã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>while &lt;condition&gt; {
    // code to execute
}
<span class="boring">}</span></code></pre></pre>
<p>For example, we might want to sum the numbers from 1 to 5:</p>
<blockquote>
<p>ä¾‹ãˆã°ã€1ã‹ã‚‰5ã¾ã§ã®æ•°ã‚’åˆè¨ˆã—ãŸã„ã¨ã—ã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let sum = 0;
let i = 1;
// "while i is less than or equal to 5"
// iãŒ5ã‚ˆã‚Šå°ã•ã„ã‹ç­‰ã—ã„é–“
while i &lt;= 5 {
    // `+=` is a shorthand for `sum = sum + i`
    // `+=`ã¯`sum = sum + i`ã®çœç•¥å½¢ã§ã™
    sum += i;
    i += 1;
}
<span class="boring">}</span></code></pre></pre>
<p>This will keep adding 1 to <code>i</code> and <code>i</code> to <code>sum</code> until <code>i</code> is no longer less than or equal to 5.</p>
<blockquote>
<p>ã“ã‚Œã¯ã€<code>i</code>ãŒ5ä»¥ä¸‹ã§ãªããªã‚‹ã¾ã§ã€1ã‚’<code>i</code>ã«ã€<code>i</code>ã‚’<code>sum</code>ã«è¿½åŠ ã—ç¶šã‘ã¾ã™ã€‚</p>
</blockquote>
<h2 id="the-mut-keywordmutã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰"><a class="header" href="#the-mut-keywordmutã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰">The <code>mut</code> keywordï¼ˆmutã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ï¼‰</a></h2>
<p>The example above won't compile as is. You'll get an error like:</p>
<blockquote>
<p>ä¸Šè¨˜ä¾‹ã¯ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã‚Œã¾ã›ã‚“ã€‚æ¬¡ã®ã‚ˆã†ãªã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã™ã€‚</p>
</blockquote>
<pre><code class="language-text">error[E0384]: cannot assign twice to immutable variable `sum`
 --&gt; src/main.rs:7:9
  |
2 |     let sum = 0;
  |         ---
  |         |
  |         first assignment to `sum`
  |         help: consider making this binding mutable: `mut sum`
...
7 |         sum += i;
  |         ^^^^^^^^ cannot assign twice to immutable variable

error[E0384]: cannot assign twice to immutable variable `i`
 --&gt; src/main.rs:8:9
  |
3 |     let i = 1;
  |         -
  |         |
  |         first assignment to `i`
  |         help: consider making this binding mutable: `mut i`
...
8 |         i += 1;
  |         ^^^^^^ cannot assign twice to immutable variable
</code></pre>
<p>This is because variables in Rust are <strong>immutable</strong> by default.<br />
You can't change their value once it has been assigned.</p>
<blockquote>
<p>ã“ã‚Œã¯ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§Rustã®å¤‰æ•°ãŒ<strong>ä¸å¤‰</strong>ã§ã‚ã‚‹ãŸã‚ã§ã™ã€‚
ä¸€åº¦ã€å¤‰æ•°ãŒå€¤ã‚’å‰²ã‚Šå½“ã¦ã‚‰ã‚Œã‚‹ã¨ã€ãã‚Œã‚‰ã®å€¤ã‚’å¤‰æ›´ã§ãã¾ã›ã‚“ã€‚</p>
</blockquote>
<p>If you want to allow modifications, you have to declare the variable as <strong>mutable</strong> using the <code>mut</code> keyword:</p>
<blockquote>
<p>å¤‰æ›´ã‚’è¨±å¯ã—ãŸã„å ´åˆã€<code>mut</code>ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’ä½¿ç”¨ã—ã¦ã€<strong>å¯å¤‰</strong>ã¨ã—ã¦å¤‰æ•°ã‚’å®£è¨€ã—ãªãã¦ã¯ãªã‚Šã¾ã›ã‚“ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// `sum` and `i` are mutable now!
// ç¾åœ¨ã€`sum`ã¨`i`ã¯å¯å¤‰ã§ã™ï¼
let mut sum = 0;
let mut i = 1;

while i &lt;= 5 {
    sum += i;
    i += 1;
}
<span class="boring">}</span></code></pre></pre>
<p>This will compile and run without errors.</p>
<blockquote>
<p>ã“ã‚Œã¯ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã‚Œã€ã‚¨ãƒ©ãƒ¼ãªã—ã§å®Ÿè¡Œã•ã‚Œã¾ã™ã€‚</p>
</blockquote>
<h2 id="further-readingå‚è€ƒè³‡æ–™-1"><a class="header" href="#further-readingå‚è€ƒè³‡æ–™-1">Further readingï¼ˆå‚è€ƒè³‡æ–™ï¼‰</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/std/keyword.while.html"><code>while</code> loop documentation</a></li>
</ul>
<h2 id="exercise-8"><a class="header" href="#exercise-8">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/02_basic_calculator/06_while"><code>02_basic_calculator/06_while</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="loops-part-2-forãƒ«ãƒ¼ãƒ—ãã®2-for"><a class="header" href="#loops-part-2-forãƒ«ãƒ¼ãƒ—ãã®2-for">Loops, part 2: <code>for</code>ï¼ˆãƒ«ãƒ¼ãƒ—ã€ãã®2: forï¼‰</a></h1>
<p>Having to manually increment a counter variable is somewhat tedious. The pattern is also extremely common!<br />
To make this easier, Rust provides a more concise way to iterate over a range of values: the <code>for</code> loop.</p>
<blockquote>
<p>æ‰‹å‹•ã§ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼å¤‰æ•°ã‚’ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ãƒˆã—ãªã‘ã‚Œã°ãªã‚‰ãªã„ã“ã¨ã¯ã€ãªã«ã‹ã¨é¢å€’ã§ã™ã€‚
ã¾ãŸã€ã“ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã¯ã¨ã¦ã‚‚ä¸€èˆ¬çš„ã§ã™ï¼
ã“ã‚Œã‚’ç°¡å˜ã«ã™ã‚‹ãŸã‚ã«ã€Rustã¯å€¤ã®ç¯„å›²ã‚’åå¾©å‡¦ç†ã™ã‚‹ã€ã‚ˆã‚Šç°¡æ½”ãªæ–¹æ³•ã‚’æä¾›ã—ã¦ã„ã¾ã™ã€‚ãã‚Œã¯<code>for</code>ãƒ«ãƒ¼ãƒ—ã§ã™ã€‚</p>
</blockquote>
<h2 id="the-for-loopforãƒ«ãƒ¼ãƒ—"><a class="header" href="#the-for-loopforãƒ«ãƒ¼ãƒ—">The <code>for</code> loopï¼ˆforãƒ«ãƒ¼ãƒ—ï¼‰</a></h2>
<p>A <code>for</code> loop is a way to execute a block of code for each element in an iterator<sup class="footnote-reference"><a href="#iterator">1</a></sup>.
Here's the general syntax:</p>
<blockquote>
<p><code>for</code>ãƒ«ãƒ¼ãƒ—ã¯ã€ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ãƒ¼å†…ã®ãã‚Œãã‚Œã®è¦ç´ ã§ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯ã‚’å®Ÿè¡Œã™ã‚‹æ–¹æ³•ã§ã™ã€‚
ã“ã“ã«ä¸€èˆ¬çš„ãªæ§‹æ–‡ã‚’ç¤ºã—ã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for &lt;element&gt; in &lt;iterator&gt; {
    // code to execute
}
<span class="boring">}</span></code></pre></pre>
<h2 id="rangesãƒ¬ãƒ³ã‚¸ç¯„å›²"><a class="header" href="#rangesãƒ¬ãƒ³ã‚¸ç¯„å›²">Rangesï¼ˆãƒ¬ãƒ³ã‚¸ã€ç¯„å›²ï¼‰</a></h2>
<p>Rust's standard library provides <strong>range</strong> type that can be used to iterate over a sequence of numbers<sup class="footnote-reference"><a href="#weird-ranges">2</a></sup>.
For example, if we want to sum the numbers from 1 to 5:</p>
<blockquote>
<p>Rustæ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã¯ã€æ•°ã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚’åå¾©å‡¦ç†ã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã§ãã‚‹<strong>ãƒ¬ãƒ³ã‚¸</strong>å‹ã‚’æä¾›ã—ã¦ã„ã¾ã™ã€‚
ä¾‹ãˆã°ã€1ã‹ã‚‰5ã¾ã§ã®æ•°ã‚’åˆè¨ˆã—ãŸã„ã¨ã—ã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut sum = 0;
for i in 1..=5 {
    sum += i;
}
<span class="boring">}</span></code></pre></pre>
<p>Every time the loop runs, <code>i</code> will be assigned the next value in the range before executing the block of code.
There are five kinds of ranges in Rust:</p>
<ul>
<li><code>1..5</code>: A (half-open) range. It includes all numbers from 1 to 4. It doesn't include the last value, 5.</li>
<li><code>1..=5</code>: An inclusive range. It includes all numbers from 1 to 5. It includes the last value, 5.</li>
<li><code>1..</code>: An open-ended range. It includes all numbers from 1 to infinity (well, until the maximum value of the integer type).</li>
<li><code>..5</code>: A range that starts at the minimum value for the integer type and ends at 4. It doesn't include the last value, 5.</li>
<li><code>..=5</code>: A range that starts at the minimum value for the integer type and ends at 5. It includes the last value, 5.</li>
</ul>
<blockquote>
<p>ãƒ«ãƒ¼ãƒ—ãŒå®Ÿè¡Œã•ã‚Œã‚‹ãŸã³ã«ã€<code>i</code>ã¯ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯ã‚’å®Ÿè¡Œã™ã‚‹å‰ã«ã€ãƒ¬ãƒ³ã‚¸å†…ã®æ¬¡ã®å€¤ãŒå‰²ã‚Šå½“ã¦ã‚‰ã‚Œã¾ã™ã€‚
Rustã«ã¯æ¬¡ã®5ç¨®é¡ã®ãƒ¬ãƒ³ã‚¸ãŒã‚ã‚Šã¾ã™ã€‚</p>
<ul>
<li><code>1..5</code>: å·¦é–‰å³é–‹ãƒ¬ãƒ³ã‚¸ã§ã™ã€‚ãã‚Œã¯1ã‹ã‚‰4ã¾ã§ã®ã™ã¹ã¦ã®å€¤ã‚’å«ã¿ã¾ã™ã€‚ãã‚Œã¯æœ€å¾Œã®å€¤ã§ã‚ã‚‹5ã‚’å«ã¿ã¾ã›ã‚“ã€‚</li>
<li><code>1..=5</code>: åŒ…æ‹¬çš„ï¼ˆå·¦é–‰å³é–‰ï¼‰ãªãƒ¬ãƒ³ã‚¸ã§ã™ã€‚ãã‚Œã¯1ã‹ã‚‰5ã¾ã§ã®ã™ã¹ã¦ã®å€¤ã‚’å«ã¿ã¾ã™ã€‚ãã‚Œã¯æœ€å¾Œã®å€¤ã§ã‚ã‚‹5ã‚’å«ã¿ã¾ã™ã€‚</li>
<li><code>1..</code>: æœ€å¾ŒãŒé–‹ã‹ã‚ŒãŸãƒ¬ãƒ³ã‚¸ã§ã™ã€‚ãã‚Œã¯1ã‹ã‚‰ç„¡é™ã¾ã§ã®ã™ã¹ã¦ã®å€¤ã‚’å«ã¿ã¾ã™ï¼ˆã¨ã„ã£ã¦ã‚‚ã€ãã®æ•´æ•°å‹ã®æœ€å¤§å€¤ã¾ã§ã§ã™ï¼‰ã€‚</li>
<li><code>..5</code>: ãã®æ•´æ•°å‹ã®æœ€å°å€¤ã‹ã‚‰é–‹å§‹ã—ã¦4ã§çµ‚ã‚ã‚‹ãƒ¬ãƒ³ã‚¸ã§ã™ã€‚ãã‚Œã¯æœ€å¾Œã®å€¤ã§ã‚ã‚‹5ã‚’å«ã¿ã¾ã›ã‚“ã€‚</li>
<li><code>..=5</code>: ãã®æ•´æ•°å‹ã®æœ€å°å€¤ã‹ã‚‰é–‹å§‹ã—ã¦5ã§çµ‚ã‚ã‚‹ãƒ¬ãƒ³ã‚¸ã§ã™ã€‚ãã‚Œã¯æœ€å¾Œã®å€¤ã§ã‚ã‚‹5ã‚’å«ã¿ã¾ã™ã€‚</li>
</ul>
</blockquote>
<p>You can use a <code>for</code> loop with the first three kinds of ranges, where the starting point
is explicitly specified. The last two range types are used in other contexts, that we'll cover later.
The extreme values of a range don't have to be integer literalsâ€”they can be variables or expressions too!
For example:</p>
<blockquote>
<p>ãƒ¬ãƒ³ã‚¸ã®æœ€åˆã®3ç¨®é¡ã‚’<code>for</code>ãƒ«ãƒ¼ãƒ—ã§ä½¿ç”¨ã§ãã€é–‹å§‹å€¤ã¯æ˜ç¤ºçš„ã«æŒ‡å®šã•ã‚Œã¦ã„ã¾ã™ã€‚
æœ€å¾Œã®2ã¤ã®ãƒ¬ãƒ³ã‚¸ã‚¿ã‚¤ãƒ—ã¯ã€ä»–ã®æ–‡è„ˆã§ä½¿ç”¨ã•ã‚Œã¾ã™ãŒã€ãã‚Œã¯å¾Œã§èª¬æ˜ã—ã¾ã™ã€‚
ãƒ¬ãƒ³ã‚¸ã®æ¥µç«¯ãªå€¤ã¯ã€æ•´æ•°ãƒªãƒ†ãƒ©ãƒ«ã§ã‚ã‚‹å¿…è¦ã¯ãªãã€ãã‚Œã‚‰ã¯å¤‰æ•°ã‚„å¼ã§ã‚‚å¯èƒ½ã§ã™ï¼</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let end = 5;
let mut sum = 0;

for i in 1..(end + 1) {
    sum += i;
}
<span class="boring">}</span></code></pre></pre>
<h2 id="further-readingå‚è€ƒè³‡æ–™-2"><a class="header" href="#further-readingå‚è€ƒè³‡æ–™-2">Further readingï¼ˆå‚è€ƒè³‡æ–™ï¼‰</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/std/keyword.for.html"><code>for</code> loop documentation</a></li>
</ul>
<div class="footnote-definition" id="iterator"><sup class="footnote-definition-label">1</sup>
<p>Later in the course we'll give a precise definition of what counts as an "iterator".
For now, think of it as a sequence of values that you can loop over.
ã‚³ãƒ¼ã‚¹ã®å¾ŒåŠã§ã€ã€Œã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ãƒ¼ã€ã¨ã¯ä½•ã‚’ç¤ºã™ã‹ã€æ­£ç¢ºãªå®šç¾©ã‚’ä¸ãˆã¾ã™ã€‚
ç¾æ™‚ç‚¹ã§ã¯ã€ãã‚Œã‚’ãƒ«ãƒ¼ãƒ—å¯èƒ½ãªå€¤ã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã¨è€ƒãˆã¦ãã ã•ã„ã€‚</p>
</div>
<div class="footnote-definition" id="weird-ranges"><sup class="footnote-definition-label">2</sup>
<p>You can use ranges with other types too (e.g. characters and IP addresses),
but integers are definitely the most common case in day-to-day Rust programming.
ä¾‹ãˆã°æ–‡å­—ã‚„IPã‚¢ãƒ‰ãƒ¬ã‚¹ãªã©ã€ä»–ã®å‹ã§ãƒ¬ãƒ³ã‚¸ã‚’ä½¿ç”¨ã§ãã¾ã™ãŒã€æ•´æ•°ãŒçµ¶å¯¾çš„ã«æ—¥å¸¸ã®Rustãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã§æœ€ã‚‚ä¸€èˆ¬çš„ãªã‚±ãƒ¼ã‚¹ã§ã™ã€‚</p>
</div>
<h2 id="exercise-9"><a class="header" href="#exercise-9">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/02_basic_calculator/07_for"><code>02_basic_calculator/07_for</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overflowã‚ªãƒ¼ãƒãƒ¼ãƒ•ãƒ­ãƒ¼"><a class="header" href="#overflowã‚ªãƒ¼ãƒãƒ¼ãƒ•ãƒ­ãƒ¼">Overflowï¼ˆã‚ªãƒ¼ãƒãƒ¼ãƒ•ãƒ­ãƒ¼ï¼‰</a></h1>
<p>The factorial of a number grows quite fast.<br />
For example, the factorial of 20 is 2,432,902,008,176,640,000. That's already bigger than the maximum value for a
32-bit integer, 2,147,483,647.</p>
<blockquote>
<p>éšä¹—ã®æ•°ã¯ã¨ã¦ã‚‚æ—©ãå¢—åŠ ã—ã¾ã™ã€‚
ä¾‹ãˆã°ã€20ã®éšä¹—ã¯2,432,902,008,176,640,000ã§ã™ã€‚ã“ã‚Œã¯ã™ã§ã«32ãƒ“ãƒƒãƒˆæ•´æ•°ã®æœ€å¤§å€¤ã§ã‚ã‚‹2,147,483,647ã‚ˆã‚Šã‚‚å¤§ãã„ã§ã™ã€‚</p>
</blockquote>
<p>When the result of an arithmetic operation is bigger than the maximum value for a given integer type,
we are talking about <strong>an integer overflow</strong>.</p>
<blockquote>
<p>ç®—è¡“æ“ä½œã®çµæœãŒç‰¹å®šã®æ•´æ•°å‹ã®æœ€å¤§å€¤ã‚ˆã‚Šã‚‚å¤§ãããªã‚‹ã¨ãã€ãã‚Œã¯<strong>æ•´æ•°ã‚ªãƒ¼ãƒãƒ¼ãƒ•ãƒ­ãƒ¼</strong>ã¨å‘¼ã°ã‚Œã¾ã™ã€‚</p>
</blockquote>
<p>Integer overflows are an issue because they violate the contract for arithmetic operations.<br />
The result of an arithmetic operation between two integers of a given type should be another integer of the same type.
But the <em>mathematically correct result</em> doesn't fit into that integer type!</p>
<blockquote>
<p>æ•´æ•°ã‚ªãƒ¼ãƒãƒ¼ãƒ•ãƒ­ãƒ¼ã¯ã€ãã‚Œã‚‰ãŒç®—è¡“æ“ä½œã®å¥‘ç´„ã«é•åã™ã‚‹ãŸã‚å•é¡Œã§ã™ã€‚
ç‰¹å®šã®å‹ã®2ã¤ã®æ•´æ•°ã®ç®—è¡“æ¼”ç®—ã®çµæœã¯ã€åŒã˜å‹ã®åˆ¥ãªå€¤ã«ãªã‚‹ã¹ãã§ã™ã€‚
ã—ã‹ã—ã€_æ•°å­¦çš„ã«æ­£ç¢ºãªçµæœ_ã¯ã€ãã®æ•´æ•°å‹ã«åã¾ã‚Šã¾ã›ã‚“ï¼</p>
</blockquote>
<blockquote>
<p>If the result is smaller than the minimum value for a given integer type, we refer to the event as <strong>an integer
underflow</strong>.<br />
For brevity, we'll only talk about integer overflows for the rest of this section, but keep in mind that
everything we say applies to integer underflows as well.</p>
<p>The <code>speed</code> function you wrote in the <a href="02_basic_calculator/02_variables.html">"Variables" section</a> underflowed for some input
combinations.
E.g. if <code>end</code> is smaller than <code>start</code>, <code>end - start</code> will underflow the <code>u32</code> type since the result is supposed
to be negative but <code>u32</code> can't represent negative numbers.</p>
</blockquote>
<blockquote>
<p>çµæœãŒç‰¹å®šã®æ•´æ•°å‹ã®æœ€å°å€¤ã‚ˆã‚Šã‚‚å°ã•ã„å ´åˆã€ãã®ã‚¤ãƒ™ãƒ³ãƒˆã‚’<strong>æ•´æ•°ã‚¢ãƒ³ãƒ€ãƒ¼ãƒ•ãƒ­ãƒ¼</strong>ã¨å‘¼ã³ã¾ã™ã€‚
ç°¡æ½”ã«ã™ã‚‹ãŸã‚ã«ã€ã“ã®ç¯€ã®æ®‹ã‚Šã¯æ•´æ•°ã‚ªãƒ¼ãƒãƒ¼ãƒ•ãƒ­ãƒ¼ã«ã¤ã„ã¦è©±ã—ã¾ã™ãŒã€ã“ã“ã§è©±ã™ã™ã¹ã¦ã®ã“ã¨ã¯æ•´æ•°ã‚¢ãƒ³ãƒ€ãƒ¼ãƒ•ãƒ­ãƒ¼ã«ã‚‚é©ç”¨ã™ã‚‹ã“ã¨ã‚’å¿ƒã«ç•™ã‚ã¦ãŠã„ã¦ãã ã•ã„ã€‚</p>
<p>ã€Œå¤‰æ•°ã€ç¯€ã§è¨˜è¿°ã—ãŸ<code>speed</code>é–¢æ•°ã¯ã€ä»»æ„ã®å…¥åŠ›ã®çµ„ã¿åˆã‚ã›ã§ã‚¢ãƒ³ãƒ€ãƒ¼ãƒ•ãƒ­ãƒ¼ã—ã¾ã™ã€‚
ä¾‹ãˆã°ã€<code>end</code>ãŒ<code>start</code>ã‚ˆã‚Šã‚‚å°ã•ã„å ´åˆã€<code>end - start</code>ã¯ã€ãã®çµæœã¯è² ãŒæƒ³å®šã•ã‚Œã¾ã™ãŒã€<code>u32</code>ã¯è² æ•°ã‚’è¡¨ç¾ã§ããªã„ãŸã‚ã€<code>u32</code>å‹ã§ã‚¢ãƒ³ãƒ€ãƒ¼ãƒ•ãƒ­ãƒ¼ã—ã¾ã™ã€‚</p>
</blockquote>
<h2 id="no-automatic-promotionè‡ªå‹•æ˜‡æ ¼ã¯ã‚ã‚Šã¾ã›ã‚“"><a class="header" href="#no-automatic-promotionè‡ªå‹•æ˜‡æ ¼ã¯ã‚ã‚Šã¾ã›ã‚“">No automatic promotionï¼ˆè‡ªå‹•æ˜‡æ ¼ã¯ã‚ã‚Šã¾ã›ã‚“ï¼‰</a></h2>
<p>One possible approach would be automatically promote the result to a bigger integer type.
E.g. if you're summing two <code>u8</code> integers and the result is 256 (<code>u8::MAX + 1</code>), Rust could choose to interpret the
result as <code>u16</code>, the next integer type that's big enough to hold 256.</p>
<p>But, as we've discussed before, Rust is quite picky about type conversions. Automatic integer promotion
is not Rust's solution to the integer overflow problem.</p>
<blockquote>
<p>1ã¤ã®å¯èƒ½ãªã‚¢ãƒ—ãƒ­ãƒ¼ãƒã¯ã€çµæœã‚’ã‚ˆã‚Šå¤§ããªæ•´æ•°å‹ã«è‡ªå‹•çš„ã«æ˜‡æ ¼ã•ã›ã‚‹ã“ã¨ã§ã™ã€‚
ä¾‹ãˆã°ã€2ã¤ã®<code>u8</code>æ•´æ•°ã‚’åˆè¨ˆã—ã¦ã€çµæœãŒ256ï¼ˆ<code>u8::MAX + 1</code>ï¼‰ã«ãªã‚‹å ´åˆã€Rustã¯<code>u16</code>ã¨ã—ã¦çµæœã‚’è§£é‡ˆã™ã‚‹ã“ã¨ã‚’é¸æŠã™ã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚
æ¬¡ã®æ•´æ•°å‹ã¯ã€256ã‚’ä¿æŒã™ã‚‹ã»ã©ååˆ†å¤§ãã„ã§ã™ã€‚</p>
<p>ã—ã‹ã—ã€å‰ã«è­°è«–ã—ãŸã‚ˆã†ã«ã€Rustã¯å‹å¤‰æ›ã«ã¤ã„ã¦ã¨ã¦ã‚‚ã†ã‚‹ã•ã„ã§ã™ã€‚
è‡ªå‹•æ•´æ•°æ˜‡æ ¼ã¯ã€æ•´æ•°ã‚ªãƒ¼ãƒãƒ¼ãƒ•ãƒ­ãƒ¼å•é¡Œã«å¯¾ã™ã‚‹Rustã®è§£æ±ºç­–ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚</p>
</blockquote>
<h2 id="alternativesä»£æ›¿æ‰‹æ®µ"><a class="header" href="#alternativesä»£æ›¿æ‰‹æ®µ">Alternativesï¼ˆä»£æ›¿æ‰‹æ®µï¼‰</a></h2>
<p>Since we ruled out automatic promotion, what can we do when an integer overflow occurs?<br />
It boils down to two different approaches:</p>
<ul>
<li>Reject the operation</li>
<li>Come up with a "sensible" result that fits into the expected integer type</li>
</ul>
<blockquote>
<p>è‡ªå‹•æ˜‡æ ¼ã‚’é™¤å¤–ã—ãŸãŸã‚ã€æ•´æ•°ã‚ªãƒ¼ãƒãƒ¼ãƒ•ãƒ­ãƒ¼ãŒç™ºç”Ÿã—ãŸã¨ãä½•ãŒã§ãã‚‹ã§ã—ã‚‡ã†ã‹ï¼Ÿ
2ã¤ã®ç•°ãªã‚‹ã‚¢ãƒ—ãƒ­ãƒ¼ãƒã«ã¾ã¨ã‚ã‚‰ã‚Œã¾ã™ã€‚</p>
<ul>
<li>æ“ä½œã‚’æ‹’å¦ã™ã‚‹</li>
<li>æœŸå¾…ã•ã‚Œã‚‹æ•´æ•°å‹ã«ãƒ•ã‚£ãƒƒãƒˆã™ã‚‹ã€Œè‰¯è­˜ã‚ã‚‹ã€çµæœã‚’è€ƒãˆã‚‹</li>
</ul>
</blockquote>
<h3 id="reject-the-operationæ“ä½œã‚’æ‹’å¦ã™ã‚‹"><a class="header" href="#reject-the-operationæ“ä½œã‚’æ‹’å¦ã™ã‚‹">Reject the operationï¼ˆæ“ä½œã‚’æ‹’å¦ã™ã‚‹ï¼‰</a></h3>
<p>This is the most conservative approach: we stop the program when an integer overflow occurs.<br />
That's done via a panic, the mechanism we've already seen in the <a href="02_basic_calculator/04_panics.html">"Panics" section</a>.</p>
<blockquote>
<p>ã“ã‚Œã¯æœ€ã‚‚ä¿å®ˆçš„ãªã‚¢ãƒ—ãƒ­ãƒ¼ãƒã§ã™ã€‚
æ•´æ•°ã‚ªãƒ¼ãƒãƒ¼ãƒ•ãƒ­ãƒ¼ãŒç™ºç”Ÿã—ãŸã¨ããƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’åœæ­¢ã—ã¾ã™ã€‚
ã“ã‚Œã¯ãƒ‘ãƒ‹ãƒƒã‚¯ã‚’ä»‹ã—ã¦è¡Œã‚ã‚Œã€ãã®ãƒ¡ã‚«ãƒ‹ã‚ºãƒ ã¯ã€ã€Œãƒ‘ãƒ‹ãƒƒã‚¯ã€ç¯€ã§ã™ã§ã«ç¢ºèªã—ã¾ã—ãŸã€‚</p>
</blockquote>
<h3 id="come-up-with-a-sensible-resultè‰¯è­˜ã‚ã‚‹çµæœã‚’è€ƒãˆã‚‹"><a class="header" href="#come-up-with-a-sensible-resultè‰¯è­˜ã‚ã‚‹çµæœã‚’è€ƒãˆã‚‹">Come up with a "sensible" resultï¼ˆã€è‰¯è­˜ã‚ã‚‹ã€çµæœã‚’è€ƒãˆã‚‹ï¼‰</a></h3>
<p>When the result of an arithmetic operation is bigger than the maximum value for a given integer type, you can
choose to <strong>wrap around</strong>.<br />
If you think of all the possible values for a given integer type as a circle, wrapping around means that when you
reach the maximum value, you start again from the minimum value.</p>
<blockquote>
<p>ç®—è¡“æ“ä½œã®çµæœãŒç‰¹å®šã®æ•´æ•°å‹ã®æœ€å¤§å€¤ã‚ˆã‚Šã‚‚å¤§ãããªã£ãŸã¨ãã€<strong>åŒ…ã¿è¾¼ã‚€</strong>ã“ã¨ã‚’é¸æŠã§ãã¾ã™ã€‚
å††ã¨ã—ã¦ä¸ãˆã‚‰ã‚ŒãŸæ•´æ•°å‹ã§ã™ã¹ã¦ã®å¯èƒ½æ€§ã®ã‚ã‚‹å€¤ã‚’è€ƒãˆã‚‹ã¨ã€åŒ…ã¿è¾¼ã¿ã¯æœ€å¤§å€¤ã«åˆ°é”ã—ãŸã¨ãã€æœ€å°å€¤ã‹ã‚‰å†ã³é–‹å§‹ã™ã‚‹ã“ã¨ã‚’æ„å‘³ã—ã¾ã™ã€‚</p>
</blockquote>
<p>For example, if you do a <strong>wrapping addition</strong> between 1 and 255 (=<code>u8::MAX</code>), the result is 0 (=<code>u8::MIN</code>).
If you're working with signed integers, the same principle applies. E.g. adding 1 to 127 (=<code>i8::MAX</code>) with wrapping
will give you -128 (=<code>i8::MIN</code>).</p>
<blockquote>
<p>ä¾‹ãˆã°ã€1ã¨255 (=<code>u8::MAX</code>)ã®<strong>åŒ…ã¿è¾¼ã¿åŠ ç®—</strong>ã‚’ã™ã‚‹ã¨ã€çµæœã¯0ï¼ˆ=<code>u8::MIN</code>ï¼‰ã«ãªã‚Šã¾ã™ã€‚
ç¬¦å·ä»˜ãæ•´æ•°ã§ä½œæ¥­ã—ã¦ã„ã‚‹å ´åˆã€åŒã˜åŸå‰‡ãŒé©ç”¨ã•ã‚Œã¾ã™ã€‚
ä¾‹ãˆã°ã€åŒ…ã¿è¾¼ã¿ã‚’ä½¿ç”¨ã—ãŸ1ã¨127ï¼ˆ=<code>i8::MAX</code>ï¼‰ã®åŠ ç®—ã¯ã€-128ï¼ˆ=<code>i8::MIN</code>ï¼‰ã‚’ä¸ãˆã¾ã™ã€‚</p>
</blockquote>
<h2 id="overflow-checksã‚ªãƒ¼ãƒãƒ¼ãƒ•ãƒ­ãƒ¼æ¤œæŸ»"><a class="header" href="#overflow-checksã‚ªãƒ¼ãƒãƒ¼ãƒ•ãƒ­ãƒ¼æ¤œæŸ»"><code>overflow-checks</code>ï¼ˆã‚ªãƒ¼ãƒãƒ¼ãƒ•ãƒ­ãƒ¼æ¤œæŸ»ï¼‰</a></h2>
<p>Rust lets you, the developer, choose which approach to use when an integer overflow occurs.
The behaviour is controlled by the <code>overflow-checks</code> profile setting.</p>
<blockquote>
<p>Rustã¯ã€æ•´æ•°ã‚ªãƒ¼ãƒãƒ¼ãƒ•ãƒ­ãƒ¼ãŒç™ºç”Ÿã—ãŸã¨ãã«ä½¿ç”¨ã™ã‚‹ã‚¢ãƒ—ãƒ­ãƒ¼ãƒã‚’é–‹ç™ºè€…ã«é¸æŠã§ãã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚
ãã®æŒ¯ã‚‹èˆã„ã¯ã€<code>overflow-checks</code>ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«è¨­å®šã«ã‚ˆã£ã¦åˆ¶å¾¡ã•ã‚Œã¾ã™ã€‚</p>
</blockquote>
<p>If <code>overflow-checks</code> is set to <code>true</code>, Rust will <strong>panic at runtime</strong> when an integer operation overflows.
If <code>overflow-checks</code> is set to <code>false</code>, Rust will <strong>wrap around</strong> when an integer operation overflows.</p>
<blockquote>
<p><code>overflow-checks</code>ãŒ<code>true</code>ã«è¨­å®šã•ã‚Œã¦ã„ã‚‹å ´åˆã€Rustã¯æ•´æ•°ã‚ªãƒ¼ãƒãƒ¼ãƒ•ãƒ­ãƒ¼ãŒç™ºç”Ÿã—ãŸã¨ã<strong>ãƒ©ãƒ³ã‚¿ã‚¤ãƒ ã§ãƒ‘ãƒ‹ãƒƒã‚¯</strong>ã—ã¾ã™ã€‚
<code>overflow-checks</code>ãŒ<code>false</code>ã«è¨­å®šã•ã‚Œã¦ã„ã‚‹å ´åˆã€Rustã¯æ•´æ•°ã‚ªãƒ¼ãƒãƒ¼ãƒ•ãƒ­ãƒ¼ãŒç™ºç”Ÿã—ãŸã¨ã<strong>åŒ…ã¿è¾¼ã¿</strong>ã—ã¾ã™ã€‚</p>
</blockquote>
<p>You may be wonderingâ€”what is a profile setting? Let's get into that!</p>
<blockquote>
<p>å›°æƒ‘ã—ã¦ã„ã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«è¨­å®šã¨ã¯ä½•ã§ã—ã‚‡ã†ã‹ï¼Ÿ
ãã‚Œã«ã¤ã„ã¦èª¬æ˜ã—ã¾ã—ã‚‡ã†ï¼</p>
</blockquote>
<h2 id="profilesãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«"><a class="header" href="#profilesãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«">Profilesï¼ˆãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«ï¼‰</a></h2>
<p>A <a href="https://doc.rust-lang.org/cargo/reference/profiles.html"><strong>profile</strong></a> is a set of configuration options that can be
used to customize the way Rust code is compiled.</p>
<blockquote>
<p><strong>ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«</strong>ã¯ã€Rustã‚³ãƒ¼ãƒ‰ãŒã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã‚Œã‚‹æ–¹æ³•ã‚’ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã§ãã‚‹æ§‹æˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®ã‚»ãƒƒãƒˆã§ã™ã€‚</p>
</blockquote>
<p>Cargo provides two built-in profiles: <code>dev</code> and <code>release</code>.<br />
The <code>dev</code> profile is used every time you run <code>cargo build</code>, <code>cargo run</code> or <code>cargo test</code>. It's aimed at local
development,
therefore it sacrifices runtime performance in favor of faster compilation times and a better debugging experience.<br />
The <code>release</code> profile, instead, is optimized for runtime performance but incurs longer compilation times. You need
to explicitly request via the <code>--release</code> flagâ€”e.g. <code>cargo build --release</code> or <code>cargo run --release</code>.</p>
<blockquote>
<p>Cargoã¯ã€<code>dev</code>ã¨<code>release</code>ã®2ã¤ã®çµ„ã¿è¾¼ã¿ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æä¾›ã—ã¾ã™ã€‚
<code>dev</code>ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«ã¯ã€<code>cargo build</code>ã€<code>cargo run</code>ã¾ãŸã¯<code>cargo test</code>ã‚’å®Ÿè¡Œã™ã‚‹ãŸã³ã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚
ãã‚Œã¯ãƒ­ãƒ¼ã‚«ãƒ«é–‹ç™ºã‚’ç›®çš„ã¨ã—ã¦ã„ã‚‹ãŸã‚ã€ãã‚Œã¯çŸ­ã„ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚é–“ã¨ã‚ˆã‚Šè‰¯ã„ãƒ‡ãƒãƒƒã‚°ä½“é¨“ã‚’å¾—ã‚‹ãŸã‚ã«ã€ãƒ©ãƒ³ã‚¿ã‚¤ãƒ ã®æ€§èƒ½ã‚’çŠ ç‰²ã«ã—ã¦ã„ã¾ã™ã€‚
ä»£ã‚ã‚Šã«ã€<code>release</code>ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«ã¯ãƒ©ãƒ³ã‚¿ã‚¤ãƒ æ€§èƒ½ã®ãŸã‚ã«æœ€é©åŒ–ã•ã‚Œã¾ã™ãŒã€ã‚ˆã‚Šé•·ã„ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚é–“ãŒå¿…è¦ã§ã™ã€‚
æ˜ç¤ºçš„ã«<code>--release</code>ãƒ•ãƒ©ã‚°ã‚’è¦æ±‚ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚
ä¾‹ãˆã°ã€<code>cargo build --release</code>ã¾ãŸã¯<code>cargo run --release</code>ã§ã™ã€‚</p>
</blockquote>
<blockquote>
<p>"Have you built your project in release mode?" is almost a meme in the Rust community.<br />
It refers to developers who are not familiar with Rust and complain about its performance on
social media (e.g. Reddit, Twitter, etc.) before realizing they haven't built their project in
release mode.</p>
</blockquote>
<blockquote>
<p>ã€Œãƒªãƒªãƒ¼ã‚¹ãƒ¢ãƒ¼ãƒ‰ã§ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚’ãƒ“ãƒ«ãƒ‰ã—ã¾ã—ãŸã‹ï¼Ÿã€ã¯ã€Rustã‚³ãƒŸãƒ¥ãƒ‹ãƒ†ã‚£ã§ã»ã¼ãƒŸãƒ¼ãƒ ï¼ˆæ–‡åŒ–ã®ä¸­ã§äººã‹ã‚‰äººã«åºƒãŒã£ã¦ã„ãè¡Œå‹•ã‚„ã‚¢ã‚¤ãƒ‡ã‚¢ã®ã“ã¨ï¼‰ã§ã™ã€‚
ãã‚Œã¯ã€Rustã«æ…£ã‚Œã¦ã„ãªã„é–‹ç™ºè€…ãŒã€ãƒªãƒªãƒ¼ã‚¹ãƒ¢ãƒ¼ãƒ‰ã§ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚’ãƒ“ãƒ«ãƒ‰ã—ã¦ã„ãªã„ã“ã¨ã«æ°—ã¥ãå‰ã«ã€Redditã‚„ãƒ„ã‚¤ãƒƒã‚¿ãƒ¼ãªã©ã®ã‚½ãƒ¼ã‚·ãƒ£ãƒ«ãƒ¡ãƒ‡ã‚£ã‚¢ã§ãã®æ€§èƒ½ã«ã¤ã„ã¦ä¸æº€ã‚’è¨€ã†ã“ã¨ã‚’ç¤ºã—ã¾ã™ã€‚</p>
</blockquote>
<p>You can also define custom profiles or customize the built-in ones.</p>
<blockquote>
<p>ã¾ãŸã€ã‚«ã‚¹ã‚¿ãƒ ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å®šç¾©ã—ãŸã‚Šã€çµ„ã¿è¾¼ã¿ã®ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ã€‚</p>
</blockquote>
<h3 id="overflow-checkã‚ªãƒ¼ãƒãƒ¼ãƒ•ãƒ­ãƒ¼ç¢ºèª"><a class="header" href="#overflow-checkã‚ªãƒ¼ãƒãƒ¼ãƒ•ãƒ­ãƒ¼ç¢ºèª"><code>overflow-check</code>ï¼ˆã‚ªãƒ¼ãƒãƒ¼ãƒ•ãƒ­ãƒ¼ç¢ºèªï¼‰</a></h3>
<p>By default, <code>overflow-checks</code> is set to:</p>
<ul>
<li><code>true</code> for the <code>dev</code> profile</li>
<li><code>false</code> for the <code>release</code> profile</li>
</ul>
<blockquote>
<p>ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã€<code>overflow-checks</code>ã¯æ¬¡ã®é€šã‚Šè¨­å®šã•ã‚Œã¦ã„ã¾ã™ã€‚</p>
<p><code>true</code>ã¯<code>dev</code>ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«ã«å¯¾ã—ã¦
<code>false</code>ã¯<code>release</code>ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«ã«å¯¾ã—ã¦</p>
</blockquote>
<p>This is in line with the goals of the two profiles.<br />
<code>dev</code> is aimed at local development, so it panics in order to highlight potential issues as early as possible.<br />
<code>release</code>, instead, is tuned for runtime performance: checking for overflows would slow down the program, so it
prefers to wrap around.</p>
<blockquote>
<p>ã“ã‚Œã¯ã€2ã¤ã®ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«ã®ç›®æ¨™ã¨ä¸€è‡´ã—ã¦ã„ã¾ã™ã€‚
<code>dev</code>ã¯ãƒ­ãƒ¼ã‚«ãƒ«é–‹ç™ºã‚’ç›®çš„ã¨ã—ã¦ã„ã‚‹ãŸã‚ã€ãã‚Œã¯å¯èƒ½ãªé™ã‚Šæ—©æœŸã«å•é¡Œã®å¯èƒ½æ€§ã‚’å¼·èª¿ã™ã‚‹ãŸã‚ã«ãƒ‘ãƒ‹ãƒƒã‚¯ã—ã¾ã™ã€‚
ä»£ã‚ã‚Šã«ã€<code>release</code>ã¯ã€ãƒ©ãƒ³ã‚¿ã‚¤ãƒ æ€§èƒ½ã‚’å‘ä¸Šã•ã›ã‚‹ãŸã‚ã«èª¿æ•´ã•ã‚Œã¦ãŠã‚Šã€ã‚ªãƒ¼ãƒãƒ¼ãƒ•ãƒ­ãƒ¼ã®ç¢ºèªã¯ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’é…ãã™ã‚‹ãŸã‚ã€ãã‚Œã¯åŒ…ã¿è¾¼ã‚€ã“ã¨ã‚’é¸æŠã—ã¦ã„ã¾ã™ã€‚</p>
</blockquote>
<p>At the same time, having different behaviours for the two profiles can lead to subtle bugs.<br />
Our recommendation is to enable <code>overflow-checks</code> for both profiles: it's better to crash than to silently produce
incorrect results. The runtime performance hit is negligible in most cases; if you're working on a performance-critical
application, you can run benchmarks to decide if it's something you can afford.</p>
<blockquote>
<p>åŒæ™‚ã«ã€2ã¤ã®ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«ã§ç•°ãªã‚‹æŒ¯ã‚‹èˆã„ã‚’æŒã¤ã“ã¨ã§ã€äº›ç´°ãªãƒã‚°ã‚’æ‹›ãå¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚
æ¨å¥¨ã¯ã€ä¸¡æ–¹ã®ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«ã§<code>overflow-checks</code>ã‚’æœ‰åŠ¹ã«ã™ã‚‹ã“ã¨ã§ã™ã€‚
ãã‚Œã¯ã€é™ã‹ã«èª¤ã£ãŸçµæœã‚’ç”Ÿç”£ã™ã‚‹ã‚ˆã‚Šã‚‚ã€ã‚¯ãƒ©ãƒƒã‚·ãƒ¥ã—ãŸã»ã†ãŒè‰¯ã„ã‹ã‚‰ã§ã™ã€‚
ãƒ©ãƒ³ã‚¿ã‚¤ãƒ æ€§èƒ½ã®å½±éŸ¿ã¯ã€ã»ã¨ã‚“ã©ã®å ´åˆã§ç„¡è¦–ã§ãã¾ã™ã€‚
ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãŒé‡è¦ãªã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã§ä½œæ¥­ã—ã¦ã„ã‚‹å ´åˆã€ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯ã‚’å®Ÿè¡Œã—ã¦ã€ãã‚ŒãŒè¨±å®¹ã§ãã‚‹ã‹æ±ºå®šã§ãã¾ã™ã€‚</p>
</blockquote>
<h2 id="further-readingå‚è€ƒè³‡æ–™-3"><a class="header" href="#further-readingå‚è€ƒè³‡æ–™-3">Further readingï¼ˆå‚è€ƒè³‡æ–™ï¼‰</a></h2>
<ul>
<li>Check out <a href="https://huonw.github.io/blog/2016/04/myths-and-legends-about-integer-overflow-in-rust/">"Myths and legends about integer overflow in Rust"</a>
for an in-depth discussion about integer overflow in Rust.</li>
</ul>
<h2 id="exercise-10"><a class="header" href="#exercise-10">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/02_basic_calculator/08_overflow"><code>02_basic_calculator/08_overflow</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="case-by-case-behaviorçŠ¶æ³ã«å¿œã˜ãŸæŒ¯ã‚‹èˆã„"><a class="header" href="#case-by-case-behaviorçŠ¶æ³ã«å¿œã˜ãŸæŒ¯ã‚‹èˆã„">Case-by-case behaviorï¼ˆçŠ¶æ³ã«å¿œã˜ãŸæŒ¯ã‚‹èˆã„ï¼‰</a></h1>
<p><code>overflow-checks</code> is a blunt tool: it's a global setting that affects the whole program.<br />
It often happens that you want to handle integer overflows differently depending on the context: sometimes
wrapping is the right choice, other times panicking is preferable.</p>
<blockquote>
<p><code>overflow-checks</code>ã¯é æ…®ã®ãªã„ãƒ„ãƒ¼ãƒ«ã§ã™ã€‚
ãã‚Œã¯ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ å…¨ä½“ã«å½±éŸ¿ã‚’ä¸ãˆã‚‹ã‚°ãƒ­ãƒ¼ãƒãƒ«ãªè¨­å®šã§ã™ã€‚
æ–‡è„ˆã«ã‚ˆã£ã¦ç•°ãªã‚‹æ•´æ•°ã‚ªãƒ¼ãƒãƒ¼ãƒ•ãƒ­ãƒ¼ã‚’å‡¦ç†ã—ãŸã„ã“ã¨ãŒã‚ˆãã‚ã‚Šã¾ã™ã€‚
æ™‚ã€…ã€åŒ…ã¿è¾¼ã¿ã¯æ­£ã—ã„é¸æŠã§ã€ä»–ã®ã¨ãã¯ãƒ‘ãƒ‹ãƒƒã‚¯ãŒå¥½ã¾ã—ã„ã§ã™ã€‚</p>
</blockquote>
<h2 id="wrapping_-methodswrapping_ãƒ¡ã‚½ãƒƒãƒ‰"><a class="header" href="#wrapping_-methodswrapping_ãƒ¡ã‚½ãƒƒãƒ‰"><code>wrapping_</code> methodsï¼ˆwrapping_ãƒ¡ã‚½ãƒƒãƒ‰ï¼‰</a></h2>
<p>You can opt into wrapping arithmetic on a per-operation basis by using the <code>wrapping_</code> methods<sup class="footnote-reference"><a href="#method">1</a></sup>.<br />
For example, you can use <code>wrapping_add</code> to add two integers with wrapping:</p>
<blockquote>
<p><code>wrapping_</code>ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ç”¨ã—ã¦ã€æ“ä½œã”ã¨ã«åŒ…ã¿è¾¼ã¿ç®—è¡“ã‚’é¸æŠã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚
ä¾‹ãˆã°ã€åŒ…ã¿è¾¼ã¿ã‚’ä½¿ç”¨ã—ã¦2ã¤ã®æ•´æ•°ã‚’åŠ ç®—ã™ã‚‹ãŸã‚ã«ã€<code>wrapping_add</code>ã‚’ä½¿ç”¨ã§ãã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 255u8;
let y = 1u8;
let sum = x.wrapping_add(y);
assert_eq!(sum, 0);
<span class="boring">}</span></code></pre></pre>
<h2 id="saturating_-methodssaturating_ãƒ¡ã‚½ãƒƒãƒ‰"><a class="header" href="#saturating_-methodssaturating_ãƒ¡ã‚½ãƒƒãƒ‰"><code>saturating_</code> methodsï¼ˆsaturating_ãƒ¡ã‚½ãƒƒãƒ‰ï¼‰</a></h2>
<p>Alternatively, you can opt into <strong>saturating arithmetic</strong> by using the <code>saturating_</code> methods.<br />
Instead of wrapping around, saturating arithmetic will return the maximum or minimum value for the integer type.
For example:</p>
<blockquote>
<p>ä»£ã‚ã‚Šã«ã€<code>saturating_</code>ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ç”¨ã—ã¦<strong>é£½å’Œç®—è¡“</strong>ã‚’é¸æŠã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚
åŒ…ã¿è¾¼ã¿ã®ä»£ã‚ã‚Šã«ã€é£½å’Œç®—è¡“ã¯æ•´æ•°å‹ã®æœ€å¤§å€¤ã¾ãŸã¯æœ€å°å€¤ã‚’è¿”ã—ã¾ã™ã€‚
ä¾‹ãˆã°ãƒ»ãƒ»ãƒ»</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 255u8;
let y = 1u8;
let sum = x.saturating_add(y);
assert_eq!(sum, 255);
<span class="boring">}</span></code></pre></pre>
<p>Since <code>255 + 1</code> is <code>256</code>, which is bigger than <code>u8::MAX</code>, the result is <code>u8::MAX</code> (255).<br />
The opposite happens for underflows: <code>0 - 1</code> is <code>-1</code>, which is smaller than <code>u8::MIN</code>, so the result is <code>u8::MIN</code> (0).</p>
<blockquote>
<p><code>255 + 1</code>ã¯<code>256</code>ã§ã‚ã‚Šã€<code>u8::MAX</code>ã‚ˆã‚Šå¤§ãã„ãŸã‚ã€çµæœã¯<code>u8::MAX</code>ï¼ˆ255ï¼‰ã§ã™ã€‚
ã‚¢ãƒ³ãƒ€ãƒ¼ãƒ•ãƒ­ãƒ¼ã®å ´åˆã¯é€†ã§ã™ã€‚<code>0 - 1</code>ã¯<code>-1</code>ã§ã‚ã‚Šã€<code>u8::MIN</code>ã‚ˆã‚Šå°ã•ã„ãŸã‚ã€çµæœã¯<code>u8::MIN</code>ï¼ˆ0ï¼‰ã§ã™ã€‚</p>
</blockquote>
<p>You can't get saturating arithmetic via the <code>overflow-checks</code> profile settingâ€”you have to explicitly opt into it
when performing the arithmetic operation.</p>
<blockquote>
<p>é£½å’Œç®—è¡“ã¯<code>overflow-checks</code>ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«è¨­å®šã‚’ä»‹ã—ã¦å–å¾—ã§ãã¾ã›ã‚“ã€‚
ç®—è¡“æ“ä½œã‚’å®Ÿè¡Œã™ã‚‹ã¨ãã«æ˜ç¤ºçš„ã«é¸æŠã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚</p>
</blockquote>
<div class="footnote-definition" id="method"><sup class="footnote-definition-label">1</sup>
<p>You can think of methods as functions that are "attached" to a specific type.
We'll cover methods (and how to define them) in the next chapter.
ç‰¹å®šã®å‹ã«ã€Œä»˜å±ã—ãŸã€é–¢æ•°ã¨ã—ã¦ãƒ¡ã‚½ãƒƒãƒ‰ã‚’è€ƒãˆã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚
æ¬¡ã®ç« ã§ãƒ¡ã‚½ãƒƒãƒ‰ï¼ˆãŠã‚ˆã³ãã‚Œã‚‰ã‚’å®šç¾©ã™ã‚‹æ–¹æ³•ï¼‰ã«ã¤ã„ã¦èª¬æ˜ã—ã¾ã™ã€‚</p>
</div>
<h2 id="exercise-11"><a class="header" href="#exercise-11">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/02_basic_calculator/09_saturating"><code>02_basic_calculator/09_saturating</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="conversions-pt-1å¤‰æ›ãã®1"><a class="header" href="#conversions-pt-1å¤‰æ›ãã®1">Conversions, pt. 1ï¼ˆå¤‰æ›ã€ãã®1ï¼‰</a></h1>
<p>We've repeated over and over again that Rust won't perform
implicit type conversions for integers.<br />
How do you perform <em>explicit</em> conversions then?</p>
<blockquote>
<p>Rustã¯æ•´æ•°ã®æš—é»™çš„ãªå‹å¤‰æ›ã‚’è¡Œã‚ãªã„ã“ã¨ã‚’ä½•åº¦ã‚‚ç¹°ã‚Šè¿”ã—èª¬æ˜ã—ã¾ã—ãŸã€‚
ã§ã¯ã€ã©ã®ç”¨ã«_æ˜ç¤ºçš„ã«_å¤‰æ›ã‚’è¡Œã†ã®ã§ã—ã‚‡ã†ã‹ï¼Ÿ</p>
</blockquote>
<h2 id="as"><a class="header" href="#as"><code>as</code></a></h2>
<p>You can use the <code>as</code> operator to convert between integer types.<br />
<code>as</code> conversions are <strong>infallible</strong>.
For example:</p>
<blockquote>
<p>æ•´æ•°å‹é–“ã‚’å¤‰æ›ã™ã‚‹ãŸã‚ã«<code>as</code>æ¼”ç®—å­ã‚’ä½¿ç”¨ã§ãã¾ã™ã€‚
<code>as</code>å¤‰æ›ã¯<strong>å¤±æ•—ã—ã¾ã›ã‚“</strong>ã€‚
ä¾‹ãˆã°ãƒ»ãƒ»ãƒ»</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a: u32 = 10;

// Cast `a` into the `u64` type
// `a`ã‚’`u64`å‹ã«ã‚­ãƒ£ã‚¹ãƒˆã—ã¾ã™ã€‚
let b = a as u64;

// You can use `_` as the target type
// if it can be correctly inferred
// by the compiler. For example:
// ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã«ã‚ˆã£ã¦æ­£ç¢ºã«æ¨è«–ã•ã‚Œã‚‹å ´åˆã€ç›®çš„ã®å‹ã¨ã—ã¦`_`ã‚’ä½¿ç”¨ã§ãã¾ã™ã€‚
// ä¾‹ãˆã°ãƒ»ãƒ»ãƒ»
let c: u64 = a as _;
<span class="boring">}</span></code></pre></pre>
<p>The semantics of this conversion are what you expect: all <code>u32</code> values are valid <code>u64</code>
values.</p>
<blockquote>
<p>ã“ã®å¤‰æ›ã®æ„å‘³ã¯ã€ä½•ã‚’æœŸå¾…ã™ã‚‹ã‹ã‚’ç¤ºã—ã¾ã™ã€‚
ã™ã¹ã¦ã®<code>u32</code>å€¤ã¯æœ‰åŠ¹ãª<code>u64</code>å€¤ã§ã™ã€‚</p>
</blockquote>
<h3 id="truncationåˆ‡ã‚Šæ¨ã¦"><a class="header" href="#truncationåˆ‡ã‚Šæ¨ã¦">Truncationï¼ˆåˆ‡ã‚Šæ¨ã¦ï¼‰</a></h3>
<p>Things get more interesting if we go in the opposite direction:</p>
<blockquote>
<p>åå¯¾æ–¹å‘ã«è¡Œã£ãŸå ´åˆã€ã‚ˆã‚Šèˆˆå‘³æ·±ã„ã“ã¨ãŒèµ·ã“ã‚Šã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// A number that's too big
// to fit into a `u8`
// `u8`ã«åã¾ã‚‰ãªã„ã»ã©å¤§ããªæ•°ã§ã™ã€‚
let a: u16 = 255 + 1;
let b = a as u8;
<span class="boring">}</span></code></pre></pre>
<p>This program will run without issues, because <code>as</code> conversions are infallible.
But what is the value of <code>b</code>?
When going from a larger integer type to a smaller, the Rust compiler will perform
a <strong>truncation</strong>.</p>
<blockquote>
<p><code>as</code>å¤‰æ›ã¯å¤±æ•—ã—ãªã„ãŸã‚ã€ã“ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯å•é¡Œãªãå®Ÿè¡Œã•ã‚Œã¾ã™ã€‚
ã§ã¯ã€<code>b</code>ã®å€¤ã¯ä½•ã§ã—ã‚‡ã†ã‹ï¼Ÿ
å¤§ããªæ•´æ•°å‹ã‚’å°ã•ãªæ•´æ•°å‹ã«å¤‰æ›ã—ãŸã¨ãã€Rustã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ¼ã¯<strong>åˆ‡ã‚Šæ¨ã¦</strong>ã‚’è¡Œã„ã¾ã™ã€‚</p>
</blockquote>
<p>To understand what happens, let's start by looking at how <code>256u16</code> is
represented in memory, as a sequence of bits:</p>
<blockquote>
<p>ä½•ãŒèµ·ã“ã‚‹ã‹ã‚’ç†è§£ã™ã‚‹ãŸã‚ã«ã€<code>256u16</code>ãŒãƒ“ãƒƒãƒˆã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã¨ã—ã¦ãƒ¡ãƒ¢ãƒªå†…ã§è¡¨ç¾ã•ã‚Œã‚‹æ–¹æ³•ã‚’ç¢ºèªã™ã‚‹ã“ã¨ã‹ã‚‰å§‹ã‚ã¾ã—ã‚‡ã†ã€‚</p>
</blockquote>
<pre><code class="language-text"> 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0
|               |               |
+---------------+---------------+
  First 8 bits    Last 8 bits
</code></pre>
<p>When converting to a <code>u8</code>, the Rust compiler will keep the last 8 bits of a <code>u16</code>
memory representation:</p>
<blockquote>
<p><code>u8</code>ã«å¤‰æ›ã™ã‚‹ã¨ãã€Rustã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ¼ã¯<code>u16</code>ã®ãƒ¡ãƒ¢ãƒªè¡¨ç¾ã®æœ€å¾Œã®8ãƒ“ãƒƒãƒˆã‚’ç¶­æŒã—ã¾ã™ã€‚</p>
</blockquote>
<pre><code class="language-text"> 0 0 0 0 0 0 0 0
|               |
+---------------+
  Last 8 bits
</code></pre>
<p>Hence <code>256 as u8</code> is equal to <code>0</code>. That's... not ideal, in most scenarios.<br />
In fact, the Rust compiler will actively try to stop you if it sees you trying
to cast a literal value which will result in a truncation:</p>
<blockquote>
<p>ã‚ˆã£ã¦ã€<code>256 as u8</code>ã¯<code>0</code>ã¨ç­‰ã—ã„ã§ã™ã€‚ã»ã¨ã‚“ã©ã®ã‚·ãƒŠãƒªã‚ªã§ã€ãã‚Œã¯ãƒ»ãƒ»ãƒ»ç†æƒ³çš„ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚
å®Ÿéš›ã«ã€Rustã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ¼ã¯ã€åˆ‡ã‚Šæ¨ã¦ã®çµæœã«ãªã‚‹ãƒªãƒ†ãƒ©ãƒ«å€¤ã‚’ã‚­ãƒ£ã‚¹ãƒˆã™ã‚‹è©¦ã¿ã‚’ç¢ºèªã™ã‚‹ã¨ã€ç©æ¥µçš„ã«åœæ­¢ã—ã‚ˆã†ã¨ã—ã¾ã™ã€‚</p>
</blockquote>
<pre><code class="language-text">error: literal out of range for `i8`
  |
4 |     let a = 255 as i8;
  |             ^^^
  |
  = note: the literal `255` does not fit into the type `i8` whose range is `-128..=127`
  = help: consider using the type `u8` instead
  = note: `#[deny(overflowing_literals)]` on by default
</code></pre>
<h3 id="recommendationæ¨å¥¨äº‹é …"><a class="header" href="#recommendationæ¨å¥¨äº‹é …">Recommendationï¼ˆæ¨å¥¨äº‹é …ï¼‰</a></h3>
<p>As a rule of thumb, be quite careful with <code>as</code> casting.<br />
Use it <em>exclusively</em> for going from a smaller type to a larger type.
To convert from a larger to smaller integer type, rely on the
<a href="02_basic_calculator/../05_ticket_v2/13_try_from.html"><em>fallible</em> conversion machinery</a> that we'll
explore later in the course.</p>
<blockquote>
<p>çµŒé¨“å‰‡ã¨ã—ã¦ã€<code>as</code>ã‚­ãƒ£ã‚¹ãƒˆã®ä½¿ç”¨ã¯ã¨ã¦ã‚‚æ³¨æ„ã—ã¦è¡Œã£ã¦ãã ã•ã„ã€‚
ãã‚Œã¯ã€å°ã•ãªå‹ã‹ã‚‰å¤§ããªå‹ã«å¤‰æ›ã™ã‚‹ãŸã‚ã«_æ’ä»–çš„ã«_ä½¿ç”¨ã—ã¦ãã ã•ã„ã€‚
_å¤±æ•—ã—ãªã„å¤‰æ›æ©Ÿæ¢°_ã«ã¤ã„ã¦ã‚³ãƒ¼ã‚¹ã®å¾ŒåŠã§æ¢æ±‚ã—ã¾ã™ã€‚</p>
</blockquote>
<h3 id="limitationsåˆ¶é™äº‹é …"><a class="header" href="#limitationsåˆ¶é™äº‹é …">Limitationsï¼ˆåˆ¶é™äº‹é …ï¼‰</a></h3>
<p>Surprising behaviour is not the only downside of <code>as</code> casting.
It is also fairly limited: you can only rely on <code>as</code> casting
for primitive types and a few other special cases.<br />
When working with composite types, you'll have to rely on
different conversion mechanisms (<a href="02_basic_calculator/../05_ticket_v2/13_try_from.html">fallible</a>
and <a href="02_basic_calculator/../04_traits/09_from.html">infallible</a>), which we'll explore later on.</p>
<blockquote>
<p>é©šãã¹ãæŒ¯ã‚‹èˆã„ã¯ã€<code>as</code>ã‚­ãƒ£ã‚¹ãƒˆã®å”¯ä¸€ã®æ¬ ç‚¹ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚
ã¾ãŸã€ãã‚Œã¯ã‹ãªã‚Šåˆ¶é™ã•ã‚Œã¦ã„ã¾ã™ã€‚
<code>as</code>ã‚­ãƒ£ã‚¹ãƒˆã¯ã€ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ãªå‹ã¨ã„ãã¤ã‹ã®ä»–ã®ç‰¹åˆ¥ãªå ´é¢ã«ã®ã¿ä¾å­˜ã—ã¦ã„ã¾ã™ã€‚
è¤‡åˆå‹ã§ä½œæ¥­ã—ã¦ã„ã‚‹ã¨ãã€å¾Œã§æ¢æ±‚ã™ã‚‹_å¤±æ•—ã™ã‚‹_ã¨_å¤±æ•—ã—ãªã„_ã®ç•°ãªã‚‹å¤‰æ›ãƒ¡ã‚«ãƒ‹ã‚ºãƒ ã«ä¾å­˜ã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚</p>
</blockquote>
<h2 id="further-readingå‚è€ƒè³‡æ–™-4"><a class="header" href="#further-readingå‚è€ƒè³‡æ–™-4">Further readingï¼ˆå‚è€ƒè³‡æ–™ï¼‰</a></h2>
<ul>
<li>Check out <a href="https://doc.rust-lang.org/reference/expressions/operator-expr.html#numeric-cast">Rust's official reference</a>
to learn the precise behaviour of <code>as</code> casting for each source/target combination,
as well as the exhaustive list of allowed conversions.
å¤‰æ›ã‚’è¨±å¯ã™ã‚‹ç¶²ç¾…çš„ãªãƒªã‚¹ãƒˆã¨åŒæ§˜ã«ã€ãã‚Œãã‚Œã®ã‚½ãƒ¼ã‚¹/ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã®çµ„ã¿åˆã‚ã›ã«å¯¾ã™ã‚‹<code>as</code>ã‚­ãƒ£ã‚¹ãƒˆã®æ­£ç¢ºãªå‹•ä½œã‚’å­¦ã¶ãŸã‚ã«ã€_Rustã®å…¬å¼ãƒªãƒ•ã‚¡ãƒ¬ãƒ³ã‚¹_ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚</li>
</ul>
<h2 id="exercise-12"><a class="header" href="#exercise-12">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/02_basic_calculator/10_as_casting"><code>02_basic_calculator/10_as_casting</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="modelling-a-ticketãƒã‚±ãƒƒãƒˆã®ãƒ¢ãƒ‡ãƒªãƒ³ã‚°"><a class="header" href="#modelling-a-ticketãƒã‚±ãƒƒãƒˆã®ãƒ¢ãƒ‡ãƒªãƒ³ã‚°">Modelling A Ticketï¼ˆãƒã‚±ãƒƒãƒˆã®ãƒ¢ãƒ‡ãƒªãƒ³ã‚°ï¼‰</a></h1>
<p>The first chapter should have given you a good grasp over some of Rust's primitive types, operators and
basic control flow constructs.<br />
In this chapter we'll go one step further and cover what makes Rust truly unique: <strong>ownership</strong>.<br />
Ownership is what enables Rust to be both memory-safe and performant, with no garbage collector.</p>
<blockquote>
<p>æœ€åˆã®ç« ã¯ã€Rustã®ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–å‹ã€æ¼”ç®—å­ãã—ã¦åŸºæœ¬çš„ãªåˆ¶å¾¡ãƒ•ãƒ­ãƒ¼ã®æ§‹ç¯‰ã«ã¤ã„ã¦è‰¯ã„ç†è§£ã‚’ä¸ãˆã‚‹ã¯ãšã§ã™ã€‚
ã“ã®ç« ã¯ã€å…ˆã«ã‚¹ãƒ†ãƒƒãƒ—ã‚’é€²ã‚ã¦ã€Rustã‚’æœ¬å½“ã«ãƒ¦ãƒ‹ãƒ¼ã‚¯ã«ã™ã‚‹<strong>æ‰€æœ‰æ¨©</strong>ã«ã¤ã„ã¦èª¬æ˜ã—ã¾ã™ã€‚
æ‰€æœ‰æ¨©ã¯ã€ãƒ¡ãƒ¢ãƒªã‚»ãƒ¼ãƒ•ã¨é«˜æ€§èƒ½ã®ä¸¡æ–¹ã‚’æœ‰åŠ¹ã«ã™ã‚‹ã‚‚ã®ã§ã€ã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚¿ãƒ¼ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚</p>
</blockquote>
<p>As our running example, we'll use a (JIRA-like) ticket, the kind you'd use to track bugs, features, or tasks in
a software project.<br />
We'll take a stab at modeling it in Rust. It'll be the first iterationâ€”it won't be perfect nor very idiomatic
by the end of the chapter. It'll be enough of a challenge though!<br />
To move forward you'll have to pick up several new Rust concepts, such as:</p>
<ul>
<li><code>struct</code>s, one of Rust's ways to define custom types</li>
<li>Ownership, references and borrowing</li>
<li>Memory management: stack, heap, pointers, data layout, destructors</li>
<li>Modules and visibility</li>
<li>Strings</li>
</ul>
<blockquote>
<p>å®Ÿè¡Œä¾‹ã¨ã—ã¦ã€ã‚½ãƒ•ãƒˆã‚¦ã‚§ã‚¢ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®ãƒã‚°ã€æ©Ÿèƒ½ã¾ãŸã¯ã‚¿ã‚¹ã‚¯ã‚’è¿½è·¡ã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã™ã‚‹ã€JIRAã®ã‚ˆã†ãªãƒã‚±ãƒƒãƒˆã‚’ä½¿ç”¨ã—ã¾ã™ã€‚
Rustã§ãƒ¢ãƒ‡ãƒªãƒ³ã‚°ã™ã‚‹äºˆå®šã§ã™ã€‚ãã‚Œã¯æœ€åˆã®ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã§ã€ç« ã®æœ€å¾Œã§ã‚‚ãã‚Œã¯å®Œå…¨ã§ç†æƒ³çš„ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚
ã—ã‹ã—ã€ãã‚Œã¯æŒ‘æˆ¦ã™ã‚‹ã«ã¯ååˆ†ã§ã™ï¼
å…ˆã«é€²ã‚€ãŸã‚ã«ã€æ¬¡ã®ã‚ˆã†ãªRustã®æ–°ã—ã„æ¦‚å¿µã‚’å–ã‚Šä¸Šã’ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚</p>
<ul>
<li><code>struct</code>ã¯ã€ã‚«ã‚¹ã‚¿ãƒ å‹ã‚’å®šç¾©ã™ã‚‹Rustã®1ã¤ã®æ–¹æ³•ã§ã™ã€‚</li>
<li>æ‰€æœ‰æ¨©ã€å‚ç…§ãã—ã¦å€Ÿç”¨</li>
<li>ãƒ¡ãƒ¢ãƒªç®¡ç†: ã‚¹ã‚¿ãƒƒã‚¯ã€ãƒ’ãƒ¼ãƒ—ã€ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã€ãƒ‡ãƒ¼ã‚¿ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã€ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãƒ¼</li>
<li>ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¨å¯è¦–æ€§</li>
<li>æ–‡å­—åˆ—</li>
</ul>
</blockquote>
<h2 id="exercise-13"><a class="header" href="#exercise-13">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/03_ticket_v1/00_intro"><code>03_ticket_v1/00_intro</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="structsæ§‹é€ ä½“"><a class="header" href="#structsæ§‹é€ ä½“">Structsï¼ˆæ§‹é€ ä½“ï¼‰</a></h1>
<p>We need to keep track of three pieces of information for each ticket:</p>
<ul>
<li>A title</li>
<li>A description</li>
<li>A status</li>
</ul>
<blockquote>
<p>ãã‚Œãã‚Œã®ãƒã‚±ãƒƒãƒˆã®3ã¤ã®æƒ…å ±ã‚’è¿½è·¡ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚</p>
<ul>
<li>ã‚¿ã‚¤ãƒˆãƒ«</li>
<li>èª¬æ˜</li>
<li>çŠ¶æ…‹</li>
</ul>
</blockquote>
<p>We can start by using a <a href="https://doc.rust-lang.org/std/string/struct.String.html"><code>String</code></a>
to represent them. <code>String</code> is the type defined in Rust's standard library to represent
<a href="https://en.wikipedia.org/wiki/UTF-8">UTF-8 encoded</a> text.</p>
<blockquote>
<p>ãã‚Œã‚‰ã‚’è¡¨ç¾ã™ã‚‹ãŸã‚ã«<code>String</code>ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã‹ã‚‰å§‹ã‚ã¾ã™ã€‚
<code>String</code>ã¯ã€<code>UTF-8ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰</code>ãƒ†ã‚­ã‚¹ãƒˆã‚’è¡¨ç¾ã™ã‚‹ãŸã‚ã«ã€Rustã®æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã«å®šç¾©ã•ã‚ŒãŸå‹ã§ã™ã€‚</p>
</blockquote>
<p>But how do we <strong>combine</strong> these three pieces of information into a single entity?</p>
<blockquote>
<p>ã—ã‹ã—ã€ã©ã®ã‚ˆã†ã«ã“ã‚Œã‚‰3ã¤ã®æƒ…å ±ã®æ–­ç‰‡ã‚’ã€å˜ä¸€ã®ã‚¨ãƒ³ãƒˆãƒªã«<strong>çµ„ã¿åˆã‚ã›</strong>ã™ã‚‹ã®ã§ã—ã‚‡ã†ã‹ï¼Ÿ</p>
</blockquote>
<h2 id="defining-a-structstructã®å®šç¾©"><a class="header" href="#defining-a-structstructã®å®šç¾©">Defining a <code>struct</code>ï¼ˆstructã®å®šç¾©ï¼‰</a></h2>
<p>A <code>struct</code> defines a <strong>new Rust type</strong>.</p>
<blockquote>
<p><code>struct</code>ã¯ã€<strong>æ–°ã—ã„Rustã®å‹</strong>ã‚’å®šç¾©ã—ã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Ticket {
    title: String,
    description: String,
    status: String
}
<span class="boring">}</span></code></pre></pre>
<p>A struct is quite similar to what you would call a class or an object in other programming languages.</p>
<blockquote>
<p>æ§‹é€ ä½“ã¯ã€ä»–ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°è¨€èªã§ã‚¯ãƒ©ã‚¹ã¾ãŸã¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨å‘¼ã‚“ã§ã„ã‚‹ã‚‚ã®ã«ã€ã¨ã¦ã‚‚ä¼¼ã¦ã„ã¾ã™ã€‚</p>
</blockquote>
<h2 id="defining-fieldsãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®å®šç¾©"><a class="header" href="#defining-fieldsãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®å®šç¾©">Defining fieldsï¼ˆãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®å®šç¾©ï¼‰</a></h2>
<p>The new type is built by combining other types as <strong>fields</strong>.<br />
Each field must have a name and a type, separated by a colon, <code>:</code>. If there are multiple fields, they are separated by a comma, <code>,</code>.</p>
<blockquote>
<p>æ–°ã—ã„å‹ã¯ã€<strong>ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰</strong>ã¨ã—ã¦ä»–ã®å‹ã‚’çµ„ã¿åˆã‚ã›ã‚‹ã“ã¨ã«ã‚ˆã£ã¦æ§‹ç¯‰ã•ã‚Œã¾ã™ã€‚
ãã‚Œãã‚Œã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¯ã€ã‚³ãƒ­ãƒ³<code>:</code>ã§åŒºåˆ‡ã‚‰ã‚ŒãŸåå‰ã¨å‹ã‚’æŒãŸãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚
è¤‡æ•°ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒã‚ã‚‹å ´åˆã€ãã‚Œã‚‰ã¯ã‚«ãƒ³ãƒ<code>,</code>ã§åŒºåˆ‡ã‚‰ã‚Œã¾ã™ã€‚</p>
</blockquote>
<p>Fields don't have to be of the same type, as you can see in the <code>Configuration</code> struct below:</p>
<blockquote>
<p>ä¸‹ã®<code>Configuration</code>æ§‹é€ ä½“ã§ç¢ºèªã§ãã‚‹ã‚ˆã†ã«ã€ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¯åŒã˜å‹ã§ã‚ã‚‹å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Configuration {
   version: u32,
   active: bool
}
<span class="boring">}</span></code></pre></pre>
<h2 id="instantiationã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åŒ–"><a class="header" href="#instantiationã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åŒ–">Instantiationï¼ˆã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åŒ–ï¼‰</a></h2>
<p>You can create an instance of a struct by specifying the values for each field:</p>
<blockquote>
<p>ãã‚Œãã‚Œã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®å€¤ã‚’æŒ‡å®šã™ã‚‹ã“ã¨ã§ã€æ§‹é€ ä½“ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ä½œæˆã§ãã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Syntax: &lt;StructName&gt; { &lt;field_name&gt;: &lt;value&gt;, ... }
let ticket = Ticket {
    title: "Build a ticket system".into(),
    description: "Create a system that can manage tickets across a Kanban board".into(),
    status: "Open".into()
};
<span class="boring">}</span></code></pre></pre>
<h2 id="accessing-fieldsãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚¢ã‚¯ã‚»ã‚¹"><a class="header" href="#accessing-fieldsãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚¢ã‚¯ã‚»ã‚¹">Accessing fieldsï¼ˆãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚¢ã‚¯ã‚»ã‚¹ï¼‰</a></h2>
<p>You can access the fields of a struct using the <code>.</code> operator:</p>
<blockquote>
<p><code>.</code>æ¼”ç®—å­ã‚’ä½¿ç”¨ã—ã¦ã€æ§‹é€ ä½“ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«ã‚¢ã‚¯ã‚»ã‚¹ã§ãã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Field access
let x = ticket.description;
<span class="boring">}</span></code></pre></pre>
<h2 id="methodsãƒ¡ã‚½ãƒƒãƒ‰"><a class="header" href="#methodsãƒ¡ã‚½ãƒƒãƒ‰">Methodsï¼ˆãƒ¡ã‚½ãƒƒãƒ‰ï¼‰</a></h2>
<p>We can attach behaviour to our structs by defining <strong>methods</strong>.<br />
Using the <code>Ticket</code> struct as an example:</p>
<blockquote>
<p><strong>ãƒ¡ã‚½ãƒƒãƒ‰</strong>ã‚’å®šç¾©ã™ã‚‹ã“ã¨ã§ã€æ§‹é€ ä½“ã®æŒ¯ã‚‹èˆã„ã‚’å–ã‚Šä»˜ã‘ã§ãã¾ã™ã€‚
ä¾‹ã¨ã—ã¦ã€<code>Ticket</code>æ§‹é€ ä½“ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Ticket {
    fn is_open(self) -&gt; bool {
        self.status == "Open"
    }
}

// Syntax:
// impl &lt;StructName&gt; {
//    fn &lt;method_name&gt;(&lt;parameters&gt;) -&gt; &lt;return_type&gt; {
//        // Method body
//    }
// }
<span class="boring">}</span></code></pre></pre>
<p>Methods are pretty similar to functions, with two key differences:</p>
<ol>
<li>methods must be defined inside an <strong><code>impl</code> block</strong></li>
<li>methods may use <code>self</code> as their first parameter.
<code>self</code> is a keyword and represents the instance of the struct the method is being called on.</li>
</ol>
<blockquote>
<p>ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€2ã¤ã®ä¸»è¦ãªé•ã„ã‚’æŒã¡ã¾ã™ãŒã€é–¢æ•°ã«ã¨ã¦ã‚‚ä¼¼ã¦ã„ã¾ã™ã€‚</p>
<ol>
<li>ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€<strong><code>impl</code>ãƒ–ãƒ­ãƒƒã‚¯</strong>å†…ã«å®šç¾©ã•ã‚Œãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚</li>
<li>ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ãã‚Œã‚‰ã®æœ€åˆã®å¼•æ•°ã¨ã—ã¦<code>self</code>ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚
<code>self</code>ã¯ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã§ã‚ã‚Šã€ãƒ¡ã‚½ãƒƒãƒ‰ãŒå‘¼ã°ã‚ŒãŸã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’è¡¨ç¾ã—ã¾ã™ã€‚</li>
</ol>
</blockquote>
<h3 id="self"><a class="header" href="#self"><code>self</code></a></h3>
<p>If a method takes <code>self</code> as its first parameter, it can be called using the <strong>method call syntax</strong>:</p>
<blockquote>
<p>ãƒ¡ã‚½ãƒƒãƒ‰ãŒæœ€åˆã®å¼•æ•°ã§<code>self</code>ã‚’å—ã‘å–ã‚‹å ´åˆã€ãã‚Œã¯<strong>ãƒ¡ã‚½ãƒƒãƒ‰å‘¼ã³å‡ºã—æ§‹æ–‡</strong>ã‚’ä½¿ç”¨ã—ã¦å‘¼ã³å‡ºã™ã“ã¨ãŒã§ãã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Method call syntax: &lt;instance&gt;.&lt;method_name&gt;(&lt;parameters&gt;)
let is_open = ticket.is_open();
<span class="boring">}</span></code></pre></pre>
<p>This is the same calling syntax you used to perform saturating arithmetic operations on <code>u32</code> values
in <a href="03_ticket_v1/../02_basic_calculator/09_saturating.html">the previous chapter</a>.</p>
<blockquote>
<p>ã“ã‚Œã¯ã€å‰ã®ç« ã§<code>u32</code>å€¤ã«å¯¾ã—ã¦é£½å’Œç®—è¡“æ¼”ç®—ã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã—ãŸå‘¼ã³å‡ºã—æ§‹æ–‡ã¨åŒã˜ã§ã™ã€‚</p>
</blockquote>
<h3 id="static-methodsé™çš„ãƒ¡ã‚½ãƒƒãƒ‰"><a class="header" href="#static-methodsé™çš„ãƒ¡ã‚½ãƒƒãƒ‰">Static methodsï¼ˆé™çš„ãƒ¡ã‚½ãƒƒãƒ‰ï¼‰</a></h3>
<p>If a method doesn't take <code>self</code> as its first parameter, it's a <strong>static method</strong>.</p>
<blockquote>
<p>ãƒ¡ã‚½ãƒƒãƒ‰ãŒæœ€åˆã®å¼•æ•°ã§<code>self</code>ã‚’å—ã‘å–ã‚‰ãªã„å ´åˆã€ãã‚Œã¯<strong>é™çš„ãƒ¡ã‚½ãƒƒãƒ‰</strong>ã§ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Configuration {
    version: u32,
    active: bool
}

impl Configuration {
    // `default` is a static method on `Configuration`
    // `default`ã¯`Configuration`ã®é™çš„ãƒ¡ã‚½ãƒƒãƒ‰ã§ã™ã€‚
    fn default() -&gt; Configuration {
        Configuration { version: 0, active: false }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The only way to call a static method is by using the <strong>function call syntax</strong>:</p>
<blockquote>
<p>é™çš„ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã™å”¯ä¸€ã®æ–¹æ³•ã¯ã€<strong>é–¢æ•°å‘¼ã³å‡ºã—æ§‹æ–‡</strong>ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã§ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Function call syntax: &lt;StructName&gt;::&lt;method_name&gt;(&lt;parameters&gt;)
let default_config = Configuration::default();
<span class="boring">}</span></code></pre></pre>
<h3 id="equivalenceç­‰ä¾¡"><a class="header" href="#equivalenceç­‰ä¾¡">Equivalenceï¼ˆç­‰ä¾¡ï¼‰</a></h3>
<p>You can use the function call syntax even for methods that take <code>self</code> as their first parameter:</p>
<blockquote>
<p>æœ€åˆã®å¼•æ•°ã§<code>self</code>ã‚’å—ã‘å–ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰ã«å¯¾ã—ã¦ã‚‚ã€é–¢æ•°å‘¼ã³å‡ºã—æ§‹æ–‡ã‚’ä½¿ç”¨ã§ãã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Function call syntax: &lt;StructName&gt;::&lt;method_name&gt;(&lt;instance&gt;, &lt;parameters&gt;)
let is_open = Ticket::is_open(ticket);
<span class="boring">}</span></code></pre></pre>
<p>The function call syntax makes it quite clear that <code>ticket</code> is being used as <code>self</code>, the first parameter of the method,
but it's definitely more verbose. Prefer the method call syntax when possible.</p>
<blockquote>
<p>é–¢æ•°å‘¼ã³å‡ºã—æ§‹æ–‡ã¯ã€<code>ticket</code>ãŒã€ãƒ¡ã‚½ãƒƒãƒ‰ã®æœ€åˆã®å¼•æ•°ã®<code>self</code>ã¨ã—ã¦ä½¿ç”¨ã•ã‚Œã‚‹ã“ã¨ã‚’ã¨ã¦ã‚‚æ˜ç¢ºã«ã—ã¾ã™ãŒã€é–“é•ã„ãªãã‚ˆã‚Šå†—é•·ã§ã™ã€‚
å¯èƒ½ã§ã‚ã‚Œã°ã€ãƒ¡ã‚½ãƒƒãƒ‰å‘¼ã³å‡ºã—æ§‹æ–‡ã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„ã€‚</p>
</blockquote>
<h2 id="exercise-14"><a class="header" href="#exercise-14">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/03_ticket_v1/01_struct"><code>03_ticket_v1/01_struct</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="validationæ¤œè¨¼"><a class="header" href="#validationæ¤œè¨¼">Validationï¼ˆæ¤œè¨¼ï¼‰</a></h1>
<p>Let's go back to our ticket definition:</p>
<blockquote>
<p>ãƒã‚±ãƒƒãƒˆã®å®šç¾©ã«æˆ»ã‚Šã¾ã—ã‚‡ã†ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Ticket {
    title: String,
    description: String,
    status: String,
}
<span class="boring">}</span></code></pre></pre>
<p>We are using "raw" types for the fields of our <code>Ticket</code> struct.
This means that users can create a ticket with an empty title, a suuuuuuuper long description or
a nonsensical status (e.g. "Funny").<br />
We can do better than that!</p>
<blockquote>
<p><code>Ticket</code>æ§‹é€ ä½“ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«ã€Œç”Ÿã€ã®å‹ã‚’ä½¿ç”¨ã—ã¦ã„ã¾ã™ã€‚
ã“ã‚Œã¯ã€ç©ºã®ã‚¿ã‚¤ãƒˆãƒ«ã€ã¨ã¦ã‚‚é•·ã„èª¬æ˜ã€ã¾ãŸã¯æ„å‘³ã®ãªã„çŠ¶æ…‹ï¼ˆä¾‹ãˆã°ã€ã€Œé¢ç™½ã„ã€ï¼‰ã§ãƒã‚±ãƒƒãƒˆã‚’ä½œæˆã§ãã‚‹ã“ã¨ã‚’æ„å‘³ã—ã¾ã™ã€‚
ã‚‚ã£ã¨è‰¯ã„æ–¹æ³•ãŒã‚ã‚Šã¾ã™ï¼</p>
</blockquote>
<h2 id="further-readingå‚è€ƒè³‡æ–™-5"><a class="header" href="#further-readingå‚è€ƒè³‡æ–™-5">Further readingï¼ˆå‚è€ƒè³‡æ–™ï¼‰</a></h2>
<ul>
<li>Check out <a href="https://doc.rust-lang.org/std/string/struct.String.html"><code>String</code>'s documentation</a>
for a thorough overview of the methods it provides. You'll need it for the exercise!</li>
</ul>
<blockquote>
<ul>
<li><code>String</code>ãŒæä¾›ã™ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰ã®æ¦‚è¦ã‚’ç¢ºèªã™ã‚‹ãŸã‚ã«ã€<code>String</code>ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚
ã“ã®æ¼”ç¿’ã«ã¯ãã‚ŒãŒå¿…è¦ã§ã™ã€‚</li>
</ul>
</blockquote>
<h2 id="exercise-15"><a class="header" href="#exercise-15">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/03_ticket_v1/02_validation"><code>03_ticket_v1/02_validation</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="modulesãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«"><a class="header" href="#modulesãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«">Modulesï¼ˆãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ï¼‰</a></h1>
<p>The <code>new</code> method you've just defined is trying to enforce some <strong>constraints</strong> on the field values for <code>Ticket</code>.
But are those invariants really enforced? What prevents a developer from creating a <code>Ticket</code>
without going through <code>Ticket::new</code>?</p>
<blockquote>
<p>ã¡ã‚‡ã†ã©å®šç¾©ã—ãŸ<code>new</code>ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€<code>Ticket</code>ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®å€¤ã«ä½•ã‚‰ã‹ã®<strong>åˆ¶ç´„</strong>ã‚’å¼·åˆ¶ã™ã‚‹ã“ã¨ã‚’è©¦ã¿ã¾ã™ã€‚
ã—ã‹ã—ã€ãã‚Œã‚‰ã®ä¸å¤‰æ€§ã¯æœ¬å½“ã«å¼·åˆ¶ã•ã‚Œã‚‹ã®ã§ã—ã‚‡ã†ã‹ï¼Ÿ
<code>Ticket::new</code>ã‚’ä»‹ã™ã‚‹ã“ã¨ãªãã€é–‹ç™ºè€…ãŒ<code>Ticket</code>ã‚’ä½œæˆã™ã‚‹ã“ã¨ã‚’é˜²ãã®ã¯ä½•ã§ã—ã‚‡ã†ã‹ï¼Ÿ</p>
</blockquote>
<p>To get proper <strong>encapsulation</strong> you need to become familiar with two new concepts: <strong>visibility</strong> and <strong>modules</strong>.
Let's start with modules.</p>
<blockquote>
<p>é©åˆ‡ãª<strong>ã‚«ãƒ—ã‚»ãƒ«åŒ–</strong>ã‚’å¾—ã‚‹ãŸã‚ã«ã€<strong>å¯è¦–æ€§</strong>ã¨<strong>ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«</strong>ã¨ã„ã†2ã¤ã®æ–°ã—ã„æ¦‚å¿µã«æ…£ã‚Œã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚
ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‹ã‚‰å§‹ã‚ã¾ã—ã‚‡ã†ã€‚</p>
</blockquote>
<h2 id="what-is-a-moduleãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¨ã¯"><a class="header" href="#what-is-a-moduleãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¨ã¯">What is a module?ï¼ˆãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¨ã¯ï¼Ÿï¼‰</a></h2>
<p>In Rust a <strong>module</strong> is a way to group related code together, under a common namespace (i.e. the module's name).<br />
You've already seen modules in action: the unit tests that verify the correctness of your code are defined in a
different module, named <code>tests</code>.</p>
<blockquote>
<p>Rustã«ãŠã„ã¦ã€<strong>ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«</strong>ã¯ã€ä¾‹ãˆã°ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®åå‰ãªã©ã€ä¸€èˆ¬çš„ãªåå‰ç©ºé–“ã®ä¸‹ã§ã€é–¢é€£ã—ãŸã‚³ãƒ¼ãƒ‰åŒå£«ã§ã‚°ãƒ«ãƒ¼ãƒ—ã‚’ä½œæˆã™ã‚‹æ–¹æ³•ã§ã™ã€‚
å®Ÿéš›ã«ã™ã§ã«ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ç¢ºèªã—ã¦ã„ã¾ã™ã€‚ã‚³ãƒ¼ãƒ‰ã®æ­£ç¢ºæ€§ã‚’æ¤œè¨¼ã™ã‚‹ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆã¯ã€<code>tests</code>ã¨åä»˜ã‘ã‚‰ã‚ŒãŸç•°ãªã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«å®šç¾©ã•ã‚Œã¦ã„ã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    // [...]
}
<span class="boring">}</span></code></pre></pre>
<h2 id="inline-modulesã‚¤ãƒ³ãƒ©ã‚¤ãƒ³ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«"><a class="header" href="#inline-modulesã‚¤ãƒ³ãƒ©ã‚¤ãƒ³ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«">Inline modulesï¼ˆã‚¤ãƒ³ãƒ©ã‚¤ãƒ³ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ï¼‰</a></h2>
<p>The <code>tests</code> module above is an example of an <strong>inline module</strong>: the module declaration (<code>mod tests</code>) and the module
contents (the stuff inside <code>{ ... }</code>) are next to each other.</p>
<blockquote>
<p>ä¸Šè¨˜<code>tests</code>ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ã€<strong>ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«</strong>ã®ä¾‹ã§ã€ãã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®å®šç¾©ï¼ˆ<code>mod tests</code>ï¼‰ã¨ãã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ï¼ˆ<code>{ ... }</code>ã®å†…éƒ¨ã®ã‚‚ã®ï¼‰ã¯éš£ã‚Šåˆã£ã¦ã„ã¾ã™ã€‚</p>
</blockquote>
<h2 id="module-treeãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãƒ„ãƒªãƒ¼"><a class="header" href="#module-treeãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãƒ„ãƒªãƒ¼">Module treeï¼ˆãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãƒ„ãƒªãƒ¼ï¼‰</a></h2>
<p>Modules can be nested, forming a <strong>tree</strong> structure.<br />
The root of the tree is the <strong>crate</strong> itself, which is the top-level module that contains all the other modules.
For a library crate, the root module is usually <code>src/lib.rs</code> (unless its location has been customized).
The root module is also known as the <strong>crate root</strong>.</p>
<blockquote>
<p>ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ãƒã‚¹ãƒˆã§ãã€<strong>æœ¨</strong>æ§‹é€ ã‚’å½¢æˆã—ã¾ã™ã€‚
æœ¨ã®ãƒ«ãƒ¼ãƒˆã¯<strong>ã‚¯ãƒ¬ãƒ¼ãƒˆ</strong>ãã‚Œè‡ªèº«ã§ã€ãã‚Œã¯ã™ã¹ã¦ã®ä»–ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’å«ã‚€æœ€ä¸Šä½ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ã™ã€‚
ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚¯ãƒ¬ãƒ¼ãƒˆã®å ´åˆã€å ´æ‰€ãŒã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã•ã‚Œã¦ã„ãªã„é™ã‚Šã€ãƒ«ãƒ¼ãƒˆãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯é€šå¸¸<code>src/lib.rs</code>ã§ã™ã€‚
ã¾ãŸã€ãƒ«ãƒ¼ãƒˆãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ã€<strong>ã‚¯ãƒ¬ãƒ¼ãƒˆãƒ«ãƒ¼ãƒˆ</strong>ã¨ã—ã¦ã‚‚çŸ¥ã‚‰ã‚Œã¦ã„ã¾ã™ã€‚</p>
</blockquote>
<p>The crate root can have submodules, which in turn can have their own submodules, and so on.</p>
<blockquote>
<p>ã‚¯ãƒ¬ãƒ¼ãƒˆãƒ«ãƒ¼ãƒˆã¯ã‚µãƒ–ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’æŒã¦ã€ã‚µãƒ–ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯è‡ªèº«ã®ã‚µãƒ–ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’æŒã¤ã“ã¨ãŒã§ãã€ãã‚ŒãŒç¶šãã¾ã™ã€‚</p>
</blockquote>
<h2 id="external-modules-and-the-filesystemå¤–éƒ¨ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¨ãƒ•ã‚¡ã‚¤ãƒ«ã‚·ã‚¹ãƒ†ãƒ "><a class="header" href="#external-modules-and-the-filesystemå¤–éƒ¨ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¨ãƒ•ã‚¡ã‚¤ãƒ«ã‚·ã‚¹ãƒ†ãƒ ">External modules and the filesystemï¼ˆå¤–éƒ¨ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¨ãƒ•ã‚¡ã‚¤ãƒ«ã‚·ã‚¹ãƒ†ãƒ ï¼‰</a></h2>
<p>Inline modules are useful for small pieces of code, but as your project grows you'll want to split your code into
multiple files. In the parent module, you declare the existence of a submodule using the <code>mod</code> keyword.</p>
<blockquote>
<p>ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯å°‘é‡ã®ã‚³ãƒ¼ãƒ‰ã§ä¾¿åˆ©ã§ã™ãŒã€ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãŒæˆé•·ã™ã‚‹ã«ã¤ã‚Œã¦ã€ã‚³ãƒ¼ãƒ‰ã‚’è¤‡æ•°ã®ãƒ•ã‚¡ã‚¤ãƒ«ã«åˆ†å‰²ã—ãŸã„ã¨è€ƒãˆã‚‹ã§ã—ã‚‡ã†ã€‚
è¦ªãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ã€<code>mod</code>ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’ä½¿ç”¨ã—ã¦ã€ã‚µãƒ–ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®å­˜åœ¨ã‚’å®£è¨€ã—ã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod dog;
<span class="boring">}</span></code></pre></pre>
<p><code>cargo</code>, Rust's build tool, is then in charge of finding the file that contains
the module implementation.<br />
If your module is declared in the root of your crate (e.g. <code>src/lib.rs</code> or <code>src/main.rs</code>),
<code>cargo</code> expects the file to be named either:</p>
<ul>
<li><code>src/&lt;module_name&gt;.rs</code></li>
<li><code>src/&lt;module_name&gt;/mod.rs</code></li>
</ul>
<blockquote>
<p>Rustã®ãƒ“ãƒ«ãƒ‰ãƒ„ãƒ¼ãƒ«ã§ã‚ã‚‹<code>cargo</code>ã¯ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å®Ÿè£…ã‚’å«ã‚€ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ¤œç´¢ã™ã‚‹è²¬ä»»ãŒã‚ã‚Šã¾ã™ã€‚
<code>src/lib.rs</code>ã¾ãŸã¯<code>src/main.rs</code>ãªã©ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒã‚¯ãƒ¬ãƒ¼ãƒˆã®ãƒ«ãƒ¼ãƒˆã«å®£è¨€ã•ã‚Œã¦ã„ã‚‹å ´åˆã€<code>cargo</code>ã¯ãƒ•ã‚¡ã‚¤ãƒ«ã®åå‰ãŒæ¬¡ã®ã„ãšã‚Œã‹ã§ã‚ã‚‹ã“ã¨ã‚’æœŸå¾…ã—ã¾ã™ã€‚</p>
<ul>
<li><code>src/&lt;module_name&gt;.rs</code></li>
<li><code>src/&lt;module_name&gt;/mod.rs</code></li>
</ul>
</blockquote>
<p>If your module is a submodule of another module, the file should be named:</p>
<ul>
<li><code>[..]/&lt;parent_module&gt;/&lt;module_name&gt;.rs</code></li>
<li><code>[..]/&lt;parent_module&gt;/&lt;module_name&gt;/mod.rs</code></li>
</ul>
<blockquote>
<p>ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒä»–ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ã‚µãƒ–ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®å ´åˆã€ãƒ•ã‚¡ã‚¤ãƒ«ã¯æ¬¡ã®é€šã‚Šåä»˜ã‘ã‚‰ã‚Œã‚‹ã¹ãã§ã™ã€‚</p>
<ul>
<li><code>[..]/&lt;parent_module&gt;/&lt;module_name&gt;.rs</code></li>
<li><code>[..]/&lt;parent_module&gt;/&lt;module_name&gt;/mod.rs</code></li>
</ul>
</blockquote>
<p>E.g. <code>src/animals/dog.rs</code> or <code>src/animals/dog/mod.rs</code> if <code>dog</code> is a submodule of <code>animals</code>.</p>
<blockquote>
<p>ä¾‹ãˆã°ã€<code>dog</code>ãŒ<code>animals</code>ã®ã‚µãƒ–ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®å ´åˆã€<code>src/animals/dog.rs</code>ã¾ãŸã¯<code>src/animals/dog/mod.rs</code>ã§ã™ã€‚</p>
</blockquote>
<p>Your IDE might help you create these files automatically when you declare a new module using the <code>mod</code> keyword.</p>
<blockquote>
<p>IDEã¯ã€<code>mod</code>ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’ä½¿ç”¨ã—ã¦æ–°ã—ã„ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’å®£è¨€ã—ãŸã¨ãã€è‡ªå‹•çš„ã«ã“ã‚Œã‚‰ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½œæˆã™ã‚‹ã“ã¨ã‚’æ”¯æ´ã™ã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚</p>
</blockquote>
<h2 id="item-paths-and-use-statementsã‚¢ã‚¤ãƒ†ãƒ ãƒ‘ã‚¹ã¨useæ–‡"><a class="header" href="#item-paths-and-use-statementsã‚¢ã‚¤ãƒ†ãƒ ãƒ‘ã‚¹ã¨useæ–‡">Item paths and <code>use</code> statementsï¼ˆã‚¢ã‚¤ãƒ†ãƒ ãƒ‘ã‚¹ã¨useæ–‡ï¼‰</a></h2>
<p>You can access items defined in the same module without any special syntax. You just use their name.</p>
<blockquote>
<p>ç‰¹åˆ¥ãªæ§‹æ–‡ãªã—ã§ã€åŒã˜ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å†…ã«å®šç¾©ã•ã‚ŒãŸã‚¢ã‚¤ãƒ†ãƒ ã«ã‚¢ã‚¯ã‚»ã‚¹ã§ãã¾ã™ã€‚
å˜ã«ãã‚Œã‚‰ã®åå‰ã‚’ä½¿ç”¨ã™ã‚‹ã ã‘ã§ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Ticket {
    // [...]
}

// No need to qualify `Ticket` in any way here
// because we're in the same module
// åŒã˜ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å†…ã«ã„ã‚‹ãŸã‚ã€ã“ã“ã§ã¯ãªã«ã‚‚`Ticket`ã‚’ä¿®é£¾ã™ã‚‹å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚
fn mark_ticket_as_done(ticket: Ticket) {
    // [...]
}
<span class="boring">}</span></code></pre></pre>
<p>That's not the case if you want to access an entity from a different module.<br />
You have to use a <strong>path</strong> pointing to the entity you want to access.</p>
<blockquote>
<p>ç•°ãªã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã«ã‚¢ã‚¯ã‚»ã‚¹ã—ãŸã„å ´åˆã¯åˆ¥ã§ã™ã€‚
ã‚¢ã‚¯ã‚»ã‚¹ã—ãŸã„ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã‚’ç¤ºã™<strong>ãƒ‘ã‚¹</strong>ã‚’ä½¿ç”¨ã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚</p>
</blockquote>
<p>You can compose the path in various ways:</p>
<ul>
<li>starting from the root of the current crate, e.g. <code>crate::module_1::module_2::MyStruct</code></li>
<li>starting from the parent module, e.g. <code>super::my_function</code></li>
<li>starting from the current module, e.g. <code>sub_module_1::MyStruct</code></li>
</ul>
<blockquote>
<p>ã•ã¾ã–ã¾ãªæ–¹æ³•ã§ãƒ‘ã‚¹ã‚’æ§‹æˆã§ãã¾ã™ã€‚</p>
<ul>
<li>ä¾‹ãˆã°ã€<code>crate::module_1::module_2::MyStruct</code>ã®ã‚ˆã†ã«ã€ç¾åœ¨ã®ã‚¯ãƒ¬ãƒ¼ãƒˆã®ãƒ«ãƒ¼ãƒˆã‹ã‚‰é–‹å§‹</li>
<li>ä¾‹ãˆã°ã€<code>super::my_function</code>ã®ã†ã‚ˆã†ã«ã€è¦ªãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‹ã‚‰é–‹å§‹</li>
<li>ä¾‹ãˆã°ã€<code>sub_module_1::MyStruct</code>ã®ã‚ˆã†ã«ã€ç¾åœ¨ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‹ã‚‰é–‹å§‹</li>
</ul>
</blockquote>
<p>Having to write the full path every time you want to refer to a type can be cumbersome.
To make your life easier, you can introduce a <code>use</code> statement to bring the entity into scope.</p>
<blockquote>
<p>å‹ã‚’å‚ç…§ã—ãŸã„å ´åˆã¯ã„ã¤ã§ã‚‚ã€å®Œå…¨ãªãƒ‘ã‚¹ã‚’è¨˜è¿°ã—ãªã‘ã‚Œã°ãªã‚‰ãªã„ã“ã¨ã¯ã€é¢å€’ã«ãªã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚
äººç”Ÿã‚’æ¥½ã«ã™ã‚‹ãŸã‚ã«ã€ã‚¹ã‚³ãƒ¼ãƒ—å†…ã«ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã‚’æŒã¡è¾¼ã‚€<code>use</code>æ–‡ã‚’å°å…¥ã§ãã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Bring `MyStruct` into scope
use crate::module_1::module_2::MyStruct;

// Now you can refer to `MyStruct` directly
fn a_function(s: MyStruct) {
     // [...]
}
<span class="boring">}</span></code></pre></pre>
<h3 id="star-importsã‚¹ã‚¿ãƒ¼ã‚¤ãƒ³ãƒãƒ¼ãƒˆ"><a class="header" href="#star-importsã‚¹ã‚¿ãƒ¼ã‚¤ãƒ³ãƒãƒ¼ãƒˆ">Star importsï¼ˆã‚¹ã‚¿ãƒ¼ã‚¤ãƒ³ãƒãƒ¼ãƒˆï¼‰</a></h3>
<p>You can also import all the items from a module with a single <code>use</code> statement.</p>
<blockquote>
<p>ã¾ãŸã€å˜ä¸€ã®<code>use</code>æ–‡ã‚’ä½¿ç”¨ã—ã¦ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‹ã‚‰ã™ã¹ã¦ã®ã‚¢ã‚¤ãƒ†ãƒ ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã§ãã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::module_1::module_2::*;
<span class="boring">}</span></code></pre></pre>
<p>This is known as a <strong>star import</strong>.<br />
It is generally discouraged because it can pollute the current namespace, making it hard to understand
where each name comes from and potentially introducing name conflicts.<br />
Nonetheless, it can be useful in some cases, like when writing unit tests. You might have noticed
that most of our test modules start with a <code>use super::*;</code> statement to bring all the items from the parent module
(the one being tested) into scope.</p>
<blockquote>
<p>ã“ã‚Œã¯<strong>ã‚¹ã‚¿ãƒ¼ã‚¤ãƒ³ãƒãƒ¼ãƒˆ</strong>ã¨ã—ã¦çŸ¥ã‚‰ã‚Œã¦ã„ã¾ã™ã€‚
ãã‚Œã¯ã€ãã‚Œãã‚Œã®åå‰ãŒã©ã“ã‹ã‚‰æ¥ãŸã®ã‹ç†è§£ã™ã‚‹ã“ã¨ã‚’é›£ã—ãã—ã¦ã€åå‰ã®è¡çªã‚’æ‹›ãå¯èƒ½æ€§ãŒã‚ã‚Šã€ç¾åœ¨ã®åå‰ç©ºé–“ã‚’æ±šæŸ“ã™ã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹ãŸã‚ã€ä¸€èˆ¬çš„ã«ã¯æ¨å¥¨ã•ã‚Œã¾ã›ã‚“ã€‚
ãã‚Œã«ã‚‚é–¢ã‚ã‚‰ãšã€ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆã‚’è¨˜è¿°ã—ã¦ã„ã‚‹ã¨ããªã©ã€ã‚¹ã‚¿ãƒ¼ã‚¤ãƒ³ãƒãƒ¼ãƒˆã¯ã„ãã¤ã‹ã®å ´é¢ã§ä¾¿åˆ©ã§ã™ã€‚
ã»ã¨ã‚“ã©ã®ãƒ†ã‚¹ãƒˆãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒã€è¦ªãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‹ã‚‰ãƒ†ã‚¹ãƒˆã•ã‚Œã‚‹ã™ã¹ã¦ã®ã‚¢ã‚¤ãƒ†ãƒ ã‚’ã‚¹ã‚³ãƒ¼ãƒ—å†…ã«æŒã¡è¾¼ã‚€ãŸã‚ã«ã€<code>user super::*;</code>æ–‡ã§é–‹å§‹ã—ã¦ã„ã‚‹ã“ã¨ã«æ°—ä»˜ã„ãŸã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚</p>
</blockquote>
<h2 id="exercise-16"><a class="header" href="#exercise-16">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/03_ticket_v1/03_modules"><code>03_ticket_v1/03_modules</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="visibilityå¯è¦–æ€§"><a class="header" href="#visibilityå¯è¦–æ€§">Visibilityï¼ˆå¯è¦–æ€§ï¼‰</a></h1>
<p>When you start breaking down your code into multiple modules, you need to start thinking about <strong>visibility</strong>.
Visibility determines which regions of your code (or other people's code) can access a given entity,
be it a struct, a function, a field, etc.</p>
<blockquote>
<p>ã‚³ãƒ¼ãƒ‰ã‚’è¤‡æ•°ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«åˆ†å‰²ã—å§‹ã‚ãŸã¨ãã€<strong>å¯è¦–æ€§</strong>ã«ã¤ã„ã¦è€ƒãˆå§‹ã‚ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚
å¯è¦–æ€§ã¯ã€ã‚³ãƒ¼ãƒ‰ã¾ãŸã¯ä»–ã®äººã®ã‚³ãƒ¼ãƒ‰ã®ã©ã®é ˜åŸŸãŒã€æ§‹é€ ä½“ã€é–¢æ•°ã€ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãªã©ã€ç‰¹å®šã®ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã«ã‚¢ã‚¯ã‚»ã‚¹ã§ãã‚‹ã‹ã‚’æ±ºå®šã—ã¾ã™ã€‚</p>
</blockquote>
<h2 id="private-by-defaultãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆ"><a class="header" href="#private-by-defaultãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆ">Private by defaultï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆï¼‰</a></h2>
<p>By default, everything in Rust is <strong>private</strong>.<br />
A private entity can only be accessed:</p>
<ol>
<li>within the same module where it's defined, or</li>
<li>by one of its submodules</li>
</ol>
<blockquote>
<p>ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã€Rustã®ã™ã¹ã¦ã¯<strong>ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆ</strong>ã§ã™ã€‚
ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆãªã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã¯ã€æ¬¡ã®ã„ãšã‚Œã‹ã§ã®ã¿ã‚¢ã‚¯ã‚»ã‚¹ã§ãã¾ã™ã€‚</p>
<ol>
<li>ãã‚ŒãŒå®šç¾©ã•ã‚ŒãŸåŒã˜ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å†…ã§ã€ã¾ãŸã¯ãƒ»ãƒ»ãƒ»</li>
<li>ãã®ã‚µãƒ–ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ã„ãšã‚Œã‹ã«ã‚ˆã£ã¦</li>
</ol>
</blockquote>
<p>We've used this extensively in the previous exercises:</p>
<ul>
<li><code>create_todo_ticket</code> worked (once you added a <code>use</code> statement) because <code>helpers</code> is a submodule of the crate root,
where <code>Ticket</code> is defined. Therefore, <code>create_todo_ticket</code> can access <code>Ticket</code> without any issues even
though <code>Ticket</code> is private.</li>
<li>All our unit tests are defined in a submodule of the code they're testing, so they can access everything without
restrictions.</li>
</ul>
<blockquote>
<p>å‰ã®æ¼”ç¿’ã§ã“ã‚Œã‚’åºƒç¯„å›²ã«ä½¿ç”¨ã—ã¾ã—ãŸã€‚</p>
<ul>
<li><code>create_todo_ticket</code>ã¯ã€<code>helpers</code>ãŒ<code>Ticket</code>ãŒå®šç¾©ã•ã‚ŒãŸã‚¯ãƒ¬ãƒ¼ãƒˆãƒ«ãƒ¼ãƒˆã®ã‚µãƒ–ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ãŸã‚ã€ä¸€æ—¦<code>use</code>æ–‡ã‚’è¿½åŠ ã™ã‚‹ã¨æ©Ÿèƒ½ã—ã¾ã—ãŸã€‚
ã‚ˆã£ã¦ã€<code>create_todo_ticket</code>ã¯ã€<code>Ticket</code>ãŒãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆã§ã‚ã‚‹ã«ã‚‚é–¢ã‚ã‚‰ãšã€å•é¡Œãªã<code>Ticket</code>ã«ã‚¢ã‚¯ã‚»ã‚¹ã§ãã¾ã™ã€‚</li>
<li>ã™ã¹ã¦ã®ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆã¯ã€ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆãŒãƒ†ã‚¹ãƒˆã—ã¦ã„ã‚‹ã‚³ãƒ¼ãƒ‰ï¼ˆ<code>Ticket</code>ï¼‰ã®ã‚µãƒ–ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«å®šç¾©ã•ã‚ŒãŸãŸã‚ã€ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆã¯åˆ¶é™ç„¡ã—ã§ã™ã¹ã¦ã«ã‚¢ã‚¯ã‚»ã‚¹ã§ãã¾ã™ã€‚</li>
</ul>
</blockquote>
<h2 id="visibility-modifierså¯è¦–æ€§ä¿®é£¾å­"><a class="header" href="#visibility-modifierså¯è¦–æ€§ä¿®é£¾å­">Visibility modifiersï¼ˆå¯è¦–æ€§ä¿®é£¾å­ï¼‰</a></h2>
<p>You can modify the default visibility of an entity using a <strong>visibility modifier</strong>.<br />
Some common visibility modifiers are:</p>
<ul>
<li><code>pub</code>: makes the entity <strong>public</strong>, i.e. accessible from outside the module where it's defined, potentially from
other crates.</li>
<li><code>pub(crate)</code>: makes the entity public within the same <strong>crate</strong>, but not outside of it.</li>
<li><code>pub(super)</code>: makes the entity public within the parent module.</li>
<li><code>pub(in path::to::module)</code>: makes the entity public within the specified module.</li>
</ul>
<blockquote>
<p><strong>å¯è¦–æ€§ä¿®é£¾å­</strong>ã‚’ä½¿ç”¨ã—ã¦ã€ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®å¯è¦–æ€§ã‚’å¤‰æ›´ã§ãã¾ã™ã€‚
ã„ãã¤ã‹ä¸€èˆ¬çš„ãªå¯è¦–æ€§ä¿®é£¾å­ã‚’æ¬¡ã«ç¤ºã—ã¾ã™ã€‚</p>
<ul>
<li><code>pub</code>: ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã‚’<strong>ãƒ‘ãƒ–ãƒªãƒƒã‚¯</strong>ã«ã—ã¾ã™ã€‚ä¾‹ãˆã°ã€ãã‚ŒãŒå®šç¾©ã•ã‚ŒãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®å¤–ã‹ã‚‰ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½ã§ã€ä»–ã®ã‚¯ãƒ¬ãƒ¼ãƒˆã‹ã‚‰ã‚‚å¯èƒ½ã§ã™ã€‚</li>
<li><code>pub(crate)</code>: åŒã˜<strong>ã‚¯ãƒ¬ãƒ¼ãƒˆ</strong>å†…ã§ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã‚’ãƒ‘ãƒ–ãƒªãƒƒã‚¯ã«ã—ã¾ã™ãŒã€ãã®ã‚¯ãƒ¬ãƒ¼ãƒˆã®å¤–éƒ¨ã‹ã‚‰ã‚¢ã‚¯ã‚»ã‚¹ã§ãã¾ã›ã‚“ã€‚</li>
<li><code>pub(super)</code>: è¦ªãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å†…ã§ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã‚’ãƒ‘ãƒ–ãƒªãƒƒã‚¯ã«ã—ã¾ã™ã€‚</li>
<li><code>pub(in path::to::module)</code>: æŒ‡å®šã•ã‚ŒãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å†…ã§ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã‚’ãƒ‘ãƒ–ãƒªãƒƒã‚¯ã«ã—ã¾ã™ã€‚</li>
</ul>
</blockquote>
<p>You can use these modifiers on modules, structs, functions, fields, etc.
For example:</p>
<blockquote>
<p>ã“ã‚Œã‚‰ã®ä¿®é£¾å­ã‚’æ§‹é€ ä½“ã€é–¢æ•°ã€ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãªã©ã«ä½¿ç”¨ã§ãã¾ã™ã€‚
ä¾‹ãˆã°ãƒ»ãƒ»ãƒ»</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Configuration {
    pub(crate) version: u32,
    active: bool,
}
<span class="boring">}</span></code></pre></pre>
<p><code>Configuration</code> is public, but you can only access the <code>version</code> field from within the same crate.
The <code>active</code> field, instead, is private and can only be accessed from within the same module or one of its submodules.</p>
<blockquote>
<p><code>Configuration</code>ã¯ãƒ‘ãƒ–ãƒªãƒƒã‚¯ã§ã™ãŒã€åŒã˜ã‚¯ãƒ¬ãƒ¼ãƒˆå†…ã§ã®ã¿<code>version</code>ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«ã‚¢ã‚¯ã‚»ã‚¹ã§ãã¾ã™ã€‚
ä»£ã‚ã‚Šã«<code>active</code>ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¯ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆã§ã€åŒã˜ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‹ãã®ã‚µãƒ–ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å†…ã§ã®ã¿ã‚¢ã‚¯ã‚»ã‚¹ã§ãã¾ã™ã€‚</p>
</blockquote>
<h2 id="exercise-17"><a class="header" href="#exercise-17">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/03_ticket_v1/04_visibility"><code>03_ticket_v1/04_visibility</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="encapsulationã‚«ãƒ—ã‚»ãƒ«åŒ–"><a class="header" href="#encapsulationã‚«ãƒ—ã‚»ãƒ«åŒ–">Encapsulationï¼ˆã‚«ãƒ—ã‚»ãƒ«åŒ–ï¼‰</a></h1>
<p>Now that we have a basic understanding of modules and visibility, let's circle back to <strong>encapsulation</strong>.<br />
Encapsulation is the practice of hiding the internal representation of an object. It is most commonly
used to enforce some <strong>invariants</strong> on the object's state.</p>
<blockquote>
<p>ç¾åœ¨ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¨å¯è¦–æ€§ã®åŸºæœ¬çš„ãªç†è§£ãŒã‚ã‚‹ãŸã‚ã€<strong>ã‚«ãƒ—ã‚»ãƒ«åŒ–</strong>ã«ã¤ã„ã¦å†åº¦è€ƒãˆã¦ã¿ã¾ã—ã‚‡ã†ã€‚
ã‚«ãƒ—ã‚»ãƒ«åŒ–ã¯ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å†…éƒ¨è¡¨ç¾ã‚’éš ã™å®Ÿè·µã§ã™ã€‚
ãã‚Œã¯ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®çŠ¶æ…‹ã«ã€ä½•ã‚‰ã‹ã®<strong>ä¸å¤‰</strong>ã«å¼·åˆ¶ã™ã‚‹ãŸã‚ã«ã€æœ€ã‚‚ä¸€èˆ¬çš„ã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚</p>
</blockquote>
<p>Going back to our <code>Ticket</code> struct:</p>
<blockquote>
<p><code>Ticket</code>æ§‹é€ ä½“ã«æˆ»ã‚Šã¾ã—ã‚‡ã†ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Ticket {
    title: String,
    description: String,
    status: String,
}
<span class="boring">}</span></code></pre></pre>
<p>If all fields are made public, there is no encapsulation.<br />
You must assume that the fields can be modified at any time, set to any value that's allowed by
their type. You can't rule out that a ticket might have an empty title or a status
that doesn't make sense.</p>
<blockquote>
<p>ã™ã¹ã¦ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’ãƒ‘ãƒ–ãƒªãƒƒã‚¯ã«ã™ã‚‹å ´åˆã€ã‚«ãƒ—ã‚»ãƒ«åŒ–ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚
ã„ã¤ã§ã‚‚ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒå¤‰æ›´ã•ã‚Œã€ãã‚Œã‚‰ã®å‹ã«å¾“ã£ã¦ä»»æ„ãªå€¤ã‚’è¨­å®šã•ã‚Œã‚‹ã“ã¨ã‚’æƒ³å®šã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚
ãƒã‚±ãƒƒãƒˆãŒã€æ„å‘³ã®ãªã„ç©ºã®ã‚¿ã‚¤ãƒˆãƒ«ã‚„çŠ¶æ…‹ã‚’æŒã¤ã‹ã‚‚ã—ã‚Œãšã€ãã‚Œã‚’é™¤å¤–ã§ãã¾ã›ã‚“ã€‚</p>
</blockquote>
<p>To enforce stricter rules, we must keep the fields private<sup class="footnote-reference"><a href="#newtype">1</a></sup>.
We can then provide public methods to interact with a <code>Ticket</code> instance.
Those public methods will have the responsibility of upholding our invariants (e.g. a title must not be empty).</p>
<blockquote>
<p>å³å¯†ãªãƒ«ãƒ¼ãƒ«ã‚’å¼·åˆ¶ã™ã‚‹ãŸã‚ã«ã€ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆã«ç¶­æŒã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚
ãã—ã¦ã€<code>Ticket</code>ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¨ç›¸äº’ä½œç”¨ã™ã‚‹ãƒ‘ãƒ–ãƒªãƒƒã‚¯ãªãƒ¡ã‚½ãƒƒãƒ‰ã‚’æä¾›ã§ãã¾ã™ã€‚
ãã‚Œã‚‰ãƒ‘ãƒ–ãƒªãƒƒã‚¯ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ä¾‹ãˆã°ã‚¿ã‚¤ãƒˆãƒ«ã¯ç©ºã§ã‚ã£ã¦ã¯ãªã‚‰ãªã„ãªã©ã®ã€ä¸å¤‰ã‚’ç¶­æŒã™ã‚‹è²¬ä»»ã‚’ã‚‚ã¡ã¾ã™ã€‚</p>
</blockquote>
<p>If all fields are private, it is no longer possible to create a <code>Ticket</code> instance directly using the struct
instantiation syntax:</p>
<blockquote>
<p>ã™ã¹ã¦ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆã®å ´åˆã€æ§‹é€ ä½“ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åŒ–æ§‹æ–‡ã‚’ä½¿ç”¨ã—ã¦ã€ç›´æ¥<code>Ticket</code>ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ä½œæˆã§ããªããªã‚Šã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// This won't work!
// ï¼ˆ`Ticket`æ§‹é€ ä½“ã®ã™ã¹ã¦ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆã§ã‚ã‚‹ãŸã‚ï¼‰æ¬¡ã¯æ©Ÿèƒ½ã—ã¾ã›ã‚“ï¼
let ticket = Ticket {
    title: "Build a ticket system".into(),
    description: "Create a system that can manage tickets across a Kanban board".into(),
    status: "Open".into()
};
<span class="boring">}</span></code></pre></pre>
<p>You've seen this in action in the previous exercise on visibility.<br />
We now need to provide one or more public <strong>constructors</strong>â€”i.e. static methods or functions that can be used
from outside the module to create a new instance of the struct.<br />
Luckily enough we already have one: <code>Ticket::new</code>, as implemented in <a href="03_ticket_v1/02_validation.html">a previous exercise</a>.</p>
<blockquote>
<p>å¯è¦–æ€§ã®å‰ã®æ¼”ç¿’å†…ã§å®Ÿéš›ã«ã“ã‚Œã‚’ç¢ºèªã—ã¾ã—ãŸã€‚
ç¾åœ¨ã€ä¾‹ãˆã°æ§‹é€ ä½“ã®æ–°ã—ã„ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ä½œæˆã™ã‚‹ãŸã‚ã«ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®å¤–å´ã‹ã‚‰ä½¿ç”¨ã•ã‚Œã‚‹é™çš„ãƒ¡ã‚½ãƒƒãƒ‰ã¾ãŸã¯é–¢æ•°ãªã©ã€1ã¤ä»¥ä¸Šã®ãƒ‘ãƒ–ãƒªãƒƒã‚¯ãª<strong>ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãƒ¼</strong>ã‚’æä¾›ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚
ã¨ã¦ã‚‚å¹¸ã„ãªã“ã¨ã«ã€å‰ã®æ¼”ç¿’ã§å®Ÿè£…ã—ãŸ<code>Ticket::new</code>ãŒã™ã§ã«ã‚ã‚Šã¾ã™ã€‚</p>
</blockquote>
<h2 id="accessor-methodsã‚¢ã‚¯ã‚»ãƒƒã‚µãƒ¼ãƒ¡ã‚½ãƒƒãƒ‰"><a class="header" href="#accessor-methodsã‚¢ã‚¯ã‚»ãƒƒã‚µãƒ¼ãƒ¡ã‚½ãƒƒãƒ‰">Accessor methodsï¼ˆã‚¢ã‚¯ã‚»ãƒƒã‚µãƒ¼ãƒ¡ã‚½ãƒƒãƒ‰ï¼‰</a></h2>
<p>In summary:</p>
<ul>
<li>All <code>Ticket</code> fields are private</li>
<li>We provide a public constructor, <code>Ticket::new</code>, that enforces our validation rules on creation</li>
</ul>
<blockquote>
<p>è¦ç´„ã™ã‚‹ã¨:</p>
<ul>
<li>ã™ã¹ã¦ã®<code>Ticket</code>ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¯ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆã§ã™ã€‚</li>
<li>ä½œæˆæ™‚ã®æ¤œè¨¼ãƒ«ãƒ¼ãƒ«ã‚’å¼·åˆ¶ã™ã‚‹ãƒ‘ãƒ–ãƒªãƒƒã‚¯ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãƒ¼ã§ã‚ã‚‹<code>Ticket::new</code>ã‚’æä¾›ã—ã¾ã™ã€‚</li>
</ul>
</blockquote>
<p>That's a good start, but it's not enough: apart from creating a <code>Ticket</code>, we also need to interact with it.
But how can we access the fields if they're private?</p>
<blockquote>
<p>ã“ã‚Œã¯è‰¯ã„ã‚¹ã‚¿ãƒ¼ãƒˆã§ã™ãŒã€ååˆ†ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚<code>Ticket</code>ã®ä½œæˆã¨ã¯åˆ¥ã«ã€ãƒã‚±ãƒƒãƒˆã¨ç›¸äº’ä½œç”¨ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚
ã—ã‹ã—ã€ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆãªå ´åˆã€ã©ã®ã‚ˆã†ã«ã‚¢ã‚¯ã‚»ã‚¹ã§ãã‚‹ã®ã§ã—ã‚‡ã†ã‹ï¼Ÿ</p>
</blockquote>
<p>We need to provide <strong>accessor methods</strong>.<br />
Accessor methods are public methods that allow you to read the value of a private field (or fields) of a struct.</p>
<blockquote>
<p><strong>ã‚¢ã‚¯ã‚»ãƒƒã‚µãƒ¼ãƒ¡ã‚½ãƒƒãƒ‰</strong>ã‚’æä¾›ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚
ã‚¢ã‚¯ã‚»ãƒƒã‚µãƒ¼ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€æ§‹é€ ä½“ã®ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆãªãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¾ãŸã¯è¤‡æ•°ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®å€¤ã‚’èª­ã¿å–ã‚Œã‚‹ãƒ‘ãƒ–ãƒªãƒƒã‚¯ãƒ¡ã‚½ãƒƒãƒ‰ã§ã™ã€‚</p>
</blockquote>
<p>Rust doesn't have a built-in way to generate accessor methods for you, like some other languages do.
You have to write them yourselfâ€”they're just regular methods.</p>
<blockquote>
<p>Rustã¯ã€ä»–ã®è¨€èªã®ã‚ˆã†ã«ã€ã‚¢ã‚¯ã‚»ãƒƒã‚µãƒ¼ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ç”Ÿæˆã™ã‚‹çµ„ã¿è¾¼ã¿ã®ä»•çµ„ã¿ãŒã‚ã‚Šã¾ã›ã‚“ã€‚
ã‚¢ã‚¯ã‚»ãƒƒã‚µãƒ¼ãƒ¡ã‚½ãƒƒãƒ‰ã‚’è‡ªèº«ã§è¨˜è¿°ã—ãªãã¦ã¯ãªã‚Šã¾ã›ã‚“ã€‚ã‚¢ã‚¯ã‚»ãƒƒã‚µãƒ¼ãƒ¡ã‚½ãƒƒãƒ‰ã¯å˜ãªã‚‹æ™®é€šã®ãƒ¡ã‚½ãƒƒãƒ‰ã§ã™ã€‚</p>
</blockquote>
<div class="footnote-definition" id="newtype"><sup class="footnote-definition-label">1</sup>
<p>Or refine their type, a technique we'll explore <a href="03_ticket_v1/../05_ticket_v2/15_outro.html">later on</a>.
ã¾ãŸã¯ã€å‹ã‚’æ´—ç·´ã™ã‚‹å¾Œã§æ¢æ±‚ã™ã‚‹ãƒ†ã‚¯ãƒ‹ãƒƒã‚¯ã§ã™ã€‚</p>
</div>
<h2 id="exercise-18"><a class="header" href="#exercise-18">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/03_ticket_v1/05_encapsulation"><code>03_ticket_v1/05_encapsulation</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ownershipæ‰€æœ‰æ¨©"><a class="header" href="#ownershipæ‰€æœ‰æ¨©">Ownershipï¼ˆæ‰€æœ‰æ¨©ï¼‰</a></h1>
<p>If you solved the previous exercise using what this course has taught you so far,
your accessor methods probably look like this:</p>
<blockquote>
<p>ã“ã®ã‚³ãƒ¼ã‚¹ãŒã“ã‚Œã¾ã§ã«æ•™ãˆãŸæ–¹æ³•ã‚’ä½¿ç”¨ã—ã¦ã€å‰ã®æ¼”ç¿’ã‚’è§£ã„ãŸå ´åˆã€ã‚¢ã‚¯ã‚»ãƒƒã‚µãƒ¼ãƒ¡ã‚½ãƒƒãƒ‰ã¯ãŠãã‚‰ãæ¬¡ã®ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Ticket {
    pub fn title(self) -&gt; String {
        self.title
    }

    pub fn description(self) -&gt; String {
        self.description
    }

    pub fn status(self) -&gt; String {
        self.status
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Those methods compile and are enough to get tests to pass, but in a real-world scenario they won't get you very far.
Consider this snippet:</p>
<blockquote>
<p>ãã‚Œã‚‰ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã‚Œã€ãƒ†ã‚¹ãƒˆã«ãƒ‘ã‚¹ã™ã‚‹ã®ã«ååˆ†ã§ã™ãŒã€ãã‚Œã‚‰ã¯å®Ÿéš›ã®ã‚·ãƒŠãƒªã‚ªã§å½¹ã«ç«‹ã¡ã¾ã›ã‚“ã€‚
æ¬¡ã®ã‚¹ãƒ‹ãƒšãƒƒãƒˆã‚’è€ƒãˆã¦ãã ã•ã„ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if ticket.status() == "To-Do" {
    // We haven't covered the `println!` macro yet,
    // but for now it's enough to know that it prints
    // a (templated) message to the console
    // ã¾ã `println!`ãƒã‚¯ãƒ­ã‚’èª¬æ˜ã—ã¦ã„ã¾ã›ã‚“ãŒã€ç¾æ™‚ç‚¹ã§ã¯ã€ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã«
    // ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆåŒ–ã—ãŸãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å‡ºåŠ›ã™ã‚‹ã“ã¨ã‚’ç†è§£ã™ã‚‹ã ã‘ã§ååˆ†ã§ã™ã€‚
    println!("Your next task is: {}", ticket.title());
}
<span class="boring">}</span></code></pre></pre>
<p>If you try to compile it, you'll get an error:</p>
<blockquote>
<p>ãã®ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚’è©¦ã¿ã‚‹ã¨ã€ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã™ã€‚</p>
</blockquote>
<pre><code class="language-text">error[E0382]: use of moved value: `ticket`
  --&gt; src/main.rs:30:43
   |
25 |     let ticket = Ticket::new(/* */);
   |         ------ move occurs because `ticket` has type `Ticket`,
   |                which does not implement the `Copy` trait
26 |     if ticket.status() == "To-Do" {
   |               -------- `ticket` moved due to this method call
...
30 |         println!("Your next task is: {}", ticket.title());
   |                                           ^^^^^^ value used here after move
   |
note: `Ticket::status` takes ownership of the receiver `self`, which moves `ticket`
  --&gt; src/main.rs:12:23
   |
12 |         pub fn status(self) -&gt; String {
   |                       ^^^^
</code></pre>
<p>Congrats, this is your first borrow-checker error!</p>
<blockquote>
<p>ãŠã‚ã§ã¨ã†ã”ã–ã„ã¾ã™ã€‚ã“ã‚Œã¯æœ€åˆã®å€Ÿç”¨ãƒã‚§ãƒƒã‚«ãƒ¼ã®ã‚¨ãƒ©ãƒ¼ã§ã™ï¼</p>
</blockquote>
<h2 id="the-perks-of-rusts-ownership-systemrustã®æ‰€æœ‰æ¨©ã‚·ã‚¹ãƒ†ãƒ ã®ç‰¹å…¸"><a class="header" href="#the-perks-of-rusts-ownership-systemrustã®æ‰€æœ‰æ¨©ã‚·ã‚¹ãƒ†ãƒ ã®ç‰¹å…¸">The perks of Rust's ownership systemï¼ˆRustã®æ‰€æœ‰æ¨©ã‚·ã‚¹ãƒ†ãƒ ã®ç‰¹å…¸ï¼‰</a></h2>
<p>Rust's ownership system is designed to ensure that:</p>
<ul>
<li>Data is never mutated while it's being read</li>
<li>Data is never read while it's being mutated</li>
<li>Data is never accessed after it has been destroyed</li>
</ul>
<blockquote>
<p>Rustã®æ‰€æœ‰æ¨©ã‚·ã‚¹ãƒ†ãƒ ã¯ã€æ¬¡ã‚’ç¢ºå®Ÿã«ã™ã‚‹ãŸã‚ã«è¨­è¨ˆã•ã‚Œã¦ã„ã¾ã™ã€‚</p>
<ul>
<li>ãƒ‡ãƒ¼ã‚¿ãŒèª­ã¿è¾¼ã¾ã‚Œã¦ã„ã‚‹é–“ã«å¤‰æ›´ã•ã‚Œãªã„ã€‚</li>
<li>ãƒ‡ãƒ¼ã‚¿ãŒå¤‰æ›´ã•ã‚Œã¦ã„ã‚‹é–“ã«èª­ã¿è¾¼ã¾ã‚Œãªã„ã€‚</li>
<li>ãƒ‡ãƒ¼ã‚¿ãŒç ´å£Šã•ã‚ŒãŸå¾Œã§ã‚¢ã‚¯ã‚»ã‚¹ã•ã‚Œãªã„ã€‚</li>
</ul>
</blockquote>
<p>These constraints are enforced by the <strong>borrow checker</strong>, a subsystem of the Rust compiler,
often the subject of jokes and memes in the Rust community.</p>
<blockquote>
<p>ã“ã‚Œã‚‰ã®åˆ¶ç´„ã¯ã€Rustã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ¼ã®ã‚µãƒ–ã‚·ã‚¹ãƒ†ãƒ ã§ã‚ã‚‹<strong>å€Ÿç”¨ãƒã‚§ãƒƒã‚«ãƒ¼</strong>ã«ã‚ˆã£ã¦å¼·åˆ¶ã•ã‚Œã€Rustã‚³ãƒŸãƒ¥ãƒ‹ãƒ†ã‚£ãƒ¼å†…ã§ã‚ˆãã‚¸ãƒ§ãƒ¼ã‚¯ã‚„ãƒŸãƒ¼ãƒ ã®å¯¾è±¡ã¨ãªã£ã¦ã„ã¾ã™ã€‚</p>
</blockquote>
<p>Ownership is a key concept in Rust, and it's what makes the language unique.
Ownership enables Rust to provide <strong>memory safety without compromising performance</strong>.
All these things are true at the same time for Rust:</p>
<ol>
<li>There is no runtime garbage collector</li>
<li>As a developer, you rarely have to manage memory directly</li>
<li>You can't cause dangling pointers, double frees, and other memory-related bugs</li>
</ol>
<blockquote>
<p>Rustã«ãŠã„ã¦ã€æ‰€æœ‰æ¨©ã¯é‡è¦ãªæ¦‚å¿µã§ã‚ã‚Šã€è¨€èªã‚’ãƒ¦ãƒ‹ãƒ¼ã‚¯ã«ã—ã¾ã™ã€‚
æ‰€æœ‰æ¨©ã¯ã€Rustã«<strong>æ€§èƒ½ã®å¦¥å”ãªã—ã«ãƒ¡ãƒ¢ãƒªå®‰å…¨</strong>ã‚’æä¾›ã—ã¾ã™ã€‚
æ¬¡ã®ã™ã¹ã¦ã¯ã€Rustã«ãŠã„ã¦åŒæ™‚ã«æˆç«‹ã—ã¾ã™ã€‚</p>
<ol>
<li>ãƒ©ãƒ³ã‚¿ã‚¤ãƒ ãªã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚¿ãƒ¼ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚</li>
<li>é–‹ç™ºè€…ã¨ã—ã¦ã€ã¾ã‚Œã«ç›´æ¥ãƒ¡ãƒ¢ãƒªã‚’ç®¡ç†ã—ãªã‘ã‚Œã°ãªã‚‰ãªã„ã¨ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚</li>
<li>ãƒ€ãƒ³ã‚°ãƒªãƒ³ã‚°ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã€äºŒé‡è§£æ”¾ã€ãã—ã¦ä»–ã®ãƒ¡ãƒ¢ãƒªã«é–¢é€£ã™ã‚‹ãƒã‚°ã‚’å¼•ãèµ·ã“ã›ã¾ã›ã‚“ã€‚</li>
</ol>
</blockquote>
<p>Languages like Python, JavaScript, and Java give you 2. and 3., but not 1.<br />
Language like C or C++ give you 1., but neither 2. nor 3.</p>
<blockquote>
<p>Pythonã€JavaScriptã€ãã—ã¦Javaã®ã‚ˆã†ãªè¨€èªã¯ã€ï¼’ã¨3ã¯æˆç«‹ã—ã¾ã™ãŒã€1ã¯æˆç«‹ã—ã¾ã›ã‚“ã€‚
Cã‚„C++ã®ã‚ˆã†ãªè¨€èªã¯ã€1ã¯æˆç«‹ã—ã¾ã™ãŒã€2ã¨3ã¯æˆç«‹ã—ã¾ã›ã‚“ã€‚</p>
</blockquote>
<p>Depending on your background, 3. might sound a bit arcane: what is a "dangling pointer"?
What is a "double free"? Why are they dangerous?<br />
Don't worry: we'll cover these concepts in more details during the rest of the course.</p>
<blockquote>
<p>ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã«ä¾å­˜ã—ã¦ã€3ã¯å°‘ã—é›£è§£ã«èã“ãˆã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚
ã€Œãƒ€ãƒ³ã‚°ãƒªãƒ³ã‚°ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã€ã¨ã¯ä½•ã§ã—ã‚‡ã†ã‹ï¼Ÿ
ã€ŒäºŒé‡è§£æ”¾ã€ã¨ã¯ä½•ã§ã—ã‚‡ã†ã‹ï¼Ÿ
ãªãœãã‚Œã‚‰ã¯å±é™ºãªã®ã§ã—ã‚‡ã†ã‹ï¼Ÿ
å¿ƒé…ã—ãªã„ã§ãã ã•ã„ã€‚ã‚³ãƒ¼ã‚¹ã®æ®‹ã‚Šã§ã€ã“ã‚Œã‚‰ã®æ¦‚å¿µã‚’ã‚ˆã‚Šè©³ç´°ã«èª¬æ˜ã—ã¾ã™ã€‚</p>
</blockquote>
<p>For now, though, let's focus on learning how to work within Rust's ownership system.</p>
<blockquote>
<p>ã—ã‹ã—ã€ç¾æ™‚ç‚¹ã§ã¯ã€Rustã®æ‰€æœ‰æ¨©ã‚·ã‚¹ãƒ†ãƒ å†…ã§ä½œæ¥­ã™ã‚‹æ–¹æ³•ã‚’å­¦ã¶ã“ã¨ã«ç„¦ç‚¹ã‚’å½“ã¦ã¾ã—ã‚‡ã†ã€‚</p>
</blockquote>
<h2 id="the-owneræ‰€æœ‰è€…"><a class="header" href="#the-owneræ‰€æœ‰è€…">The ownerï¼ˆæ‰€æœ‰è€…ï¼‰</a></h2>
<p>In Rust, each value has an <strong>owner</strong>, statically determined at compile-time.
There is only one owner for each value at any given time.</p>
<blockquote>
<p>Rustã«ãŠã„ã¦ã€ãã‚Œãã‚Œã®å€¤ã¯ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã«é™çš„ã«æ±ºå®šã•ã‚Œã‚‹<strong>æ‰€æœ‰è€…</strong>ã‚’æŒã¡ã¾ã™ã€‚
ä»»æ„ã®æ™‚ç‚¹ã§ãã‚Œãã‚Œã®å€¤ã«ã¯ã€ãŸã£ãŸ1ã¤ã®æ‰€æœ‰è€…ãŒã„ã¾ã™ã€‚</p>
</blockquote>
<h2 id="move-semanticsãƒ ãƒ¼ãƒ–ã‚»ãƒãƒ³ãƒ†ã‚£ãƒƒã‚¯ãƒ ãƒ¼ãƒ–ã®æ„å‘³è«–"><a class="header" href="#move-semanticsãƒ ãƒ¼ãƒ–ã‚»ãƒãƒ³ãƒ†ã‚£ãƒƒã‚¯ãƒ ãƒ¼ãƒ–ã®æ„å‘³è«–">Move semanticsï¼ˆãƒ ãƒ¼ãƒ–ã‚»ãƒãƒ³ãƒ†ã‚£ãƒƒã‚¯ã€ãƒ ãƒ¼ãƒ–ã®æ„å‘³è«–ï¼‰</a></h2>
<p>Ownership can be transferred.</p>
<blockquote>
<p>æ‰€æœ‰æ¨©ã¯ç§»å‹•ã•ã‚Œã¾ã™ã€‚</p>
</blockquote>
<p>If you own a value, for example, you can transfer ownership to another variable:</p>
<blockquote>
<p>ä¾‹ãˆã°ã€å€¤ã‚’æ‰€æœ‰ã—ã¦ã„ã‚‹å ´åˆã€ä»–ã®å¤‰æ•°ã«æ‰€æœ‰æ¨©ã‚’ç§»å‹•ã§ãã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = "hello, world".to_string(); // &lt;--- `a` is the owner of the String
                                    // &lt;--- `a`ã¯æ–‡å­—åˆ—ã®æ‰€æœ‰è€…ã§ã™ã€‚
let b = a;  // &lt;--- `b` is now the owner of the String
            // &lt;--- ç¾åœ¨ã€`b`ã¯æ–‡å­—åˆ—ã®æ‰€æœ‰è€…ã§ã™ã€‚
<span class="boring">}</span></code></pre></pre>
<p>Rust's ownership system is baked into the type system: each function has to declare in its signature
<em>how</em> it wants to interact with its arguments.</p>
<blockquote>
<p>Rustã®æ‰€æœ‰æ¨©ã‚·ã‚¹ãƒ†ãƒ ã¯ã€å‹ã‚·ã‚¹ãƒ†ãƒ å†…ã«çµ„ã¿è¾¼ã¾ã‚Œã¦ã„ã¾ã™ã€‚
ãã‚Œãã‚Œã®é–¢æ•°ã¯ã€ãã®å¼•æ•°ã¨ç›¸äº’ä½œç”¨ã™ã‚‹æ–¹æ³•ã‚’ã€ãã®ã‚·ã‚°ãƒãƒãƒ£ãƒ¼ã§å®£è¨€ã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚</p>
</blockquote>
<p>So far, all our methods and functions have <strong>consumed</strong> their arguments: they've taken ownership of them.
For example:</p>
<blockquote>
<p>ã“ã‚Œã¾ã§ã€ã™ã¹ã¦ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¨é–¢æ•°ã¯ã€ãã‚Œã‚‰ã®å¼•æ•°ã‚’<strong>æ¶ˆè²»</strong>ã—ã¾ã—ãŸã€‚
ãã‚Œã‚‰ã¯ã€å®Ÿå¼•æ•°ã®æ‰€æœ‰æ¨©ã‚’å–ã‚Šã¾ã—ãŸã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Ticket {
    pub fn description(self) -&gt; String {
        self.description
    }
}
<span class="boring">}</span></code></pre></pre>
<p><code>Ticket::description</code> takes ownership of the <code>Ticket</code> instance it's called on.<br />
This is known as <strong>move semantics</strong>: ownership of the value (<code>self</code>) is <strong>moved</strong> from the caller to
the callee, and the caller can't use it anymore.</p>
<blockquote>
<p><code>Ticket::description</code>ã¯ã€ãã‚Œã‚’å‘¼ã³å‡ºã—ãŸ<code>Ticket</code>ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®æ‰€æœ‰æ¨©ã‚’å–ã‚Šã¾ã™ã€‚
ã“ã‚Œã¯ã€<strong>ãƒ ãƒ¼ãƒ–ã‚»ãƒãƒ³ãƒ†ã‚£ãƒƒã‚¯</strong>ã¨ã—ã¦çŸ¥ã‚‰ã‚Œã¦ã„ã¾ã™ã€‚
å€¤ï¼ˆ<code>self</code>ï¼‰ã®æ‰€æœ‰æ¨©ã¯ã€å‘¼ã³å‡ºã—å…ƒã‹ã‚‰å‘¼ã³å‡ºã—å…ˆã«<strong>ç§»å‹•</strong>ã—ã¦ã€å‘¼ã³å‡ºã—å…ƒã¯ãã‚Œã‚’ä½¿ç”¨ã§ãã¾ã›ã‚“ã€‚</p>
</blockquote>
<p>That's exactly the language used by the compiler in the error message we saw earlier:</p>
<blockquote>
<p>ãã‚Œã¯ã€å‰ã«è¦‹ãŸã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã§ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ¼ã«ã‚ˆã£ã¦ä½¿ç”¨ã•ã‚ŒãŸæ­£ç¢ºãªè¨€èªã§ã™ã€‚</p>
</blockquote>
<pre><code class="language-text">error[E0382]: use of moved value: `ticket`
  --&gt; src/main.rs:30:43
   |
25 |     let ticket = Ticket::new(/* */);
   |         ------ move occurs because `ticket` has type `Ticket`,
   |                which does not implement the `Copy` trait
26 |     if ticket.status() == "To-Do" {
   |               -------- `ticket` moved due to this method call
...
30 |         println!("Your next task is: {}", ticket.title());
   |                                           ^^^^^^ value used here after move
   |
note: `Ticket::status` takes ownership of the receiver `self`, which moves `ticket`
  --&gt; src/main.rs:12:23
   |
12 |         pub fn status(self) -&gt; String {
   |                       ^^^^
</code></pre>
<p>In particular, this is the sequence of events that unfold when we call <code>ticket.status()</code>:</p>
<ul>
<li><code>Ticket::status</code> takes ownership of the <code>Ticket</code> instance</li>
<li><code>Ticket::status</code> extracts <code>status</code> from <code>self</code> and transfers ownership of <code>status</code> back to the caller</li>
<li>The rest of the <code>Ticket</code> instance is discarded (<code>title</code> and <code>description</code>)</li>
</ul>
<blockquote>
<p>ç‰¹ã«ã€æ¬¡ã¯ã€<code>ticket.status()</code>ã‚’å‘¼ã³å‡ºã—ãŸã¨ãã«ã€å±•é–‹ã•ã‚ŒãŸã‚¤ãƒ™ãƒ³ãƒˆã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã§ã™ã€‚</p>
<ul>
<li><code>Ticket::status</code>ã¯ã€<code>Ticket</code>ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®æ‰€æœ‰æ¨©ã‚’å–ã‚Šã¾ã™ã€‚</li>
<li><code>Ticket::status</code>ã¯ã€<code>self</code>ã‹ã‚‰<code>status</code>ã‚’æŠ½å‡ºã—ã¦ã€å‘¼ã³å‡ºã—å…ƒã«<code>status</code>ã®æ‰€æœ‰æ¨©ã‚’ç§»å‹•ã—ã¾ã™ã€‚</li>
<li><code>Ticket</code>ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®æ®‹ã‚Šã¯ã€ç ´æ£„ã•ã‚Œã¾ã™ï¼ˆ<code>title</code>ã¨<code>description</code>ï¼‰ã€‚</li>
</ul>
</blockquote>
<p>When we try to use <code>ticket</code> again via <code>ticket.title()</code>, the compiler complains: the <code>ticket</code> value is gone now,
we no longer own it, therefore we can't use it anymore.</p>
<blockquote>
<p><code>ticket.title()</code>ã§å†åº¦<code>ticket</code>ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã‚’è©¦ã¿ã‚‹ã¨ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ¼ã¯ä¸æº€ã‚’è¨€ã„ã¾ã™ã€‚
ç¾åœ¨<code>ticket</code>ã®å€¤ã¯ãªããªã£ãŸãŸã‚ã€ã‚‚ã¯ã‚„ãã‚Œã‚’æ‰€æœ‰ã—ã¦ãŠã‚‰ãšã€ã“ã‚Œä»¥ä¸Šãã‚Œã‚’ä½¿ç”¨ã§ãã¾ã›ã‚“ã€‚</p>
</blockquote>
<p>To build <em>useful</em> accessor methods we need to start working with <strong>references</strong>.</p>
<blockquote>
<p>_æœ‰ç”¨ãª_ã‚¢ã‚¯ã‚»ãƒƒã‚µãƒ¼ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æ§‹ç¯‰ã™ã‚‹ãŸã‚ã«ã€<strong>å‚ç…§</strong>ã‚’ä½¿ç”¨ã—ãŸä½œæ¥­ã‚’å§‹ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚</p>
</blockquote>
<h2 id="borrowingå€Ÿç”¨"><a class="header" href="#borrowingå€Ÿç”¨">Borrowingï¼ˆå€Ÿç”¨ï¼‰</a></h2>
<p>It is desirable to have methods that can read the value of a variable without taking ownership of it.<br />
Programming would be quite limited otherwise. In Rust, that's done via <strong>borrowing</strong>.</p>
<blockquote>
<p>å€¤ã®æ‰€æœ‰æ¨©ã‚’å–ã‚‰ãšã«ã€å¤‰æ•°ã®å€¤ã‚’èª­ã¿è¾¼ã‚€ã“ã¨ãŒã§ãã‚‹ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æŒã¤ã“ã¨ãŒæœ›ã¾ã—ã„ã§ã™ã€‚
ãã†ã§ãªã‘ã‚Œã°ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã¯ã€ã‹ãªã‚Šåˆ¶é™ã•ã‚Œã¾ã™ã€‚
Rustã§ã¯ã€ãã‚Œã‚’<strong>å€Ÿç”¨</strong>ã‚’ä»‹ã—ã¦è¡Œã„ã¾ã™ã€‚</p>
</blockquote>
<p>Whenever you borrow a value, you get a <strong>reference</strong> to it.<br />
References are tagged with their privileges<sup class="footnote-reference"><a href="#refine">1</a></sup>:</p>
<ul>
<li>Immutable references (<code>&amp;</code>) allow you to read the value, but not to mutate it</li>
<li>Mutable references (<code>&amp;mut</code>) allow you to read and mutate the value</li>
</ul>
<blockquote>
<p>å€¤ã‚’å€Ÿç”¨ã™ã‚‹ã¨ãã¯ã„ã¤ã§ã‚‚ã€ãã®<strong>å‚ç…§</strong>ã‚’å–å¾—ã—ã¾ã™ã€‚
å‚ç…§ã¯ã€ãã‚Œã‚‰ã®æ¨©é™ã§ã‚¿ã‚°ä»˜ã‘ã•ã‚Œã¾ã™ã€‚</p>
<ul>
<li>ä¸å¤‰å‚ç…§ï¼ˆ<code>&amp;</code>ï¼‰ã¯ã€å€¤ã‚’èª­ã¿è¾¼ã‚ã‚‹ã‚ˆã†ã«ã—ã¾ã™ãŒã€ãã‚Œã‚’å¤‰æ›´ã§ãã¾ã›ã‚“ã€‚</li>
<li>å¯å¤‰å‚ç…§ï¼ˆ<code>&amp;mut</code>ï¼‰ã¯ã€å€¤ã‚’èª­ã¿è¾¼ã¿ã€å¤‰æ›´ã§ãã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚</li>
</ul>
</blockquote>
<p>Going back to the goals of Rust's ownership system:</p>
<ul>
<li>Data is never mutated while it's being read</li>
<li>Data is never read while it's being mutated</li>
</ul>
<blockquote>
<p>Rustã®æ‰€æœ‰æ¨©ã‚·ã‚¹ãƒ†ãƒ ã®ç›®çš„ã«æˆ»ã‚Šã¾ã™ã€‚</p>
<ul>
<li>ãƒ‡ãƒ¼ã‚¿ã¯ã€ãã‚ŒãŒèª­ã¿è¾¼ã¾ã‚Œã¦ã„ã‚‹é–“ã€å¤‰æ›´ã§ãã¾ã›ã‚“ã€‚</li>
<li>ãƒ‡ãƒ¼ã‚¿ã¯ã€ãã‚ŒãŒå¤‰æ›´ã•ã‚Œã¦ã„ã‚‹é–“ã€èª­ã¿è¾¼ã¿ã§ãã¾ã›ã‚“ã€‚</li>
</ul>
</blockquote>
<p>To ensure these two properties, Rust has to introduce some restrictions on references:</p>
<ul>
<li>You can't have a mutable reference and an immutable reference to the same value at the same time</li>
<li>You can't have more than one mutable reference to the same value at the same time</li>
<li>The owner can't mutate the value while it's being borrowed</li>
<li>You can have as many immutable references as you want, as long as there are no mutable references</li>
</ul>
<blockquote>
<p>ã“ã‚Œã‚‰2ã¤ã®å±æ€§ã‚’ç¢ºå®Ÿã«ã™ã‚‹ãŸã‚ã«ã€Rustã¯å‚ç…§ã«ã„ãã¤ã‹ã®åˆ¶ç´„ã‚’å°å…¥ã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚</p>
<ul>
<li>åŒæ™‚ã«åŒã˜å€¤ã¸ã®å¯å¤‰å‚ç…§ã¨ä¸å¤‰å‚ç…§ã‚’æŒã¤ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚</li>
<li>åŒæ™‚ã«åŒã˜å€¤ã¸ã®å¯å¤‰å‚ç…§ã‚’è¤‡æ•°æŒã¤ã“ã¨ã¯ã§ãã¾ã›ã‚“ï¼ˆ1ã¤ã—ã‹æŒã¦ãªã„ï¼‰ã€‚</li>
<li>æ‰€æœ‰è€…ã¯ã€å€¤ãŒå€Ÿç”¨ã•ã‚Œã¦ã„ã‚‹é–“ã€å€¤ã‚’å¤‰æ›´ã§ãã¾ã›ã‚“ã€‚</li>
<li>å¯å¤‰å‚ç…§ãŒãªã„é™ã‚Šã€å¸Œæœ›ã«å¿œã˜ã¦å¤šãã®ä¸å¤‰å‚ç…§ã‚’æŒã¦ã¾ã™ã€‚</li>
</ul>
</blockquote>
<p>In a way, you can think of an immutable reference as a "read-only" lock on the value,
while a mutable reference is like a "read-write" lock.</p>
<blockquote>
<p>ã‚ã‚‹æ„å‘³ã§ã€å€¤ã®ã€Œèª­ã¿è¾¼ã¿å°‚ç”¨ã€ãƒ­ãƒƒã‚¯ã¨ã—ã¦ä¸å¤‰å‚ç…§ã‚’è€ƒãˆã‚‹ã“ã¨ãŒã§ãã‚‹ä¸€æ–¹ã§ã€å¯å¤‰å‚ç…§ã¯ã€Œèª­ã¿æ›¸ãã€ãƒ­ãƒƒã‚¯ã®ã‚ˆã†ã§ã™ã€‚</p>
</blockquote>
<p>All these restrictions are enforced at compile-time by the borrow checker.</p>
<blockquote>
<p>ã“ã‚Œã‚‰ã™ã¹ã¦ã®åˆ¶ç´„ã¯ã€å€Ÿç”¨ãƒã‚§ãƒƒã‚«ãƒ¼ã«ã‚ˆã£ã¦ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã«å¼·åˆ¶ã•ã‚Œã¾ã™ã€‚</p>
</blockquote>
<h3 id="syntaxæ§‹æ–‡-1"><a class="header" href="#syntaxæ§‹æ–‡-1">Syntaxï¼ˆæ§‹æ–‡ï¼‰</a></h3>
<p>How do you borrow a value, in practice?<br />
By adding <code>&amp;</code> or <code>&amp;mut</code> <strong>in front a variable</strong>, you're borrowing its value.
Careful though! The same symbols (<code>&amp;</code> and <code>&amp;mut</code>) in <strong>front of a type</strong> have a different meaning:
they denote a different type, a reference to the original type.</p>
<p>For example:</p>
<blockquote>
<p>å®Ÿéš›ã«ã€ã©ã®ã‚ˆã†ã«å€¤ã‚’å€Ÿç”¨ã™ã‚Œã°ã‚ˆã„ã®ã§ã—ã‚‡ã†ã‹ï¼Ÿ
<strong>å¤‰æ•°ã®å‰</strong>ã«<code>&amp;</code>ã¾ãŸã¯<code>&amp;mut</code>ã‚’è¿½åŠ ã™ã‚‹ã“ã¨ã§ã€ãã®å€¤ã‚’å€Ÿç”¨ã§ãã¾ã™ã€‚
ãŸã ã—ã€æ³¨æ„ã—ã¦ãã ã•ã„ï¼
<strong>å‹ã®å‰</strong>ã®åŒã˜ã‚·ãƒ³ãƒœãƒ«ï¼ˆ<code>&amp;</code>ã¨<code>&amp;mut</code>ï¼‰ã¯ã€ç•°ãªã‚‹æ„å‘³ã‚’æŒã¡ã¾ã™ã€‚
ãã‚Œã‚‰ã¯ã€ã‚ªãƒªã‚¸ãƒŠãƒ«ã®å‹ã¸ã®å‚ç…§ã‚’ç¤ºã™ç•°ãªã‚‹å‹ã§ã™ã€‚</p>
<p>ä¾‹ãˆã°ãƒ»ãƒ»ãƒ»</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">struct Configuration {
    version: u32,
    active: bool,
}

fn main() {
    let config = Configuration {
        version: 1,
        active: true,
    };
    // `b` is a reference to the `version` field of `config`.
    // The type of `b` is `&amp;u32`, since it contains a reference to a `u32` value.
    // We create a reference by borrowing `config.version`, using the `&amp;` operator.
    // Same symbol (`&amp;`), different meaning depending on the context!
    // `b`ã¯ã€`config`ã®`version`ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¸ã®å‚ç…§ã§ã™ã€‚
    // `b`ã¯`u32`å€¤ã¸ã®å‚ç…§ã‚’å«ã‚€ãŸã‚ã€`b`ã®å‹ã¯`&amp;u32`ã§ã™ã€‚
    // `&amp;`æ¼”ç®—å­ã‚’ä½¿ç”¨ã—ã¦`config.version`ã‚’å€Ÿç”¨ã™ã‚‹ã“ã¨ã§ã€å‚ç…§ã‚’ä½œæˆã—ã¾ã—ãŸã€‚
    // åŒã˜ã‚·ãƒ³ãƒœãƒ«ï¼ˆ`&amp;`ï¼‰ã§ã™ãŒã€æ–‡è„ˆã«ä¾å­˜ã—ã¦ç•°ãªã‚‹æ„å‘³ã‚’æŒã¡ã¾ã™ï¼
    let b: &amp;u32 = &amp;config.version;
    //     ^ The type annotation is not necessary,
    //       it's just there to clarify what's going on
    //       å‹æ³¨é‡ˆã¯å¿…è¦ã‚ã‚Šã¾ã›ã‚“ãŒã€ãã‚Œã¯ä½•ãŒèµ·ã“ã£ã¦ã„ã‚‹ã‹ã‚’æ˜ç¢ºã«ã™ã‚‹ãŸã‚ã ã‘ã«ã‚ã‚Šã¾ã™ã€‚
}</code></pre></pre>
<p>The same concept applies to function arguments and return types:</p>
<blockquote>
<p>åŒã˜æ¦‚å¿µã¯ã€é–¢æ•°ã®å¼•æ•°ã¨æˆ»ã‚Šå€¤ã®å‹ã«é©ç”¨ã•ã‚Œã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// `f` takes a mutable reference to a `u32` as an argument,
// bound to the name `number`
// `f`ã¯ã€å¼•æ•°ã¨ã—ã¦`u32`ã¸ã®å¯å¤‰å‚ç…§ã‚’å–ã‚Šã€åå‰`number`ã«æ‹˜æŸã•ã‚Œã¾ã™ã€‚
fn f(number: &amp;mut u32) -&gt; &amp;u32 {
    // [...]
}
<span class="boring">}</span></code></pre></pre>
<h2 id="breathe-in-breathe-outæ¯ã‚’å¸ã£ã¦æ¯ã‚’åã"><a class="header" href="#breathe-in-breathe-outæ¯ã‚’å¸ã£ã¦æ¯ã‚’åã">Breathe in, breathe outï¼ˆæ¯ã‚’å¸ã£ã¦ã€æ¯ã‚’åãï¼‰</a></h2>
<p>Rust's ownership system can be a bit overwhelming at first.<br />
But don't worry: it'll become second nature with practice.<br />
And you're going to get a lot of practice over the rest of this chapter, as well as the rest of the course!
We'll revisit each concept multiple times to make sure you get familiar with them
and truly understand how they work.</p>
<blockquote>
<p>Rustã®æ‰€æœ‰æ¨©ã‚·ã‚¹ãƒ†ãƒ ã¯ã€æœ€åˆã¯å°‘ã—æ‰“ã¡ã®ã‚ã•ã›ã‚‰ã‚Œã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚
ã—ã‹ã—ã€å¿ƒé…ã—ãªã„ã§ãã ã•ã„ã€‚ãã‚Œã¯å®Ÿè·µã«ã‚ˆã‚Šè‡ªç„¶ã«ãªã‚Šã¾ã™ã€‚
ãã—ã¦ã€ã‚³ãƒ¼ã‚¹ã®æ®‹ã‚Šã¨åŒæ§˜ã«ã€ã“ã®ç« ã®æ®‹ã‚Šã§å¤šãã®å®Ÿè·µã‚’è¡Œã„ã¾ã™ã€‚
ãã‚Œã‚‰ã«æ…£ã‚Œã‚‹ã“ã¨ã‚’ç¢ºå®Ÿã«ã™ã‚‹ãŸã‚ã«ã€ä½•å›ã‚‚ãã‚Œãã‚Œã®æ¦‚å¿µã‚’å†è¨ªã—ã¦ã€ãã‚Œã‚‰ãŒã©ã®ã‚ˆã†ã«æ©Ÿèƒ½ã™ã‚‹ã‹ã‚’æœ¬å½“ã«ç†è§£ã—ã¾ã™ã€‚</p>
</blockquote>
<p>Towards the end of this chapter we'll explain <em>why</em> Rust's ownership system is designed the way it is.
For the time being, focus on understanding the <em>how</em>. Take each compiler error as a learning opportunity!</p>
<blockquote>
<p>ã“ã®ç« ã®æœ€å¾Œã«ã€Rustã®æ‰€æœ‰æ¨©ã‚·ã‚¹ãƒ†ãƒ ãŒã€ãã®ã‚ˆã†ã«è¨­è¨ˆã•ã‚ŒãŸç†ç”±ã‚’èª¬æ˜ã—ã¾ã™ã€‚
ç¾æ™‚ç‚¹ã§ã¯ã€_ã©ã®ã‚ˆã†ã«_ç†è§£ã™ã‚‹ã‹ã«ç„¦ç‚¹ã‚’å½“ã¦ã¦ãã ã•ã„ã€‚
å­¦ã¶æ©Ÿä¼šã¨ã—ã¦ã€ãã‚Œãã‚Œã®ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚¨ãƒ©ãƒ¼ã‚’å—ã‘å…¥ã‚Œã¦ãã ã•ã„ï¼</p>
</blockquote>
<div class="footnote-definition" id="refine"><sup class="footnote-definition-label">1</sup>
<p>This is a great mental model to start out, but it doesn't capture the <em>full</em> picture.
We'll refine our understanding of references <a href="03_ticket_v1/../07_threads/06_interior_mutability.html">later in the course</a>.
ã“ã‚Œã¯å§‹ã‚ã‚‹ãŸã‚ã®ç´ æ™´ã‚‰ã—ã„ãƒ¡ãƒ³ã‚¿ãƒ«ãƒ¢ãƒ‡ãƒ«ã§ã™ãŒã€_å®Œå…¨ãª_å§¿ã‚’æ‰ãˆã¦ã„ã¾ã›ã‚“ã€‚
ã‚³ãƒ¼ã‚¹ã®å¾ŒåŠã§ã€å‚ç…§ã®ç†è§£ã‚’æ´—ç·´ã•ã›ã¾ã™ã€‚</p>
</div>
<h2 id="exercise-19"><a class="header" href="#exercise-19">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/03_ticket_v1/06_ownership"><code>03_ticket_v1/06_ownership</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mutable-referenceså¯å¤‰å‚ç…§"><a class="header" href="#mutable-referenceså¯å¤‰å‚ç…§">Mutable referencesï¼ˆå¯å¤‰å‚ç…§ï¼‰</a></h1>
<p>Your accessor methods should look like this now:</p>
<blockquote>
<p>ç¾åœ¨ã€ã‚¢ã‚¯ã‚»ãƒƒã‚µãƒ¼ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€æ¬¡ã®ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Ticket {
    pub fn title(&amp;self) -&gt; &amp;String {
        &amp;self.title
    }

    pub fn description(&amp;self) -&gt; &amp;String {
        &amp;self.description
    }

    pub fn status(&amp;self) -&gt; &amp;String {
        &amp;self.status
    }
}
<span class="boring">}</span></code></pre></pre>
<p>A sprinkle of <code>&amp;</code> here and there did the trick!<br />
We now have a way to access the fields of a <code>Ticket</code> instance without consuming it in the process.
Let's see how we can enhance our <code>Ticket</code> struct with <strong>setter methods</strong> next.</p>
<blockquote>
<p>ã“ã“ã«<code>&amp;</code>ã‚’æŒ¯ã‚Šã‹ã‘ã‚‹ã“ã¨ã§ã€ãã‚Œã‚‰ã¯ã†ã¾ãã„ãã¾ã—ãŸï¼
ç¾åœ¨ã€å‡¦ç†ã§<code>Ticket</code>ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’æ¶ˆè²»ã—ãªã„ã§ã€<code>Ticket</code>ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹æ–¹æ³•ã‚’æŒã¤ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚
æ¬¡ã«ã€<strong>ã‚»ãƒƒã‚¿ãƒ¼ãƒ¡ã‚½ãƒƒãƒ‰</strong>ã§<code>Ticket</code>æ§‹é€ ä½“ã‚’å¼·åŒ–ã™ã‚‹æ–¹æ³•ã‚’ç¢ºèªã—ã¾ã—ã‚‡ã†ã€‚</p>
</blockquote>
<h2 id="settersã‚»ãƒƒã‚¿ãƒ¼"><a class="header" href="#settersã‚»ãƒƒã‚¿ãƒ¼">Settersï¼ˆã‚»ãƒƒã‚¿ãƒ¼ï¼‰</a></h2>
<p>Setter methods allow users to change the values of <code>Ticket</code>'s private fields while making sure that its invariants
are respected (i.e. you can't set a <code>Ticket</code>'s title to an empty string).</p>
<blockquote>
<p>ã‚»ãƒƒã‚¿ãƒ¼ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ä¾‹ãˆã°ã€<code>Ticket</code>ã®ã‚¿ã‚¤ãƒˆãƒ«ã«ç©ºã®æ–‡å­—åˆ—ã‚’è¨­å®šã§ããªã„ãªã©ã€<code>Ticket</code>ã®ä¸å¤‰æ€§ã‚’å°Šé‡ã™ã‚‹ã“ã¨ã‚’ç¢ºå®Ÿã«ã™ã‚‹ä¸€æ–¹ã§ã€<code>Ticket</code>ã®ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®å€¤ã‚’å¤‰æ›´ã§ãã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚</p>
</blockquote>
<p>There are two common ways to implement setters in Rust:</p>
<ul>
<li>Taking <code>self</code> as input.</li>
<li>Taking <code>&amp;mut self</code> as input.</li>
</ul>
<blockquote>
<p>Rustã«ãŠã„ã¦ã‚»ãƒƒã‚¿ãƒ¼ã‚’å®Ÿè£…ã™ã‚‹2ã¤ã®ä¸€èˆ¬çš„ãªæ–¹æ³•ãŒã‚ã‚Šã¾ã™ã€‚</p>
<ul>
<li>å…¥åŠ›ã¨ã—ã¦<code>self</code>ã‚’å—ã‘å–ã‚‹ã€‚</li>
<li>å…¥åŠ›ã¨ã—ã¦<code>&amp;mut self</code>ã‚’å—ã‘å–ã‚‹ã€‚</li>
</ul>
</blockquote>
<h3 id="taking-self-as-inputå…¥åŠ›ã¨ã—ã¦selfã‚’å—ã‘å–ã‚‹"><a class="header" href="#taking-self-as-inputå…¥åŠ›ã¨ã—ã¦selfã‚’å—ã‘å–ã‚‹">Taking <code>self</code> as inputï¼ˆå…¥åŠ›ã¨ã—ã¦selfã‚’å—ã‘å–ã‚‹ï¼‰</a></h3>
<p>The first approach looks like this:</p>
<blockquote>
<p>æœ€åˆã®æ–¹æ³•ã¯æ¬¡ã®ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Ticket {
    pub fn set_title(mut self, new_title: String) -&gt; Self {
        // Validate the new title [...]
        // æ–°ã—ã„ã‚¿ã‚¤ãƒˆãƒ«ã‚’æ¤œè¨¼ã—ã¾ã™ã€‚
        self.title = new_title;
        self
    }
}
<span class="boring">}</span></code></pre></pre>
<p>It takes ownership of <code>self</code>, changes the title, and returns the modified <code>Ticket</code> instance.<br />
This is how you'd use it:</p>
<blockquote>
<p>ãã‚Œã¯ã€<code>self</code>ã®æ‰€æœ‰æ¨©ã‚’å–å¾—ã—ã¦ã€ã‚¿ã‚¤ãƒˆãƒ«ã‚’å¤‰æ›´ã—ãŸå¾Œã€å¤‰æ›´ã•ã‚ŒãŸ<code>Ticket</code>ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’è¿”ã—ã¾ã™ã€‚
æ¬¡ã¯ãã‚Œã‚’ä½¿ç”¨ã™ã‚‹æ–¹æ³•ã§ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let ticket = Ticket::new("Title".into(), "Description".into(), "To-Do".into());
let ticket = ticket.set_title("New title".into());
<span class="boring">}</span></code></pre></pre>
<p>Since <code>set_title</code> takes ownership of <code>self</code> (i.e. it <strong>consumes it</strong>), we need to reassign the result to a variable.
In the example above we take advantage of <strong>variable shadowing</strong> to reuse the same variable name: when
you declare a new variable with the same name as an existing one, the new variable <strong>shadows</strong> the old one. This
is a common pattern in Rust code.</p>
<blockquote>
<p><code>set_title</code>ãŒ<code>self</code>ã®æ‰€æœ‰æ¨©ã‚’å–å¾—ã—ã¦ã€<strong>ãã‚Œã‚’æ¶ˆè²»ã™ã‚‹</strong>ãŸã‚ã€å¤‰æ•°ã«çµæœã‚’å†å‰²ã‚Šå½“ã¦ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚
ä¸Šè¨˜ä¾‹ã«ãŠã„ã¦ã€å¤‰æ•°ã®åå‰ã‚’å†åˆ©ç”¨ã™ã‚‹_å¤‰æ•°ã®ã‚·ãƒ£ãƒ‰ãƒ¼ã‚¤ãƒ³ã‚°_ã‚’åˆ©ç”¨ã—ã¦ã„ã¾ã™ã€‚
å­˜åœ¨ã™ã‚‹åŒã˜åå‰ã§æ–°ã—ã„å¤‰æ•°ã‚’å®£è¨€ã—ãŸã¨ãã€æ–°ã—ã„å¤‰æ•°ã¯å¤ã„ã‚‚ã®ã‚’<strong>éš ã—ã¾ã™</strong>ã€‚
Rustã®ã‚³ãƒ¼ãƒ‰ã§ã€ã“ã‚Œã¯ä¸€èˆ¬çš„ãªãƒ‘ã‚¿ãƒ¼ãƒ³ã§ã™ã€‚</p>
</blockquote>
<p><code>self</code>-setters work quite nicely when you need to change multiple fields at once: you can chain multiple calls together!</p>
<blockquote>
<p>ä¸€åº¦ã«è¤‡æ•°ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’å¤‰æ›´ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã¨ãã‚‚ã€<code>self</code>ã‚»ãƒƒã‚¿ãƒ¼ã¯ã¨ã¦ã‚‚è‰¯ãæ©Ÿèƒ½ã—ã¾ã™ã€‚
è¤‡æ•°ã®å‘¼ã³å‡ºã—ã‚’ä¸€ç·’ã«ç¹‹ã’ã‚Œã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let ticket = ticket
    .set_title("New title".into())
    .set_description("New description".into())
    .set_status("In Progress".into());
<span class="boring">}</span></code></pre></pre>
<h3 id="taking-mut-self-as-inputå…¥åŠ›ã¨ã—ã¦mut-selfã‚’å—ã‘å–ã‚‹"><a class="header" href="#taking-mut-self-as-inputå…¥åŠ›ã¨ã—ã¦mut-selfã‚’å—ã‘å–ã‚‹">Taking <code>&amp;mut self</code> as inputï¼ˆå…¥åŠ›ã¨ã—ã¦&amp;mut selfã‚’å—ã‘å–ã‚‹ï¼‰</a></h3>
<p>The second approach to setters, using <code>&amp;mut self</code>, looks like this instead:</p>
<blockquote>
<p><code>&amp;mut self</code>ã‚’ä½¿ç”¨ã™ã‚‹ã‚»ãƒƒã‚¿ãƒ¼ã®2ã¤ç›®ã®æ–¹æ³•ã¯ã€æ¬¡ã®ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Ticket {
    pub fn set_title(&amp;mut self, new_title: String) {
        // Validate the new title [...]
        // æ–°ã—ã„ã‚¿ã‚¤ãƒˆãƒ«ã‚’æ¤œè¨¼ã—ã¾ã™ã€‚

        self.title = new_title;
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This time the method takes a mutable reference to <code>self</code> as input, changes the title, and that's it.
Nothing is returned.</p>
<blockquote>
<p>ä»Šå›ã€ãƒ¡ã‚½ãƒƒãƒ‰ã¯å…¥åŠ›ã¨ã—ã¦<code>self</code>ã¸ã®å¯å¤‰å‚ç…§ã‚’å—ã‘å–ã‚Šã€ã‚¿ã‚¤ãƒˆãƒ«ã‚’å¤‰æ›´ã—ã¦ã€ãã‚Œã ã‘ã§ã™ã€‚
ä½•ã‚‚è¿”ã•ã‚Œã¾ã›ã‚“ã€‚</p>
</blockquote>
<p>You'd use it like this:</p>
<blockquote>
<p>æ¬¡ã®ã‚ˆã†ã«ãã‚Œã‚’ä½¿ç”¨ã—ã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut ticket = Ticket::new("Title".into(), "Description".into(), "To-Do".into());
ticket.set_title("New title".into());

// Use the modified ticket
// å¤‰æ›´ã•ã‚ŒãŸãƒã‚±ãƒƒãƒˆã‚’ä½¿ç”¨ã—ã¾ã™ã€‚
<span class="boring">}</span></code></pre></pre>
<p>Ownership stays with the caller, so the original <code>ticket</code> variable is still valid. We don't need to reassign the result.
We need to mark <code>ticket</code> as mutable though, because we're taking a mutable reference to it.</p>
<blockquote>
<p>æ‰€æœ‰æ¨©ã¯å‘¼ã³å‡ºã—å…ƒã«ç•™ã¾ã‚‹ãŸã‚ã€ã‚ªãƒªã‚¸ãƒŠãƒ«ã®<code>ticket</code>å¤‰æ•°ã¯ã¾ã æœ‰åŠ¹ã§ã™ã€‚
çµæœã‚’å†å‰²ã‚Šå½“ã¦ã™ã‚‹å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚
ã—ã‹ã—ã€ãã®å¯å¤‰å‚ç…§ã‚’å¾—ã¦ã„ã‚‹ãŸã‚ã€å¯å¤‰ã¨ã—ã¦<code>ticket</code>ã‚’ãƒãƒ¼ã‚¯ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚</p>
</blockquote>
<p><code>&amp;mut</code>-setters have a downside: you can't chain multiple calls together.
Since they don't return the modified <code>Ticket</code> instance, you can't call another setter on the result of the first one.
You have to call each setter separately:</p>
<blockquote>
<p><code>&amp;mut</code>ã‚»ãƒƒã‚¿ãƒ¼ã¯æ¬ ç‚¹ãŒã‚ã‚Šã¾ã™ã€‚è¤‡æ•°ã®å‘¼ã³å‡ºã—ã‚’ä¸€ç·’ã«ç¹‹ã’ã‚Œã¾ã›ã‚“ã€‚
å¤‰æ›´ã•ã‚ŒãŸ<code>ticket</code>ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’è¿”ã•ãªã„ãŸã‚ã€æœ€åˆã®çµæœã§ä»–ã®ã‚»ãƒƒã‚¿ãƒ¼ã‚’å‘¼ã³å‡ºã—ã§ãã¾ã›ã‚“ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>ticket.set_title("New title".into());
ticket.set_description("New description".into());
ticket.set_status("In Progress".into());
<span class="boring">}</span></code></pre></pre>
<h2 id="exercise-20"><a class="header" href="#exercise-20">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/03_ticket_v1/07_setters"><code>03_ticket_v1/07_setters</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="memory-layoutãƒ¡ãƒ¢ãƒªãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ"><a class="header" href="#memory-layoutãƒ¡ãƒ¢ãƒªãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ">Memory layoutï¼ˆãƒ¡ãƒ¢ãƒªãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆï¼‰</a></h1>
<p>We've looked at ownership and references from an operational point of viewâ€”what you can and can't do with them.
Now it's a good time to take a look under the hood: let's talk about <strong>memory</strong>.</p>
<blockquote>
<p>æ“ä½œã®è¦³ç‚¹ã‹ã‚‰ã€æ‰€æœ‰æ¨©ã¨å‚ç…§ã‚’ä½¿ç”¨ã—ã¦ä½•ãŒã§ãã¦ã€ä½•ãŒã§ããªã„ã‹ã‚’ç¢ºèªã—ã¾ã—ãŸã€‚
ç¾åœ¨ã€å†…éƒ¨ã‚’ç¢ºèªã™ã‚‹è‰¯ã„æ™‚ã§ã™ã€‚</p>
</blockquote>
<h2 id="stack-and-heapã‚¹ã‚¿ãƒƒã‚¯ã¨ãƒ’ãƒ¼ãƒ—"><a class="header" href="#stack-and-heapã‚¹ã‚¿ãƒƒã‚¯ã¨ãƒ’ãƒ¼ãƒ—">Stack and heapï¼ˆã‚¹ã‚¿ãƒƒã‚¯ã¨ãƒ’ãƒ¼ãƒ—ï¼‰</a></h2>
<p>When discussing memory, you'll often hear people talk about the <strong>stack</strong> and the <strong>heap</strong>.<br />
These are two different memory regions used by programs to store data.</p>
<blockquote>
<p>ãƒ¡ãƒ¢ãƒªã‚’è­°è«–ã™ã‚‹ã¨ãã€äººãŒ<strong>ã‚¹ã‚¿ãƒƒã‚¯</strong>ã¨<strong>ãƒ’ãƒ¼ãƒ—</strong>ã«ã¤ã„ã¦è©±ã—ã¦ã„ã‚‹ã“ã¨ã‚’ã€ã‚ˆãèãã§ã—ã‚‡ã†ã€‚
ã“ã‚Œã‚‰ã¯ã€ãƒ‡ãƒ¼ã‚¿ã‚’ä¿å­˜ã™ã‚‹ãŸã‚ã«ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã«ã‚ˆã£ã¦ä½¿ç”¨ã•ã‚Œã‚‹2ã¤ã®ç•°ãªã‚‹ãƒ¡ãƒ¢ãƒªé ˜åŸŸã§ã™ã€‚</p>
</blockquote>
<p>Let's start with the stack.</p>
<blockquote>
<p>ã‚¹ã‚¿ãƒƒã‚¯ã‹ã‚‰å§‹ã‚ã¾ã—ã‚‡ã†ã€‚</p>
</blockquote>
<h2 id="stackã‚¹ã‚¿ãƒƒã‚¯"><a class="header" href="#stackã‚¹ã‚¿ãƒƒã‚¯">Stackï¼ˆã‚¹ã‚¿ãƒƒã‚¯ï¼‰</a></h2>
<p>The <strong>stack</strong> is a <strong>LIFO</strong> (Last In, First Out) data structure.<br />
When you call a function, a new <strong>stack frame</strong> is added on top of the stack. That stack frame stores
the function's arguments, local variables and a few "bookkeeping" values.<br />
When the function returns, the stack frame is popped off the stack<sup class="footnote-reference"><a href="#stack-overflow">1</a></sup>.</p>
<blockquote>
<p><strong>ã‚¹ã‚¿ãƒƒã‚¯</strong>ã¯<strong>LIFO</strong>ï¼ˆLast In, First Out: æœ€å¾Œã«å…¥ã£ãŸã‚‰ã€æœ€åˆã«å‡ºã‚‹ï¼‰ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã§ã™ã€‚
é–¢æ•°ã‚’å‘¼ã³å‡ºã—ãŸã¨ãã€æ–°ã—ã„<strong>ã‚¹ã‚¿ãƒƒã‚¯ãƒ•ãƒ¬ãƒ¼ãƒ </strong>ãŒã‚¹ã‚¿ãƒƒã‚¯ã®æœ€ä¸Šéƒ¨ã«è¿½åŠ ã•ã‚Œã¾ã™ã€‚
ã‚¹ã‚¿ãƒƒã‚¯ãƒ•ãƒ¬ãƒ¼ãƒ ã¯é–¢æ•°ã®å¼•æ•°ã€ãƒ­ãƒ¼ã‚«ãƒ«å¤‰æ•°ã€ãã—ã¦å°‘ã—ã®ã€Œç°¿è¨˜ã™ã‚‹ãŸã‚ã€ã®å€¤ã‚’ä¿å­˜ã—ã¾ã™ã€‚
é–¢æ•°ãŒæˆ»ã£ãŸã¨ãã€ã‚¹ã‚¿ãƒƒã‚¯ãƒ•ãƒ¬ãƒ¼ãƒ ã¯ã‚¹ã‚¿ãƒƒã‚¯ã‹ã‚‰å–ã‚Šå‡ºã•ã‚Œã¾ã™ã€‚</p>
</blockquote>
<blockquote>
<p><code>bookkeeping</code>: ç°¿è¨˜ã€å¸³ç°¿ç®¡ç†ã€çµŒç†ã®æ„å‘³ã ãŒã€ã“ã®å ´åˆã€ã‚¹ã‚¿ãƒƒã‚¯ã‚’ç®¡ç†ã™ã‚‹ã“ã¨ã‚’ç¤ºã—ã¦ã„ã‚‹ã¨è€ƒãˆã‚‰ã‚Œã‚‹ã€‚
ã‚¹ã‚¿ãƒƒã‚¯ã‚’åˆ©ç”¨ã™ã‚‹ãŸã‚ã«ã¯ã€ã‚¹ã‚¿ãƒƒã‚¯ã®å…ˆé ­ã‚’æŒ‡ã™ãƒã‚¤ãƒ³ã‚¿ãŒå¿…è¦ã§ã€ãã®ãƒã‚¤ãƒ³ã‚¿ã®ä½ç½®ã‚’ç®¡ç†ã™ã‚‹ã“ã¨ãŒå¿…è¦ã«ãªã‚‹ã€‚</p>
</blockquote>
<pre><code class="language-text">                                 +-----------------+
                       func2     | frame for func2 |   func2
+-----------------+  is called   +-----------------+  returns   +-----------------+
| frame for func1 | -----------&gt; | frame for func1 | ---------&gt; | frame for func1 |
+-----------------+              +-----------------+            +-----------------+
</code></pre>
<p>From an operational point of view, stack allocation/de-allocation is <strong>very fast</strong>.<br />
We are always pushing and popping data from the top of the stack, so we don't need to search for free memory.
We also don't have to worry about fragmentation: the stack is a single contiguous block of memory.</p>
<blockquote>
<p>æ“ä½œã®è¦³ç‚¹ã‹ã‚‰ã€ã‚¹ã‚¿ãƒƒã‚¯ã®å‰²ã‚Šå½“ã¦ï¼è§£æ”¾ã¯<strong>ã¨ã¦ã‚‚æ—©ã„</strong>ã§ã™ã€‚
å¸¸ã«ã‚¹ã‚¿ãƒƒã‚¯ã®æœ€ä¸Šéƒ¨ã«ãƒ‡ãƒ¼ã‚¿ã‚’å…¥ã‚Œã¦ã€æœ€ä¸Šéƒ¨ã‹ã‚‰ãƒ‡ãƒ¼ã‚¿ã‚’å–ã‚Šå‡ºã™ãŸã‚ã€ç©ºããƒ¡ãƒ¢ãƒªã‚’æ¢ã™å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚
ã¾ãŸã€ãƒ•ãƒ©ã‚°ãƒ¡ãƒ³ãƒˆã«ã¤ã„ã¦å¿ƒé…ã™ã‚‹å¿…è¦ã‚‚ã‚ã‚Šã¾ã›ã‚“ã€‚
ã‚¹ã‚¿ãƒƒã‚¯ã¯ã€1ã¤ã®é€£ç¶šã—ãŸãƒ¡ãƒ¢ãƒªãƒ–ãƒ­ãƒƒã‚¯ã§ã™ã€‚</p>
</blockquote>
<h3 id="rust"><a class="header" href="#rust">Rust</a></h3>
<p>Rust will often allocate data on the stack.<br />
You have a <code>u32</code> input argument in a function? Those 32 bits will be on the stack.<br />
You define a local variable of type <code>i64</code>? Those 64 bits will be on the stack.<br />
It all works quite nicely because the size of those integers is known at compile time, therefore
the compiled program knows how much space it needs to reserve on the stack for them.</p>
<blockquote>
<p>Rustã¯ã€ã‚ˆãã‚¹ã‚¿ãƒƒã‚¯ã«ãƒ‡ãƒ¼ã‚¿ã‚’å‰²ã‚Šå½“ã¦ã¾ã™ã€‚
é–¢æ•°ã«<code>u32</code>ã®å…¥åŠ›å¼•æ•°ãŒã‚ã‚Šã¾ã™ã‹ï¼Ÿãã®32ãƒ“ãƒƒãƒˆã¯ã‚¹ã‚¿ãƒƒã‚¯ã«ã‚ã‚Šã¾ã™ã€‚
<code>i64</code>å‹ã®ãƒ­ãƒ¼ã‚«ãƒ«å¤‰æ•°ã‚’å®šç¾©ã—ã¦ã¾ã™ã‹ï¼Ÿãã®64ãƒ“ãƒƒãƒˆã¯ã‚¹ã‚¿ãƒƒã‚¯ã«ã‚ã‚Šã¾ã™ã€‚
ãã‚Œã‚‰æ•´æ•°ã®ã‚µã‚¤ã‚ºã¯ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã«ã‚ã‹ã‚‹ãŸã‚ã€ãã®ã™ã¹ã¦ã¯ã¨ã¦ã‚‚ç´ æ™´ã‚‰ã—ãæ©Ÿèƒ½ã—ã¾ã™ã€‚
ã‚ˆã£ã¦ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã‚ŒãŸãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯ã€ãã‚Œã‚‰ã®ãŸã‚ã«ã‚¹ã‚¿ãƒƒã‚¯ã«äºˆç´„ã™ã‚‹å¿…è¦ãŒã‚ã‚‹é ˜åŸŸã®é‡ã‚’ç†è§£ã—ã¦ã„ã¾ã™ã€‚</p>
</blockquote>
<h3 id="stdmemsize_of"><a class="header" href="#stdmemsize_of"><code>std::mem::size_of</code></a></h3>
<p>You can verify how much space a type would take on the stack
using the <a href="https://doc.rust-lang.org/std/mem/fn.size_of.html"><code>std::mem::size_of</code></a> function.</p>
<blockquote>
<p>å‹ãŒã‚¹ã‚¿ãƒƒã‚¯ã«ã©ã‚Œã ã‘å¤šãã®é ˜åŸŸã‚’å–å¾—ã™ã‚‹ã‹ã€<code>std::mem::size_of</code>é–¢æ•°ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã§æ¤œè¨¼ã§ãã¾ã™ã€‚</p>
</blockquote>
<p>For a <code>u8</code>, for example:</p>
<blockquote>
<p>ä¾‹ãˆã°<code>u8</code>ã§ã¯ãƒ»ãƒ»ãƒ»</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// We'll explain this funny-looking syntax (`::&lt;u8&gt;`) later on.
// Ignore it for now.
// å¾Œã§ã€ã“ã®é¢ç™½ãè¦‹ãˆã‚‹æ§‹æ–‡ï¼ˆ`::&lt;u8&gt;`ï¼‰ã‚’èª¬æ˜ã—ã¾ã™ã€‚
// ç¾æ™‚ç‚¹ã§ã¯ç„¡è¦–ã—ã¦ãã ã•ã„ã€‚
assert_eq!(std::mem::size_of::&lt;u8&gt;(), 1);
<span class="boring">}</span></code></pre></pre>
<p>1 makes sense, because a <code>u8</code> is 8 bits long, or 1 byte.</p>
<blockquote>
<p><code>u8</code>ã¯8ãƒ“ãƒƒãƒˆé•·ã¾ãŸã¯1ãƒã‚¤ãƒˆã§ã‚ã‚‹ãŸã‚ã€1ã¯ç†ã«ã‹ãªã£ã¦ã„ã¾ã™ã€‚</p>
</blockquote>
<div class="footnote-definition" id="stack-overflow"><sup class="footnote-definition-label">1</sup>
<p>If you have nested function calls, each function pushes its data onto the stack when it's called but
it doesn't pop it off until the innermost function returns.
If you have too many nested function calls, you can run out of stack spaceâ€”the stack is not infinite!
That's called a <a href="https://en.wikipedia.org/wiki/Stack_overflow"><strong>stack overflow</strong></a>.
ãƒã‚¹ãƒˆã•ã‚ŒãŸé–¢æ•°å‘¼ã³å‡ºã—ãŒã‚ã‚‹å ´åˆã€é–¢æ•°ãŒå‘¼ã³å‡ºã•ã‚ŒãŸã¨ãã€ãã‚Œãã‚Œã®é–¢æ•°ã¯ã‚¹ã‚¿ãƒƒã‚¯ã«é–¢æ•°ã®ãƒ‡ãƒ¼ã‚¿ã‚’ãƒ—ãƒƒã‚·ãƒ¥ã—ã¾ã™ãŒã€æœ€ã‚‚å†…å´ã«ã‚ã‚‹é–¢æ•°ãŒæˆ»ã‚‹ã¾ã§ã€ãã®ãƒ‡ãƒ¼ã‚¿ã¯å–ã‚Šå‡ºã•ã‚Œã¾ã›ã‚“ã€‚
éå¸¸ã«å¤šããƒã‚¹ãƒˆã—ãŸé–¢æ•°å‘¼ã³å‡ºã—ãŒã‚ã‚‹å ´åˆã€ã‚¹ã‚¿ãƒƒã‚¯é ˜åŸŸã‚’ä½¿ã„æœãŸã™ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚ã‚¹ã‚¿ãƒƒã‚¯ã¯ç„¡é™ã§ã‚ã‚Šã¾ã›ã‚“ã€‚
ã“ã‚Œã¯<strong>ã‚¹ã‚¿ãƒƒã‚¯ãƒ»ã‚ªãƒ¼ãƒãƒ¼ãƒ•ãƒ­ãƒ¼</strong>ã¨å‘¼ã°ã‚Œã¾ã™ã€‚</p>
</div>
<h2 id="exercise-21"><a class="header" href="#exercise-21">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/03_ticket_v1/08_stack"><code>03_ticket_v1/08_stack</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="heapãƒ’ãƒ¼ãƒ—"><a class="header" href="#heapãƒ’ãƒ¼ãƒ—">Heapï¼ˆãƒ’ãƒ¼ãƒ—ï¼‰</a></h1>
<p>The stack is great, but it can't solve all our problems. What about data whose size is not known at compile time?
Collections, strings, and other dynamically-sized data cannot be (entirely) stack-allocated.
That's where the <strong>heap</strong> comes in.</p>
<blockquote>
<p>ã‚¹ã‚¿ãƒƒã‚¯ã¯å‰å¤§ã§ã™ãŒã€ã‚¹ã‚¿ãƒƒã‚¯ã¯ã™ã¹ã¦ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’è§£æ±ºã™ã‚‹ã“ã¨ãŒã§ãã¾ã›ã‚“ã€‚
ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã«ãƒ‡ãƒ¼ã‚¿ã®ã‚µã‚¤ã‚ºãŒã‚ã‹ã‚‰ãªã„å ´åˆã€ä½•ãŒç™ºç”Ÿã—ã¾ã™ã‹ï¼Ÿ
ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã€æ–‡å­—åˆ—ã€ãã—ã¦ä»–ã®å‹•çš„ãªã‚µã‚¤ã‚ºã‚’æŒã¤ãƒ‡ãƒ¼ã‚¿ã¯ã€ã¾ã£ãŸãã‚¹ã‚¿ãƒƒã‚¯ã«å‰²ã‚Šå½“ã¦ã‚‰ã‚Œã¾ã›ã‚“ã€‚
ã“ã“ã§ã€<strong>ãƒ’ãƒ¼ãƒ—</strong>ãŒç™»å ´ã—ã¾ã™ã€‚</p>
</blockquote>
<h2 id="heap-allocationsãƒ’ãƒ¼ãƒ—å‰²ã‚Šå½“ã¦"><a class="header" href="#heap-allocationsãƒ’ãƒ¼ãƒ—å‰²ã‚Šå½“ã¦">Heap allocationsï¼ˆãƒ’ãƒ¼ãƒ—å‰²ã‚Šå½“ã¦ï¼‰</a></h2>
<p>You can visualize the heap as a big chunk of memoryâ€”a huge array, if you will.<br />
Whenever you need to store data on the heap, you ask a special program, the <strong>allocator</strong>, to reserve for you
a subset of the heap. We call this interaction (and the memory you reserved) a <strong>heap allocation</strong>.
If the allocation succeeds, the allocator will give you a <strong>pointer</strong> to the start of the reserved block.</p>
<blockquote>
<p>å¤§ããªãƒ¡ãƒ¢ãƒªã®å¡Šã€å·¨å¤§ãªé…åˆ—ã¨ã—ã¦ãƒ’ãƒ¼ãƒ—ã‚’å¯è¦–åŒ–ã§ãã¾ã™ã€‚
ãƒ’ãƒ¼ãƒ—ã«ãƒ‡ãƒ¼ã‚¿ã‚’ä¿å­˜ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã¨ãã¯ã„ã¤ã§ã‚‚ã€ãƒ’ãƒ¼ãƒ—ã®éƒ¨åˆ†é›†åˆã‚’äºˆç´„ã™ã‚‹ãŸã‚ã«<strong>ã‚¢ãƒ­ã‚±ãƒ¼ã‚¿ãƒ¼</strong>ã¨ã„ã†ç‰¹åˆ¥ãªãƒ—ãƒ­ã‚°ãƒ©ãƒ ã«ä¾é ¼ã—ã¾ã™ã€‚
å‰²ã‚Šå½“ã¦ãŒæˆåŠŸã—ãŸå ´åˆã€ã‚¢ãƒ­ã‚±ãƒ¼ã‚¿ãƒ¼ã¯äºˆç´„ã•ã‚ŒãŸãƒ–ãƒ­ãƒƒã‚¯ã®é–‹å§‹ã‚’æŒ‡ã™<strong>ãƒã‚¤ãƒ³ã‚¿ãƒ¼</strong>ã‚’ä¸ãˆã¾ã™ã€‚</p>
</blockquote>
<h2 id="no-automatic-de-allocationè‡ªå‹•è§£æ”¾ãªã—"><a class="header" href="#no-automatic-de-allocationè‡ªå‹•è§£æ”¾ãªã—">No automatic de-allocationï¼ˆè‡ªå‹•è§£æ”¾ãªã—ï¼‰</a></h2>
<p>The heap is structured quite differently from the stack.<br />
Heap allocations are not contiguous, they can be located anywhere inside the heap.</p>
<blockquote>
<p>ãƒ’ãƒ¼ãƒ—ã¯ã‚¹ã‚¿ãƒƒã‚¯ã¨ã¾ã£ãŸãç•°ãªã‚‹æ§‹é€ ã«ãªã£ã¦ã„ã¾ã™ã€‚
ãƒ’ãƒ¼ãƒ—å‰²ã‚Šå½“ã¦ã¯é€£ç¶šçš„ã§ã¯ãªãã€ãã‚Œã‚‰ã¯ãƒ’ãƒ¼ãƒ—å†…ã®ã©ã“ã§ã‚‚é…ç½®ã•ã‚Œã¾ã™ã€‚</p>
</blockquote>
<pre><code class="language-text">+---+---+---+---+---+---+-...-+-...-+---+---+---+---+---+---+---+
|  Allocation 1 | Free  | ... | ... |  Allocation N |    Free   |
+---+---+---+---+---+---+ ... + ... +---+---+---+---+---+---+---+
</code></pre>
<p>It's the allocator's job to keep track of which parts of the heap are in use and which are free.
The allocator won't automatically free the memory you allocated, though: you need to be deliberate about it,
calling the allocator again to <strong>free</strong> the memory you no longer need.</p>
<blockquote>
<p>ãƒ’ãƒ¼ãƒ—ã®ã©ã®éƒ¨åˆ†ãŒä½¿ç”¨ä¸­ã§ã€ã©ã“ãŒç©ºã„ã¦ã„ã‚‹ã®ã‹ã‚’è¿½è·¡ã™ã‚‹ã“ã¨ã¯ã€ã‚¢ãƒ­ã‚±ãƒ¼ã‚¿ãƒ¼ã®ä»•äº‹ã§ã™ã€‚
ã‚¢ãƒ­ã‚±ãƒ¼ã‚¿ãƒ¼ã¯ã€å‰²ã‚Šå½“ã¦ã‚‰ã‚ŒãŸãƒ¡ãƒ¢ãƒªã‚’è‡ªå‹•çš„ã«è§£æ”¾ã—ã¾ã›ã‚“ãŒã€å†åº¦ã‚¢ãƒ­ã‚±ãƒ¼ã‚¿ãƒ¼ã‚’å‘¼ã³å‡ºã—ã¦ã€ã‚‚ã¯ã‚„å¿…è¦ã®ãªã„ãƒ¡ãƒ¢ãƒªã‚’<strong>é–‹æ”¾</strong>ã™ã‚‹ã“ã¨ã‚’ã€æ„å›³çš„ã«ã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚</p>
</blockquote>
<h2 id="performanceæ€§èƒ½"><a class="header" href="#performanceæ€§èƒ½">Performanceï¼ˆæ€§èƒ½ï¼‰</a></h2>
<p>The heap's flexibility comes at a cost: heap allocations are <strong>slower</strong> than stack allocations.
There's a lot more bookkeeping involved!<br />
If you read articles about performance optimization you'll often be advised to minimize heap allocations
and prefer stack-allocated data whenever possible.</p>
<blockquote>
<p>ãƒ’ãƒ¼ãƒ—ã®æŸ”è»Ÿæ€§ã¯ã‚³ã‚¹ãƒˆãŒæ›ã‹ã‚Šã¾ã™ã€‚ãƒ’ãƒ¼ãƒ—å‰²ã‚Šå½“ã¦ã¯ã‚¹ã‚¿ãƒƒã‚¯å‰²ã‚Šå½“ã¦ã‚ˆã‚Šã‚‚<strong>é…ã„</strong>ã§ã™ã€‚
ã“ã‚Œã‚‰ã¯ã€å¤šãã®ãƒ–ãƒƒã‚¯ã‚­ãƒ¼ãƒ”ãƒ³ã‚°ãŒé–¢ä¿‚ã—ã¦ã„ã¾ã™ã€‚
ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–ã®è¨˜äº‹ã‚’èª­ã‚“ã å ´åˆã€ã¨ãã©ããƒ’ãƒ¼ãƒ—å‰²ã‚Šå½“ã¦ã‚’æœ€å°ã«ã—ã¦ã€å¯èƒ½ãªã¨ãã¯ã„ã¤ã§ã‚‚ã‚¹ã‚¿ãƒƒã‚¯å‰²ã‚Šå½“ã¦ã‚’é¸ã¶ã‚ˆã†ã«å‹§ã‚ã‚‰ã‚Œã¾ã™ã€‚</p>
</blockquote>
<h2 id="strings-memory-layoutstringã®ãƒ¡ãƒ¢ãƒªãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ"><a class="header" href="#strings-memory-layoutstringã®ãƒ¡ãƒ¢ãƒªãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ"><code>String</code>'s memory layoutï¼ˆStringã®ãƒ¡ãƒ¢ãƒªãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆï¼‰</a></h2>
<p>When you create a local variable of type <code>String</code>,
Rust is forced to allocate on the heap<sup class="footnote-reference"><a href="#empty">1</a></sup>: it doesn't know in advance how much text you're going to put in it,
so it can't reserve the right amount of space on the stack.<br />
But a <code>String</code> is not <em>entirely</em> heap-allocated, it also keeps some data on the stack. In particular:</p>
<ul>
<li>The <strong>pointer</strong> to the heap region you reserved.</li>
<li>The <strong>length</strong> of the string, i.e. how many bytes are in the string.</li>
<li>The <strong>capacity</strong> of the string, i.e. how many bytes have been reserved on the heap.</li>
</ul>
<blockquote>
<p><code>String</code>å‹ã®ãƒ­ãƒ¼ã‚«ãƒ«å¤‰æ•°ã‚’ä½œæˆã—ãŸã¨ãã€Rustã¯ãƒ’ãƒ¼ãƒ—ã®å‰²ã‚Šå½“ã¦ã‚’å¼·åˆ¶ã•ã‚Œã¾ã™ã€‚
å¤‰æ•°ã«ã©ã‚Œã ã‘ã®ãƒ†ã‚­ã‚¹ãƒˆã‚’ã„ã‚Œã‚‹ã‹äº‹å‰ã«çŸ¥ã‚‹ã“ã¨ã¯ã§ããªã„ãŸã‚ã€ãã‚Œã¯ã‚¹ã‚¿ãƒƒã‚¯ã«æ­£ã—ã„é‡ã®é ˜åŸŸã‚’äºˆç´„ã™ã‚‹ã“ã¨ãŒã§ãã¾ã›ã‚“ã€‚
ã—ã‹ã—ã€<code>String</code>ã¯_å®Œå…¨ã«_ãƒ’ãƒ¼ãƒ—å‰²ã‚Šå½“ã¦ã§ã¯ãªãã€ã‚¹ã‚¿ãƒƒã‚¯ã«ã‚‚ã„ãã¤ã‹ãƒ‡ãƒ¼ã‚¿ã‚’ä¿æŒã—ã¦ã„ã¾ã™ã€‚ç‰¹ã«ãƒ»ãƒ»ãƒ»</p>
<ul>
<li>äºˆç´„ã—ãŸãƒ’ãƒ¼ãƒ—é ˜åŸŸã¸ã®<strong>ãƒã‚¤ãƒ³ã‚¿ãƒ¼</strong></li>
<li>æ–‡å­—åˆ—ã®<strong>é•·ã•</strong>ã€ã¤ã¾ã‚Šæ–‡å­—åˆ—ã«ã‚ã‚‹ãƒã‚¤ãƒˆæ•°</li>
<li>æ–‡å­—åˆ—ã®<strong>å®¹é‡</strong>ã€ã¤ã¾ã‚Šãƒ’ãƒ¼ãƒ—ã«äºˆç´„ã•ã‚Œã¦ã„ã‚‹ãƒã‚¤ãƒˆæ•°</li>
</ul>
</blockquote>
<p>Let's look at an example to understand this better:</p>
<blockquote>
<p>ã“ã‚Œã‚’ã‚ˆãç†è§£ã™ã‚‹ãŸã‚ã«ã€ä¾‹ã‚’ç¢ºèªã—ã¾ã—ã‚‡ã†ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut s = String::with_capacity(5);
<span class="boring">}</span></code></pre></pre>
<p>If you run this code, memory will be laid out like this:</p>
<blockquote>
<p>ã“ã®ã‚³ãƒ¼ãƒ‰ã‚’å®Ÿè¡Œã—ãŸå ´åˆã€ãƒ¡ãƒ¢ãƒªã¯æ¬¡ã®ã‚ˆã†ã«é…ç½®ã•ã‚Œã¾ã™ã€‚</p>
</blockquote>
<pre><code class="language-text">      +---------+--------+----------+
Stack | pointer | length | capacity |
      |  |      |   0    |    5     |
      +--|------+--------+----------+
         |
         |
         v
       +---+---+---+---+---+
Heap:  | ? | ? | ? | ? | ? |
       +---+---+---+---+---+
</code></pre>
<p>We asked for a <code>String</code> that can hold up to 5 bytes of text.<br />
<code>String::with_capacity</code> goes to the allocator and asks for 5 bytes of heap memory. The allocator returns
a pointer to the start of that memory block.<br />
The <code>String</code> is empty, though. On the stack, we keep track of this information by distinguishing between
the length and the capacity: this <code>String</code> can hold up to 5 bytes, but it currently holds 0 bytes of
actual text.</p>
<blockquote>
<p>5ãƒã‚¤ãƒˆã®ãƒ†ã‚­ã‚¹ãƒˆã‚’ä¿æŒã§ãã‚‹<code>String</code>ã‚’è¦æ±‚ã—ã¾ã—ãŸã€‚
<code>String::with_capacity</code>ã¯ã‚¢ãƒ­ã‚±ãƒ¼ã‚¿ãƒ¼ã«å¯¾ã—ã¦ã€ãƒ’ãƒ¼ãƒ—ãƒ¡ãƒ¢ãƒªã®ï¼•ãƒã‚¤ãƒˆã‚’è¦æ±‚ã—ã¾ã™ã€‚
ã‚¢ãƒ­ã‚±ãƒ¼ã‚¿ãƒ¼ã¯ã€ãã®ãƒ¡ãƒ¢ãƒªãƒ–ãƒ­ãƒƒã‚¯ã®é–‹å§‹ã‚’æŒ‡ã™ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã‚’è¿”ã—ã¾ã™ã€‚
ã—ã‹ã—ã€<code>String</code>ã¯ç©ºã§ã™ã€‚
ã‚¹ã‚¿ãƒƒã‚¯ã§é•·ã•ã¨å®¹é‡ã‚’åŒºåˆ¥ã™ã‚‹ã“ã¨ã§ã“ã®æƒ…å ±ã‚’è¿½è·¡ã—ã¾ã™ã€‚
ã“ã®<code>String</code>ã¯5ãƒã‚¤ãƒˆã¾ã§ä¿æŒã§ãã¾ã™ãŒã€ç¾åœ¨ã€å®Ÿéš›ã®ãƒ†ã‚­ã‚¹ãƒˆã®0ãƒã‚¤ãƒˆã‚’ä¿æŒã—ã¾ã™ã€‚</p>
</blockquote>
<p>If you push some text into the <code>String</code>, the situation will change:</p>
<blockquote>
<p><code>String</code>ã«ä»»æ„ã®ãƒ†ã‚­ã‚¹ãƒˆã‚’å…¥ã‚ŒãŸã¨ãã€çŠ¶æ³ã¯å¤‰ã‚ã‚Šã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>s.push_str("Hey");
<span class="boring">}</span></code></pre></pre>
<pre><code class="language-text">      +---------+--------+----------+
Stack | pointer | length | capacity |
      |  |      |   3    |    5     |
      +--|  ----+--------+----------+
         |
         |
         v
       +---+---+---+---+---+
Heap:  | H | e | y | ? | ? |
       +---+---+---+---+---+
</code></pre>
<p><code>s</code> now holds 3 bytes of text. Its length is updated to 3, but capacity remains 5.
Three of the five bytes on the heap are used to store the characters <code>H</code>, <code>e</code>, and <code>y</code>.</p>
<blockquote>
<p>ç¾åœ¨ã€<code>s</code>ã¯3ãƒã‚¤ãƒˆã®ãƒ†ã‚­ã‚¹ãƒˆã‚’ä¿æŒã—ã¦ã„ã¾ã™ã€‚
ãã®é•·ã•ã¯3ã«æ›´æ–°ã•ã‚Œã¾ã™ãŒã€å®¹é‡ã¯5ã®ã¾ã¾ã§ã™ã€‚
ãƒ’ãƒ¼ãƒ—ä¸Šã®5ãƒã‚¤ãƒˆã®3ãƒã‚¤ãƒˆã¯ã€æ–‡å­—<code>H</code>ã€<code>e</code>ã€<code>y</code>ã‚’ä¿å­˜ã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚</p>
</blockquote>
<h3 id="usize"><a class="header" href="#usize"><code>usize</code></a></h3>
<p>How much space do we need to store pointer, length and capacity on the stack?<br />
It depends on the <strong>architecture</strong> of the machine you're running on.</p>
<blockquote>
<p>ã‚¹ã‚¿ãƒƒã‚¯ã«ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã€é•·ã•ãã—ã¦å®¹é‡ã‚’ä¿å­˜ã™ã‚‹ãŸã‚ã«å¿…è¦ãªé ˜åŸŸã¯ã©ã‚Œãã‚‰ã„ã§ã—ã‚‡ã†ã‹ï¼Ÿ
ãã‚Œã¯ã€å®Ÿè¡Œã—ã¦ã„ã‚‹ãƒã‚·ãƒ³ã®<strong>ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£</strong>ã«ä¾å­˜ã—ã¾ã™ã€‚</p>
</blockquote>
<p>Every memory location on your machine has an <a href="https://en.wikipedia.org/wiki/Memory_address"><strong>address</strong></a>, commonly
represented as an unsigned integer.
Depending on the maximum size of the address space (i.e. how much memory your machine can address),
this integer can have a different size. Most modern machines use either a 32-bit or a 64-bit address space.</p>
<blockquote>
<p>ãƒã‚·ãƒ³ä¸Šã®ãã‚Œãã‚Œã®ãƒ¡ãƒ¢ãƒªä½ç½®ã¯<strong>ã‚¢ãƒ‰ãƒ¬ã‚¹</strong>ã§ã€ä¸€èˆ¬çš„ã«ç¬¦å·ãªã—æ•´æ•°ã§è¡¨ç¾ã•ã‚Œã¾ã™ã€‚
ã‚¢ãƒ‰ãƒ¬ã‚¹ç©ºé–“ã®æœ€å¤§ã‚µã‚¤ã‚ºã«ä¾å­˜ã—ã¦ï¼ˆã¤ã¾ã‚Šã€ãƒã‚·ãƒ³ãŒå‡¦ç†ã§ãã‚‹ãƒ¡ãƒ¢ãƒªã®é‡ï¼‰ã€ã“ã®æ•´æ•°ã¯ã•ã¾ã–ã¾ãªã‚µã‚¤ã‚ºã«ãªã‚Šã¾ã™ã€‚
æœ€ã‚‚ç¾ä»£çš„ãªãƒã‚·ãƒ³ã¯ã€32ãƒ“ãƒƒãƒˆã¾ãŸã¯64ãƒ“ãƒƒãƒˆã®ã‚¢ãƒ‰ãƒ¬ã‚¹ç©ºé–“ã®ã©ã¡ã‚‰ã‹ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚</p>
</blockquote>
<p>Rust abstracts away these architecture-specific details by providing the <code>usize</code> type:
an unsigned integer that's as big as the number of bytes needed to address memory on your machine.
On a 32-bit machine, <code>usize</code> is equivalent to <code>u32</code>. On a 64-bit machine, it matches <code>u64</code>.</p>
<blockquote>
<p>Rustã¯ã€<code>usize</code>å‹ã‚’æä¾›ã™ã‚‹ã“ã¨ã§ã€ã“ã‚Œã‚‰ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ç‰¹æœ‰ã®è©³ç´°ã‚’æŠ½è±¡åŒ–ã—ã¾ã™ã€‚
<code>usize</code>ã¯ã€ãƒã‚·ãƒ³ä¸Šã®ãƒ¡ãƒ¢ãƒªã‚’æŒ‡ã—ç¤ºã™ãŸã‚ã«å¿…è¦ãªã»ã©å¤§ããªãƒã‚¤ãƒˆæ•°ã‚’ã‚‚ã¤ç¬¦å·ãªã—æ•´æ•°ã§ã™ã€‚
32ãƒ“ãƒƒãƒˆãƒã‚·ãƒ³ã§<code>usize</code>ã¯<code>u32</code>ã¨åŒç­‰ã§ã™ã€‚64ãƒ“ãƒƒãƒˆãƒã‚·ãƒ³ã§ãã‚Œã¯<code>u64</code>ã¨ä¸€è‡´ã—ã¾ã™ã€‚</p>
</blockquote>
<p>Capacity, length and pointers are all represented as <code>usize</code>s in Rust<sup class="footnote-reference"><a href="#equivalence">2</a></sup>.</p>
<blockquote>
<p>Rustã«ãŠã„ã¦ã€å®¹é‡ã€é•·ã•ãã—ã¦ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã¯ã€ã™ã¹ã¦ã®<code>usize</code>ã¨ã—ã¦è¡¨ç¾ã•ã‚Œã¾ã™ã€‚</p>
</blockquote>
<h3 id="no-stdmemsize_of-for-the-heapãƒ’ãƒ¼ãƒ—ç”¨ã®stdmemsize_ofã¯ãªã„"><a class="header" href="#no-stdmemsize_of-for-the-heapãƒ’ãƒ¼ãƒ—ç”¨ã®stdmemsize_ofã¯ãªã„">No <code>std::mem::size_of</code> for the heapï¼ˆãƒ’ãƒ¼ãƒ—ç”¨ã®std::mem::size_ofã¯ãªã„ï¼‰</a></h3>
<p><code>std::mem::size_of</code> returns the amount of space a type would take on the stack,
which is also known as the <strong>size of the type</strong>.</p>
<blockquote>
<p><code>std::mem::size_of</code>ã¯å‹ãŒã‚¹ã‚¿ãƒƒã‚¯ã«ç²å¾—ã™ã‚‹é ˜åŸŸã®é‡ã‚’è¿”ã—ã€ãã‚Œã¯<strong>å‹ã®ã‚µã‚¤ã‚º</strong>ã¨ã—ã¦ã‚‚çŸ¥ã‚‰ã‚Œã¦ã„ã¾ã™ã€‚</p>
</blockquote>
<blockquote>
<p>What about the memory buffer that <code>String</code> is managing on the heap? Isn't that
part of the size of <code>String</code>?</p>
</blockquote>
<blockquote>
<p><code>String</code>ãŒãƒ’ãƒ¼ãƒ—ä¸Šã§ç®¡ç†ã•ã‚Œã‚‹ãƒ¡ãƒ¢ãƒªãƒãƒƒãƒ•ã‚¡ã¯ã©ã†ã§ã—ã‚‡ã†ã‹ï¼Ÿ
ãã‚Œã¯ã€<code>String</code>ã®ã‚µã‚¤ã‚ºã®ä¸€éƒ¨ã§ã¯ãªã„ã§ã™ã‹ï¼Ÿ</p>
</blockquote>
<p>No!<br />
That heap allocation is a <strong>resource</strong> that <code>String</code> is managing.
It's not considered to be part of the <code>String</code> type by the compiler.</p>
<blockquote>
<p>ã„ã„ãˆï¼
ãƒ’ãƒ¼ãƒ—å‰²ã‚Šå½“ã¦ã¯ã€<code>String</code>ãŒç®¡ç†ã—ã¦ã„ã‚‹<strong>ãƒªã‚½ãƒ¼ã‚¹</strong>ã§ã™ã€‚
ãã‚Œã¯ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ¼ã«ã‚ˆã£ã¦<code>String</code>å‹ã®ä¸€éƒ¨ã¨ã—ã¦è€ƒãˆã‚‰ã‚Œã¦ã„ã¾ã›ã‚“ã€‚</p>
</blockquote>
<p><code>std::mem::size_of</code> doesn't know (or care) about additional heap-allocated data
that a type might manage or refer to via pointers, as is the case with <code>String</code>,
therefore it doesn't track its size.</p>
<blockquote>
<p><code>std::mem::size_of</code>ã¯ã€ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã‚’ä»‹ã—ã¦å‹ãŒç®¡ç†ã¾ãŸã¯å‚ç…§ã™ã‚‹ãƒ’ãƒ¼ãƒ—ã«å‰²ã‚Šå½“ã¦ã‚‰ã‚ŒãŸè¿½åŠ ãƒ‡ãƒ¼ã‚¿ã‚’çŸ¥ã‚‰ãªã„ã—ã€æ°—ã«ã—ã¦ã„ã¾ã›ã‚“ã€‚
ã‚ˆã£ã¦ã€<code>std::mem::size_of</code>ã¯ãã®ã‚µã‚¤ã‚ºã‚’è¿½è·¡ã—ã¾ã›ã‚“ã€‚</p>
</blockquote>
<p>Unfortunately there is no equivalent of <code>std::mem::size_of</code> to measure the amount of
heap memory that a certain value is allocating at runtime. Some types might
provide methods to inspect their heap usage (e.g. <code>String</code>'s <code>capacity</code> method),
but there is no general-purpose "API" to retrieve runtime heap usage in Rust.<br />
You can, however, use a memory profiler tool (e.g. <a href="https://valgrind.org/docs/manual/dh-manual.html">DHAT</a>
or <a href="https://docs.rs/dhat/latest/dhat/">a custom allocator</a>) to inspect the heap usage of your program.</p>
<blockquote>
<p>ä¸é‹ã«ã‚‚ã€ãƒ©ãƒ³ã‚¿ã‚¤ãƒ ã§ã‚ã‚‹å€¤ãŒå‰²ã‚Šå½“ã¦ã‚‰ã‚ŒãŸãƒ’ãƒ¼ãƒ—ãƒ¡ãƒ¢ãƒªã®é‡ã‚’è¨ˆæ¸¬ã™ã‚‹<code>std::mem::size_of</code>ã¨åŒç­‰ãªã‚‚ã®ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚
ã‚ã‚‹å‹ã¯ã€ãã‚Œã‚‰ã®ãƒ’ãƒ¼ãƒ—ä½¿ç”¨ã‚’èª¿æŸ»ã™ã‚‹ãŸã‚ã®ãƒ¡ã‚½ãƒƒãƒ‰ï¼ˆä¾‹ãˆã°ã€<code>String</code>ã®<code>capacity</code>ãƒ¡ã‚½ãƒƒãƒ‰ï¼‰ã‚’æä¾›ã—ã¦ã„ã¾ã™ãŒã€Rustã§ã¯ãƒ©ã‚¤ãƒ³ã‚¿ã‚¤ãƒ ã§ãƒ’ãƒ¼ãƒ—ä½¿ç”¨ã‚’å–å¾—ã™ã‚‹ä¸€èˆ¬çš„ãªç›®çš„ã®ã€ŒAPIã€ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚
ã—ã‹ã—ã€ãƒ¡ãƒ¢ãƒªãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ©ãƒ¼ãƒ„ãƒ¼ãƒ«ã‚’ä½¿ç”¨ã™ã‚‹ã‹ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®ãƒ’ãƒ¼ãƒ—ä½¿ç”¨ã‚’èª¿æŸ»ã™ã‚‹ã€ä¾‹ãˆã°<code>DHAT</code>ã¾ãŸã¯ã‚«ã‚¹ã‚¿ãƒ ã‚¢ãƒ­ã‚±ãƒ¼ã‚¿ãƒ¼ã‚’ä½¿ç”¨ã§ãã¾ã™ã€‚</p>
</blockquote>
<div class="footnote-definition" id="empty"><sup class="footnote-definition-label">1</sup>
<p><code>std</code> doesn't allocate if you create an <strong>empty</strong> <code>String</code> (i.e. <code>String::new()</code>).
Heap memory will be reserved when you push data into it for the first time.
ä¾‹ãˆã°<code>String::new()</code>ãªã©ã§<strong>ç©º</strong>ã®<code>String</code>ã‚’ä½œæˆã—ãŸå ´åˆã€<code>std</code>ã¯å‰²ã‚Šå½“ã¦ã—ã¾ã›ã‚“ã€‚
æœ€åˆã«ãƒ’ãƒ¼ãƒ—ã«ãƒ‡ãƒ¼ã‚¿ã‚’å…¥ã‚ŒãŸã¨ãã€ãƒ’ãƒ¼ãƒ—ãƒ¡ãƒ¢ãƒªã¯äºˆç´„ã•ã‚Œã¾ã™ã€‚</p>
</div>
<div class="footnote-definition" id="equivalence"><sup class="footnote-definition-label">2</sup>
<p>The size of a pointer depends on the operating system too.
In certain environments, a pointer is <strong>larger</strong> than a memory address (e.g. <a href="https://blog.acolyer.org/2019/05/28/cheri-abi/">CHERI</a>).
Rust makes the simplifying assumption that pointers are the same size as memory addresses,
which is true for most modern systems you're likely to encounter.
ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã®ã‚µã‚¤ã‚ºã¯ã‚ªãƒšãƒ¬ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ ã«ã‚‚ä¾å­˜ã—ã¾ã™ã€‚
ç‰¹å®šã®ç’°å¢ƒã§ã¯ã€ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã¯ãƒ¡ãƒ¢ãƒªã‚¢ãƒ‰ãƒ¬ã‚¹ã‚ˆã‚Šã‚‚<strong>å¤§ãã</strong>ãªã‚Šã¾ã™ï¼ˆä¾‹ãˆã°<code>CHERI</code>ï¼‰ã€‚
Rustã¯ã€ãƒ¡ãƒ¢ãƒªã‚¢ãƒ‰ãƒ¬ã‚¹ã¨åŒã˜ã‚µã‚¤ã‚ºã§ã‚ã‚‹ã¨ã„ã†å˜ç´”åŒ–ã•ã‚ŒãŸä»®å®šã‚’ã—ã¦ã€ãã‚Œã¯é­é‡ã™ã‚‹å¯èƒ½æ€§ã®ã‚ã‚‹æœ€ã‚‚ç¾ä»£çš„ãªã‚·ã‚¹ãƒ†ãƒ ã§å½“ã¦ã¯ã¾ã‚Šã¾ã™ã€‚</p>
</div>
<h2 id="exercise-22"><a class="header" href="#exercise-22">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/03_ticket_v1/09_heap"><code>03_ticket_v1/09_heap</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="referenceså‚ç…§"><a class="header" href="#referenceså‚ç…§">Referencesï¼ˆå‚ç…§ï¼‰</a></h1>
<p>What about references, like <code>&amp;String</code> or <code>&amp;mut String</code>? How are they represented in memory?</p>
<blockquote>
<p><code>&amp;String</code>ã¾ãŸã¯<code>&amp;mut String</code>ã®ã‚ˆã†ãªå‚ç…§ã«ã¤ã„ã¦ã¯ã©ã†ã§ã—ã‚‡ã†ã‹ï¼Ÿ
ãã‚Œã‚‰ã¯ãƒ¡ãƒ¢ãƒªå†…ã§ã©ã®ã‚ˆã†ã«è¡¨ç¾ã•ã‚Œã¦ã„ã‚‹ã®ã§ã—ã‚‡ã†ã‹ï¼Ÿ</p>
</blockquote>
<p>Most references<sup class="footnote-reference"><a href="#fat">1</a></sup> in Rust are represented, in memory, as a pointer to a memory location.<br />
It follows that their size is the same as the size of a pointer, a <code>usize</code>.</p>
<blockquote>
<p>Rustã«ãŠã‘ã‚‹ã»ã¨ã‚“ã©ã®å‚ç…§ã¯ã€ãƒ¡ãƒ¢ãƒªå†…ã§ãƒ¡ãƒ¢ãƒªä½ç½®ã‚’æŒ‡ã—ç¤ºã™ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã¨ã—ã¦è¡¨ç¾ã•ã‚Œã¦ã„ã¾ã™ã€‚
ãã‚Œã¯ã€ãã‚Œã‚‰ã®ã‚µã‚¤ã‚ºãŒãƒã‚¤ãƒ³ã‚¿ãƒ¼ã®ã‚µã‚¤ã‚ºã¨åŒã˜ã§<code>usize</code>ã«ãªã‚Šã¾ã™ã€‚</p>
</blockquote>
<p>You can verify this using <code>std::mem::size_of</code>:</p>
<blockquote>
<p>ã“ã‚Œã‚’<code>std::mem::size_of</code>ã‚’ä½¿ç”¨ã—ã¦æ¤œè¨¼ã§ãã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>assert_eq!(std::mem::size_of::&lt;&amp;String&gt;(), 8);
assert_eq!(std::mem::size_of::&lt;&amp;mut String&gt;(), 8);
<span class="boring">}</span></code></pre></pre>
<p>A <code>&amp;String</code>, in particular, is a pointer to the memory location where the <code>String</code>'s metadata is stored.<br />
If you run this snippet:</p>
<blockquote>
<p>ç‰¹ã«ã€<code>&amp;String</code>ã¯ã€<code>String</code>ã®ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ãŒä¿å­˜ã•ã‚ŒãŸãƒ¡ãƒ¢ãƒªä½ç½®ã‚’æŒ‡ã—ç¤ºã™ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã§ã™ã€‚
ã“ã®ã‚¹ãƒ‹ãƒšãƒƒãƒˆã‚’å®Ÿè¡Œã—ãŸå ´åˆãƒ»ãƒ»ãƒ»</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from("Hey");
let r = &amp;s;
<span class="boring">}</span></code></pre></pre>
<p>you'll get something like this in memory:</p>
<blockquote>
<p>ãƒ¡ãƒ¢ãƒªå†…ã§ã“ã‚Œã¯æ¬¡ã®ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚</p>
</blockquote>
<pre><code class="language-text">           --------------------------------------
           |                                    |
      +----v----+--------+----------+      +----|----+
Stack | pointer | length | capacity |      | pointer |
      |  |      |   3    |    5     |      |         |
      +--|  ----+--------+----------+      +---------+
         |          s                           r
         |
         v
       +---+---+---+---+---+
Heap   | H | e | y | ? | ? |
       +---+---+---+---+---+
</code></pre>
<p>It's a pointer to a pointer to the heap-allocated data, if you will.
The same goes for <code>&amp;mut String</code>.</p>
<blockquote>
<p>ã‚‚ã—ã€ãã‚Œã‚’ã—ãŸå ´åˆã€ãã‚Œã¯ãƒ’ãƒ¼ãƒ—ã«å‰²ã‚Šå½“ã¦ã‚‰ã‚ŒãŸãƒ‡ãƒ¼ã‚¿ã‚’æŒ‡ã—ç¤ºã™ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã®ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã§ã™ã€‚
åŒã˜ã“ã¨ã¯<code>&amp;mut String</code>ã«ã‚‚å½“ã¦ã¯ã¾ã‚Šã¾ã™ã€‚</p>
</blockquote>
<h2 id="not-all-pointers-point-to-the-heapã™ã¹ã¦ã®ãƒã‚¤ãƒ³ã‚¿ãƒ¼ãŒãƒ’ãƒ¼ãƒ—ã‚’æŒ‡ã—ç¤ºã™ã‚ã‘ã§ã¯ãªã„"><a class="header" href="#not-all-pointers-point-to-the-heapã™ã¹ã¦ã®ãƒã‚¤ãƒ³ã‚¿ãƒ¼ãŒãƒ’ãƒ¼ãƒ—ã‚’æŒ‡ã—ç¤ºã™ã‚ã‘ã§ã¯ãªã„">Not all pointers point to the heapï¼ˆã™ã¹ã¦ã®ãƒã‚¤ãƒ³ã‚¿ãƒ¼ãŒãƒ’ãƒ¼ãƒ—ã‚’æŒ‡ã—ç¤ºã™ã‚ã‘ã§ã¯ãªã„ï¼‰</a></h2>
<p>The example above should clarify one thing: not all pointers point to the heap.<br />
They just point to a memory location, which <em>may</em> be on the heap, but doesn't have to be.</p>
<blockquote>
<p>ä¸Šè¨˜ä¾‹ã¯ã€æ˜ç¢ºã«1ã¤ã®ã“ã¨ã‚’èª¬æ˜ã—ã¦ã„ã¾ã™ã€‚ã™ã¹ã¦ã®ãƒã‚¤ãƒ³ã‚¿ãƒ¼ãŒãƒ’ãƒ¼ãƒ—ã‚’æŒ‡ã—ç¤ºã™ã‚ã‘ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚
ãã‚Œã‚‰ã¯ã€å˜ã«ãƒ¡ãƒ¢ãƒªã®ä½ç½®ã‚’æŒ‡ã—ç¤ºã—ã¦ãŠã‚Šã€ãã‚Œã¯ãƒ’ãƒ¼ãƒ—ä¸Šã«ã‚ã‚‹_ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“_ãŒã€ãã†ã§ã‚ã‚‹å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚</p>
</blockquote>
<div class="footnote-definition" id="fat"><sup class="footnote-definition-label">1</sup>
<p><a href="03_ticket_v1/../04_traits/06_str_slice.html">Later in the course</a> we'll talk about <strong>fat pointers</strong>,
i.e. pointers with additional metadata. As the name implies, they are larger than
the pointers we discussed in this chapter, also known as <strong>thin pointers</strong>.
ã‚³ãƒ¼ã‚¹ã®å¾ŒåŠã§ã€ä¾‹ãˆã°è¿½åŠ ã®ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’æŒã¤ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã§ã‚ã‚‹ã€<strong>ãƒ•ã‚¡ãƒƒãƒˆãƒã‚¤ãƒ³ã‚¿ãƒ¼</strong>ã«ã¤ã„ã¦è©±ã—ã¾ã™ã€‚
åå‰ãŒæš—ã«æ„å‘³ã™ã‚‹é€šã‚Šã€ãã‚Œã‚‰ã¯ã“ã®ç« ã§è­°è«–ã—ãŸ<strong>ã‚·ãƒ³ãƒã‚¤ãƒ³ã‚¿ãƒ¼</strong>ã¨ã—ã¦ã‚‚çŸ¥ã‚‰ã‚Œã¦ã„ã‚‹ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã‚ˆã‚Šã‚‚å¤§ãã„ã§ã™ã€‚</p>
</div>
<h2 id="exercise-23"><a class="header" href="#exercise-23">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/03_ticket_v1/10_references_in_memory"><code>03_ticket_v1/10_references_in_memory</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="destructorsãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãƒ¼"><a class="header" href="#destructorsãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãƒ¼">Destructorsï¼ˆãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãƒ¼ï¼‰</a></h1>
<p>When introducing the heap, we mentioned that you're responsible for freeing the memory you allocate.<br />
When introducing the borrow-checker, we also stated that you rarely have to manage memory directly in Rust.</p>
<blockquote>
<p>ãƒ’ãƒ¼ãƒ—ã‚’ç´¹ä»‹ã—ãŸã¨ãã€å‰²ã‚Šå½“ã¦ãŸãƒ¡ãƒ¢ãƒªã‚’è§£æ”¾ã™ã‚‹è²¬ä»»ãŒã‚ã‚‹ã“ã¨ã‚’è¨€åŠã—ã¾ã—ãŸã€‚
å€Ÿç”¨ãƒã‚§ãƒƒã‚«ãƒ¼ã‚’ç´¹ä»‹ã—ãŸã¨ãã€Rustã§ã¯ã€ãƒ¡ãƒ¢ãƒªã‚’ç›´æ¥ç®¡ç†ã™ã‚‹å¿…è¦ãŒã»ã¨ã‚“ã©ãªã„ã“ã¨ã‚‚è¿°ã¹ã¾ã—ãŸã€‚</p>
</blockquote>
<p>These two statements might seem contradictory at first.
Let's see how they fit together by introducing <strong>scopes</strong> and <strong>destructors</strong>.</p>
<blockquote>
<p>æœ€åˆã¯ã€2ã¤ã®æ–‡ãŒçŸ›ç›¾ã—ã¦ã„ã‚‹ã‚ˆã†ã«è¦‹ãˆã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚
<strong>ã‚¹ã‚³ãƒ¼ãƒ—</strong>ã¨<strong>ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãƒ¼</strong>ã‚’å°å…¥ã—ã¦ã€ãã‚Œã‚‰ãŒã©ã®ã‚ˆã†ã«é©åˆã™ã‚‹ã‹ç¢ºèªã—ã¾ã—ã‚‡ã†ã€‚</p>
</blockquote>
<h2 id="scopesã‚¹ã‚³ãƒ¼ãƒ—"><a class="header" href="#scopesã‚¹ã‚³ãƒ¼ãƒ—">Scopesï¼ˆã‚¹ã‚³ãƒ¼ãƒ—ï¼‰</a></h2>
<p>The <strong>scope</strong> of a variable is the region of Rust code where that variable is valid, or <strong>alive</strong>.</p>
<blockquote>
<p>å¤‰æ•°ã®<strong>ã‚¹ã‚³ãƒ¼ãƒ—</strong>ã¯ã€ãã®å¤‰æ•°ãŒæœ‰åŠ¹ã¾ãŸã¯<strong>ç”Ÿãã¦ã„ã‚‹</strong>Rustã‚³ãƒ¼ãƒ‰ã®é ˜åŸŸã§ã™ã€‚</p>
</blockquote>
<p>The scope of a variable starts with its declaration.
It ends when one of the following happens:</p>
<ol>
<li>
<p>the block (i.e. the code between <code>{}</code>) where the variable was declared ends</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
   // `x` is not yet in scope here
   let y = "Hello".to_string();
   let x = "World".to_string(); // &lt;-- x's scope starts here...
   let h = "!".to_string(); //   |
} //  &lt;-------------- ...and ends here</code></pre></pre>
</li>
<li>
<p>ownership of the variable is transferred to someone else (e.g. a function or another variable)</p>
<pre><pre class="playground"><code class="language-rust">fn compute(t: String) {
   // Do something [...]
}

fn main() {
    let s = "Hello".to_string(); // &lt;-- s's scope starts here...
                //                    |
    compute(s); // &lt;------------------- ..and ends here
                //   because `s` is moved into `compute`
}</code></pre></pre>
</li>
</ol>
<blockquote>
<p>å¤‰æ•°ã®ã‚¹ã‚³ãƒ¼ãƒ—ã¯ã€ãã®å®£è¨€ã§å§‹ã¾ã‚Šã¾ã™ã€‚
ãã‚Œã¯ã€æ¬¡ã®ã†ã¡1ã¤ãŒç™ºç”Ÿã™ã‚‹ã¨çµ‚ã‚ã‚Šã¾ã™ã€‚</p>
<ol>
<li>ãã®å¤‰æ•°ãŒå®£è¨€ã•ã‚ŒãŸã€ä¾‹ãˆã°<code>{}</code>é–“ã®ã‚³ãƒ¼ãƒ‰ãªã©ã®ãƒ–ãƒ­ãƒƒã‚¯ãŒçµ‚äº†ã™ã‚‹ã€‚</li>
<li>å¤‰æ•°ã®æ‰€æœ‰æ¨©ãŒã€ä¾‹ãˆã°é–¢æ•°ã¾ãŸã¯ä»–ã®å¤‰æ•°ãªã©ã€ä»–ã®èª°ã‹ã«ç§»å‹•ã•ã‚Œã‚‹ã€‚</li>
</ol>
</blockquote>
<h2 id="destructorsãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãƒ¼-1"><a class="header" href="#destructorsãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãƒ¼-1">Destructorsï¼ˆãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãƒ¼ï¼‰</a></h2>
<p>When the owner of a value goes out of scope, Rust invokes its <strong>destructor</strong>.<br />
The destructor tries to clean up the resources used by that valueâ€”in particular, whatever memory it allocated.</p>
<blockquote>
<p>å€¤ã®æ‰€æœ‰è€…ãŒã‚¹ã‚³ãƒ¼ãƒ—å¤–ã«ãªã‚‹ã¨ã€Rustã¯ãã®<strong>ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãƒ¼</strong>ã‚’å‘¼ã³å‡ºã—ã¾ã™ã€‚
ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãƒ¼ã¯ã€ãã®å€¤ã«ã‚ˆã£ã¦ä½¿ç”¨ã•ã‚ŒãŸãƒªã‚½ãƒ¼ã‚¹ã€ç‰¹ã«å‰²ã‚Šå½“ã¦ã‚‰ã‚ŒãŸãƒ¡ãƒ¢ãƒªã‚’ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ã™ã‚‹ã“ã¨ã‚’è©¦ã¿ã¾ã™ã€‚</p>
</blockquote>
<p>You can manually invoke the destructor of a value by passing it to <code>std::mem::drop</code>.<br />
That's why you'll often hear Rust developers saying "that value has been <strong>dropped</strong>" as a way to state that a value
has gone out of scope and its destructor has been invoked.</p>
<blockquote>
<p>å€¤ã‚’<code>std::mem::drop</code>ã«æ¸¡ã™ã“ã¨ã§ã€å€¤ã®ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãƒ¼ã‚’æ‰‹å‹•ã§å‘¼ã³å‡ºã™ã“ã¨ãŒã§ãã¾ã™ã€‚
Rustã®é–‹ç™ºè€…ãŒã€å€¤ãŒã‚¹ã‚³ãƒ¼ãƒ—å¤–ã«ãªã‚Šã€ãã®ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãƒ¼ãŒå‘¼ã³å‡ºã•ã‚ŒãŸã“ã¨ã‚’è¿°ã¹ã‚‹æ–¹æ³•ã¨ã—ã¦ã€ã€Œãã®å€¤ã¯<strong>ãƒ‰ãƒ­ãƒƒãƒ—</strong>ã•ã‚Œã¾ã—ãŸã€ã¨è¨€ã†ã“ã¨ã‚’ã‚ˆãèãã§ã—ã‚‡ã†ã€‚</p>
</blockquote>
<h3 id="visualizing-drop-pointsãƒ‰ãƒ­ãƒƒãƒ—ãƒã‚¤ãƒ³ãƒˆã®å¯è¦–åŒ–"><a class="header" href="#visualizing-drop-pointsãƒ‰ãƒ­ãƒƒãƒ—ãƒã‚¤ãƒ³ãƒˆã®å¯è¦–åŒ–">Visualizing drop pointsï¼ˆãƒ‰ãƒ­ãƒƒãƒ—ãƒã‚¤ãƒ³ãƒˆã®å¯è¦–åŒ–ï¼‰</a></h3>
<p>We can insert explicit calls to <code>drop</code> to "spell out" what the compiler does for us. Going back to the previous example:</p>
<blockquote>
<p>ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ¼ãŒã—ã¦ãã‚Œã‚‹ã“ã¨ã‚’ã€Œè¨˜è¿°ã—ã¦ä¼ãˆã‚‹ã€ãŸã‚ã«ã€æ˜ç¤ºçš„ãª<code>drop</code>å‘¼ã³å‡ºã—ã‚’æŒ¿å…¥ã§ãã¾ã™ã€‚
å‰ã®ä¾‹ã«æˆ»ã‚Šã¾ã—ã‚‡ã†ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">fn main() {
   let y = "Hello".to_string();
   let x = "World".to_string();
   let h = "!".to_string();
}</code></pre></pre>
<p>It's equivalent to:</p>
<blockquote>
<p>ä¸Šè¨˜ã¯æ¬¡ã¨ç­‰ä¾¡ã§ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">fn main() {
   let y = "Hello".to_string();
   let x = "World".to_string();
   let h = "!".to_string();
   // Variables are dropped in reverse order of declaration
   // å¤‰æ•°ã¯ã€å®£è¨€ã®é€†é †ã§ãƒ‰ãƒ­ãƒƒãƒ—ã•ã‚Œã¾ã™ã€‚
   drop(h);
   drop(x);
   drop(y);
}</code></pre></pre>
<p>Let's look at the second example instead, where <code>s</code>'s ownership is transferred to <code>compute</code>:</p>
<blockquote>
<p>ä»£ã‚ã‚Šã«ã€<code>s</code>ã®æ‰€æœ‰æ¨©ãŒ<code>compute</code>ã«ç§»å‹•ã—ãŸã€2ã¤ç›®ã®ä¾‹ã‚’ç¢ºèªã—ã¾ã—ã‚‡ã†ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">fn compute(s: String) {
   // Do something [...]
   // ãªã«ã‹ã—ã¾ã™ã€‚
}

fn main() {
   let s = "Hello".to_string();
   compute(s);
}</code></pre></pre>
<p>It's equivalent to this:</p>
<blockquote>
<p>ãã‚Œã¯æ¬¡ã¨ç­‰ä¾¡ã§ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">fn compute(t: String) {
    // Do something [...]
    // ãªã«ã‹ã—ã¾ã™ã€‚
    drop(t); // &lt;-- Assuming `t` wasn't dropped or moved
             //     before this point, the compiler will call
             //     `drop` here, when it goes out of scope
             //    ã“ã®æ™‚ç‚¹ã¾ã§`t`ãŒãƒ‰ãƒ­ãƒƒãƒ—ã•ã‚ŒãŸã‚Šç§»å‹•ã•ã‚Œã¦ã„ãªã„ã¨ä»®å®šã—ã¦ã€
             //    ãã‚ŒãŒã‚¹ã‚³ãƒ¼ãƒ—å¤–ã«ãªã£ãŸã¨ãã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ¼ã¯ã“ã“ã§ï½€drop`ã‚’å‘¼ã³å‡ºã—ã¾ã™ã€‚
}

fn main() {
    let s = "Hello".to_string();
    compute(s);
}</code></pre></pre>
<p>Notice the difference: even though <code>s</code> is no longer valid after <code>compute</code> is called in <code>main</code>, there is no <code>drop(s)</code>
in <code>main</code>.
When you transfer ownership of a value to a function, you're also <strong>transferring the responsibility of cleaning it up</strong>.</p>
<blockquote>
<p>é•ã„ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚<code>main</code>å†…ã§<code>compute</code>ãŒå‘¼ã³å‡ºã•ã‚ŒãŸå¾Œã€<code>s</code>ã¯ã‚‚ã¯ã‚„æœ‰åŠ¹ã§ã¯ã‚ã‚Šã¾ã›ã‚“ãŒã€<code>main</code>å†…ã«<code>drop(s)</code>ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚
é–¢æ•°ã«å€¤ã®æ‰€æœ‰æ¨©ã‚’ç§»å‹•ã—ãŸã¨ãã€<strong>ãã‚Œã‚’ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ã™ã‚‹è²¬ä»»ã‚‚ç§»å‹•</strong>ã—ã¾ã™ã€‚</p>
</blockquote>
<p>This ensures that the destructor for a value is called <strong>at most<sup class="footnote-reference"><a href="#leak">1</a></sup> once</strong>, preventing
<a href="https://owasp.org/www-community/vulnerabilities/Doubly_freeing_memory">double free bugs</a> by design.</p>
<blockquote>
<p>å€¤ã®ãŸã‚ã®ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãƒ¼ã¯ã€è¨­è¨ˆã«ã‚ˆã£ã¦äºŒé‡è§£æ”¾ã®ãƒã‚°ã‚’é¿ã‘ã‚‹ãŸã‚ã«ã€<strong>æœ€å¤§ã§ä¸€åº¦</strong>å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚</p>
</blockquote>
<h3 id="use-after-dropãƒ‰ãƒ­ãƒƒãƒ—ã®ã‚ã¨ã§ä½¿ç”¨ã™ã‚‹"><a class="header" href="#use-after-dropãƒ‰ãƒ­ãƒƒãƒ—ã®ã‚ã¨ã§ä½¿ç”¨ã™ã‚‹">Use after dropï¼ˆãƒ‰ãƒ­ãƒƒãƒ—ã®ã‚ã¨ã§ä½¿ç”¨ã™ã‚‹ï¼‰</a></h3>
<p>What happens if you try to use a value after it's been dropped?</p>
<blockquote>
<p>å€¤ãŒãƒ‰ãƒ­ãƒƒãƒ—ã•ã‚ŒãŸå¾Œã§ã€å€¤ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã‚’è©¦ã¿ã‚‹ã¨ä½•ãŒç™ºç”Ÿã™ã‚‹ã§ã—ã‚‡ã†ã‹ï¼Ÿ</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = "Hello".to_string();
drop(x);
println!("{}", x);
<span class="boring">}</span></code></pre></pre>
<p>If you try to compile this code, you'll get an error:</p>
<blockquote>
<p>ã“ã®ã‚³ãƒ¼ãƒ‰ã‚’ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã™ã‚‹ã“ã¨ã‚’è©¦ã¿ã‚‹ã¨ã€æ¬¡ã®ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>error[E0382]: use of moved value: `x`
 --&gt; src/main.rs:4:20
  |
3 |     drop(x);
  |          - value moved here
4 |     println!("{}", x);
  |                    ^ value used here after move
<span class="boring">}</span></code></pre></pre>
<p>Drop <strong>consumes</strong> the value it's called on, meaning that the value is no longer valid after the call.<br />
The compiler will therefore prevent you from using it, avoiding <a href="https://owasp.org/www-community/vulnerabilities/Using_freed_memory">use-after-free bugs</a>.</p>
<blockquote>
<p>ãƒ‰ãƒ­ãƒƒãƒ—ã¯ã€ãã‚ŒãŒå‘¼ã°ã‚ŒãŸå€¤ã‚’<strong>æ¶ˆè²»ã™ã‚‹</strong>ãŸã‚ã€å‘¼ã³å‡ºã—ãŸå¾Œã€ãã®å€¤ã¯ã‚‚ã¯ã‚„æœ‰åŠ¹ã§ã¯ãªã„ã“ã¨ã‚’æ„å‘³ã—ã¾ã™ã€‚
ã‚ˆã£ã¦ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ¼ã¯ã€è§£æ”¾å¾Œã«ä½¿ç”¨ã™ã‚‹ãƒã‚°ã‚’å›é¿ã™ã‚‹ãŸã‚ã«ã€ãã‚Œã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã‚’é˜²ãã¾ã™ã€‚</p>
</blockquote>
<h3 id="dropping-referenceså‚ç…§ã®ãƒ‰ãƒ­ãƒƒãƒ—"><a class="header" href="#dropping-referenceså‚ç…§ã®ãƒ‰ãƒ­ãƒƒãƒ—">Dropping referencesï¼ˆå‚ç…§ã®ãƒ‰ãƒ­ãƒƒãƒ—ï¼‰</a></h3>
<p>What if a variable contains a reference?<br />
For example:</p>
<blockquote>
<p>å¤‰æ•°ãŒå‚ç…§ã‚’å«ã‚“ã§ã„ãŸå ´åˆã¯ã©ã†ãªã‚‹ã§ã—ã‚‡ã†ã‹ï¼Ÿ
ä¾‹ãˆã°ãƒ»ãƒ»ãƒ»</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 42i32;
let y = &amp;x;
drop(y);
<span class="boring">}</span></code></pre></pre>
<p>When you call <code>drop(y)</code>... nothing happens.<br />
If you actually try to compile this code, you'll get a warning:</p>
<blockquote>
<p><code>drop(y)</code>ã‚’å‘¼ã³å‡ºã—ãŸã¨ããƒ»ãƒ»ãƒ»ä½•ã‚‚ç™ºç”Ÿã—ã¾ã›ã‚“ã€‚
å®Ÿéš›ã«ã“ã®ã‚³ãƒ¼ãƒ‰ã‚’ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã™ã‚‹ã“ã¨ã‚’è©¦ã¿ãŸå ´åˆã€è­¦å‘ŠãŒç™ºç”Ÿã—ã¾ã™ã€‚</p>
</blockquote>
<pre><code class="language-text">warning: calls to `std::mem::drop` with a reference
         instead of an owned value does nothing
 --&gt; src/main.rs:4:5
  |
4 |     drop(y);
  |     ^^^^^-^
  |          |
  |          argument has type `&amp;i32`
  |
</code></pre>
<p>It goes back to what we said earlier: we only want to call the destructor once.<br />
You can have multiple references to the same valueâ€”if we called the destructor for the value they point at
when one of them goes out of scope, what would happen to the others?
They would refer to a memory location that's no longer valid: a so-called <a href="https://en.wikipedia.org/wiki/Dangling_pointer"><strong>dangling pointer</strong></a>,
a close relative of <a href="https://owasp.org/www-community/vulnerabilities/Using_freed_memory"><strong>use-after-free bugs</strong></a>.
Rust's ownership system rules out these kinds of bugs by design.</p>
<blockquote>
<p>ã“ã‚Œã¯ã€å‰è¿°ã®ã“ã¨ã«æˆ»ã‚Šã¾ã™ï¼šãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãƒ¼ã‚’ä¸€åº¦ã ã‘å‘¼ã³å‡ºã—ãŸã„ã ã‘ã§ã™ã€‚
åŒã˜å€¤ã¸ã®è¤‡æ•°ã®å‚ç…§ã‚’æŒã¤ã“ã¨ãŒã§ãã¾ã™ã€‚ãã‚Œã‚‰ã®1ã¤ãŒã‚¹ã‚³ãƒ¼ãƒ—å¤–ã«ãªã£ãŸã¨ãã«ãã®å€¤ã®ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãƒ¼ã‚’å‘¼ã³å‡ºã—ãŸå ´åˆã€ä»–ã«ä½•ãŒç™ºç”Ÿã™ã‚‹ã§ã—ã‚‡ã†ã‹ï¼Ÿ
ãã‚Œã‚‰ã¯ã€ãƒ€ãƒ³ã‚°ãƒªãƒ³ã‚°ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã¨ã‚‚å‘¼ã°ã‚Œã‚‹ã€ã‚‚ã¯ã‚„æœ‰åŠ¹ã§ãªã„ãƒ¡ãƒ¢ãƒªä½ç½®ã‚’å‚ç…§ã—ã¦ã€è§£æ”¾ã—ãŸå¾Œã«ä½¿ç”¨ã™ã‚‹ãƒã‚°ã«å¯†æ¥ã«é–¢é€£ã—ã¾ã™ã€‚
Rustã®æ‰€æœ‰æ¨©ã‚·ã‚¹ãƒ†ãƒ ã¯ã€è¨­è¨ˆã«ã‚ˆã£ã¦ã“ã‚Œã‚‰ã®ç¨®é¡ã®ãƒã‚°ã‚’æ’é™¤ã—ã¾ã™ã€‚</p>
</blockquote>
<div class="footnote-definition" id="leak"><sup class="footnote-definition-label">1</sup>
<p>Rust doesn't guarantee that destructors will run. They won't, for example, if
you explicitly choose to <a href="03_ticket_v1/../07_threads/03_leak.html">leak memory</a>.
Rustã¯ã€ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãƒ¼ãŒå®Ÿè¡Œã•ã‚Œã‚‹ã“ã¨ã‚’ä¿è¨¼ã—ã¾ã›ã‚“ã€‚
ä¾‹ãˆã°ã€ãƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯ã‚’æ˜ç¤ºçš„ã«é¸æŠã—ãŸå ´åˆã€ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãƒ¼ã®å‘¼ã³å‡ºã—ã¯ã•ã‚Œã¾ã›ã‚“ã€‚</p>
</div>
<h2 id="exercise-24"><a class="header" href="#exercise-24">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/03_ticket_v1/11_destructor"><code>03_ticket_v1/11_destructor</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wrapping-upä»•ä¸Šã’"><a class="header" href="#wrapping-upä»•ä¸Šã’">Wrapping upï¼ˆä»•ä¸Šã’ï¼‰</a></h1>
<p>We've covered a lot of foundational Rust concepts in this chapter.<br />
Before moving on, let's go through one last exercise to consolidate what we've learned.
You'll have minimal guidance this timeâ€”just the exercise description and the tests to guide you.</p>
<blockquote>
<p>ã“ã®ç« ã§ã¯ã€å¤šãã®åŸºç¤çš„ãªRustã®æ¦‚å¿µã‚’èª¬æ˜ã—ã¾ã—ãŸã€‚
æ¬¡ã«é€²ã‚€å‰ã«ã€å­¦ã‚“ã ã“ã¨ã‚’å¼·å›ºã«ã™ã‚‹ãŸã‚ã«æœ€å¾Œã®æ¼”ç¿’ã‚’1ã¤è¡Œã„ã¾ã—ã‚‡ã†ã€‚
ä»Šå›ã€æœ€å°é™ã®æ¡ˆå†…ãŒã‚ã‚Šã¾ã™ã€‚å˜ãªã‚‹æ¼”ç¿’ã®èª¬æ˜ã¨ã€ãƒ†ã‚¹ãƒˆã®æ¡ˆå†…ã§ã™ã€‚</p>
</blockquote>
<h2 id="exercise-25"><a class="header" href="#exercise-25">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/03_ticket_v1/12_outro"><code>03_ticket_v1/12_outro</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="traitsãƒˆãƒ¬ã‚¤ãƒˆ"><a class="header" href="#traitsãƒˆãƒ¬ã‚¤ãƒˆ">Traitsï¼ˆãƒˆãƒ¬ã‚¤ãƒˆï¼‰</a></h1>
<p>In the previous chapter we covered the basics of Rust's type and ownership system.<br />
It's time to dig deeper: we'll explore <strong>traits</strong>, Rust's take on interfaces.</p>
<blockquote>
<p>å‰ã®ç« ã§ã€Rustã®å‹ã¨æ‰€æœ‰æ¨©ã‚·ã‚¹ãƒ†ãƒ ã®åŸºæœ¬ã‚’èª¬æ˜ã—ã¾ã—ãŸã€‚
ã‚ˆã‚Šæ·±ãæ˜ã‚Šä¸‹ã’ã‚‹æ™‚é–“ã§ã™ã€‚Rustã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ã‚¤ã‚¹ã«å¯¾ã™ã‚‹è€ƒãˆæ–¹ã§ã‚ã‚‹<strong>ãƒˆãƒ¬ã‚¤ãƒˆ</strong>ã‚’æ¢æ±‚ã—ã¾ã™ã€‚</p>
</blockquote>
<p>Once you learn about traits, you'll start seeing their fingerprints all over the place.<br />
In fact, you've already seen traits in action throughout the previous chapter, e.g. <code>.into()</code> invocations as well
as operators like <code>==</code> and <code>+</code>.</p>
<blockquote>
<p>ä¸€æ—¦ã€ãƒˆãƒ¬ã‚¤ãƒˆã«ã¤ã„ã¦å­¦ã¶ã¨ã€ãã®æŒ‡ç´‹ãŒã‚ã‚‰ã‚†ã‚‹å ´æ‰€ã§è¦‹ã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚
äº‹å®Ÿã€å‰ã®ç« ã‚’é€šã˜ã¦å®Ÿéš›ã«ãƒˆãƒ¬ã‚¤ãƒˆã‚’è¦‹ã¾ã—ãŸã€‚ä¾‹ãˆã°ã€<code>.into()</code>å‘¼ã³å‡ºã—ã¨åŒæ§˜ã«<code>==</code>ã‚„<code>+</code>ã®ã‚ˆã†ãªæ¼”ç®—å­ã§ã™ã€‚</p>
</blockquote>
<p>On top of traits as a concept, we'll also cover some of the key traits that are defined in Rust's standard library:</p>
<ul>
<li>Operator traits (e.g. <code>Add</code>, <code>Sub</code>, <code>PartialEq</code>, etc.)</li>
<li><code>From</code> and <code>Into</code>, for infallible conversions</li>
<li><code>Clone</code> and <code>Copy</code>, for copying values</li>
<li><code>Deref</code> and deref coercion</li>
<li><code>Sized</code>, to mark types with a known size</li>
<li><code>Drop</code>, for custom cleanup logic</li>
</ul>
<blockquote>
<p>æ¦‚å¿µã¨ã—ã¦ã®ãƒˆãƒ¬ã‚¤ãƒˆã‚’è¸ã¾ãˆãŸä¸Šã§ã€Rustæ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªå†…ã«å®šç¾©ã•ã‚ŒãŸã„ãã¤ã‹ä¸»è¦ãªãƒˆãƒ¬ã‚¤ãƒˆã‚’èª¬æ˜ã—ã¾ã™ã€‚</p>
</blockquote>
<p>Since we'll be talking about conversions, we'll seize the opportunity to plug some of the "knowledge gaps"
from the previous chapterâ€”e.g. what is <code>"A title"</code>, exactly? Time to learn more about slices too!</p>
<blockquote>
<p>å¤‰æ›ã«ã¤ã„ã¦è©±ã™äºˆå®šã§ã‚ã‚‹ãŸã‚ã€å‰ã®ç« ã‹ã‚‰ã®ã„ãã¤ã‹ã®ã€ŒçŸ¥è­˜ã®ä¹–é›¢ã€ã‚’åŸ‹ã‚ã‚‹ãŸã‚ã«æ©Ÿä¼šã‚’æ´ã¿ã¾ã™ã€‚
ä¾‹ãˆã°ã€æ­£ç¢ºã«ã€Œ<code>"A title"</code>ã€ã¨ã¯ä½•ã§ã—ã‚‡ã†ã‹ï¼Ÿã¾ãŸã‚¹ãƒ©ã‚¤ã‚¹ã«ã¤ã„ã¦ã‚ˆã‚Šå­¦ã¶æ™‚ã§ã™ï¼</p>
</blockquote>
<h2 id="exercise-26"><a class="header" href="#exercise-26">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/04_traits/00_intro"><code>04_traits/00_intro</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="traitsãƒˆãƒ¬ã‚¤ãƒˆ-1"><a class="header" href="#traitsãƒˆãƒ¬ã‚¤ãƒˆ-1">Traitsï¼ˆãƒˆãƒ¬ã‚¤ãƒˆï¼‰</a></h1>
<p>Let's look again at our <code>Ticket</code> type:</p>
<p><code>Ticket</code>å‹ã‚’å†åº¦ç¢ºèªã—ã¾ã—ã‚‡ã†ã€‚</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Ticket {
    title: String,
    description: String,
    status: String,
}
<span class="boring">}</span></code></pre></pre>
<p>All our tests, so far, have been making assertions using <code>Ticket</code>'s fields.</p>
<blockquote>
<p>ã“ã‚Œã¾ã§ã€ã™ã¹ã¦ã®ãƒ†ã‚¹ãƒˆã¯ã€<code>Ticket</code>ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’ä½¿ç”¨ã—ã¦ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ã—ã¦ãã¾ã—ãŸã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>assert_eq!(ticket.title(), "A new title");
<span class="boring">}</span></code></pre></pre>
<p>What if we wanted to compare two <code>Ticket</code> instances directly?</p>
<blockquote>
<p>ç›´æ¥2ã¤ã®<code>Ticket</code>ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’æ¯”è¼ƒã—ãŸã„å ´åˆã€ã©ã†ã™ã‚Œã°ã„ã„ã§ã—ã‚‡ã†ã‹ï¼Ÿ</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let ticket1 = Ticket::new(/* ... */);
let ticket2 = Ticket::new(/* ... */);
ticket1 == ticket2
<span class="boring">}</span></code></pre></pre>
<p>The compiler will stop us:</p>
<blockquote>
<p>ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ¼ã¯æ­¢ã‚ã¾ã™ã€‚</p>
</blockquote>
<pre><code class="language-text">error[E0369]: binary operation `==` cannot be applied to type `Ticket`
  --&gt; src/main.rs:18:13
   |
18 |     ticket1 == ticket2
   |     ------- ^^ ------- Ticket
   |     |
   |     Ticket
   |
note: an implementation of `PartialEq` might be missing for `Ticket`
</code></pre>
<p><code>Ticket</code> is a new type. Out of the box, there is <strong>no behavior attached to it</strong>.<br />
Rust doesn't magically infer how to compare two <code>Ticket</code> instances just because they contain <code>String</code>s.</p>
<blockquote>
<p><code>Ticket</code>ã¯æ–°ã—ã„å‹ã§ã™ã€‚çµ„ã¿è¾¼ã¿ã§ã€<strong>ãã‚Œã«ã¯æŒ¯ã‚‹èˆã„ãŒä»˜å±ã—ã¦ã„ã¾ã›ã‚“</strong>ã€‚
Rustã¯ã€<code>Ticket</code>ãŒ<code>String</code>ã‚’å«ã‚“ã§ã„ã‚‹ãŸã‚ã€2ã¤ã®<code>Ticket</code>ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’æ¯”è¼ƒã™ã‚‹æ–¹æ³•ã‚’é­”æ³•ã®ã‚ˆã†ã«æ¨æ¸¬ã—ã¾ã›ã‚“ã€‚</p>
</blockquote>
<p>The Rust compiler is nudging us in the right direction though: it's suggesting that we might be missing an implementation
of <code>PartialEq</code>. <code>PartialEq</code> is a <strong>trait</strong>!</p>
<blockquote>
<p>ã—ã‹ã—ã€Rustã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ¼ã¯ã€æ­£ã—ã„æ–¹å‘ã¸ãã£ã¨çªã„ã¦ã„ã¾ã™ã€‚ãã‚Œã¯<code>PartialEq</code>ã®å®Ÿè£…ãŒä¸è¶³ã—ã¦ã„ã‚‹ã‹ã‚‚ã—ã‚Œãªã„ã“ã¨ã‚’ç¤ºå”†ã—ã¦ã„ã¾ã™ã€‚
<code>PartialEq</code>ã¯<strong>ãƒˆãƒ¬ã‚¤ãƒˆ</strong>ã§ã™ï¼</p>
</blockquote>
<h2 id="what-are-traitsãƒˆãƒ¬ã‚¤ãƒˆã¨ã¯"><a class="header" href="#what-are-traitsãƒˆãƒ¬ã‚¤ãƒˆã¨ã¯">What are traits?ï¼ˆãƒˆãƒ¬ã‚¤ãƒˆã¨ã¯ï¼Ÿï¼‰</a></h2>
<p>Traits are Rust's way of defining <strong>interfaces</strong>.<br />
A trait defines a set of methods that a type must implement to satisfy the trait's contract.</p>
<blockquote>
<p>ãƒˆãƒ¬ã‚¤ãƒˆã¯ã€<strong>ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ã‚¤ã‚¹</strong>ã‚’å®šç¾©ã™ã‚‹Rustã®æ–¹æ³•ã§ã™ã€‚
ãƒˆãƒ¬ã‚¤ãƒˆã¯ã€ãƒˆãƒ¬ã‚¤ãƒˆã®å¥‘ç´„ã‚’æº€ãŸã™ãŸã‚ã«ã€å‹ãŒå®Ÿè£…ã—ãªãã¦ã¯ãªã‚‰ãªã„ãƒ¡ã‚½ãƒƒãƒ‰ã®é›†åˆã‚’å®šç¾©ã—ã¾ã™ã€‚</p>
</blockquote>
<h3 id="defining-a-traitãƒˆãƒ¬ã‚¤ãƒˆã®å®šç¾©"><a class="header" href="#defining-a-traitãƒˆãƒ¬ã‚¤ãƒˆã®å®šç¾©">Defining a traitï¼ˆãƒˆãƒ¬ã‚¤ãƒˆã®å®šç¾©ï¼‰</a></h3>
<p>The syntax for a trait definition goes like this:</p>
<blockquote>
<p>ãƒˆãƒ¬ã‚¤ãƒˆã‚’å®šç¾©ã™ã‚‹æ§‹æ–‡ã¯æ¬¡ã®ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait &lt;TraitName&gt; {
    fn &lt;method_name&gt;(&lt;parameters&gt;) -&gt; &lt;return_type&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p>We might, for example, define a trait named <code>MaybeZero</code> that requires its implementors to define an <code>is_zero</code> method:</p>
<blockquote>
<p>ä¾‹ãˆã°ã€<code>is_zero</code>ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®šç¾©ã™ã‚‹ãŸã‚ã«ã€å®Ÿè£…è€…ã«ãã‚Œã‚’è¦æ±‚ã™ã‚‹<code>MaybeZero</code>ã¨åä»˜ã‘ã‚‰ã‚ŒãŸãƒˆãƒ¬ã‚¤ãƒˆã‚’å®šç¾©ã™ã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait MaybeZero {
    fn is_zero(self) -&gt; bool;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="implementing-a-traitãƒˆãƒ¬ã‚¤ãƒˆã®å®Ÿè£…"><a class="header" href="#implementing-a-traitãƒˆãƒ¬ã‚¤ãƒˆã®å®Ÿè£…">Implementing a traitï¼ˆãƒˆãƒ¬ã‚¤ãƒˆã®å®Ÿè£…ï¼‰</a></h3>
<p>To implement a trait for a type we use the <code>impl</code> keyword, just like we do for regular<sup class="footnote-reference"><a href="#inherent">1</a></sup> methods,
but the syntax is a bit different:</p>
<blockquote>
<p>å‹ã«ãƒˆãƒ¬ã‚¤ãƒˆã‚’å®Ÿè£…ã™ã‚‹ãŸã‚ã«ã€ã¡ã‚‡ã†ã©é€šå¸¸ã®ãƒ¡ã‚½ãƒƒãƒ‰ã§ã—ãŸã‚ˆã†ã«ã€<code>impl</code>ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’ä½¿ç”¨ã—ã¾ã™ãŒã€æ§‹æ–‡ã¯å°‘ã—ç•°ãªã‚Šã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl &lt;TraitName&gt; for &lt;TypeName&gt; {
    fn &lt;method_name&gt;(&lt;parameters&gt;) -&gt; &lt;return_type&gt; {
        // Method body
    }
}
<span class="boring">}</span></code></pre></pre>
<p>For example, to implement the <code>MaybeZero</code> trait for a custom number type, <code>WrappingU32</code>:</p>
<blockquote>
<p>ä¾‹ãˆã°ã€ã‚«ã‚¹ã‚¿ãƒ ãªæ•°å€¤å‹ã®<code>WrappingU32</code>ã«<code>MaybeZero</code>ãƒˆãƒ¬ã‚¤ãƒˆã‚’å®Ÿè£…ã™ã‚‹ã«ã¯ãƒ»ãƒ»ãƒ»</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct WrappingU32 {
    inner: u32,
}

impl MaybeZero for WrappingU32 {
    fn is_zero(self) -&gt; bool {
        self.inner == 0
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="invoking-a-trait-methodãƒˆãƒ¬ã‚¤ãƒˆãƒ¡ã‚½ãƒƒãƒ‰ã®å‘¼ã³å‡ºã—"><a class="header" href="#invoking-a-trait-methodãƒˆãƒ¬ã‚¤ãƒˆãƒ¡ã‚½ãƒƒãƒ‰ã®å‘¼ã³å‡ºã—">Invoking a trait methodï¼ˆãƒˆãƒ¬ã‚¤ãƒˆãƒ¡ã‚½ãƒƒãƒ‰ã®å‘¼ã³å‡ºã—ï¼‰</a></h3>
<p>To invoke a trait method, we use the <code>.</code> operator, just like we do with regular methods:</p>
<p>ãƒˆãƒ¬ã‚¤ãƒˆãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã™ãŸã‚ã«ã€ã¡ã‚‡ã†ã©é€šå¸¸ã®ãƒ¡ã‚½ãƒƒãƒ‰ã§ã—ãŸã‚ˆã†ã«ã€<code>.</code>æ¼”ç®—å­ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = WrappingU32 { inner: 5 };
assert!(!x.is_zero());
<span class="boring">}</span></code></pre></pre>
<p>To invoke a trait method, two things must be true:</p>
<ul>
<li>The type must implement the trait.</li>
<li>The trait must be in scope.</li>
</ul>
<blockquote>
<p>ãƒˆãƒ¬ã‚¤ãƒˆãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã™ãŸã‚ã«ã€æ¬¡ã®2ã¤ãŒæˆç«‹ã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚</p>
<ul>
<li>å‹ãŒãã®ãƒˆãƒ¬ã‚¤ãƒˆã‚’å®Ÿè£…ã—ã¦ã„ãªãã¦ã¯ãªã‚Šã¾ã›ã‚“ã€‚</li>
<li>ãƒˆãƒ¬ã‚¤ãƒˆãŒã‚¹ã‚³ãƒ¼ãƒ—å†…ã«ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚</li>
</ul>
</blockquote>
<p>To satisfy the latter, you may have to add a <code>use</code> statement for the trait:</p>
<blockquote>
<p>å¾Œè€…ã‚’æº€ãŸã™ãŸã‚ã«ã€ãã®ãƒˆãƒ¬ã‚¤ãƒˆã®ãŸã‚ã«<code>use</code>æ–‡ã‚’è¿½åŠ ã—ãªã‘ã‚Œã°ãªã‚‰ãªã„ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::MaybeZero;
<span class="boring">}</span></code></pre></pre>
<p>This is not necessary if:</p>
<ul>
<li>The trait is defined in the same module where the invocation occurs.</li>
<li>The trait is defined in the standard library's <strong>prelude</strong>.
The prelude is a set of traits and types that are automatically imported into every Rust program.
It's as if <code>use std::prelude::*;</code> was added at the beginning of every Rust module.</li>
</ul>
<blockquote>
<p>æ¬¡ã®å ´åˆã¯ã€ã“ã‚Œã¯å¿…è¦ã‚ã‚Šã¾ã›ã‚“ã€‚</p>
<ul>
<li>ãƒˆãƒ¬ã‚¤ãƒˆãŒã€å‘¼ã³å‡ºã—ãŒç™ºç”Ÿã™ã‚‹åŒã˜ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å†…ã§å®šç¾©ã•ã‚Œã¦ã„ã‚‹ã€‚</li>
<li>ãƒˆãƒ¬ã‚¤ãƒˆãŒã€æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®<strong>prelude</strong>ã«å®šç¾©ã•ã‚Œã¦ã„ã‚‹ã€‚
<code>prelude</code>ã¯ã€ã™ã¹ã¦ã®Rustãƒ—ãƒ­ã‚°ãƒ©ãƒ å†…ã«è‡ªå‹•çš„ã«ã‚¤ãƒ³ãƒãƒ¼ãƒˆã•ã‚Œã‚‹ãƒˆãƒ¬ã‚¤ãƒˆã‚„å‹ã®é›†åˆã§ã™ã€‚
ãã‚Œã¯ã€<code>use::std::prelude:**;</code>ã¨ã—ã¦ã€ã™ã¹ã¦ã®Rustãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®é–‹å§‹ã«è¿½åŠ ã•ã‚ŒãŸã‹ã®ã‚ˆã†ã§ã™ã€‚</li>
</ul>
</blockquote>
<p>You can find the list of traits and types in the prelude in the
<a href="https://doc.rust-lang.org/std/prelude/index.html">Rust documentation</a>.</p>
<blockquote>
<p>preludeå†…ã®ãƒˆãƒ¬ã‚¤ãƒˆã¨å‹ã®ãƒªã‚¹ãƒˆã¯ã€Rustãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã§è¦‹ã¤ã‘ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚</p>
</blockquote>
<div class="footnote-definition" id="inherent"><sup class="footnote-definition-label">1</sup>
<p>A method defined directly on a type, without using a trait, is also known as an <strong>inherent method</strong>.
ãƒˆãƒ¬ã‚¤ãƒˆã‚’ä½¿ç”¨ã—ãªã„ã§ã€å‹ã«ç›´æ¥å®šç¾©ã•ã‚ŒãŸãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€<strong>ç¶™æ‰¿ãƒ¡ã‚½ãƒƒãƒ‰</strong>ã¨ã‚‚çŸ¥ã‚‰ã‚Œã¦ã„ã¾ã™ã€‚</p>
</div>
<h2 id="exercise-27"><a class="header" href="#exercise-27">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/04_traits/01_trait"><code>04_traits/01_trait</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="implementing-traitsãƒˆãƒ¬ã‚¤ãƒˆã®å®Ÿè£…"><a class="header" href="#implementing-traitsãƒˆãƒ¬ã‚¤ãƒˆã®å®Ÿè£…">Implementing traitsï¼ˆãƒˆãƒ¬ã‚¤ãƒˆã®å®Ÿè£…ï¼‰</a></h1>
<p>When a type is defined in another crate (e.g. <code>u32</code>, from Rust's standard library), you
can't directly define new methods for it. If you try:</p>
<blockquote>
<p>ä¾‹ãˆã°ã€Rustæ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®<code>u32</code>ãªã©ã€å‹ãŒä»–ã®ã‚¯ãƒ¬ãƒ¼ãƒˆã«å®šç¾©ã•ã‚Œã¦ã„ã‚‹ã¨ãã€ãã‚Œã«ç›´æ¥æ–°ã—ã„ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®šç¾©ã§ãã¾ã›ã‚“ã€‚
ãã‚Œã‚’è©¦ã¿ã‚‹ã¨ãƒ»ãƒ»ãƒ»</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl u32 {
    fn is_even(&amp;self) -&gt; bool {
        self % 2 == 0
    }
}
<span class="boring">}</span></code></pre></pre>
<p>the compiler will complain:</p>
<blockquote>
<p>ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã¯æ–‡å¥ã‚’è¨€ã†ã§ã—ã‚‡ã†ã€‚</p>
</blockquote>
<pre><code class="language-text">error[E0390]: cannot define inherent `impl` for primitive types
  |
1 | impl u32 {
  | ^^^^^^^^
  |
  = help: consider using an extension trait instead
</code></pre>
<h2 id="extension-traitæ‹¡å¼µãƒˆãƒ¬ã‚¤ãƒˆ"><a class="header" href="#extension-traitæ‹¡å¼µãƒˆãƒ¬ã‚¤ãƒˆ">Extension traitï¼ˆæ‹¡å¼µãƒˆãƒ¬ã‚¤ãƒˆï¼‰</a></h2>
<p>An <strong>extension trait</strong> is a trait whose primary purpose is to attach new methods
to foreign types, such as <code>u32</code>.
That's exactly the pattern you deployed in the previous exercise, by defining
the <code>IsEven</code> trait and then implementing it for <code>i32</code> and <code>u32</code>. You are then
free to call <code>is_even</code> on those types as long as <code>IsEven</code> is in scope.</p>
<blockquote>
<p><strong>æ‹¡å¼µãƒˆãƒ¬ã‚¤ãƒˆ</strong>ã¯ã€<code>u32</code>ã®ã‚ˆã†ãªå¤–éƒ¨ã®å‹ã«æ–°ã—ã„ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å–ã‚Šä»˜ã‘ã‚‹ã“ã¨ãŒä¸»ãªç›®çš„ã®ãƒˆãƒ¬ã‚¤ãƒˆã§ã™ã€‚
ã“ã‚Œã¯ã€<code>IsEven</code>ãƒˆãƒ¬ã‚¤ãƒˆã‚’å®šç¾©ã—ã¦ã€ãã—ã¦<code>i32</code>ã¨<code>u32</code>ã«å®Ÿè£…ã—ãŸã€ã¾ã•ã—ãå‰ã®æ¼”ç¿’ã§å±•é–‹ã—ãŸãƒ‘ã‚¿ãƒ¼ãƒ³ã§ã™ã€‚
ãã—ã¦ã€<code>IsEven</code>ãŒã‚¹ã‚³ãƒ¼ãƒ—å†…ã«ã‚ã‚‹é™ã‚Šã€ãã‚Œã‚‰ã®å‹ã®<code>is_even</code>å‘¼ã³å‡ºã—ã¯è‡ªç”±ã§ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">// Bring the trait in scope
// ãƒˆãƒ¬ã‚¤ãƒˆã‚’ã‚¹ã‚³ãƒ¼ãƒ—å†…ã«æŒã¡è¾¼ã¿ã¾ã™ã€‚
use my_library::IsEven;

fn main() {
    // Invoke its method on a type that implements it
    // ãã‚Œã‚’å®Ÿè£…ã—ãŸå‹ã®ãã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã—ã¾ã™ã€‚
    if 4.is_even() {
        // [...]
    }
}</code></pre></pre>
<h2 id="one-implementation1ã¤ã®å®Ÿè£…"><a class="header" href="#one-implementation1ã¤ã®å®Ÿè£…">One implementationï¼ˆ1ã¤ã®å®Ÿè£…ï¼‰</a></h2>
<p>There are limitations to the trait implementations you can write.<br />
The simplest and most straight-forward one: you can't implement the same trait twice,
in a crate, for the same type.</p>
<p>For example:</p>
<blockquote>
<p>è¨˜è¿°ã§ãã‚‹ãƒˆãƒ¬ã‚¤ãƒˆã®å®Ÿè£…ã«ã¯åˆ¶é™ãŒã‚ã‚Šã¾ã™ã€‚
æœ€ã‚‚å˜ç´”ã§æœ€ã‚‚ç°¡å˜ãª1ã¤ã¯ã€ã‚¯ãƒ¬ãƒ¼ãƒˆå†…ã§ä»»æ„ã®å‹ã«åŒã˜ãƒˆãƒ¬ã‚¤ãƒˆã‚’2å›å®Ÿè£…ã§ããªã„ã“ã¨ã§ã™ã€‚</p>
<p>ä¾‹ãˆã°ãƒ»ãƒ»ãƒ»</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait IsEven {
    fn is_even(&amp;self) -&gt; bool;
}

impl IsEven for u32 {
    fn is_even(&amp;self) -&gt; bool {
        true
    }
}

impl IsEven for u32 {
    fn is_even(&amp;self) -&gt; bool {
        false
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The compiler will reject it:</p>
<blockquote>
<p>ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ¼ã¯ãã‚Œã‚’æ‹’å¦ã—ã¾ã™ã€‚</p>
</blockquote>
<pre><code class="language-text">error[E0119]: conflicting implementations of trait `IsEven` for type `u32`
   |
5  | impl IsEven for u32 {
   | ------------------- first implementation here
...
11 | impl IsEven for u32 {
   | ^^^^^^^^^^^^^^^^^^^ conflicting implementation for `u32`
</code></pre>
<p>There can be no ambiguity as to what trait implementation should be used when <code>IsEven::is_even</code>
is invoked on a <code>u32</code> value, therefore there can only be one.</p>
<blockquote>
<p><code>u32</code>å€¤ã«å¯¾ã—ã¦<code>IsEven::is_even</code>ãŒå‘¼ã³å‡ºã•ã‚ŒãŸã¨ãã€ã©ã®ãƒˆãƒ¬ã‚¤ãƒˆã®å®Ÿè£…ã‚’ä½¿ç”¨ã™ã‚‹ã¹ãã‹ã«ã¤ã„ã¦æ›–æ˜§ã•ãŒã‚ã£ã¦ã¯ãªã‚Šã¾ã›ã‚“ã€‚
å¾“ã£ã¦ã€1ã¤ã—ã‹å­˜åœ¨ã§ãã¾ã›ã‚“ã€‚</p>
</blockquote>
<h2 id="orphan-ruleå­¤ç«‹ãƒ«ãƒ¼ãƒ«"><a class="header" href="#orphan-ruleå­¤ç«‹ãƒ«ãƒ¼ãƒ«">Orphan ruleï¼ˆå­¤ç«‹ãƒ«ãƒ¼ãƒ«ï¼‰</a></h2>
<p>Things get more nuanced when multiple crates are involved.
In particular, at least one of the following must be true:</p>
<ul>
<li>The trait is defined in the current crate</li>
<li>The implementor type is defined in the current crate</li>
</ul>
<blockquote>
<p>è¤‡æ•°ã®ã‚¯ãƒ¬ãƒ¼ãƒˆãŒå·»ãè¾¼ã¾ã‚Œã‚‹ã¨ã€ã‚‚ã®ã¯ã‚ˆã‚Šå¾®å¦™ãªå·®ç•°ãŒã§ã¦ãã¾ã™ã€‚
ç‰¹ã«ã€æ¬¡ã®å†…ã€å°‘ãªãã¨ã‚‚1ã¤ã¯æˆç«‹ã—ãªãã¦ã¯ãªã‚Šã¾ã›ã‚“ã€‚</p>
<ul>
<li>ãƒˆãƒ¬ã‚¤ãƒˆãŒã€ç¾åœ¨ã®ã‚¯ãƒ¬ãƒ¼ãƒˆã§å®šç¾©ã•ã‚Œã¦ã„ã‚‹ã€‚</li>
<li>å®Ÿè£…å‹ï¼ˆãƒˆãƒ¬ã‚¤ãƒˆã‚’å®Ÿè£…ã™ã‚‹å‹ï¼‰ãŒã€ç¾åœ¨ã®ã‚¯ãƒ¬ãƒ¼ãƒˆã§å®šç¾©ã•ã‚Œã¦ã„ã‚‹ã€‚</li>
</ul>
</blockquote>
<p>This is known as Rust's <strong>orphan rule</strong>. Its goal is to make the method resolution
process unambiguous.</p>
<blockquote>
<p>ã“ã‚Œã¯Rustã®<strong>å­¤ç«‹ãƒ«ãƒ¼ãƒ«</strong>ã¨ã—ã¦çŸ¥ã‚‰ã‚Œã¦ã„ã¾ã™ã€‚
ãã®ç›®çš„ã¯ã€ãƒ¡ã‚½ãƒƒãƒ‰è§£æ±ºå‡¦ç†ã‚’æ›–æ˜§ã«ã«ã—ãªã„ã“ã¨ã§ã™ã€‚</p>
</blockquote>
<p>Imagine the following situation:</p>
<ul>
<li>Crate <code>A</code> defines the <code>IsEven</code> trait</li>
<li>Crate <code>B</code> implements <code>IsEven</code> for <code>u32</code></li>
<li>Crate <code>C</code> provides a (different) implementation of the <code>IsEven</code> trait for <code>u32</code></li>
<li>Crate <code>D</code> depends on both <code>B</code> and <code>C</code> and calls <code>1.is_even()</code></li>
</ul>
<blockquote>
<p>æ¬¡ã®çŠ¶æ³ã‚’æƒ³åƒã—ã¦ãã ã•ã„ã€‚</p>
<ul>
<li>ã‚¯ãƒ¬ãƒ¼ãƒˆ<code>A</code>ãŒã€<code>IsEven</code>ãƒˆãƒ¬ã‚¤ãƒˆã‚’å®šç¾©ã™ã‚‹ã€‚</li>
<li>ã‚¯ãƒ¬ãƒ¼ãƒˆ<code>B</code>ãŒã€<code>u32</code>ã«å¯¾ã—ã¦<code>IsEven</code>ã‚’å®Ÿè£…ã™ã‚‹ã€‚</li>
<li>ã‚¯ãƒ¬ãƒ¼ãƒˆ<code>C</code>ãŒã€<code>u32</code>ã«å¯¾ã—ã¦ã€<code>IsEven</code>ã®ç•°ãªã‚‹å®Ÿè£…ã‚’æä¾›ã™ã‚‹ã€‚</li>
<li>ã‚¯ãƒ¬ãƒ¼ãƒˆ<code>D</code>ã¯ã€<code>B</code>ã¨<code>C</code>ã®ä¸¡æ–¹ã«ä¾å­˜ã—ã¦ãŠã‚Šã€<code>1.is_even()</code>ã‚’å‘¼ã³å‡ºã™ã€‚</li>
</ul>
</blockquote>
<p>Which implementation should be used? The one defined in <code>B</code>? Or the one defined in <code>C</code>?<br />
There's no good answer, therefore the orphan rule was defined to prevent this scenario.
Thanks to the orphan rule, neither crate <code>B</code> nor crate <code>C</code> would compile.</p>
<blockquote>
<p>ã©ã¡ã‚‰ã®å®Ÿè£…ãŒä½¿ç”¨ã•ã‚Œã‚‹ã¹ãã§ã—ã‚‡ã†ã‹ï¼Ÿ<code>B</code>ã§å®šç¾©ã•ã‚ŒãŸã‚‚ã®ã§ã—ã‚‡ã†ã‹ï¼Ÿãã‚Œã¨ã‚‚<code>C</code>ã§å®šç¾©ã•ã‚ŒãŸã‚‚ã®ã§ã—ã‚‡ã†ã‹ï¼Ÿ
è‰¯ã„ç­”ãˆã¯ã‚ã‚Šã¾ã›ã‚“ã€‚å¾“ã£ã¦ã€å­¤ç«‹ãƒ«ãƒ¼ãƒ«ã¯ã“ã®ã‚·ãƒŠãƒªã‚ªã‚’é¿ã‘ã‚‹ãŸã‚ã«å®šç¾©ã•ã‚Œã¾ã—ãŸã€‚
å­¤ç«‹ãƒ«ãƒ¼ãƒ«ã®ãŠã‹ã’ã§ã€<code>B</code>ã‚¯ãƒ¬ãƒ¼ãƒˆã¨<code>C</code>ã‚¯ãƒ¬ãƒ¼ãƒˆã¯ã©ã¡ã‚‰ã‚‚ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã‚Œã¾ã›ã‚“ã€‚</p>
</blockquote>
<h2 id="further-readingå‚è€ƒè³‡æ–™-6"><a class="header" href="#further-readingå‚è€ƒè³‡æ–™-6">Further readingï¼ˆå‚è€ƒè³‡æ–™ï¼‰</a></h2>
<ul>
<li>There are some caveats and exceptions to the orphan rule as stated above.
Check out <a href="https://doc.rust-lang.org/reference/items/implementations.html#trait-implementation-coherence">the reference</a>
if you want to get familiar with its nuances.</li>
</ul>
<blockquote>
<ul>
<li>ä¸Šè¨˜ã§è¿°ã¹ãŸå­¤ç«‹ãƒ«ãƒ¼ãƒ«ã«ã¯ã€ã„ãã¤ã‹ã®æ³¨æ„äº‹é …ã¨ä¾‹å¤–ãŒã‚ã‚Šã¾ã™ã€‚
ãã®å¾®å¦™ãªå·®ç•°ã«æ…£ã‚ŒãŸã„å ´åˆã¯ã€ãƒªãƒ•ã‚¡ãƒ¬ãƒ³ã‚¹ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚</li>
</ul>
</blockquote>
<h2 id="exercise-28"><a class="header" href="#exercise-28">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/04_traits/02_orphan_rule"><code>04_traits/02_orphan_rule</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="operator-overloadingæ¼”ç®—å­ã®ã‚ªãƒ¼ãƒãƒ¼ãƒ­ãƒ¼ãƒ‰"><a class="header" href="#operator-overloadingæ¼”ç®—å­ã®ã‚ªãƒ¼ãƒãƒ¼ãƒ­ãƒ¼ãƒ‰">Operator overloadingï¼ˆæ¼”ç®—å­ã®ã‚ªãƒ¼ãƒãƒ¼ãƒ­ãƒ¼ãƒ‰ï¼‰</a></h1>
<p>Now that we have a basic understanding of what traits are, let's circle back to <strong>operator overloading</strong>.
Operator overloading is the ability to define custom behavior for operators like <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>==</code>, <code>!=</code>, etc.</p>
<blockquote>
<p>ç¾åœ¨ã€ãƒˆãƒ¬ã‚¤ãƒˆãŒä½•ã‹åŸºæœ¬çš„ãªç†è§£ã‚’å¾—ãŸã®ã§ã€<strong>æ¼”ç®—å­ã®ã‚ªãƒ¼ãƒãƒ¼ãƒ­ãƒ¼ãƒ‰</strong>ã«æˆ»ã‚Šã¾ã—ã‚‡ã†ã€‚
æ¼”ç®—å­ã®ã‚ªãƒ¼ãƒãƒ¼ãƒ­ãƒ¼ãƒ‰ã¯ã€<code>+</code>ã€<code>-</code>ã€<code>*</code>ã€<code>/</code>ã€<code>==</code>ã€<code>!=</code>ãªã©ã®æ¼”ç®—å­ã®ã‚«ã‚¹ã‚¿ãƒ ãªæŒ¯ã‚‹èˆã„ã‚’å®šç¾©ã™ã‚‹èƒ½åŠ›ã§ã™ã€‚</p>
</blockquote>
<h2 id="operators-are-traitsæ¼”ç®—å­ã¯ãƒˆãƒ¬ã‚¤ãƒˆ"><a class="header" href="#operators-are-traitsæ¼”ç®—å­ã¯ãƒˆãƒ¬ã‚¤ãƒˆ">Operators are traitsï¼ˆæ¼”ç®—å­ã¯ãƒˆãƒ¬ã‚¤ãƒˆï¼‰</a></h2>
<p>In Rust, operators are traits.<br />
For each operator, there is a corresponding trait that defines the behavior of that operator.
By implementing that trait for your type, you <strong>unlock</strong> the usage of the corresponding operators.</p>
<blockquote>
<p>Rustã«ãŠã„ã¦ã€æ¼”ç®—å­ã¯ãƒˆãƒ¬ã‚¤ãƒˆã§ã™ã€‚
ãã‚Œãã‚Œã®æ¼”ç®—å­ã«ã¯ã€ãã®æ¼”ç®—å­ã®æŒ¯ã‚‹èˆã„ã‚’å®šç¾©ã™ã‚‹ãŸã‚ã«ã€å¯¾å¿œã—ãŸãƒˆãƒ¬ã‚¤ãƒˆãŒã‚ã‚Šã¾ã™ã€‚
å‹ã«ãã®ãƒˆãƒ¬ã‚¤ãƒˆã‚’å®Ÿè£…ã™ã‚‹ã“ã¨ã§ã€å¯¾å¿œã™ã‚‹æ¼”ç®—å­ã®ä½¿ç”¨ã‚’<strong>è§£é™¤</strong>ã—ã¾ã™ã€‚</p>
</blockquote>
<p>For example, the <a href="https://doc.rust-lang.org/std/cmp/trait.PartialEq.html"><code>PartialEq</code> trait</a> defines the behavior of
the <code>==</code> and <code>!=</code> operators:</p>
<blockquote>
<p>ä¾‹ãˆã°ã€<code>PartialEq</code>ãƒˆãƒ¬ã‚¤ãƒˆã¯ã€<code>==</code>ã¨<code>!=</code>æ¼”ç®—å­ã®æŒ¯ã‚‹èˆã„ã‚’å®šç¾©ã—ã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// The `PartialEq` trait definition, from Rust's standard library
// (It is *slightly* simplified, for now)
// Rustæ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®`PartialEq`ãƒˆãƒ¬ã‚¤ãƒˆã®å®šç¾©ã§ã™ã€‚
// ï¼ˆã“ã“ã§ã¯ã€ãã‚Œã¯*ã™ã“ã—*ç°¡ç•¥åŒ–ã•ã‚Œã¦ã„ã¾ã™ï¼‰
pub trait PartialEq {
    // Required method
    // è¦æ±‚ã•ã‚Œã‚‹ãƒ¡ã‚½ãƒƒãƒ‰ã§ã™ã€‚
    //
    // `Self` is a Rust keyword that stands for
    // "the type that is implementing the trait"
    // `Self`ã¯ã€Œãƒˆãƒ¬ã‚¤ãƒˆã‚’å®Ÿè£…ã—ãŸå‹ã€ã‚’è¡¨ã™Rustã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã§ã™ã€‚
    fn eq(&amp;self, other: &amp;Self) -&gt; bool;

    // Provided method
    // æä¾›ã•ã‚ŒãŸãƒ¡ã‚½ãƒƒãƒ‰ã§ã™ã€‚
    fn ne(&amp;self, other: &amp;Self) -&gt; bool { ... }
}
<span class="boring">}</span></code></pre></pre>
<p>When you write <code>x == y</code> the compiler will look for an implementation of the <code>PartialEq</code> trait for the types of <code>x</code> and <code>y</code>
and replace <code>x == y</code> with <code>x.eq(y)</code>. It's syntactic sugar!</p>
<blockquote>
<p><code>x == y</code>ã‚’è¨˜è¿°ã™ã‚‹ã¨ã€<code>x</code>ã¨<code>y</code>ã®å‹ã®<code>PartialEq</code>ãƒˆãƒ¬ã‚¤ãƒˆã®å®Ÿè£…ã‚’æ¢ã—ã€<code>x == y</code>ã‚’<code>x.eq(y)</code>ã«ç½®ãæ›ãˆã¾ã™ã€‚
ãã‚Œã¯ç³–è¡£æ§‹æ–‡ã§ã™ï¼</p>
</blockquote>
<p>This is the correspondence for the main operators:</p>
<blockquote>
<p>æ¬¡ã¯ä¸»è¦ãªæ¼”ç®—å­ã®å¯¾å¿œã§ã™ã€‚</p>
</blockquote>
<div class="table-wrapper"><table><thead><tr><th>Operator</th><th>Trait</th></tr></thead><tbody>
<tr><td><code>+</code></td><td><a href="https://doc.rust-lang.org/std/ops/trait.Add.html"><code>Add</code></a></td></tr>
<tr><td><code>-</code></td><td><a href="https://doc.rust-lang.org/std/ops/trait.Sub.html"><code>Sub</code></a></td></tr>
<tr><td><code>*</code></td><td><a href="https://doc.rust-lang.org/std/ops/trait.Mul.html"><code>Mul</code></a></td></tr>
<tr><td><code>/</code></td><td><a href="https://doc.rust-lang.org/std/ops/trait.Div.html"><code>Div</code></a></td></tr>
<tr><td><code>%</code></td><td><a href="https://doc.rust-lang.org/std/ops/trait.Rem.html"><code>Rem</code></a></td></tr>
<tr><td><code>==</code> and <code>!=</code></td><td><a href="https://doc.rust-lang.org/std/cmp/trait.PartialEq.html"><code>PartialEq</code></a></td></tr>
<tr><td><code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, and <code>&gt;=</code></td><td><a href="https://doc.rust-lang.org/std/cmp/trait.PartialOrd.html"><code>PartialOrd</code></a></td></tr>
</tbody></table>
</div>
<p>Arithmetic operators live in the <a href="https://doc.rust-lang.org/std/ops/index.html"><code>std::ops</code></a> module,
while comparison ones live in the <a href="https://doc.rust-lang.org/std/cmp/index.html"><code>std::cmp</code></a> module.</p>
<blockquote>
<p>ç®—è¡“æ¼”ç®—å­ã¯ã€<code>std::ops</code>ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ã‚ã‚Šã€æ¯”è¼ƒæ¼”ç®—å­ã¯<code>std::cmp</code>ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ã‚ã‚Šã¾ã™ã€‚</p>
</blockquote>
<h2 id="default-implementationsãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå®Ÿè£…"><a class="header" href="#default-implementationsãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå®Ÿè£…">Default implementationsï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå®Ÿè£…ï¼‰</a></h2>
<p>The comment on <code>PartialEq::ne</code> states that "<code>ne</code> is a provided method".<br />
It means that <code>PartialEq</code> provides a <strong>default implementation</strong> for <code>ne</code> in the trait definitionâ€”the <code>{ ... }</code> elided
block in the definition snippet.<br />
If we expand the elided block, it looks like this:</p>
<blockquote>
<p><code>PartialEq::ne</code>ã®ã‚³ãƒ¡ãƒ³ãƒˆã¯ã€ã€Œ<code>ne</code>ã¯æä¾›ã•ã‚ŒãŸãƒ¡ã‚½ãƒƒãƒ‰ã§ã™ã€ã¨è¿°ã¹ã¦ã„ã¾ã™ã€‚
ãã‚Œã¯ã€<code>PartialEq</code>ãŒãƒˆãƒ¬ã‚¤ãƒˆå®šç¾©å†…ã§<code>ne</code>ã®<strong>ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå®Ÿè£…</strong>ã‚’æä¾›ã—ã¦ã„ã‚‹ã“ã¨ã‚’æ„å‘³ã—ã¾ã™ã€‚
ãã‚Œã¯ã€å®šç¾©ã‚¹ãƒ‹ãƒšãƒƒãƒˆå†…ã®çœç•¥ã•ã‚ŒãŸãƒ–ãƒ­ãƒƒã‚¯<code>{ ... }</code>ã§ã™ã€‚
çœç•¥ã•ã‚ŒãŸãƒ–ãƒ­ãƒƒã‚¯ã‚’å±•é–‹ã™ã‚‹ã¨ã€æ¬¡ãŒè¡¨ç¤ºã•ã‚Œã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait PartialEq {
    fn eq(&amp;self, other: &amp;Self) -&gt; bool;

    fn ne(&amp;self, other: &amp;Self) -&gt; bool {
        !self.eq(other)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>It's what you expect: <code>ne</code> is the negation of <code>eq</code>.<br />
Since a default implementation is provided, you can skip implementing <code>ne</code> when you implement <code>PartialEq</code> for your type.
It's enough to implement <code>eq</code>:</p>
<blockquote>
<p>ãã‚Œã¯æœŸå¾…ã—ãŸã‚‚ã®ã§ã™ã€‚<code>ne</code>ã¯<code>eq</code>ã®å¦å®šã§ã™ã€‚
ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå®Ÿè£…ãŒæä¾›ã•ã‚Œã¦ã„ã‚‹ãŸã‚ã€å‹ã«<code>PartialEq</code>ã‚’å®Ÿè£…ã™ã‚‹æ™‚ã€<code>ne</code>ã®å®Ÿè£…ã‚’ã‚¹ã‚­ãƒƒãƒ—ã§ãã¾ã™ã€‚
<code>eq</code>ã®å®Ÿè£…ã§ååˆ†ã§ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct WrappingU8 {
    inner: u8,
}

impl PartialEq for WrappingU8 {
    fn eq(&amp;self, other: &amp;WrappingU8) -&gt; bool {
        self.inner == other.inner
    }

    // No `ne` implementation here
    // ã“ã“ã«`ne`ã®å®Ÿè£…ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚
}
<span class="boring">}</span></code></pre></pre>
<p>You are not forced to use the default implementation though.
You can choose to override it when you implement the trait:</p>
<blockquote>
<p>ã—ã‹ã—ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå®Ÿè£…ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã‚’å¼·åˆ¶ã•ã‚Œã¾ã›ã‚“ã€‚
ãƒˆãƒ¬ã‚¤ã‚’å®Ÿè£…ã™ã‚‹ã¨ãã€ä¸Šæ›¸ãã™ã‚‹ã“ã¨ã‚’é¸æŠã§ãã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MyType;

impl PartialEq for MyType {
    fn eq(&amp;self, other: &amp;MyType) -&gt; bool {
        // Custom implementation
        // ç‹¬è‡ªã®å®Ÿè£…
    }

    fn ne(&amp;self, other: &amp;MyType) -&gt; bool {
        // Custom implementation
        // ç‹¬è‡ªã®å®Ÿè£…
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="exercise-29"><a class="header" href="#exercise-29">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/04_traits/03_operator_overloading"><code>04_traits/03_operator_overloading</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="derive-macroså°å‡ºãƒã‚¯ãƒ­"><a class="header" href="#derive-macroså°å‡ºãƒã‚¯ãƒ­">Derive macrosï¼ˆå°å‡ºãƒã‚¯ãƒ­ï¼‰</a></h1>
<p>Implementing <code>PartialEq</code> for <code>Ticket</code> was a bit tedious, wasn't it?
You had to manually compare each field of the struct.</p>
<blockquote>
<p><code>Ticket</code>ã®<code>PartialEq</code>ã®å®Ÿè£…ã¯å°‘ã—é€€å±ˆã§ã¯ãªã„ã§ã™ã‹ï¼Ÿ
æ§‹é€ ä½“ã®ãã‚Œãã‚Œã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’æ‰‹å‹•ã§æ¯”è¼ƒã—ãªãã¦ã¯ãªã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚</p>
</blockquote>
<h2 id="destructuring-syntaxåˆ†å‰²æ§‹æ–‡"><a class="header" href="#destructuring-syntaxåˆ†å‰²æ§‹æ–‡">Destructuring syntaxï¼ˆåˆ†å‰²æ§‹æ–‡ï¼‰</a></h2>
<p>Furthermore, the implementation is brittle: if the struct definition changes
(e.g. a new field is added), you have to remember to update the <code>PartialEq</code> implementation.</p>
<blockquote>
<p>ã•ã‚‰ã«ã€ãã®å®Ÿè£…ã¯å£Šã‚Œã‚„ã™ã„ã§ã™ã€‚
æ–°ã—ã„ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒè¿½åŠ ã•ã‚Œã‚‹ãªã©ã€æ§‹é€ ä½“ã®å®šç¾©ãŒå¤‰æ›´ã—ãŸå ´åˆã€<code>PartialEq</code>ã®å®Ÿè£…ã‚’æ›´æ–°ã™ã‚‹ã“ã¨ã‚’å¿˜ã‚Œãªã„ã‚ˆã†ã«ã—ãªãã¦ã¯ãªã‚Šã¾ã›ã‚“ã€‚</p>
</blockquote>
<p>You can mitigate the risk by <strong>destructuring</strong> the struct into its fields:</p>
<blockquote>
<p>æ§‹é€ ä½“ã‚’ãã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«<strong>åˆ†å‰²</strong>ã™ã‚‹ã“ã¨ã§ã€ãã®ãƒªã‚¹ã‚¯ã‚’è»½æ¸›ã§ãã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl PartialEq for Ticket {
    fn eq(&amp;self, other: &amp;Self) -&gt; bool {
        let Ticket {
            title,
            description,
            status,
        } = self;
        // [...]
    }
}
<span class="boring">}</span></code></pre></pre>
<p>If the definition of <code>Ticket</code> changes, the compiler will error out, complaining that your
destructuring is no longer exhaustive.<br />
You can also rename struct fields, to avoid variable shadowing:</p>
<blockquote>
<p><code>Ticket</code>ã®å®šç¾©ãŒå¤‰æ›´ã•ã‚ŒãŸå ´åˆã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ¼ã¯ã€åˆ†å‰²ãŒã‚‚ã¯ã‚„ç¶²ç¾…çš„ã§ãªã„ã¨ã—ã¦ã‚¨ãƒ©ãƒ¼ã‚’å‡ºåŠ›ã—ã¾ã™ã€‚
ã¾ãŸã€å¤‰æ•°ã®ã‚·ãƒ£ãƒ‰ãƒ¼ã‚¤ãƒ³ã‚°ã‚’é˜²ããŸã‚ã«ã€æ§‹é€ ä½“ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®åå‰ã‚’å¤‰æ›´ã§ãã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl PartialEq for Ticket {
    fn eq(&amp;self, other: &amp;Self) -&gt; bool {
        let Ticket {
            title,
            description,
            status,
        } = self;
        let Ticket {
            title: other_title,
            description: other_description,
            status: other_status,
        } = other;
        // [...]
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Destructuring is a useful pattern to have in your toolkit, but
there's an even more convenient way to do this: <strong>derive macros</strong>.</p>
<blockquote>
<p>åˆ†å‰²ã¯ãƒ„ãƒ¼ãƒ«ã‚­ãƒƒãƒˆå†…ã«ã‚ã‚‹ã¨ä¾¿åˆ©ãªãƒ‘ã‚¿ãƒ¼ãƒ³ã§ã™ãŒã€å®Ÿè£…ã™ã‚‹ãŸã‚ã«ã€ã‚ˆã‚Šä¾¿åˆ©ãªæ–¹æ³•ãŒã‚ã‚Šã¾ã™ã€‚
ãã‚Œã¯<strong>å°å‡ºãƒã‚¯ãƒ­</strong>ã§ã™ã€‚</p>
</blockquote>
<h2 id="macrosãƒã‚¯ãƒ­"><a class="header" href="#macrosãƒã‚¯ãƒ­">Macrosï¼ˆãƒã‚¯ãƒ­ï¼‰</a></h2>
<p>You've already encountered a few macros in past exercises:</p>
<ul>
<li><code>assert_eq!</code> and <code>assert!</code>, in the test cases</li>
<li><code>println!</code>, to print to the console</li>
</ul>
<blockquote>
<p>éå»ã®æ¼”ç¿’ã§ã™ã§ã«ã„ãã¤ã‹ã®ãƒã‚¯ãƒ­ã«é­é‡ã—ã¦ã„ã¾ã™ã€‚</p>
<ul>
<li>ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹å†…ã®<code>assert_eq!</code>ã¨<code>assert!</code></li>
<li>ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã«å‡ºåŠ›ã™ã‚‹ãŸã‚ã®<code>println!</code></li>
</ul>
</blockquote>
<p>Rust macros are <strong>code generators</strong>.<br />
They generate new Rust code based on the input you provide, and that generated code is then compiled alongside
the rest of your program. Some macros are built into Rust's standard library, but you can also
write your own. We won't be creating our own macro in this course, but you can find some useful
pointers in the <a href="04_traits/04_derive.html#further-reading%E5%8F%82%E8%80%83%E8%B3%87%E6%96%99">"Further reading" section</a></p>
<blockquote>
<p>Rustã®ãƒã‚¯ãƒ­ã¯<strong>ã‚³ãƒ¼ãƒ‰ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ãƒ¼</strong>ã§ã™ã€‚
ãã‚Œã‚‰ã¯ã€æä¾›ã—ãŸå…¥åŠ›ã«åŸºã¥ã„ã¦æ–°ã—ã„Rustã‚³ãƒ¼ãƒ‰ã‚’ç”Ÿæˆã—ã¦ã€ç”Ÿæˆã•ã‚ŒãŸã‚³ãƒ¼ãƒ‰ã¯ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®æ®‹ã‚Šã¨ä¸€ç·’ã«ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã‚Œã¾ã™ã€‚
ã„ãã¤ã‹ã®ãƒã‚¯ãƒ­ã¯ã€Rustæ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªå†…ã«çµ„ã¿è¾¼ã¾ã‚Œã¦ã„ã¾ã™ãŒã€ç‹¬è‡ªã«è¨˜è¿°ã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ã€‚
ã“ã®ã‚³ãƒ¼ã‚¹ã§ç‹¬è‡ªã®ãƒã‚¯ãƒ­ã‚’ä½œæˆã™ã‚‹ã¤ã‚‚ã‚Šã¯ã‚ã‚Šã¾ã›ã‚“ãŒã€å‚è€ƒè³‡æ–™ã®ç¯€ã«ã„ãã¤ã‹ã®æœ‰ç›ŠãªæŒ‡é‡ã‚’è¦‹ã¤ã‘ã‚Œã¾ã™ã€‚</p>
</blockquote>
<h3 id="inspectionæ¤œæŸ»"><a class="header" href="#inspectionæ¤œæŸ»">Inspectionï¼ˆæ¤œæŸ»ï¼‰</a></h3>
<p>Some IDEs let you expand a macro to inspect the generated code. If that's not possible, you can use
<a href="https://github.com/dtolnay/cargo-expand"><code>cargo-expand</code></a>.</p>
<blockquote>
<p>ä¸€éƒ¨ã®IDEã¯ã€ç”Ÿæˆã•ã‚Œã‚‹ã‚³ãƒ¼ãƒ‰ã‚’æ¤œæŸ»ã™ã‚‹ãŸã‚ã«ãƒã‚¯ãƒ­ã‚’å±•é–‹ã—ã¾ã™ã€‚
ãã‚ŒãŒä¸å¯èƒ½ãªå ´åˆã€<code>cargo-expand</code>ã‚’ä½¿ç”¨ã§ãã¾ã™ã€‚</p>
</blockquote>
<h3 id="derive-macroså°å‡ºãƒã‚¯ãƒ­-1"><a class="header" href="#derive-macroså°å‡ºãƒã‚¯ãƒ­-1">Derive macrosï¼ˆå°å‡ºãƒã‚¯ãƒ­ï¼‰</a></h3>
<p>A <strong>derive macro</strong> is a particular flavour of Rust macro. It is specified as an <strong>attribute</strong> on top of a struct.</p>
<blockquote>
<p><strong>å°å‡ºãƒã‚¯ãƒ­</strong>ã¯ã€Rustãƒã‚¯ãƒ­ã®ç‰¹åˆ¥ãªé¢¨å‘³ã§ã™ã€‚
ãã‚Œã¯ã€æ§‹é€ ä½“ã®ä¸Šã«<strong>å±æ€§</strong>ã¨ã—ã¦æŒ‡å®šã•ã‚Œã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(PartialEq)]
struct Ticket {
    title: String,
    description: String,
    status: String
}
<span class="boring">}</span></code></pre></pre>
<p>Derive macros are used to automate the implementation of common (and "obvious") traits for custom types.
In the example above, the <code>PartialEq</code> trait is automatically implemented for <code>Ticket</code>.
If you expand the macro, you'll see that the generated code is functionally equivalent to the one you wrote manually,
although a bit more cumbersome to read:</p>
<blockquote>
<p>å°å‡ºãƒã‚¯ãƒ­ã¯ã€ã‚«ã‚¹ã‚¿ãƒ å‹ã«ä¸€èˆ¬çš„ãªãƒˆãƒ¬ã‚¤ãƒˆã®å®Ÿè£…ã‚’è‡ªå‹•åŒ–ã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚
ä¸Šè¨˜ä¾‹ã«ãŠã„ã¦ã€<code>PartialEq</code>ãƒˆãƒ¬ã‚¤ãƒˆã¯<code>Ticket</code>ã«è‡ªå‹•ã§å®Ÿè£…ã•ã‚Œã¾ã™ã€‚
ãƒã‚¯ãƒ­ã‚’å±•é–‹ã—ãŸå ´åˆã€èª­ã‚€ã®ãŒã‚ˆã‚Šå°‘ã—ç…©ã‚ã—ã„ã§ã™ãŒã€æ‰‹å‹•ã§è¨˜è¿°ã—ãŸã‚‚ã®ã¨æ©Ÿèƒ½çš„ã«ç­‰ä¾¡ãªã‚³ãƒ¼ãƒ‰ãŒç”Ÿæˆã•ã‚Œã‚‹ã“ã¨ã‚’ç¢ºèªã§ãã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[automatically_derived]
impl ::core::cmp::PartialEq for Ticket {
    #[inline]
    fn eq(&amp;self, other: &amp;Ticket) -&gt; bool {
        self.title == other.title &amp;&amp; self.description == other.description
            &amp;&amp; self.status == other.status
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The compiler will nudge you to derive traits when possible.</p>
<blockquote>
<p>ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ¼ã¯ã€å¯èƒ½ãªå ´åˆã«ãƒˆãƒ¬ã‚¤ãƒˆã‚’å°å‡ºã™ã‚‹ã“ã¨ã‚’æ¨å¥¨ã—ã¾ã™ã€‚</p>
</blockquote>
<h2 id="further-readingå‚è€ƒè³‡æ–™-7"><a class="header" href="#further-readingå‚è€ƒè³‡æ–™-7">Further readingï¼ˆå‚è€ƒè³‡æ–™ï¼‰</a></h2>
<ul>
<li><a href="https://veykril.github.io/tlborm/">The little book of Rust macros</a></li>
<li><a href="https://github.com/dtolnay/proc-macro-workshop">Proc macro workshop</a></li>
</ul>
<h2 id="exercise-30"><a class="header" href="#exercise-30">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/04_traits/04_derive"><code>04_traits/04_derive</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="trait-boundsãƒˆãƒ¬ã‚¤ãƒˆåˆ¶ç´„"><a class="header" href="#trait-boundsãƒˆãƒ¬ã‚¤ãƒˆåˆ¶ç´„">Trait boundsï¼ˆãƒˆãƒ¬ã‚¤ãƒˆåˆ¶ç´„ï¼‰</a></h1>
<p>We've seen two use cases for traits so far:</p>
<ul>
<li>Unlocking "built-in" behaviour (e.g. operator overloading)</li>
<li>Adding new behaviour to existing types (i.e. extension traits)</li>
</ul>
<blockquote>
<p>ã“ã‚Œã¾ã§ã€ãƒˆãƒ¬ã‚¤ãƒˆã®2ã¤ã®ãƒ¦ãƒ¼ã‚¹ã‚±ãƒ¼ã‚¹ã‚’ç¢ºèªã—ã¾ã—ãŸã€‚</p>
<ul>
<li>ä¾‹ãˆã°ã€æ¼”ç®—å­ã®ã‚ªãƒ¼ãƒãƒ¼ãƒ­ãƒ¼ãƒ‰ãªã©ã€ã€Œçµ„ã¿è¾¼ã¿æ©Ÿèƒ½ã€ã®æŒ¯ã‚‹èˆã„ã‚’è§£é™¤ã™ã‚‹ã€‚</li>
<li>æ‹¡å¼µãƒˆãƒ¬ã‚¤ãƒˆãªã©ã€æ—¢å­˜ã®å‹ã«æ–°ã—ã„æŒ¯ã‚‹èˆã„ã‚’è¿½åŠ ã™ã‚‹ã€‚</li>
</ul>
</blockquote>
<p>There's a third use case: <strong>generic programming</strong>.</p>
<blockquote>
<p>3ã¤ç›®ã®ãƒ¦ãƒ¼ã‚¹ã‚±ãƒ¼ã‚¹ãŒã‚ã‚Šã¾ã™ã€‚ãã‚Œã¯<strong>ã‚¸ã‚§ãƒãƒªãƒƒã‚¯ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°</strong>ã§ã™ã€‚</p>
</blockquote>
<h2 id="the-problemèª²é¡Œ"><a class="header" href="#the-problemèª²é¡Œ">The problemï¼ˆèª²é¡Œï¼‰</a></h2>
<p>All our functions and methods, so far, have been working with <strong>concrete types</strong>.<br />
Code that operates on concrete types is usually straightforward to write and understand. But it's also
limited in its reusability.<br />
Let's imagine, for example, that we want to write a function that returns <code>true</code> if an integer is even.
Working with concrete types, we'd have to write a separate function for each integer type we want to
support:</p>
<blockquote>
<p>ã“ã‚Œã¾ã§ã€ã™ã¹ã¦ã®é–¢æ•°ã¨ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€<strong>å…·è±¡å‹</strong>ã¨æ©Ÿèƒ½ã—ã¦ãã¾ã—ãŸã€‚
å…·è±¡å‹ã«å¯¾ã—ã¦æ“ä½œã™ã‚‹ã‚³ãƒ¼ãƒ‰ã¯ã€é€šå¸¸ã€è¨˜è¿°ã™ã‚‹ã“ã¨ã‚„ç†è§£ã™ã‚‹ã“ã¨ãŒç°¡å˜ã§ã™ã€‚
ã—ã‹ã—ã€ãã‚Œã¯ãã®å†åˆ©ç”¨æ€§ã‚’åˆ¶é™ã•ã‚Œã¾ã™ã€‚
ä¾‹ãˆã°ã€æ•´æ•°ãŒå¶æ•°ã§ã‚ã‚‹å ´åˆã«<code>true</code>ã‚’è¿”ã™é–¢æ•°ã‚’è¨˜è¿°ã—ãŸã„ã¨ã—ã¾ã—ã‚‡ã†ã€‚
å…·è±¡å‹ã¨æ©Ÿèƒ½ã™ã‚‹å ´åˆã€ã‚µãƒãƒ¼ãƒˆã—ãŸã„æ•´æ•°å‹ãã‚Œãã‚Œã«å¯¾ã—ã¦ã€åˆ¥ã€…ã®é–¢æ•°ã‚’è¨˜è¿°ã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn is_even_i32(n: i32) -&gt; bool {
    n % 2 == 0
}

fn is_even_i64(n: i64) -&gt; bool {
    n % 2 == 0
}

// Etc.
<span class="boring">}</span></code></pre></pre>
<p>Alternatively, we could write a single extension trait and then different implementations for each integer type:</p>
<p>ä»£ã‚ã‚Šã«ã€1ã¤ã®æ‹¡å¼µãƒˆãƒ¬ã‚¤ãƒˆã¨æ•´æ•°å‹ãã‚Œãã‚Œã«ç•°ãªã‚‹å®Ÿè£…ã‚’è¨˜è¿°ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait IsEven {
    fn is_even(&amp;self) -&gt; bool;
}

impl IsEven for i32 {
    fn is_even(&amp;self) -&gt; bool {
        self % 2 == 0
    }
}

impl IsEven for i64 {
    fn is_even(&amp;self) -&gt; bool {
        self % 2 == 0
    }
}

// Etc.
<span class="boring">}</span></code></pre></pre>
<p>The duplication remains.</p>
<blockquote>
<p>é‡è¤‡ã¯æ®‹ã‚Šã¾ã™ã€‚</p>
</blockquote>
<h2 id="generic-programmingã‚¸ã‚§ãƒãƒªãƒƒã‚¯ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°"><a class="header" href="#generic-programmingã‚¸ã‚§ãƒãƒªãƒƒã‚¯ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°">Generic programmingï¼ˆã‚¸ã‚§ãƒãƒªãƒƒã‚¯ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ï¼‰</a></h2>
<p>We can do better using <strong>generics</strong>.<br />
Generics allow us to write code that works with a <strong>type parameter</strong> instead of a concrete type:</p>
<blockquote>
<p><strong>ã‚¸ã‚§ãƒãƒªãƒƒã‚¯</strong>ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã§ã€ã‚ˆã‚Šè‰¯ãã§ãã¾ã™ã€‚
ã‚¸ã‚§ãƒãƒªãƒƒã‚¯ã¯ã€å…·è±¡å‹ã®ä»£ã‚ã‚Šã«<strong>å‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼</strong>ã¨æ©Ÿèƒ½ã™ã‚‹ã‚³ãƒ¼ãƒ‰ã‚’è¨˜è¿°ã§ãã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn print_if_even&lt;T&gt;(n: T)
where
    T: IsEven + Debug
{
    if n.is_even() {
        println!("{n:?} is even");
    }
}
<span class="boring">}</span></code></pre></pre>
<p><code>print_if_even</code> is a <strong>generic function</strong>.<br />
It isn't tied to a specific input type. Instead, it works with any type <code>T</code> that:</p>
<ul>
<li>Implements the <code>IsEven</code> trait.</li>
<li>Implements the <code>Debug</code> trait.</li>
</ul>
<blockquote>
<p><code>print_if_even</code>ã¯ã€<strong>ã‚¸ã‚§ãƒãƒªãƒƒã‚¯é–¢æ•°</strong>ã§ã™ã€‚
ãã‚Œã¯ã€ç‰¹å®šã®å…¥åŠ›å‹ã«çµã³ã¤ã„ã¦ã„ã¾ã›ã‚“ã€‚ä»£ã‚ã‚Šã«ã€ãã‚Œã¯æ¬¡ã®ä»»æ„ã®<code>T</code>å‹ã¨æ©Ÿèƒ½ã—ã¾ã™ã€‚</p>
<ul>
<li><code>IsEven</code>ãƒˆãƒ¬ã‚¤ãƒˆã‚’å®Ÿè£…ã—ã¦ã„ã‚‹ã€‚</li>
<li><code>Debug</code>ãƒˆãƒ¬ã‚¤ãƒˆã‚’å®Ÿè£…ã—ã¦ã„ã‚‹ã€‚</li>
</ul>
</blockquote>
<p>This contract is expressed with a <strong>trait bound</strong>: <code>T: IsEven + Debug</code>.<br />
The <code>+</code> symbol is used to require that <code>T</code> implements multiple traits. <code>T: IsEven + Debug</code> is equivalent to
"where <code>T</code> implements <code>IsEven</code> <strong>and</strong> <code>Debug</code>".</p>
<blockquote>
<p>ã“ã®å¥‘ç´„ã¯ã€<code>T: IsEven + Debug</code>ã¨ã„ã†ã€<strong>ãƒˆãƒ¬ã‚¤ãƒˆåˆ¶ç´„</strong>ã§è¡¨ç¾ã•ã‚Œã¦ã„ã¾ã™ã€‚
<code>+</code>è¨˜å·ã¯ã€<code>T</code>ãŒè¤‡æ•°ã®ãƒˆãƒ¬ã‚¤ãƒˆã‚’å®Ÿè£…ã—ã¦ã„ã‚‹ã“ã¨ã‚’è¦æ±‚ã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚
<code>T: IsEven + Debug</code>ã¯ã€ã€Œ<code>T</code>ãŒ<code>IsEven</code> <strong>ã¨</strong> <code>Debug</code>ã‚’å®Ÿè£…ã—ã¦ã„ã‚‹ã€ã¨åŒç­‰ã§ã™ã€‚</p>
</blockquote>
<h2 id="trait-boundsãƒˆãƒ¬ã‚¤ãƒˆåˆ¶ç´„-1"><a class="header" href="#trait-boundsãƒˆãƒ¬ã‚¤ãƒˆåˆ¶ç´„-1">Trait boundsï¼ˆãƒˆãƒ¬ã‚¤ãƒˆåˆ¶ç´„ï¼‰</a></h2>
<p>What purpose do trait bounds serve in <code>print_if_even</code>?<br />
To find out, let's try to remove them:</p>
<blockquote>
<p><code>print_if_even</code>ã«ãŠã„ã¦ã€ãƒˆãƒ¬ã‚¤ãƒˆåˆ¶ç´„ã¯ã©ã®ã‚ˆã†ãªç›®çš„ãŒã‚ã‚‹ã®ã§ã—ã‚‡ã†ã‹ï¼Ÿ
ãã‚Œã‚’è¦‹å‡ºã™ãŸã‚ã«ã€ãã‚Œã‚‰ã‚’å‰Šé™¤ã—ã¦ã¿ã¾ã—ã‚‡ã†ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn print_if_even&lt;T&gt;(n: T) {
    if n.is_even() {
        println!("{n:?} is even");
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This code won't compile:</p>
<blockquote>
<p>ã“ã®ã‚³ãƒ¼ãƒ‰ã¯ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã‚Œã¾ã›ã‚“ã€‚</p>
</blockquote>
<pre><code class="language-text">error[E0599]: no method named `is_even` found for type parameter `T` in the current scope
 --&gt; src/lib.rs:2:10
  |
1 | fn print_if_even&lt;T&gt;(n: T) {
  |                  - method `is_even` not found for this type parameter
2 |     if n.is_even() {
  |          ^^^^^^^ method not found in `T`

error[E0277]: `T` doesn't implement `Debug`
 --&gt; src/lib.rs:3:19
  |
3 |         println!("{n:?} is even");
  |                   ^^^^^ `T` cannot be formatted using `{:?}` because it doesn't implement `Debug`
  |
help: consider restricting type parameter `T`
  |
1 | fn print_if_even&lt;T: std::fmt::Debug&gt;(n: T) {
  |                   +++++++++++++++++
</code></pre>
<p>Without trait bounds, the compiler doesn't know what <code>T</code> <strong>can do</strong>.<br />
It doesn't know that <code>T</code> has an <code>is_even</code> method, and it doesn't know how to format <code>T</code> for printing.
From the compiler point of view, a bare <code>T</code> has no behaviour at all.<br />
Trait bounds restrict the set of types that can be used by ensuring that the behaviour required by the function
body is present.</p>
<blockquote>
<p>ãƒˆãƒ¬ã‚¤ãƒˆåˆ¶ç´„ãªã—ã§ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ¼ã¯<code>T</code>ãŒ<strong>ã§ãã‚‹ã“ã¨</strong>ã‚’çŸ¥ã‚Šã¾ã›ã‚“ã€‚
ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ¼ã¯ã€<code>T</code>ãŒ<code>is_even</code>ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æŒã£ã¦ã„ã‚‹ã“ã¨ã‚’çŸ¥ã‚‰ãšã€å‡ºåŠ›ã™ã‚‹ãŸã‚ã«<code>T</code>ã‚’æ›¸å¼åŒ–ã™ã‚‹æ–¹æ³•ã‚’çŸ¥ã‚Šã¾ã›ã‚“ã€‚
ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ¼ã®è¦³ç‚¹ã‹ã‚‰ã€ç´ ã®<code>T</code>ã¯ã¾ã£ãŸãæŒ¯ã‚‹èˆã„ã‚’æŒã£ã¦ã„ã¾ã›ã‚“ã€‚
ãƒˆãƒ¬ã‚¤ãƒˆåˆ¶ç´„ã¯ã€é–¢æ•°æœ¬ä½“ã«å­˜åœ¨ã™ã‚‹è¦æ±‚ã•ã‚ŒãŸæŒ¯ã‚‹èˆã„ã‚’ç¢ºå®Ÿã«ã™ã‚‹ã“ã¨ã§ã€ä½¿ç”¨ã§ãã‚‹å‹ã®é›†åˆã‚’åˆ¶ç´„ã—ã¾ã™ã€‚</p>
</blockquote>
<h2 id="syntax-inlining-trait-boundsæ§‹æ–‡ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³ãƒˆãƒ¬ã‚¤ãƒˆåˆ¶ç´„"><a class="header" href="#syntax-inlining-trait-boundsæ§‹æ–‡ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³ãƒˆãƒ¬ã‚¤ãƒˆåˆ¶ç´„">Syntax: inlining trait boundsï¼ˆæ§‹æ–‡ï¼šã‚¤ãƒ³ãƒ©ã‚¤ãƒ³ãƒˆãƒ¬ã‚¤ãƒˆåˆ¶ç´„ï¼‰</a></h2>
<p>All the examples above used a <strong><code>where</code> clause</strong> to specify trait bounds:</p>
<blockquote>
<p>ä¸Šè¨˜ä¾‹ã™ã¹ã¦ã¯ã€ãƒˆãƒ¬ã‚¤ãƒˆåˆ¶ç´„ã‚’æŒ‡å®šã™ã‚‹ãŸã‚ã«<strong>whereç¯€</strong>ã‚’ä½¿ç”¨ã—ã¾ã—ãŸã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn print_if_even&lt;T&gt;(n: T)
where
    T: IsEven + Debug
//  ^^^^^^^^^^^^^^^^^
//  This is a `where` clause
{
    // [...]
}
<span class="boring">}</span></code></pre></pre>
<p>If the trait bounds are simple, you can <strong>inline</strong> them directly next to the type parameter:</p>
<blockquote>
<p>ãƒˆãƒ¬ã‚¤ãƒˆåˆ¶ç´„ãŒå˜ç´”ã§ã‚ã‚Œã°ã€å‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ã®æ¬¡ã«ãã‚Œã‚‰ã‚’ç›´æ¥<strong>ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³</strong>ã§è¨˜è¿°ã§ãã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn print_if_even&lt;T: IsEven + Debug&gt;(n: T) {
    //           ^^^^^^^^^^^^^^^^^
    //           This is an inline trait bound
    // [...]
}
<span class="boring">}</span></code></pre></pre>
<h2 id="syntax-meaningful-namesæ§‹æ–‡æ„å‘³ã®ã‚ã‚‹åå‰"><a class="header" href="#syntax-meaningful-namesæ§‹æ–‡æ„å‘³ã®ã‚ã‚‹åå‰">Syntax: meaningful namesï¼ˆæ§‹æ–‡ï¼šæ„å‘³ã®ã‚ã‚‹åå‰ï¼‰</a></h2>
<p>In the examples above, we used <code>T</code> as the type parameter name. This is a common convention when a function has
only one type parameter.<br />
Nothing stops you from using a more meaningful name, though:</p>
<blockquote>
<p>ä¸Šè¨˜ä¾‹ã«ãŠã„ã¦ã€å‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼åã¨ã—ã¦<code>T</code>ã‚’ä½¿ç”¨ã—ã¾ã—ãŸã€‚
ã“ã‚Œã¯ã€é–¢æ•°ãŒãŸã£ãŸ1ã¤ã®å‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ã‚’æŒã¤ã¨ãã®æ…£ä¾‹ã§ã™ã€‚
ã—ã‹ã—ã€ã‚ˆã‚Šæ„å‘³ã®ã‚ã‚‹åå‰ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã¯å¦¨ã’ã‚‰ã‚Œã¾ã›ã‚“ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn print_if_even&lt;Number: IsEven + Debug&gt;(n: Number) {
    // [...]
}
<span class="boring">}</span></code></pre></pre>
<p>It is actually <strong>desirable</strong> to use meaningful names when there are multiple type parameters at play or when the name
<code>T</code> doesn't convey enough information about the type's role in the function.
Maximize clarity and readability when naming type parameters, just as you would with variables or function parameters.
Follow Rust's conventions, though: use <a href="https://rust-lang.github.io/api-guidelines/naming.html#casing-conforms-to-rfc-430-c-case">upper camel case for type parameter names</a>.</p>
<blockquote>
<p>è¤‡æ•°ã®å‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ãŒé–¢ä¸ã™ã‚‹ã¨ãã‚„ã€é–¢æ•°å†…ã®å‹ã®å½¹ç›®ã«ã¤ã„ã¦ã€åå‰<code>T</code>ãŒååˆ†ãªæƒ…å ±ã‚’ä¼ãˆã¦ã„ãªã„ã¨ãã€å®Ÿéš›ã€æ„å‘³ã®ã‚ã‚‹åå‰ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã¯<strong>æœ›ã¾ã—ã„</strong>ã§ã™ã€‚
å‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ã«åå‰ã‚’ä»˜ã‘ã‚‹ã¨ãã®æœ€å¤§é™ã®æ˜ç¢ºåŒ–ã¨èª­ã¿ã‚„ã™ã•ã¯ã€ã¡ã‚‡ã†ã©å¤‰æ•°ã‚„é–¢æ•°ã®å¼•æ•°ã«åå‰ã‚’ä»˜ã‘ã‚‹ã¨ãã¨åŒã˜ã§ã™ã€‚
ãŸã ã—ã€å‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ã«å¤§æ–‡å­—ã®ã‚­ãƒ£ãƒ¡ãƒ«ã‚±ãƒ¼ã‚¹ã‚’ä½¿ç”¨ã™ã‚‹ã€Rustã®æ…£ç¿’ã«å¾“ã£ã¦ãã ã•ã„ã€‚</p>
</blockquote>
<h2 id="the-function-signature-is-kingé–¢æ•°ã®ã‚·ã‚°ãƒãƒãƒ£ãƒ¼ã¯ç‹æ§˜"><a class="header" href="#the-function-signature-is-kingé–¢æ•°ã®ã‚·ã‚°ãƒãƒãƒ£ãƒ¼ã¯ç‹æ§˜">The function signature is kingï¼ˆé–¢æ•°ã®ã‚·ã‚°ãƒãƒãƒ£ãƒ¼ã¯ç‹æ§˜ï¼‰</a></h2>
<p>You may wonder why we need trait bounds at all. Can't the compiler infer the required traits from the function's body?<br />
It could, but it won't.<br />
The rationale is the same as for <a href="04_traits/../02_basic_calculator/02_variables.html#function-arguments-are-variables">explicit type annotations on function parameters</a>:
each function signature is a contract between the caller and the callee, and the terms must be explicitly stated.
This allows for better error messages, better documentation, less unintentional breakages across versions,
and faster compilation times.</p>
<blockquote>
<p>ãƒˆãƒ¬ã‚¤ãƒˆåˆ¶ç´„ãŒå¿…è¦ãªç†ç”±ã«æˆ¸æƒ‘ã£ã¦ã„ã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ¼ã¯ã€é–¢æ•°ã®æœ¬ä½“ã‹ã‚‰è¦æ±‚ã•ã‚Œã‚‹ãƒˆãƒ¬ã‚¤ãƒˆã‚’æ¨æ¸¬ã™ã‚‹ã“ã¨ãŒã§ããªã„ã®ã§ã—ã‚‡ã†ã‹ï¼Ÿ
ã§ãã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ãŒã€ã—ã¾ã›ã‚“ã€‚
è«–ç†çš„æ ¹æ‹ ã¯ã€æ˜ç¤ºçš„ãªé–¢æ•°å¼•æ•°ã®å‹æ³¨é‡ˆã¨åŒã˜ã§ã™ã€‚
ãã‚Œãã‚Œã®é–¢æ•°ã®ã‚·ã‚°ãƒãƒãƒ£ãƒ¼ã¯ã€å‘¼ã³å‡ºã•ã‚Œã‚‹å´ã¨å‘¼ã³å‡ºã™å´ã®é–“ã®å¥‘ç´„ã§ã‚ã‚Šã€ãã®è¡¨ç¾ã¯æ˜ç¤ºçš„ã«è¿°ã¹ã‚‰ã‚Œãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚
ã“ã‚Œã¯ã€è‰¯ã„ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã€è‰¯ã„ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã€ãƒãƒ¼ã‚¸ãƒ§ãƒ³é–“ã®æ„å›³ã—ãªã„ç ´å£Šã®æ¸›å°‘ã€ãã—ã¦ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚é–“ã®çŸ­ç¸®ã‚’å¯èƒ½ã«ã—ã¾ã™ã€‚</p>
</blockquote>
<h2 id="exercise-31"><a class="header" href="#exercise-31">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/04_traits/05_trait_bounds"><code>04_traits/05_trait_bounds</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="string-slicesæ–‡å­—åˆ—ã‚¹ãƒ©ã‚¤ã‚¹"><a class="header" href="#string-slicesæ–‡å­—åˆ—ã‚¹ãƒ©ã‚¤ã‚¹">String slicesï¼ˆæ–‡å­—åˆ—ã‚¹ãƒ©ã‚¤ã‚¹ï¼‰</a></h1>
<p>Throughout the previous chapters you've seen quite a few <strong>string literals</strong> being used in the code,
like <code>"To-Do"</code> or <code>"A ticket description"</code>.
They were always followed by a call to <code>.to_string()</code> or <code>.into()</code>. It's time to understand why!</p>
<blockquote>
<p>å‰ã®ç« ã‚’é€šã˜ã¦ã€ã‚³ãƒ¼ãƒ‰å†…ã§ä½¿ç”¨ã•ã‚ŒãŸ<code>"To-Do"</code>ã¾ãŸã¯<code>"A ticket description"</code>ã®ã‚ˆã†ãªã€<strong>æ–‡å­—åˆ—ãƒªãƒ†ãƒ©ãƒ«</strong>ã‚’ã„ãã¤ã‹ç¢ºèªã—ã¾ã—ãŸã€‚
ãã‚Œã‚‰ã¯å¸¸ã«ã€<code>to_string()</code>ã¾ãŸã¯<code>into()</code>ã®å‘¼ã³å‡ºã—ãŒç¶šãã¾ã—ãŸã€‚ãã‚ŒãŒãªãœãªã®ã‹ã‚’ç†è§£ã™ã‚‹æ™‚ãŒãã¾ã—ãŸï¼</p>
</blockquote>
<h2 id="string-literalsæ–‡å­—åˆ—ãƒªãƒ†ãƒ©ãƒ«"><a class="header" href="#string-literalsæ–‡å­—åˆ—ãƒªãƒ†ãƒ©ãƒ«">String literalsï¼ˆæ–‡å­—åˆ—ãƒªãƒ†ãƒ©ãƒ«ï¼‰</a></h2>
<p>You define a string literal by enclosing the raw text in double quotes:</p>
<blockquote>
<p>ãƒ€ãƒ–ãƒ«ã‚¯ã‚¦ã‚©ãƒ¼ãƒˆã§ç´ ã®ãƒ†ã‚­ã‚¹ãƒˆã‚’å›²ã‚€ã“ã¨ã§ã€æ–‡å­—åˆ—ãƒªãƒ†ãƒ©ãƒ«ã‚’å®šç¾©ã—ã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = "Hello, world!";
<span class="boring">}</span></code></pre></pre>
<p>The type of <code>s</code> is <code>&amp;str</code>, a <strong>reference to a string slice</strong>.</p>
<blockquote>
<p><code>s</code>ã®å‹ã¯<code>&amp;str</code>ã§ã€<strong>æ–‡å­—åˆ—ã‚¹ãƒ©ã‚¤ã‚¹ã¸ã®å‚ç…§</strong>ã§ã™ã€‚</p>
</blockquote>
<h2 id="memory-layoutãƒ¡ãƒ¢ãƒªãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ-1"><a class="header" href="#memory-layoutãƒ¡ãƒ¢ãƒªãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ-1">Memory layoutï¼ˆãƒ¡ãƒ¢ãƒªãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆï¼‰</a></h2>
<p><code>&amp;str</code> and <code>String</code> are different typesâ€”they're not interchangeable.<br />
Let's recall the memory layout of a <code>String</code> from our
<a href="04_traits/../03_ticket_v1/09_heap.html">previous exploration</a>.
If we run:</p>
<blockquote>
<p><code>&amp;str</code>ã¨<code>String</code>ã¯ç•°ãªã‚‹å‹ã§ã€ãã‚Œã‚‰ã¯äº¤æ›ã§ãã¾ã›ã‚“ã€‚
å‰ã®æ¢æ±‚ã‹ã‚‰<code>String</code>ã®ãƒ¡ãƒ¢ãƒªãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã‚’æ€ã„å‡ºã—ã¾ã—ã‚‡ã†ã€‚
ã‚‚ã—ã€æ¬¡ã‚’å®Ÿè¡Œã—ãŸå ´åˆãƒ»ãƒ»ãƒ»</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut s = String::with_capacity(5);
s.push_str("Hello");
<span class="boring">}</span></code></pre></pre>
<p>we'll get this scenario in memory:</p>
<blockquote>
<p>ãƒ¡ãƒ¢ãƒªä¸Šã§æ¬¡ã®ã‚·ãƒŠãƒªã‚ªãŒå¾—ã‚‰ã‚Œã¾ã™ã€‚</p>
</blockquote>
<pre><code class="language-text">      +---------+--------+----------+
Stack | pointer | length | capacity |
      |  |      |   5    |    5     |
      +--|------+--------+----------+
         |
         |
         v
       +---+---+---+---+---+
Heap:  | H | e | l | l | o |
       +---+---+---+---+---+
</code></pre>
<p>If you remember, we've <a href="04_traits/../03_ticket_v1/10_references_in_memory.html">also examined</a>
how a <code>&amp;String</code> is laid out in memory:</p>
<blockquote>
<p>è¦šãˆã¦ã„ã‚‹å ´åˆã€ãƒ¡ãƒ¢ãƒªå†…ã§<code>&amp;String</code>ãŒé…ç½®ã•ã‚Œã‚‹æ–¹æ³•ã‚‚èª¿æŸ»ã—ã¾ã—ãŸã€‚</p>
</blockquote>
<pre><code class="language-text">     --------------------------------------
     |                                    |
+----v----+--------+----------+      +----|----+
| pointer | length | capacity |      | pointer |
|    |    |   5    |    5     |      |         |
+----|----+--------+----------+      +---------+
     |        s                          &amp;s
     |
     v
   +---+---+---+---+---+
   | H | e | l | l | o |
   +---+---+---+---+---+
</code></pre>
<p><code>&amp;String</code> points to the memory location where the <code>String</code>'s metadata is stored.<br />
If we follow the pointer, we get to the heap-allocated data. In particular, we get to the first byte of the string, <code>H</code>.</p>
<blockquote>
<p><code>&amp;String</code>ã¯ã€<code>String</code>ã®ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’ä¿å­˜ã—ãŸãƒ¡ãƒ¢ãƒªã®å ´æ‰€ã‚’æŒ‡ã—ç¤ºã—ã¦ã„ã¾ã™ã€‚
ãƒã‚¤ãƒ³ã‚¿ã‚’ãŸã©ã£ãŸå ´åˆã€ãƒ’ãƒ¼ãƒ—ã«å‰²ã‚Šå½“ã¦ã‚‰ã‚ŒãŸãƒ‡ãƒ¼ã‚¿ã«åˆ°é”ã—ã¾ã™ã€‚ç‰¹ã«ã€æ–‡å­—åˆ—ã®æœ€åˆã®ãƒã‚¤ãƒˆã®<code>H</code>ã«åˆ°é”ã—ã¾ã™ã€‚</p>
</blockquote>
<p>What if we wanted a type that represents a <strong>substring</strong> of <code>s</code>? E.g. <code>ello</code> in <code>Hello</code>?</p>
<blockquote>
<p>ä¾‹ãˆã°ã€<code>Hello</code>å†…ã®<code>ello</code>ã®ã‚ˆã†ã«ã€<code>s</code>ã®<strong>éƒ¨åˆ†æ–‡å­—åˆ—</strong>ã‚’è¡¨ç¾ã™ã‚‹å‹ãŒæ¬²ã—ã„å ´åˆã©ã†ãªã‚‹ã§ã—ã‚‡ã†ã‹ï¼Ÿ</p>
</blockquote>
<h2 id="string-slicesæ–‡å­—åˆ—ã‚¹ãƒ©ã‚¤ã‚¹-1"><a class="header" href="#string-slicesæ–‡å­—åˆ—ã‚¹ãƒ©ã‚¤ã‚¹-1">String slicesï¼ˆæ–‡å­—åˆ—ã‚¹ãƒ©ã‚¤ã‚¹ï¼‰</a></h2>
<p>A <code>&amp;str</code> is a <strong>view</strong> into a string, a <strong>reference</strong> to a sequence of UTF-8 bytes stored elsewhere.
You can, for example, create a <code>&amp;str</code> from a <code>String</code> like this:</p>
<blockquote>
<p><code>&amp;str</code>ã¯æ–‡å­—åˆ—å†…éƒ¨ã¸ã®<strong>ãƒ“ãƒ¥ãƒ¼</strong>ã§ã‚ã‚Šã€ä»–ã®å ´æ‰€ã«ä¿å­˜ã•ã‚ŒãŸUTF-8ãƒã‚¤ãƒˆã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã¸ã®å‚ç…§ã§ã™ã€‚
ä¾‹ãˆã°ã€æ¬¡ã®ã‚ˆã†ã«<code>String</code>ã‹ã‚‰<code>&amp;str</code>ã‚’ä½œæˆã§ãã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut s = String::with_capacity(5);
s.push_str("Hello");
// Create a string slice reference from the `String`, skipping the first byte.
// æœ€åˆã®ãƒã‚¤ãƒˆã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ã¦ã€`String`ã‹ã‚‰æ–‡å­—åˆ—ã‚¹ãƒ©ã‚¤ã‚¹ã®å‚ç…§ã‚’ä½œæˆã—ã¾ã™ã€‚
let slice: &amp;str = &amp;s[1..];
<span class="boring">}</span></code></pre></pre>
<p>In memory, it'd look like this:</p>
<blockquote>
<p>ãƒ¡ãƒ¢ãƒªå†…ã§ã€ãã‚Œã¯æ¬¡ã®ã‚ˆã†ã«è¦‹ãˆã¾ã™ã€‚</p>
</blockquote>
<pre><code class="language-text">                    s                              slice
      +---------+--------+----------+      +---------+--------+
Stack | pointer | length | capacity |      | pointer | length |
      |    |    |   5    |    5     |      |    |    |   4    |
      +----|----+--------+----------+      +----|----+--------+
           |        s                           |
           |                                    |
           v                                    |
         +---+---+---+---+---+                  |
Heap:    | H | e | l | l | o |                  |
         +---+---+---+---+---+                  |
               ^                                |
               |                                |
               +--------------------------------+
</code></pre>
<p><code>slice</code> stores two pieces of information on the stack:</p>
<ul>
<li>A pointer to the first byte of the slice.</li>
<li>The length of the slice.</li>
</ul>
<blockquote>
<p><code>ã‚¹ãƒ©ã‚¤ã‚¹</code>ã¯ã€ã‚¹ã‚¿ãƒƒã‚¯ä¸Šã®2ã¤ã®æƒ…å ±ã‚’è“„ç©ã—ã¾ã™ã€‚</p>
<ul>
<li>ã‚¹ãƒ©ã‚¤ã‚¹ã®æœ€åˆã®ãƒã‚¤ãƒˆã¸ã®ãƒã‚¤ãƒ³ã‚¿ãƒ¼</li>
<li>ã‚¹ãƒ©ã‚¤ã‚¹ã®é•·ã•</li>
</ul>
</blockquote>
<p><code>slice</code> doesn't own the data, it just points to it: it's a <strong>reference</strong> to the <code>String</code>'s heap-allocated data.<br />
When <code>slice</code> is dropped, the heap-allocated data won't be deallocated, because it's still owned by <code>s</code>.
That's why <code>slice</code> doesn't have a <code>capacity</code> field: it doesn't own the data, so it doesn't need to know how much
space it was allocated for it; it only cares about the data it references.</p>
<blockquote>
<p><code>ã‚¹ãƒ©ã‚¤ã‚¹</code>ã¯å˜ã«ãƒ‡ãƒ¼ã‚¿ã‚’æŒ‡ã—ç¤ºã™ãŸã‚ã€<code>ã‚¹ãƒ©ã‚¤ã‚¹</code>ã¯ãƒ‡ãƒ¼ã‚¿ã‚’æ‰€æœ‰ã—ã¾ã›ã‚“ã€‚ãã‚Œã¯<code>String</code>ã®ãƒ’ãƒ¼ãƒ—ã«å‰²ã‚Šå½“ã¦ã‚‰ã‚ŒãŸãƒ‡ãƒ¼ã‚¿ã¸ã®<strong>å‚ç…§</strong>ã§ã™ã€‚
<code>ã‚¹ãƒ©ã‚¤ã‚¹</code>ãŒãƒ‰ãƒ­ãƒƒãƒ—ã•ã‚ŒãŸã¨ãã€ãã‚Œã¯ã¾ã <code>s</code>ã«ã‚ˆã£ã¦æ‰€æœ‰ã•ã‚Œã¦ã„ã‚‹ãŸã‚ã€ãƒ’ãƒ¼ãƒ—ã«å‰²ã‚Šå½“ã¦ã‚‰ã‚ŒãŸãƒ‡ãƒ¼ã‚¿ã¯è§£æ”¾ã•ã‚Œã¾ã›ã‚“ã€‚
ãã‚ŒãŒã€<code>ã‚¹ãƒ©ã‚¤ã‚¹</code>ãŒ<code>capacity</code>ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’æŒãŸãªã„ç†ç”±ã§ã™ã€‚ãã‚Œã¯ãƒ‡ãƒ¼ã‚¿ã‚’æ‰€æœ‰ã—ãªã„ãŸã‚ã€ãã‚Œã¯ãã®ãŸã‚ã«å‰²ã‚Šå½“ã¦ã‚‰ã‚ŒãŸé ˜åŸŸã®é‡ã‚’çŸ¥ã‚‹å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚
å˜ã«ãã‚Œã¯ã€ãã‚ŒãŒå‚ç…§ã™ã‚‹ãƒ‡ãƒ¼ã‚¿ã«ã¤ã„ã¦ã®ã¿æ°—ã«ã‹ã‘ã¦ã„ã¾ã™ã€‚</p>
</blockquote>
<h2 id="str-vs-stringstrã¨string"><a class="header" href="#str-vs-stringstrã¨string"><code>&amp;str</code> vs <code>&amp;String</code>ï¼ˆ&amp;strã¨&amp;Stringï¼‰</a></h2>
<p>As a rule of thumb, use <code>&amp;str</code> rather than <code>&amp;String</code> whenever you need a reference to textual data.<br />
<code>&amp;str</code> is more flexible and generally considered more idiomatic in Rust code.</p>
<blockquote>
<p>çµŒé¨“å‰‡ã‹ã‚‰ã€ãƒ†ã‚­ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ã¸ã®å‚ç…§ãŒå¿…è¦ãªã¨ãã¯ã„ã¤ã§ã‚‚ã€<code>&amp;String</code>ã‚ˆã‚Šã‚‚<code>&amp;str</code>ã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„ã€‚
<code>&amp;str</code>ã¯ã‚ˆã‚ŠæŸ”è»Ÿã§ã€ä¸€èˆ¬çš„ã«Rustã«ãŠã„ã¦ã‚ˆã‚Šæ…£ç¿’çš„ã§ã‚ã‚‹ã¨è€ƒãˆã‚‰ã‚Œã¦ã„ã¾ã™ã€‚</p>
</blockquote>
<p>If a method returns a <code>&amp;String</code>, you're promising that there is heap-allocated UTF-8 text somewhere that
<strong>matches exactly</strong> the one you're returning a reference to.<br />
If a method returns a <code>&amp;str</code>, instead, you have a lot more freedom: you're just saying that <em>somewhere</em> there's a
bunch of text data and that a subset of it matches what you need, therefore you're returning a reference to it.</p>
<blockquote>
<p>ãƒ¡ã‚½ãƒƒãƒ‰ãŒ<code>&amp;String</code>ã‚’è¿”ã™å ´åˆã€å‚ç…§ã‚’è¿”ã™ã‚‚ã®ã¨<strong>å®Œå…¨ã«ä¸€è‡´ã™ã‚‹</strong>ã€ãƒ’ãƒ¼ãƒ—ã«å‰²ã‚Šå½“ã¦ã‚‰ã‚ŒãŸUTF-8ãƒ†ã‚­ã‚¹ãƒˆãŒã©ã“ã‹ã«ã‚ã‚‹ã“ã¨ã‚’ç´„æŸã—ã¦ã„ã¾ã™ã€‚
ä»£ã‚ã‚Šã«ãƒ¡ã‚½ãƒƒãƒ‰ãŒ<code>&amp;str</code>ã‚’è¿”ã™å ´åˆã€ã‚ˆã‚Šè‡ªç”±åº¦ãŒé«˜ããªã‚Šã¾ã™ã€‚
ã©ã“ã‹ã«ãƒ†ã‚­ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ã®æŸãŒã‚ã‚Šã€ãã®ã‚µãƒ–ã‚»ãƒƒãƒˆãŒå¿…è¦ãªã‚‚ã®ã¨ä¸€è‡´ã—ã¦ã„ã‚‹ã®ã§ã€ãã®å‚ç…§ã‚’è¿”ã™ã ã‘ã§ã‚ã‚‹ã“ã¨ã‚’å˜ã«è¨€ã£ã¦ã„ã¾ã™ã€‚</p>
</blockquote>
<h2 id="exercise-32"><a class="header" href="#exercise-32">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/04_traits/06_str_slice"><code>04_traits/06_str_slice</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deref-traitderefãƒˆãƒ¬ã‚¤ãƒˆ"><a class="header" href="#deref-traitderefãƒˆãƒ¬ã‚¤ãƒˆ"><code>Deref</code> traitï¼ˆDerefãƒˆãƒ¬ã‚¤ãƒˆï¼‰</a></h1>
<p>In the previous exercise you didn't have to do much, did you?</p>
<blockquote>
<p>å‰ã®æ¼”ç¿’ã«ãŠã„ã¦ã€ã‚ã¾ã‚Šå¤šãã®ã“ã¨ã‚’ã™ã‚‹å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“ã§ã—ãŸã‚ˆã­ï¼Ÿ</p>
</blockquote>
<p>Changing</p>
<blockquote>
<p>å¤‰æ›´å‰</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Ticket {
    pub fn title(&amp;self) -&gt; &amp;String {
        &amp;self.title
    }
}
<span class="boring">}</span></code></pre></pre>
<p>to</p>
<blockquote>
<p>å¤‰æ›´å¾Œ</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Ticket {
    pub fn title(&amp;self) -&gt; &amp;str {
        &amp;self.title
    }
}
<span class="boring">}</span></code></pre></pre>
<p>was all you needed to do to get the code to compile and the tests to pass.
Some alarm bells should be ringing in your head though.</p>
<blockquote>
<p>ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã§ãã‚‹ã‚ˆã†ã«ã‚³ãƒ¼ãƒ‰ã‚’ã—ã¦ã€ãƒ†ã‚¹ãƒˆã«ãƒ‘ã‚¹ã™ã‚‹ãŸã‚ã«å¿…è¦ãªã“ã¨ã¯ã€ã“ã‚Œã ã‘ã§ã—ãŸã€‚
ã—ã‹ã—ã€é ­ã®ä¸­ã§è­¦å ±ãŒé³´ã£ã¦ã„ã‚‹ã¯ãšã§ã™ã€‚</p>
</blockquote>
<h2 id="it-shouldnt-work-but-it-doesãã‚Œã¯æ©Ÿèƒ½ç´ ã¹ãã§ã¯ãªã„ãŒå‹•ä½œã—ã¾ã™"><a class="header" href="#it-shouldnt-work-but-it-doesãã‚Œã¯æ©Ÿèƒ½ç´ ã¹ãã§ã¯ãªã„ãŒå‹•ä½œã—ã¾ã™">It shouldn't work, but it doesï¼ˆãã‚Œã¯æ©Ÿèƒ½ç´ ã¹ãã§ã¯ãªã„ãŒã€å‹•ä½œã—ã¾ã™ï¼‰</a></h2>
<p>Let's review the facts:</p>
<ul>
<li><code>self.title</code> is a <code>String</code></li>
<li><code>&amp;self.title</code> is, therefore, a <code>&amp;String</code></li>
<li>The output of the (modified) <code>title</code> method is <code>&amp;str</code></li>
</ul>
<blockquote>
<p>äº‹å®Ÿã‚’æŒ¯ã‚Šè¿”ã‚Šã¾ã—ã‚‡ã†ã€‚</p>
<ul>
<li><code>self.title</code>ã¯<code>String</code></li>
<li><code>&amp;self.title</code>ã¯ã€ã‚ˆã£ã¦<code>&amp;String</code></li>
<li>ä¿®æ­£ã—ãŸ<code>title</code>ãƒ¡ã‚½ãƒƒãƒ‰ã®å‡ºåŠ›ã¯<code>&amp;str</code></li>
</ul>
</blockquote>
<p>You would expect a compiler error, wouldn't you? <code>Expected &amp;String, found &amp;str</code> or something similar.
Instead, it just works. <strong>Why</strong>?</p>
<blockquote>
<p>ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚¨ãƒ©ãƒ¼ã‚’æœŸå¾…ã—ãŸã®ã§ã¯ãªã„ã§ã—ã‚‡ã†ã‹ï¼Ÿ<code>&amp;Stringã‚’æœŸå¾…ã—ã¾ã—ãŸãŒã€&amp;strã‚’è¦‹ã¤ã‘ã¾ã—ãŸ</code>ã¾ãŸã¯ä½•ã‹åŒæ§˜ãªã‚‚ã®ã‚’ã€‚
ä»£ã‚ã‚Šã«ã€ãã‚Œã¯å˜ç´”ã«æ©Ÿèƒ½ã—ã¾ã™ã€‚<strong>ãªãœã§ã—ã‚‡ã†ã‹</strong>ï¼Ÿ</p>
</blockquote>
<h2 id="deref-to-the-rescuederefãŒæ•‘å‡ºã—ã¾ã™"><a class="header" href="#deref-to-the-rescuederefãŒæ•‘å‡ºã—ã¾ã™"><code>Deref</code> to the rescueï¼ˆ<code>Deref</code>ãŒæ•‘å‡ºã—ã¾ã™ï¼‰</a></h2>
<p>The <code>Deref</code> trait is the mechanism behind the language feature known as <a href="https://doc.rust-lang.org/std/ops/trait.Deref.html#deref-coercion"><strong>deref coercion</strong></a>.<br />
The trait is defined in the standard library, in the <code>std::ops</code> module:</p>
<blockquote>
<p><code>Deref</code>ãƒˆãƒ¬ã‚¤ãƒˆã¯ã€<strong>å‚ç…§å¤–ã—å‹å¼·åˆ¶</strong>ã¨ã—ã¦çŸ¥ã‚‰ã‚Œã‚‹è¨€èªæ©Ÿèƒ½ã®èƒŒå¾Œã«ã‚ã‚‹ãƒ¡ã‚«ãƒ‹ã‚ºãƒ ã§ã™ã€‚
ãã®ãƒˆãƒ¬ã‚¤ãƒˆã¯ã€æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®<code>std::ops</code>ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§å®šç¾©ã•ã‚Œã¦ã„ã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// I've slightly simplified the definition for now.
// We'll see the full definition later on.
// ã“ã“ã§ã¯ã€å®šç¾©ã‚’å°‘ã—ç°¡ç•¥åŒ–ã—ã¦ã„ã¾ã™ã€‚
// å¾Œã§å®Œå…¨ãªå®šç¾©ã‚’ç¢ºèªã™ã‚‹ã¤ã‚‚ã‚Šã§ã™ã€‚
pub trait Deref {
    type Target;

    fn deref(&amp;self) -&gt; &amp;Self::Target;
}
<span class="boring">}</span></code></pre></pre>
<p><code>type Target</code> is an <strong>associated type</strong>.<br />
It's a placeholder for a concrete type that must be specified when the trait is implemented.</p>
<blockquote>
<p><code>type Target</code>ã¯<strong>é–¢é€£å‹</strong>ã§ã™ã€‚
ãã‚Œã¯ã€ãƒˆãƒ¬ã‚¤ãƒˆãŒå®Ÿè£…ã•ã‚ŒãŸã¨ãã«æŒ‡å®šã•ã‚Œã‚‹å¿…è¦ãŒã‚ã‚‹å…·è±¡å‹ã®ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼ã§ã™ã€‚</p>
</blockquote>
<h2 id="deref-coercionå‚ç…§å¤–ã—å‹å¼·åˆ¶"><a class="header" href="#deref-coercionå‚ç…§å¤–ã—å‹å¼·åˆ¶">Deref coercionï¼ˆå‚ç…§å¤–ã—å‹å¼·åˆ¶ï¼‰</a></h2>
<p>By implementing <code>Deref&lt;Target = U&gt;</code> for a type <code>T</code> you're telling the compiler that <code>&amp;T</code> and <code>&amp;U</code> are
somewhat interchangeable.<br />
In particular, you get the following behavior:</p>
<ul>
<li>References to <code>T</code> are implicitly converted into references to <code>U</code> (i.e. <code>&amp;T</code> becomes <code>&amp;U</code>)</li>
<li>You can call on <code>&amp;T</code> all the methods defined on <code>U</code> that take <code>&amp;self</code> as input.</li>
</ul>
<blockquote>
<p>å‹<code>T</code>ã«å¯¾ã—ã¦<code>Deref&lt;Target = U&gt;</code>ã‚’å®Ÿè£…ã™ã‚‹ã“ã¨ã«ã‚ˆã‚Šã€<code>&amp;T</code>ã¨<code>&amp;U</code>ãŒäº¤æ›å¯èƒ½ã§ã‚ã‚‹ã“ã¨ã‚’ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã«ä¼ãˆã¾ã™ã€‚
ç‰¹ã«ã€æ¬¡ã®ã‚ˆã†ãªæŒ¯ã‚‹èˆã„ã‚’å¾—ã‚‰ã‚Œã¾ã™ã€‚</p>
<ul>
<li><code>T</code>ã¸ã®å‚ç…§ã¯ã€æš—é»™çš„ã«<code>U</code>ã¸ã®å‚ç…§ã«å¤‰æ›ã•ã‚Œã¾ã™ï¼ˆã¤ã¾ã‚Šã€<code>&amp;T</code>ã¯<code>&amp;U</code>ã«ãªã‚Šã¾ã™ï¼‰ã€‚</li>
<li>å…¥åŠ›ã¨ã—ã¦<code>&amp;self</code>ã‚’å—ã‘å–ã‚‹<code>U</code>ã§å®šç¾©ã•ã‚ŒãŸã™ã¹ã¦ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’<code>&amp;T</code>ã§å‘¼ã³å‡ºã™ã“ã¨ãŒã§ãã¾ã™ã€‚</li>
</ul>
</blockquote>
<p>There is one more thing around the dereference operator, <code>*</code>, but we don't need it yet (see <code>std</code>'s docs
if you're curious).</p>
<blockquote>
<p>å‚ç…§å¤–ã—æ¼”ç®—å­<code>*</code>ã«ã¯ã€ã‚‚ã†1ã¤ã‚ã‚Šã¾ã™ãŒã€ã¾ã ãã‚Œã¯å¿…è¦ã‚ã‚Šã¾ã›ã‚“ï¼ˆå¥½å¥‡å¿ƒãŒå¼·ã„ã®ã§ã‚ã‚Œã°ã€<code>std</code>ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’å‚ç…§ã—ã¦ãã ã•ã„ï¼‰ã€‚</p>
</blockquote>
<h2 id="string-implements-derefstringã¯derefã‚’å®Ÿè£…ã—ã¦ã„ã¾ã™"><a class="header" href="#string-implements-derefstringã¯derefã‚’å®Ÿè£…ã—ã¦ã„ã¾ã™"><code>String</code> implements <code>Deref</code>ï¼ˆStringã¯Derefã‚’å®Ÿè£…ã—ã¦ã„ã¾ã™ï¼‰</a></h2>
<p><code>String</code> implements <code>Deref</code> with <code>Target = str</code>:</p>
<blockquote>
<p><code>String</code>ã¯ã€<code>Target = str</code>ã‚’æŒã¤<code>Deref</code>ã‚’å®Ÿè£…ã—ã¦ã„ã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Deref for String {
    type Target = str;

    fn deref(&amp;self) -&gt; &amp;str {
        // [...]
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Thanks to this implementation and deref coercion, a <code>&amp;String</code> is automatically converted into a <code>&amp;str</code> when needed.</p>
<blockquote>
<p>ã“ã®å®Ÿè£…ã¨å‚ç…§å¤–ã—å‹å¼·åˆ¶ã®ãŠã‹ã’ã§ã€å¿…è¦ãªã¨ãã«<code>&amp;String</code>ã¯è‡ªå‹•çš„ã«<code>&amp;str</code>ã«å¤‰æ›ã•ã‚Œã¾ã™ã€‚</p>
</blockquote>
<h2 id="dont-abuse-deref-coercionå‚ç…§å¤–ã—å‹å¼·åˆ¶ã‚’ä¹±ç”¨ã—ãªã„"><a class="header" href="#dont-abuse-deref-coercionå‚ç…§å¤–ã—å‹å¼·åˆ¶ã‚’ä¹±ç”¨ã—ãªã„">Don't abuse deref coercionï¼ˆå‚ç…§å¤–ã—å‹å¼·åˆ¶ã‚’ä¹±ç”¨ã—ãªã„ï¼‰</a></h2>
<p>Deref coercion is a powerful feature, but it can lead to confusion.<br />
Automatically converting types can make the code harder to read and understand. If a method with the same name
is defined on both <code>T</code> and <code>U</code>, which one will be called?</p>
<blockquote>
<p>å‚ç…§å¤–ã—å‹å¼·åˆ¶ã¯å¼·åŠ›ãªæ©Ÿèƒ½ã§ã™ãŒã€æ··ä¹±ã‚’æ‹›ãå¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚
å‹ã®è‡ªå‹•å¤‰æ›ã¯ã€ã‚³ãƒ¼ãƒ‰ã‚’èª­ã‚€ã“ã¨ã¨ç†è§£ã™ã‚‹ã“ã¨ã‚’é›£ã—ãã™ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚
<code>T</code>ã¨<code>U</code>ã®ä¸¡æ–¹ã«å®šç¾©ã•ã‚ŒãŸåŒã˜åå‰ã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒã‚ã‚‹å ´åˆã€ã©ã¡ã‚‰ãŒå‘¼ã³å‡ºã•ã‚Œã‚‹ã§ã—ã‚‡ã†ã‹ï¼Ÿ</p>
</blockquote>
<p>We'll examine later in the course the "safest" use cases for deref coercion: smart pointers.</p>
<blockquote>
<p>ã“ã®ã‚³ãƒ¼ã‚¹ã®å¾ŒåŠã§ã€å‚ç…§å¤–ã—å‹å¼·åˆ¶ã®ã€Œæœ€ã‚‚å®‰å…¨ãªã€ãƒ¦ãƒ¼ã‚¹ã‚±ãƒ¼ã‚¹ã‚’èª¿æŸ»ã—ã¾ã™ã€‚ãã‚Œã¯ã‚¹ãƒãƒ¼ãƒˆãƒã‚¤ãƒ³ã‚¿ãƒ¼ã§ã™ã€‚</p>
</blockquote>
<h2 id="exercise-33"><a class="header" href="#exercise-33">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/04_traits/07_deref"><code>04_traits/07_deref</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sized"><a class="header" href="#sized"><code>Sized</code></a></h1>
<p>There's more to <code>&amp;str</code> than meets the eye, even after having
investigated deref coercion.<br />
From our previous <a href="04_traits/../03_ticket_v1/10_references_in_memory.html">discussion on memory layouts</a>,
it would have been reasonable to expect <code>&amp;str</code> to be represented as a single <code>usize</code> on
the stack, a pointer. That's not the case though. <code>&amp;str</code> stores some <strong>metadata</strong> next
to the pointer: the length of the slice it points to. Going back to the example from
<a href="04_traits/06_str_slice.html">a previous section</a>:</p>
<blockquote>
<p>å‚ç…§å¤–ã—å‹å¼·åˆ¶ã‚’èª¿æŸ»ã—ãŸå¾Œã§ã‚‚ã€ç›®ã«è¦‹ãˆã‚‹ä»¥ä¸Šã®ã“ã¨ãŒ<code>&amp;str</code>ã«ã‚ã‚Šã¾ã™ã€‚
å‰ã®ãƒ¡ãƒ¢ãƒªãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã§è­°è«–ã—ãŸå†…å®¹ã‹ã‚‰ã€ãã‚Œã¯<code>&amp;str</code>ãŒã‚¹ã‚¿ãƒƒã‚¯ä¸Šã®å˜ä¸€ã®<code>usize</code>ã€ã¤ã¾ã‚Šãƒã‚¤ãƒ³ã‚¿ãƒ¼ã¨ã—ã¦è¡¨ç¾ã•ã‚Œã‚‹ã“ã¨ã‚’æœŸå¾…ã™ã‚‹ã“ã¨ã¯ç†ç”±ãŒã‚ã‚Šã—ãŸã€‚
ã—ã‹ã—ã€ã“ã®å ´åˆã¯é•ã„ã€<code>&amp;str</code>ã¯ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã®éš£ã«ã„ãã¤ã‹ã®<strong>ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿</strong>ã‚’ä¿å­˜ã—ã¦ã„ã¾ã™ã€‚
ãã‚ŒãŒæŒ‡ã—ç¤ºã™ã‚¹ãƒ©ã‚¤ã‚¹ã®é•·ã•ã§ã™ã€‚
å‰ã®ç¯€ã®ä¾‹ã«æˆ»ã‚Šã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut s = String::with_capacity(5);
s.push_str("Hello");
// Create a string slice reference from the `String`, skipping the first byte.
// æœ€åˆã®ãƒã‚¤ãƒˆã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ãŸã€`String`ã‹ã‚‰ã®æ–‡å­—åˆ—ã‚¹ãƒ©ã‚¤ã‚¹ã®å‚ç…§ã‚’ä½œæˆã—ã¾ã™ã€‚
let slice: &amp;str = &amp;s[1..];
<span class="boring">}</span></code></pre></pre>
<p>In memory, we get:</p>
<pre><code class="language-text">                    s                              slice
      +---------+--------+----------+      +---------+--------+
Stack | pointer | length | capacity |      | pointer | length |
      |    |    |   5    |    5     |      |    |    |   4    |
      +----|----+--------+----------+      +----|----+--------+
           |        s                           |
           |                                    |
           v                                    |
         +---+---+---+---+---+                  |
Heap:    | H | e | l | l | o |                  |
         +---+---+---+---+---+                  |
               ^                                |
               |                                |
               +--------------------------------+
</code></pre>
<p>What's going on?</p>
<blockquote>
<p>ä½•ãŒèµ·ã“ã£ã¦ã„ã‚‹ã®ã§ã—ã‚‡ã†ã‹ï¼Ÿ</p>
</blockquote>
<h2 id="dynamically-sized-typeså‹•çš„ã‚µã‚¤ã‚ºå‹"><a class="header" href="#dynamically-sized-typeså‹•çš„ã‚µã‚¤ã‚ºå‹">Dynamically sized typesï¼ˆå‹•çš„ã‚µã‚¤ã‚ºå‹ï¼‰</a></h2>
<p><code>str</code> is a <strong>dynamically sized type</strong> (DST).<br />
A DST is a type whose size is not known at compile time. Whenever you have a
reference to a DST, like <code>&amp;str</code>, it has to include additional
information about the data it points to. It is a <strong>fat pointer</strong>.<br />
In the case of <code>&amp;str</code>, it stores the length of the slice it points to.
We'll see more examples of DSTs in the rest of the course.</p>
<blockquote>
<p><code>str</code>ã¯<strong>å‹•çš„ã‚µã‚¤ã‚ºå‹</strong>ï¼ˆDSTï¼‰ã§ã™ã€‚
DSTã¯ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã«ã‚µã‚¤ã‚ºãŒã‚ã‹ã‚‰ãªã„å‹ã§ã™ã€‚
<code>&amp;str</code>ã®ã‚ˆã†ãªã€DSTã¸ã®å‚ç…§ã‚’æŒã¤ã¨ãã¯ã„ã¤ã§ã‚‚ã€ãã‚Œã¯ãã‚ŒãŒæŒ‡ã—ç¤ºã™ãƒ‡ãƒ¼ã‚¿ã«ã¤ã„ã¦ã®è¿½åŠ æƒ…å ±ã‚’å«ã‚€å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚
ãã‚Œã¯<strong>ãƒ•ã‚¡ãƒƒãƒˆãƒã‚¤ãƒ³ã‚¿ãƒ¼</strong>ã§ã™ã€‚
<code>&amp;str</code>ã®å ´åˆã€ãã‚Œã¯ãã‚ŒãŒæŒ‡ã—ç¤ºã™ã‚¹ãƒ©ã‚¤ã‚¹ã®é•·ã•ã‚’ä¿å­˜ã—ã¾ã™ã€‚
ã‚³ãƒ¼ã‚¹ã®æ®‹ã‚Šã§ã€DSTã®ã•ã‚‰ãªã‚‹ä¾‹ã‚’ç¢ºèªã—ã¾ã™ã€‚</p>
</blockquote>
<h2 id="the-sized-traitsizedãƒˆãƒ¬ã‚¤ãƒˆ"><a class="header" href="#the-sized-traitsizedãƒˆãƒ¬ã‚¤ãƒˆ">The <code>Sized</code> traitï¼ˆ<code>Sized</code>ãƒˆãƒ¬ã‚¤ãƒˆï¼‰</a></h2>
<p>Rust's <code>std</code> library defines a trait called <code>Sized</code>.</p>
<blockquote>
<p>Rustã®<code>std</code>ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã¯ã€<code>Sized</code>ã¨å‘¼ã°ã‚Œã‚‹ãƒˆãƒ¬ã‚¤ãƒˆã‚’å®šç¾©ã—ã¦ã„ã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Sized {
    // This is an empty trait, no methods to implement.
    // ã“ã‚Œã¯ç©ºã®ãƒˆãƒ¬ã‚¤ãƒˆã§ã€å®Ÿè£…ã™ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚
}
<span class="boring">}</span></code></pre></pre>
<p>A type is <code>Sized</code> if its size is known at compile time. In other words, it's not a DST.</p>
<blockquote>
<p>ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã«ãã®ã‚µã‚¤ã‚ºãŒã‚ã‹ã£ã¦ã„ã‚‹å ´åˆã€ãã®å‹ã¯<code>Sized</code>ã§ã™ã€‚è¨€ã„æ›ãˆã‚Œã°ã€DSTã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚</p>
</blockquote>
<h3 id="marker-traitsãƒãƒ¼ã‚«ãƒ¼ãƒˆãƒ¬ã‚¤ãƒˆ"><a class="header" href="#marker-traitsãƒãƒ¼ã‚«ãƒ¼ãƒˆãƒ¬ã‚¤ãƒˆ">Marker traitsï¼ˆãƒãƒ¼ã‚«ãƒ¼ãƒˆãƒ¬ã‚¤ãƒˆï¼‰</a></h3>
<p><code>Sized</code> is your first example of a <strong>marker trait</strong>.<br />
A marker trait is a trait that doesn't require any methods to be implemented. It doesn't define any behavior.
It only serves to <strong>mark</strong> a type as having certain properties.
The mark is then leveraged by the compiler to enable certain behaviors or optimizations.</p>
<blockquote>
<p><code>Sized</code>ã¯<strong>ãƒãƒ¼ã‚«ãƒ¼ãƒˆãƒ¬ã‚¤ãƒˆ</strong>ã®æœ€åˆã®ä¾‹ã§ã™ã€‚
ãƒãƒ¼ã‚«ãƒ¼ãƒˆãƒ¬ã‚¤ãƒˆã¯ã€å®Ÿè£…ã•ã‚Œã‚‹ãƒ¡ã‚½ãƒƒãƒ‰ã‚’è¦æ±‚ã—ãªã„ãƒˆãƒ¬ã‚¤ãƒˆã§ã™ã€‚ãã‚Œã¯ä½•ã®æŒ¯ã‚‹èˆã„ã‚‚å®šç¾©ã—ã¾ã›ã‚“ã€‚
ãã‚Œã¯ã€ç‰¹å®šã®å±æ€§ã‚’æŒã¤å‹ã¨ã—ã¦<strong>ãƒãƒ¼ã‚¯</strong>ã™ã‚‹ã“ã¨ã®ã¿æä¾›ã—ã¾ã™ã€‚
ãã—ã¦ã€ãƒãƒ¼ã‚¯ã¯ç‰¹å®šã®æŒ¯ã‚‹èˆã„ã¾ãŸã¯æœ€é©åŒ–ã‚’æœ‰åŠ¹ã«ã™ã‚‹ãŸã‚ã«ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ¼ã«ã‚ˆã£ã¦åˆ©ç”¨ã•ã‚Œã¾ã™ã€‚</p>
</blockquote>
<h3 id="auto-traitsè‡ªå‹•ãƒˆãƒ¬ã‚¤ãƒˆ"><a class="header" href="#auto-traitsè‡ªå‹•ãƒˆãƒ¬ã‚¤ãƒˆ">Auto traitsï¼ˆè‡ªå‹•ãƒˆãƒ¬ã‚¤ãƒˆï¼‰</a></h3>
<p>In particular, <code>Sized</code> is also an <strong>auto trait</strong>.<br />
You don't need to implement it explicitly; the compiler implements it automatically for you
based on the type's definition.</p>
<blockquote>
<p>ç‰¹ã«ã€<code>Sized</code>ã¯<strong>è‡ªå‹•ãƒˆãƒ¬ã‚¤ãƒˆ</strong>ã§ã‚‚ã‚ã‚Šã¾ã™ã€‚
ãã‚Œã‚’æ˜ç¤ºçš„ã«å®Ÿè£…ã™ã‚‹å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚
ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ¼ã¯ã€ãã‚Œã‚’å‹ã®å®šç¾©ã«åŸºã¥ã„ã¦è‡ªå‹•çš„ã«å®Ÿè£…ã—ã¾ã™ã€‚</p>
</blockquote>
<h3 id="examplesä¾‹"><a class="header" href="#examplesä¾‹">Examplesï¼ˆä¾‹ï¼‰</a></h3>
<p>All the types we've seen so far are <code>Sized</code>: <code>u32</code>, <code>String</code>, <code>bool</code>, etc.</p>
<blockquote>
<p>ã“ã‚Œã¾ã§ã«è¦‹ã¦ããŸ<code>u32</code>ã€<code>String</code>ã€<code>bool</code>ãªã©ã®ã™ã¹ã¦ã®å‹ã¯<code>Sized</code>ã§ã™ã€‚</p>
</blockquote>
<p><code>str</code>, as we just saw, is not <code>Sized</code>.<br />
<code>&amp;str</code> is <code>Sized</code> though! We know its size at compile time: two <code>usize</code>s, one for the pointer
and one for the length.</p>
<blockquote>
<p>ã¡ã‚‡ã†ã©ç¢ºèªã—ãŸé€šã‚Šã€<code>str</code>ã¯<code>Sized</code>ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚
ã—ã‹ã—ã€<code>&amp;str</code>ã¯<code>Sized</code>ã§ã™ï¼
ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã«ãã®ã‚µã‚¤ã‚ºã‚’çŸ¥ã£ã¦ã„ã¾ã™ã€‚
2ã¤ã®<code>usize</code>ã§ã€1ã¤ã¯ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã§ã€1ã¤ã¯ãã®é•·ã•ã§ã™ã€‚</p>
</blockquote>
<h2 id="exercise-34"><a class="header" href="#exercise-34">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/04_traits/08_sized"><code>04_traits/08_sized</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="from-and-intfromã¨into"><a class="header" href="#from-and-intfromã¨into"><code>From</code> and <code>Int</code>ï¼ˆFromã¨Intoï¼‰</a></h1>
<p>Let's go back to where our string journey started:</p>
<blockquote>
<p>æ–‡å­—åˆ—ã®æ—…ã‚’å§‹ã‚ãŸã“ã¨ã‚ã«æˆ»ã‚Šã¾ã—ã‚‡ã†ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let ticket = Ticket::new("A title".into(), "A description".into(), "To-Do".into());
<span class="boring">}</span></code></pre></pre>
<p>We now know enough to start unpacking what <code>.into()</code> is doing here.</p>
<blockquote>
<p>ç¾åœ¨ã€<code>.into()</code>ãŒä½•ã‚’ã—ã¦ã„ã‚‹ã®ã‹ã‚’è§£æ˜ã‚’å§‹ã‚ã‚‹ã€ååˆ†ãªçŸ¥è­˜ãŒã‚ã‚Šã¾ã™ã€‚</p>
</blockquote>
<h2 id="the-problemèª²é¡Œ-1"><a class="header" href="#the-problemèª²é¡Œ-1">The problemï¼ˆèª²é¡Œï¼‰</a></h2>
<p>This is the signature of the <code>new</code> method:</p>
<blockquote>
<p>ã“ã‚Œã¯ã€<code>new</code>ãƒ¡ã‚½ãƒƒãƒ‰ã®ã‚·ã‚°ãƒãƒãƒ£ãƒ¼ã§ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Ticket {
    pub fn new(title: String, description: String, status: String) -&gt; Self {
        // [...]
    }
}
<span class="boring">}</span></code></pre></pre>
<p>We've also seen that string literals (such as <code>"A title"</code>) are of type <code>&amp;str</code>.<br />
We have a type mismatch here: a <code>String</code> is expected, but we have a <code>&amp;str</code>.
No magical coercion will come to save us this time; we need <strong>to perform a conversion</strong>.</p>
<p>ã¾ãŸã€<code>"A title"</code>ã®ã‚ˆã†ãªæ–‡å­—åˆ—ãƒªãƒ†ãƒ©ãƒ«ãŒ<code>&amp;str</code>å‹ã§ã‚ã‚‹ã“ã¨ã‚’ç¢ºèªã—ã¾ã—ãŸã€‚
ã“ã“ã§ã€å‹ã®ãƒŸã‚¹ãƒãƒƒãƒãŒã‚ã‚Šã¾ã™ã€‚<code>String</code>ãŒæœŸå¾…ã•ã‚Œã¦ã„ã¾ã™ãŒã€<code>&amp;str</code>ãŒã‚ã‚Šã¾ã™ã€‚
ä»Šå›ã¯ã€é­”æ³•ã®å¼·åˆ¶ã¯ã“ã‚Œã‚’æ•‘ã£ã¦ã¯ãã‚Œã¾ã›ã‚“ã€‚<strong>å¤‰æ›ã‚’å®Ÿè¡Œã™ã‚‹</strong>å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚</p>
<h2 id="from-and-intofromã¨into"><a class="header" href="#from-and-intofromã¨into"><code>From</code> and <code>Into</code>ï¼ˆFromã¨Intoï¼‰</a></h2>
<p>The Rust standard library defines two traits for <strong>infallible conversions</strong>: <code>From</code> and <code>Into</code>,
in the <code>std::convert</code> module.</p>
<blockquote>
<p>Rustæ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã¯ã€<code>From</code>ã¨<code>Into</code>ã¨ã„ã†<strong>å¤±æ•—ã—ãªã„å¤‰æ›</strong>ã®ãŸã‚ã®2ã¤ã®ãƒˆãƒ¬ã‚¤ãƒˆã‚’<code>std::convert</code>ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§å®šç¾©ã—ã¦ã„ã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait From&lt;T&gt;: Sized {
    fn from(value: T) -&gt; Self;
}

pub trait Into&lt;T&gt;: Sized {
    fn into(self) -&gt; T;
}
<span class="boring">}</span></code></pre></pre>
<p>These trait definitions showcase a few concepts that we haven't seen before: <strong>supertraits</strong> and <strong>implicit trait bounds</strong>.
Let's unpack those first.</p>
<blockquote>
<p>ã“ã‚Œã‚‰ã®ãƒˆãƒ¬ã‚¤ãƒˆã®å®šç¾©ã¯ã€å‰ã«ç¢ºèªã—ãŸã„ãã¤ã‹ã®æ¦‚å¿µã‚’æŠ«éœ²ã—ã¦ã„ã¾ã™ã€‚<strong>ã‚¹ãƒ¼ãƒ‘ãƒ¼ãƒˆãƒ¬ã‚¤ãƒˆ</strong>ã¨<strong>æš—é»™çš„ãªãƒˆãƒ¬ã‚¤ãƒˆåˆ¶ç´„</strong>ã§ã™ã€‚
ã¾ãšã€ãã‚Œã‚‰ã‚’è§£æ˜ã—ã¾ã—ã‚‡ã†ã€‚</p>
</blockquote>
<h3 id="supertrait--subtraitã‚¹ãƒ¼ãƒ‘ãƒ¼ãƒˆãƒ¬ã‚¤ãƒˆ--ã‚µãƒ–ãƒˆãƒ¬ã‚¤ãƒˆ"><a class="header" href="#supertrait--subtraitã‚¹ãƒ¼ãƒ‘ãƒ¼ãƒˆãƒ¬ã‚¤ãƒˆ--ã‚µãƒ–ãƒˆãƒ¬ã‚¤ãƒˆ">Supertrait / Subtraitï¼ˆã‚¹ãƒ¼ãƒ‘ãƒ¼ãƒˆãƒ¬ã‚¤ãƒˆ / ã‚µãƒ–ãƒˆãƒ¬ã‚¤ãƒˆï¼‰</a></h3>
<p>The <code>From: Sized</code> syntax implies that <code>From</code> is a <strong>subtrait</strong> of <code>Sized</code>: any type that
implements <code>From</code> must also implement <code>Sized</code>.
Alternatively, you could say that <code>Sized</code> is a <strong>supertrait</strong> of <code>From</code>.</p>
<blockquote>
<p><code>From: Sized</code>æ§‹æ–‡ã¯ã€<code>From</code>ãŒ<code>Sized</code>ã®ã‚µãƒ–ãƒˆãƒ¬ã‚¤ãƒˆã§ã‚ã‚‹ã“ã¨ã‚’æš—ã«æ„å‘³ã—ã¦ã„ã¾ã™ã€‚
<code>From</code>ã‚’å®Ÿè£…ã™ã‚‹ä»»æ„ã®å‹ã¯ã€<code>Sized</code>ã‚‚å®Ÿè£…ã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚
ä»£ã‚ã‚Šã«ã€<code>Sized</code>ã¯<code>From</code>ã®ã‚¹ãƒ¼ãƒ‘ãƒ¼ãƒˆãƒ¬ã‚¤ãƒˆã§ã‚ã‚‹ã¨è¨€ã†ã“ã¨ãŒã§ãã¾ã™ã€‚</p>
</blockquote>
<h3 id="implicit-trait-boundsæš—é»™çš„ãªãƒˆãƒ¬ã‚¤ãƒˆåˆ¶ç´„"><a class="header" href="#implicit-trait-boundsæš—é»™çš„ãªãƒˆãƒ¬ã‚¤ãƒˆåˆ¶ç´„">Implicit trait boundsï¼ˆæš—é»™çš„ãªãƒˆãƒ¬ã‚¤ãƒˆåˆ¶ç´„ï¼‰</a></h3>
<p>Every time you have a generic type parameter, the compiler implicitly assumes that it's <code>Sized</code>.</p>
<p>For example:</p>
<blockquote>
<p>ã‚¸ã‚§ãƒãƒªãƒƒã‚¯ãªå‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ãŒã‚ã‚‹ã¨ãã¯ã„ã¤ã§ã‚‚ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ¼ã¯æš—é»™çš„ã«ãã‚ŒãŒ<code>Sized</code>ã§ã‚ã‚‹ã“ã¨ã‚’ä»®å®šã—ã¾ã™ã€‚</p>
<p>ä¾‹ãˆã°ãƒ»ãƒ»ãƒ»</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Foo&lt;T&gt; {
    inner: T,
}
<span class="boring">}</span></code></pre></pre>
<p>is actually equivalent to:</p>
<blockquote>
<p>ä¸Šè¨˜ã¯å®Ÿéš›ã«æ¬¡ã¨ç­‰ä¾¡ã§ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Foo&lt;T: Sized&gt;
{
    inner: T,
}
<span class="boring">}</span></code></pre></pre>
<p>In the case of <code>From&lt;T&gt;</code>, the trait definition is equivalent to:</p>
<blockquote>
<p><code>From&lt;T&gt;</code>ã®å ´åˆã€ãƒˆãƒ¬ã‚¤ãƒˆã®å®šç¾©ã¯æ¬¡ã¨ç­‰ä¾¡ã§ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait From&lt;T: Sized&gt;: Sized {
    fn from(value: T) -&gt; Self;
}
<span class="boring">}</span></code></pre></pre>
<p>In other words, <em>both</em> <code>T</code> and the type implementing <code>From&lt;T&gt;</code> must be <code>Sized</code>, even
though the former bound is implicit.</p>
<blockquote>
<p>è¨€ã„æ›ãˆã‚‹ã¨ã€<code>T</code>ã¨ã€€<code>From&lt;T&gt;</code>ã‚’å®Ÿè£…ã—ãŸå‹ã¯ä¸¡æ–¹ã¨ã‚‚<code>Sized</code>ã§ãªã‘ã‚Œã°ãªã‚‰ãšã€å‰è€…ã®åˆ¶ç´„ã¯æš—é»™çš„ã§ã™ã€‚</p>
</blockquote>
<h3 id="negative-trait-boundsãƒã‚¬ãƒ†ã‚£ãƒ–ãƒˆãƒ¬ã‚¤ãƒˆåˆ¶ç´„"><a class="header" href="#negative-trait-boundsãƒã‚¬ãƒ†ã‚£ãƒ–ãƒˆãƒ¬ã‚¤ãƒˆåˆ¶ç´„">Negative trait boundsï¼ˆãƒã‚¬ãƒ†ã‚£ãƒ–ãƒˆãƒ¬ã‚¤ãƒˆåˆ¶ç´„ï¼‰</a></h3>
<p>You can opt out of the implicit <code>Sized</code> bound with a <strong>negative trait bound</strong>:</p>
<blockquote>
<p><strong>ãƒã‚¬ãƒ†ã‚£ãƒ–ãƒˆãƒ¬ã‚¤ãƒˆåˆ¶ç´„</strong>ã‚’ä½¿ç”¨ã—ã¦ã€æš—é»™çš„ãª<code>Sized</code>åˆ¶ç´„ã‚’å¤–ã™ã“ã¨ãŒã§ãã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Foo&lt;T: ?Sized&gt; {
    //            ^^^^^^^
    //            This is a negative trait bound
    //            ã“ã‚Œã¯ãƒã‚¬ãƒ†ã‚£ãƒ–ãƒˆãƒ¬ã‚¤ãƒˆåˆ¶ç´„ã§ã™ã€‚
    inner: T,
}
<span class="boring">}</span></code></pre></pre>
<p>This syntax reads as "<code>T</code> may or may not be <code>Sized</code>", and it allows you to
bind <code>T</code> to a DST (e.g. <code>Foo&lt;str&gt;</code>). It is a special case, though: negative trait bounds are exclusive to <code>Sized</code>,
you can't use them with other traits.</p>
<blockquote>
<p>ã“ã®æ§‹æ–‡ã¯ã€ã€Œ<code>T</code>ã¯<code>Sized</code>ã‹ã‚‚ã—ã‚Œãªã„ã—ã€ãã†ã§ãªã„ã‹ã‚‚ã—ã‚Œãªã„ã€ã¨èª­ã¿å–ã‚Œã€ä¾‹ãˆã°<code>Foo&lt;str&gt;</code>ã®ã‚ˆã†ã«ã€ãã‚Œã¯<code>T</code>ã‚’DSTã«æŸç¸›ã•ã‚Œã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚</p>
</blockquote>
<h2 id="str-to-stringstrã‹ã‚‰stringã¸"><a class="header" href="#str-to-stringstrã‹ã‚‰stringã¸"><code>&amp;str</code> to <code>String</code>ï¼ˆ&amp;strã‹ã‚‰Stringã¸ï¼‰</a></h2>
<p>In <a href="https://doc.rust-lang.org/std/convert/trait.From.html#implementors"><code>std</code>'s documentation</a>
you can see which <code>std</code> types implement the <code>From</code> trait.<br />
You'll find that <code>String</code> implements <code>From&lt;&amp;str&gt; for String</code>. Thus, we can write:</p>
<blockquote>
<p><code>std</code>ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆå†…ã§ã€ã©ã®<code>std</code>ã®å‹ãŒ<code>From</code>ãƒˆãƒ¬ã‚¤ãƒˆã‚’å®Ÿè£…ã—ã¦ã„ã‚‹ã‹ç¢ºèªã§ãã¾ã™ã€‚
<code>String</code>ãŒ<code>From&lt;&amp;str&gt;</code>ã‚’å®Ÿè£…ã—ã¦ã„ã‚‹ã“ã¨ã‚’ç¢ºèªã§ãã¾ã™ã€‚ã‚ˆã£ã¦ã€æ¬¡ã®ã‚ˆã†ã«è¨˜è¿°ã§ãã¾ã—ãŸã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let title = String::from("A title");
<span class="boring">}</span></code></pre></pre>
<p>We've been primarily using <code>.into()</code>, though.<br />
If you check out the <a href="https://doc.rust-lang.org/std/convert/trait.Into.html#implementors">implementors of <code>Into</code></a>
you won't find <code>Into&lt;&amp;str&gt; for String</code>. What's going on?</p>
<blockquote>
<p>ã—ã‹ã—ã€ä¸»ã«<code>.into()</code>ã‚’ä½¿ç”¨ã—ã¦ãã¾ã—ãŸã€‚
<code>Into</code>ã®å®Ÿè£…ã‚’ç¢ºèªã—ãŸå ´åˆã€<code>Into&lt;&amp;str&gt; for String</code>ã¯è¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚ä½•ãŒèµ·ã“ã£ã¦ã„ã‚‹ã®ã§ã—ã‚‡ã†ã‹ï¼Ÿ</p>
</blockquote>
<p><code>From</code> and <code>Into</code> are <strong>dual traits</strong>.<br />
In particular, <code>Into</code> is implemented for any type that implements <code>From</code> using a <strong>blanket implementation</strong>:</p>
<blockquote>
<p><code>From</code>ã¨<code>Into</code>ã¯<strong>ãƒ‡ãƒ¥ã‚¢ãƒ«ãƒˆãƒ¬ã‚¤ãƒˆ</strong>ã§ã™ã€‚
ç‰¹ã«ã€<code>Into</code>ã¯ã€<strong>ãƒ–ãƒ©ãƒ³ã‚±ãƒƒãƒˆå®Ÿè£…</strong>ã‚’ä½¿ç”¨ã—ã¦ã€<code>From</code>ã‚’å®Ÿè£…ã™ã‚‹ä»»æ„ã®å‹ã«å¯¾ã—ã¦å®Ÿè£…ã•ã‚Œã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T, U&gt; Into&lt;U&gt; for T
where
    U: From&lt;T&gt;,
{
    fn into(self) -&gt; U {
        U::from(self)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>If a type <code>U</code> implements <code>From&lt;T&gt;</code>, then <code>Into&lt;U&gt; for T</code> is automatically implemented. That's why
we can write <code>let title = "A title".into();</code>.</p>
<blockquote>
<p>å‹<code>U</code>ãŒ<code>From&lt;T&gt;</code>ã‚’å®Ÿè£…ã—ã¦ã„ã‚‹å ´åˆã€<code>Into&lt;U&gt; for T</code>ã¯è‡ªå‹•çš„ã«å®Ÿè£…ã•ã‚Œã¾ã™ã€‚
ã“ã‚ŒãŒã€<code>let title = "A title".into();</code>ã¨è¨˜è¿°ã§ããŸç†ç”±ã§ã™ã€‚</p>
</blockquote>
<h2 id="into"><a class="header" href="#into"><code>.into()</code></a></h2>
<p>Every time you see <code>.into()</code>, you're witnessing a conversion between types.<br />
What's the target type, though?</p>
<blockquote>
<p><code>.into()</code>ã‚’ç¢ºèªã™ã‚‹ãŸã³ã«ã€å‹é–“ã®å¤‰æ›ã‚’ç›®æ’ƒã—ã¾ã™ã€‚
ã—ã‹ã—ã€ç›®çš„ã®å‹ã¯ãªã‚“ã§ã—ã‚‡ã†ã‹ï¼Ÿ</p>
</blockquote>
<p>In most cases, the target type is either:</p>
<ul>
<li>Specified by the signature of a function/method (e.g. <code>Ticket::new</code> in our example above)</li>
<li>Specified in the variable declaration with a type annotation (e.g. <code>let title: String = "A title".into();</code>)</li>
</ul>
<blockquote>
<p>ã»ã¨ã‚“ã©ã®å ´åˆã€ç›®çš„ã®å‹ã¯æ¬¡ã®ã„ãšã‚Œã‹ã§ã™ã€‚</p>
<ul>
<li>é–¢æ•°/ãƒ¡ã‚½ãƒƒãƒ‰ã®ã‚·ã‚°ãƒãƒãƒ£ãƒ¼ã«ã‚ˆã£ã¦æŒ‡å®šã•ã‚Œã‚‹ï¼ˆä¾‹ãˆã°ã€ä¸Šè¨˜åˆ—ã®<code>Ticket::new</code>ï¼‰</li>
<li>å‹æ³¨é‡ˆã‚’æŒã¤å¤‰æ•°å®£è¨€ã§æŒ‡å®šã•ã‚Œã‚‹ï¼ˆä¾‹ãˆã°ã€<code>let title: String = "A title".into();</code>ï¼‰</li>
</ul>
</blockquote>
<p><code>.into()</code> will work out of the box as long as the compiler can infer the target type from the context without ambiguity.</p>
<blockquote>
<p><code>.into()</code>ã¯ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ¼ãŒæ›–æ˜§ãªãæ–‡è„ˆã‹ã‚‰ç›®çš„ã®å‹ã‚’æ¨æ¸¬ã§ãã‚‹é™ã‚Šã€ãã®ã¾ã¾æ©Ÿèƒ½ã—ã¾ã™ã€‚</p>
</blockquote>
<h2 id="exercise-35"><a class="header" href="#exercise-35">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/04_traits/09_from"><code>04_traits/09_from</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generics-and-associated-typesã‚¸ã‚§ãƒãƒªãƒƒã‚¯ã¨é–¢é€£å‹"><a class="header" href="#generics-and-associated-typesã‚¸ã‚§ãƒãƒªãƒƒã‚¯ã¨é–¢é€£å‹">Generics and associated typesï¼ˆã‚¸ã‚§ãƒãƒªãƒƒã‚¯ã¨é–¢é€£å‹ï¼‰</a></h1>
<p>Let's re-examine the definition for two of the traits we studied so far, <code>From</code> and <code>Deref</code>:</p>
<blockquote>
<p>ã“ã‚Œã¾ã§ã«å­¦ã‚“ã <code>From</code>ã¨<code>Deref</code>ã®2ã¤ã®ãƒˆãƒ¬ã‚¤ãƒˆã®å®šç¾©ã‚’å†èª¿æŸ»ã—ã¾ã—ã‚‡ã†ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait From&lt;T&gt; {
    fn from(value: T) -&gt; Self;
}

pub trait Deref {
    type Target;

    fn deref(&amp;self) -&gt; &amp;Self::Target;
}
<span class="boring">}</span></code></pre></pre>
<p>They both feature type parameters.<br />
In the case of <code>From</code>, it's a generic parameter, <code>T</code>.<br />
In the case of <code>Deref</code>, it's an associated type, <code>Target</code>.</p>
<blockquote>
<p>ãã‚Œã‚‰ä¸¡æ–¹ã¯ã€å‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ãŒç‰¹å¾´ã§ã™ã€‚
<code>From</code>ã®å ´åˆã€<code>T</code>ã¯ã‚¸ã‚§ãƒãƒªãƒƒã‚¯ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ã§ã™ã€‚
<code>Deref</code>ã®å ´åˆã€<code>Target</code>ã¯é–¢é€£å‹ã§ã™ã€‚</p>
</blockquote>
<p>What's the difference? Why use one over the other?</p>
<blockquote>
<p>é•ã„ã¯ä½•ã§ã—ã‚‡ã†ã‹ï¼Ÿãªãœã©ã¡ã‚‰ã‹ã‚’ä½¿ã†ã®ã§ã—ã‚‡ã†ã‹ï¼Ÿ</p>
</blockquote>
<h2 id="at-most-one-implementationæœ€å¤§1ã¤ã®å®Ÿè£…"><a class="header" href="#at-most-one-implementationæœ€å¤§1ã¤ã®å®Ÿè£…">At most one implementationï¼ˆæœ€å¤§1ã¤ã®å®Ÿè£…ï¼‰</a></h2>
<p>Due to how deref coercion works, there can only be one "target" type for a given type. E.g. <code>String</code> can
only deref to <code>str</code>.
It's about avoiding ambiguity: if you could implement <code>Deref</code> multiple times for a type,
which <code>Target</code> type should the compiler choose when you call a <code>&amp;self</code> method?</p>
<blockquote>
<p>å‚ç…§å¤–ã—å‹å¼·åˆ¶ãŒæ©Ÿèƒ½ã™ã‚‹ä»•çµ„ã¿ã«ã‚ˆã‚Šã€ç‰¹å®šã®å‹ã«å¯¾ã™ã‚‹1ã¤ã®ã€Œç›®çš„ã€å‹ãŒå­˜åœ¨ã—ã¾ã™ã€‚
ä¾‹ãˆã°ã€<code>String</code>ã¯ã€<code>str</code>ã«ã®ã¿å‚ç…§å¤–ã—ã•ã‚Œã¾ã™ã€‚
ãã‚Œã¯æ›–æ˜§ã•ã‚’é¿ã‘ã‚‹ãŸã‚ã§ã™ã€‚ã‚ã‚‹å‹ã«å¯¾ã—ã¦è¤‡æ•°å›<code>Deref</code>ã‚’å®Ÿè£…ã—ãŸå ´åˆã€<code>&amp;self</code>ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã—ãŸæ™‚ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ¼ã¯ã©ã®<code>Target</code>å‹ã‚’é¸æŠã™ã‚‹ã¹ãã§ã—ã‚‡ã†ã‹ï¼Ÿ</p>
</blockquote>
<p>That's why <code>Deref</code> uses an associated type, <code>Target</code>.<br />
An associated type is uniquely determined <strong>by the trait implementation</strong>.
Since you can't implement <code>Deref</code> more than once, you'll only be able to specify one <code>Target</code> for a given type
and there won't be any ambiguity.</p>
<blockquote>
<p>ãã‚ŒãŒã€<code>Deref</code>ãŒé–¢é€£å‹<code>Target</code>ã‚’ä½¿ç”¨ã™ã‚‹ç†ç”±ã§ã™ã€‚
é–¢é€£å‹ã¯ã€<strong>ãƒˆãƒ¬ã‚¤ãƒˆã®å®Ÿè£…ã«ã‚ˆã£ã¦</strong>ä¸€æ„ã«æ±ºå®šã•ã‚Œã¾ã™ã€‚
<code>Deref</code>ã‚’1ã¤ä»¥ä¸Šå®Ÿè£…ã§ããªã„ãŸã‚ã€ç‰¹å®šã®å‹ã«å¯¾ã—ã¦ãŸã£ãŸ1ã¤ã®<code>Target</code>ã‚’æŒ‡å®šã™ã‚‹ã“ã¨ãŒã§ãã€æ›–æ˜§ã•ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚</p>
</blockquote>
<h2 id="generic-traitsã‚¸ã‚§ãƒãƒªãƒƒã‚¯ãƒˆãƒ¬ã‚¤ãƒˆ"><a class="header" href="#generic-traitsã‚¸ã‚§ãƒãƒªãƒƒã‚¯ãƒˆãƒ¬ã‚¤ãƒˆ">Generic traitsï¼ˆã‚¸ã‚§ãƒãƒªãƒƒã‚¯ãƒˆãƒ¬ã‚¤ãƒˆï¼‰</a></h2>
<p>On the other hand, you can implement <code>From</code> multiple times for a type, <strong>as long as the input type <code>T</code> is different</strong>.
For example, you can implement <code>From</code> for <code>WrappingU32</code> using both <code>u32</code> and <code>u16</code> as input types:</p>
<blockquote>
<p>ä¸€æ–¹ã€ä»»æ„ã®å‹ã«å¯¾ã—ã¦ã€<strong>å…¥åŠ›å‹<code>T</code>ãŒç•°ãªã‚‹é™ã‚Š</strong>ã€è¤‡æ•°å›<code>From</code>ã‚’å®Ÿè£…ã§ãã¾ã™ã€‚
ä¾‹ãˆã°ã€<code>u32</code>ã¨<code>u16</code>ã®ä¸¡æ–¹ã‚’å…¥åŠ›å‹ã¨ã—ã¦ä½¿ç”¨ã—ã¦ã€<code>WrappingU321ã«å¯¾ã—ã¦</code>From`ã‚’å®Ÿè£…ã§ãã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl From&lt;u32&gt; for WrappingU32 {
    fn from(value: u32) -&gt; Self {
        WrappingU32 { inner: value }
    }
}

impl From&lt;u16&gt; for WrappingU32 {
    fn from(value: u16) -&gt; Self {
        WrappingU32 { inner: value.into() }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This works because <code>From&lt;u16&gt;</code> and <code>From&lt;u32&gt;</code> are considered <strong>different traits</strong>.<br />
There is no ambiguity: the compiler can determine which implementation to use based on type of the value being converted.</p>
<blockquote>
<p><code>From&lt;u16&gt;</code>ã¨<code>From&lt;u32&gt;</code>ã¯<strong>ç•°ãªã‚‹ãƒˆãƒ¬ã‚¤ãƒˆ</strong>ã¨ã¿ãªã•ã‚Œã‚‹ãŸã‚ã€ã“ã‚Œã¯æ©Ÿèƒ½ã—ã¾ã™ã€‚
æ›–æ˜§ã•ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ¼ã¯ã€å€¤ãŒå¤‰æ›ã•ã‚Œã‚‹å‹ã«åŸºã¥ã„ã¦ã€ã©ã®å®Ÿè£…ã‚’ä½¿ç”¨ã™ã‚‹ã‹æ±ºå®šã§ãã¾ã™ã€‚</p>
</blockquote>
<h2 id="case-study-addäº‹ä¾‹ç ”ç©¶-add"><a class="header" href="#case-study-addäº‹ä¾‹ç ”ç©¶-add">Case study: <code>Add</code>ï¼ˆäº‹ä¾‹ç ”ç©¶: Addï¼‰</a></h2>
<p>As a closing example, consider the <code>Add</code> trait from the standard library:</p>
<blockquote>
<p>æœ€å¾Œã®ä¾‹ã¨ã—ã¦ã€æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®<code>Add</code>ãƒˆãƒ¬ã‚¤ãƒˆã‚’è€ƒãˆã¦ã¿ã¾ã—ã‚‡ã†ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Add&lt;RHS = Self&gt; {
    type Output;

    fn add(self, rhs: RHS) -&gt; Self::Output;
}
<span class="boring">}</span></code></pre></pre>
<p>It uses both mechanisms:</p>
<ul>
<li>it has a generic parameter, <code>RHS</code> (right-hand side), which defaults to <code>Self</code></li>
<li>it has an associated type, <code>Output</code>, the type of the result of the addition</li>
</ul>
<blockquote>
<p>ãã‚Œã¯ä¸¡æ–¹ã®ãƒ¡ã‚«ãƒ‹ã‚ºãƒ ã‚’ä½¿ç”¨ã—ã¦ã„ã¾ã™ã€‚</p>
<ul>
<li><code>Self</code>ã‚’ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã«æŒã¤<code>RHS</code>ï¼ˆå³è¾ºï¼‰ã¨ã„ã†ã‚¸ã‚§ãƒãƒªãƒƒã‚¯ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ãŒã‚ã‚Šã¾ã™ã€‚</li>
<li>åŠ ç®—ã®çµæœã®å‹ã§ã‚ã‚‹<code>Output</code>ã¨ã„ã†é–¢é€£å‹ãŒã‚ã‚Šã¾ã™ã€‚</li>
</ul>
</blockquote>
<h3 id="rhs"><a class="header" href="#rhs"><code>RHS</code></a></h3>
<p><code>RHS</code> is a generic parameter to allow for different types to be added together.<br />
For example, you'll find these two implementations in the standard library:</p>
<p><code>RHS</code>ã¯ã€ç•°ãªã‚‹å‹ã‚’ä¸€ç·’ã«åŠ ç®—ã•ã‚Œã‚‹ã‚ˆã†ã«ã™ã‚‹ãŸã‚ã®ã‚¸ã‚§ãƒãƒªãƒƒã‚¯ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ã§ã™ã€‚
ä¾‹ãˆã°ã€æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã«ã“ã‚Œã‚‰2ã¤ã®å®Ÿè£…ã‚’è¦‹ã¤ã‘ã‚‹ã§ã—ã‚‡ã†ã€‚</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Add&lt;u32&gt; for u32 {
    type Output = u32;

    fn add(self, rhs: u32) -&gt; u32 {
      //                      ^^^
      // This could be written as `Self::Output` instead.
      // The compiler doesn't care, as long as the type you
      // specify here matches the type you assigned to `Output`
      // right above.
      // ã“ã‚Œã¯ã€ä»£ã‚ã‚Šã«`Self::Output`ã¨è¨˜è¿°ã§ãã¾ã™ã€‚
      // ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ¼ã¯ã€ã“ã“ã§æŒ‡å®šã—ãŸå‹ãŒã€ä¸Šè¨˜`Output`ã®å³ã«æŒ‡å®šã•ã‚Œã¦ã„ã‚‹å‹ã¨ä¸€è‡´ã—ã¦ã„ã‚‹é™ã‚Šæ°—ã«ã—ã¾ã›ã‚“ã€‚
      // [...]
    }
}

impl Add&lt;&amp;u32&gt; for u32 {
    type Output = u32;

    fn add(self, rhs: &amp;u32) -&gt; u32 {
        // [...]
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This allows the following code to compile:</p>
<p>ã“ã‚Œã¯ã€æ¬¡ã®ã‚³ãƒ¼ãƒ‰ã‚’ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã§ãã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5u32 + &amp;5u32 + 6u32;
<span class="boring">}</span></code></pre></pre>
<p>because <code>u32</code> implements <code>Add&lt;&amp;u32&gt;</code> <em>as well as</em> <code>Add&lt;u32&gt;</code>.</p>
<blockquote>
<p>ãªãœãªã‚‰ã€<code>u32</code>ã¯<code>Add&lt;u32&gt;</code>ã¨ <em>åŒæ§˜ã«</em> ã€<code>Add&lt;&amp;u32&gt;</code>ã‚’å®Ÿè£…ã—ã¦ã„ã‚‹ã‹ã‚‰ã§ã™ã€‚</p>
</blockquote>
<h3 id="output"><a class="header" href="#output"><code>Output</code></a></h3>
<p><code>Output</code> represents the type of the result of the addition.</p>
<blockquote>
<p><code>Output</code>ã¯ã€åŠ ç®—ã®çµæœã®å‹ã‚’è¡¨ç¾ã—ã¾ã™ã€‚</p>
</blockquote>
<p>Why do we need <code>Output</code> in the first place? Can't we just use <code>Self</code> as output, the type implementing <code>Add</code>?
We could, but it would limit the flexibility of the trait. In the standard library, for example, you'll find
this implementation:</p>
<blockquote>
<p>ãªãœã€ãã‚‚ãã‚‚<code>Output</code>ãŒå¿…è¦ãªã®ã§ã—ã‚‡ã†ã‹ï¼Ÿ
å‡ºåŠ›ã¨ã—ã¦å˜ã«<code>Self</code>ã‚’ä½¿ç”¨ã§ããªã„ã®ã§ã—ã‚‡ã†ã‹ï¼Ÿ
ã§ãã¾ã™ãŒã€ãã®ãƒˆãƒ¬ã‚¤ãƒˆã®æŸ”è»Ÿæ€§ã‚’åˆ¶é™ã—ã¾ã™ã€‚
ä¾‹ãˆã°ã€æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã«ãŠã„ã¦ã€æ¬¡ã®å®Ÿè£…ã‚’è¦‹ã¤ã‘ã‚‹ã§ã—ã‚‡ã†ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Add&lt;&amp;u32&gt; for &amp;u32 {
    type Output = u32;

    fn add(self, rhs: &amp;u32) -&gt; u32 {
        // [...]
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The type they're implementing the trait for is <code>&amp;u32</code>, but the result of the addition is <code>u32</code>.<br />
It would be impossible<sup class="footnote-reference"><a href="#flexible">1</a></sup> to provide this implementation if <code>add</code> had to return <code>Self</code>, i.e. <code>&amp;u32</code> in this case.
<code>Output</code> lets <code>std</code> decouple the implementor from the return type, thus supporting this case.</p>
<blockquote>
<p>ãƒˆãƒ¬ã‚¤ãƒˆã‚’å®Ÿè£…ã—ã¦ã„ã‚‹å‹ã¯<code>&amp;u32</code>ã§ã™ãŒã€åŠ ç®—ã®çµæœã®å‹ã¯<code>u32</code>ã§ã™ã€‚
<code>add</code>ãŒ<code>Self</code>ã‚’è¿”ã•ãªã‘ã‚Œã°ãªã‚‰ãªã„ã¨ãã€ä¾‹ãˆã°<code>&amp;u32</code>ã®å ´åˆã€ã“ã®å®Ÿè£…ã‚’æä¾›ã™ã‚‹ã“ã¨ã¯ä¸å¯èƒ½ã§ã™ã€‚</p>
</blockquote>
<p>On the other hand, <code>Output</code> can't be a generic parameter. The output type of the operation <strong>must</strong> be uniquely determined
once the types of the operands are known. That's why it's an associated type: for a given combination of implementor
and generic parameters, there is only one <code>Output</code> type.</p>
<blockquote>
<p>ä¸€æ–¹ã€<code>Output</code>ã¯ã‚¸ã‚§ãƒãƒªãƒƒã‚¯ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ã«ã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚
æ“ä½œã®å‡ºåŠ›å‹ã¯ã€ä¸€åº¦ã€ã‚ªãƒšãƒ©ãƒ³ãƒ‰ã®å‹ãŒçŸ¥ã‚‰ã‚Œã‚‹ã¨ã€ä¸€æ„ã«æ±ºå®šã•ã‚Œãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚
ãã‚ŒãŒã€é–¢é€£å‹ã®ã®ç†ç”±ã§ã™ã€‚å®Ÿè£…è€…ã¨ã‚¸ã‚§ãƒãƒªãƒƒã‚¯ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ã®çµ„ãŒä¸ãˆã‚‰ã‚Œã‚‹ã¨ã€ãŸã£ãŸ1ã¤ã®<code>Output</code>å‹ã—ã‹ã‚ã‚Šã¾ã›ã‚“ã€‚</p>
</blockquote>
<h2 id="conclusionçµè«–"><a class="header" href="#conclusionçµè«–">Conclusionï¼ˆçµè«–ï¼‰</a></h2>
<p>To recap:</p>
<ul>
<li>Use an <strong>associated type</strong> when the type must be uniquely determined for a given trait implementation.</li>
<li>Use a <strong>generic parameter</strong> when you want to allow multiple implementations of the trait for the same type,
with different input types.</li>
</ul>
<blockquote>
<p>è¦ç´„ã—ã¾ã™ã€‚</p>
<ul>
<li>ç‰¹å®šã®ãƒˆãƒ¬ã‚¤ãƒˆã®å®Ÿè£…ã®ãŸã‚ã«ã€å‹ãŒä¸€æ„ã«æ±ºå®šã•ã‚Œãªã‘ã‚Œã°ãªã‚‰ãªã„ã¨ãã€<strong>é–¢é€£å‹</strong>ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚</li>
<li>ç•°ãªã‚‹å…¥åŠ›å‹ã‚’æŒã¤åŒã˜å‹ã«å¯¾ã—ã¦è¤‡æ•°ã®ãƒˆãƒ¬ã‚¤ãƒˆã®å®Ÿè£…ã§ãã‚‹ã‚ˆã†ã«ã—ãŸã„ã¨ãã€<strong>ã‚¸ã‚§ãƒãƒªãƒƒã‚¯ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼</strong>ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚</li>
</ul>
</blockquote>
<div class="footnote-definition" id="flexible"><sup class="footnote-definition-label">1</sup>
<p>Flexibility is rarely free: the trait definition is more complex due to <code>Output</code>, and implementors have to reason about
what they want to return. The trade-off is only justified if that flexibility is actually needed. Keep that in mind
when designing your own traits.
æŸ”è»Ÿæ€§ãŒã€ã‚³ã‚¹ãƒˆãªã—ã«ãªã‚‹ã“ã¨ã¯ã»ã¨ã‚“ã©ã‚ã‚Šã¾ã›ã‚“ã€‚
ãƒˆãƒ¬ã‚¤ãƒˆã®å®šç¾©ãŒã€<code>Output</code>ã«ã‚ˆã£ã¦ã‚ˆã‚Šè¤‡é›‘ã«ãªã‚Šã€å®Ÿè£…è€…ã¯ä½•ã‚’è¿”ã—ãŸã„ã®ã‹ç†ç”±ã‚’è€ƒãˆãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚
ãƒˆãƒ¬ãƒ¼ãƒ‰ã‚ªãƒ•ã¯ã€æŸ”è»Ÿæ€§ãŒå®Ÿéš›ã«å¿…è¦ãªå ´åˆã«ã®ã¿æ­£å½“åŒ–ã•ã‚Œã¾ã™ã€‚
ç‹¬è‡ªã®ãƒˆãƒ¬ã‚¤ãƒˆã‚’è¨­è¨ˆã™ã‚‹ã¨ãã€ã“ã‚Œã‚’è¦šãˆã¦ãŠã„ã¦ãã ã•ã„ã€‚</p>
</div>
<h2 id="exercise-36"><a class="header" href="#exercise-36">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/04_traits/10_assoc_vs_generic"><code>04_traits/10_assoc_vs_generic</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="copying-values-pt-1å€¤ã‚’ã‚³ãƒ”ãƒ¼ã™ã‚‹ãã®1"><a class="header" href="#copying-values-pt-1å€¤ã‚’ã‚³ãƒ”ãƒ¼ã™ã‚‹ãã®1">Copying values, pt. 1ï¼ˆå€¤ã‚’ã‚³ãƒ”ãƒ¼ã™ã‚‹ã€ãã®1ï¼‰</a></h1>
<p>In the previous chapter we introduced ownership and borrowing.<br />
We stated, in particular, that:</p>
<ul>
<li>Every value in Rust has a single owner at any given time.</li>
<li>When a function takes ownership of a value ("it consumes it"), the caller can't use that value anymore.</li>
</ul>
<blockquote>
<p>å‰ã®ç« ã«ãŠã„ã¦ã€æ‰€æœ‰æ¨©ã¨å€Ÿç”¨ã‚’ç´¹ä»‹ã—ã¾ã—ãŸã€‚
ç‰¹ã«ã€æ¬¡ã®ã“ã¨ã‚’è¿°ã¹ã¾ã—ãŸã€‚</p>
<ul>
<li>Rustã«ãŠã‘ã‚‹ã™ã¹ã¦ã®å€¤ã¯ã€ç‰¹å®šã®æ™‚ç‚¹ã§å˜ç‹¬ã®æ‰€æœ‰è€…ã‚’æŒã¡ã¾ã™ã€‚</li>
<li>é–¢æ•°ãŒå€¤ã®æ‰€æœ‰æ¨©ã‚’å¾—ãŸæ™‚ï¼ˆã€Œé–¢æ•°ã¯å€¤ã‚’æ¶ˆè²»ã—ã¾ã™ã€ï¼‰ã€å‘¼ã³å‡ºã—å…ƒã¯ãã‚Œä»¥ä¸Šå€¤ã‚’ä½¿ç”¨ã§ãã¾ã›ã‚“ã€‚</li>
</ul>
</blockquote>
<p>These restrictions can be somewhat limiting.<br />
Sometimes we might have to call a function that takes ownership of a value, but we still need to use
that value afterward.</p>
<blockquote>
<p>ã“ã‚Œã‚‰ã®åˆ¶ç´„ã¯ã€ä½•ã‚‰ã‹ã®åˆ¶é™ãŒã‚ã‚Šã¾ã™ã€‚
æ™‚ã€…ã€å€¤ã®æ‰€æœ‰æ¨©ã‚’å¾—ã‚‹é–¢æ•°ã‚’å‘¼ã³å‡ºã•ãªãã¦ã¯ãªã‚Šã¾ã›ã‚“ãŒã€ãã®å¾Œã‚‚ã€ã¾ã ãã®å€¤ã‚’ä½¿ç”¨ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn consumer(s: String) { /* */ }

fn example() {
     let mut s = String::from("hello");
     consumer(s);
     s.push_str(", world!"); // error: value borrowed here after move
                             // ã‚¨ãƒ©ãƒ¼: ç§»å‹•å¾Œã«ã€ã“ã“ã§å€¤ãŒå€Ÿç”¨ã•ã‚Œã¦ã„ã¾ã™ã€‚
}
<span class="boring">}</span></code></pre></pre>
<p>That's where <code>Clone</code> comes in.</p>
<blockquote>
<p>ãã“ã§ã€<code>Clone</code>ãŒç™»å ´ã—ã¾ã™ã€‚</p>
</blockquote>
<h2 id="clone"><a class="header" href="#clone"><code>Clone</code></a></h2>
<p><code>Clone</code> is a trait defined in Rust's standard library:</p>
<blockquote>
<p><code>Clone</code>ã¯ã€Rustæ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªå†…ã«å®šç¾©ã•ã‚ŒãŸãƒˆãƒ¬ã‚¤ãƒˆã§ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Clone {
    fn clone(&amp;self) -&gt; Self;
}
<span class="boring">}</span></code></pre></pre>
<p>Its method, <code>clone</code>, takes a reference to <code>self</code> and returns a new <strong>owned</strong> instance of the same type.</p>
<blockquote>
<p>ãã®ãƒ¡ã‚½ãƒƒãƒ‰ã®<code>clone</code>ã¯ã€<code>self</code>ã¸ã®å‚ç…§ã‚’å—ã‘å–ã‚Šã€åŒã˜å‹ã®æ–°ã—ã„<strong>æ‰€æœ‰ã•ã‚ŒãŸ</strong>ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’è¿”ã—ã¾ã™ã€‚</p>
</blockquote>
<h2 id="in-actionæ´»å‹•ä¸­"><a class="header" href="#in-actionæ´»å‹•ä¸­">In actionï¼ˆæ´»å‹•ä¸­ï¼‰</a></h2>
<p>Going back to the example above, we can use <code>clone</code> to create a new <code>String</code> instance before calling <code>consumer</code>:</p>
<blockquote>
<p>ä¸Šè¨˜ä¾‹ã«æˆ»ã‚Šã€<code>consumer</code>ã‚’å‘¼ã³å‡ºã™å‰ã«ã€æ–°ã—ã„<code>String</code>ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ä½œæˆã™ã‚‹ãŸã‚ã«<code>clone</code>ã‚’ä½¿ç”¨ã§ãã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn consumer(s: String) { /* */ }

fn example() {
     let mut s = String::from("hello");
     let t = s.clone();
     consumer(t);
     s.push_str(", world!"); // no error
                             // ã‚¨ãƒ©ãƒ¼ãªã—
}
<span class="boring">}</span></code></pre></pre>
<p>Instead of giving ownership of <code>s</code> to <code>consumer</code>, we create a new <code>String</code> (by cloning <code>s</code>) and give
that to <code>consumer</code> instead.<br />
<code>s</code> remains valid and usable after the call to <code>consumer</code>.</p>
<blockquote>
<p><code>s</code>ã®æ‰€æœ‰æ¨©ã‚’<code>consumer</code>ã«ä¸ãˆã‚‹ä»£ã‚ã‚Šã«ã€<code>s</code>ã‚’ã‚¯ãƒ­ãƒ¼ãƒ³ã—ã¦æ–°ã—ã„<code>String</code>ã‚’ä½œæˆã—ã¦ã€ä»£ã‚ã‚Šã«ãã‚Œã‚’<code>consumer</code>ã«ä¸ãˆã¾ã™ã€‚
<code>s</code>ã¯æœ‰åŠ¹ã®ã¾ã¾ã§ã€<code>consumer</code>ã®å‘¼ã³å‡ºã—å¾Œã‚‚ä½¿ç”¨ã§ãã¾ã™ã€‚</p>
</blockquote>
<h2 id="in-memoryãƒ¡ãƒ¢ãƒªå†…"><a class="header" href="#in-memoryãƒ¡ãƒ¢ãƒªå†…">In memoryï¼ˆãƒ¡ãƒ¢ãƒªå†…ï¼‰</a></h2>
<p>Let's look at what happened in memory in the example above.
When <code>let mut s: String::from("hello");</code> is executed, the memory looks like this:</p>
<blockquote>
<p>ä¸Šè¨˜ä¾‹ã«ãŠã„ã¦ã€ãƒ¡ãƒ¢ãƒªå†…ã§ä½•ãŒèµ·ã“ã£ã¦ã„ã‚‹ã‹ç¢ºèªã—ã¾ã—ã‚‡ã†ã€‚
<code>let mut s: String::from("hello");</code>ãŒå®Ÿè¡Œã•ã‚ŒãŸã¨ãã€ãƒ¡ãƒ¢ãƒªã¯æ¬¡ã®ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚</p>
</blockquote>
<pre><code class="language-text">                    s
      +---------+--------+----------+
Stack | pointer | length | capacity |
      |  |      |   5    |    5     |
      +--|------+--------+----------+
         |
         |
         v
       +---+---+---+---+---+
Heap:  | H | e | l | l | o |
       +---+---+---+---+---+
</code></pre>
<p>When <code>let t = s.clone()</code> is executed, a whole new region is allocated on the heap to store a copy of the data:</p>
<blockquote>
<p><code>let t = s.clone()</code>ãŒå®Ÿè¡Œã•ã‚Œã‚‹ã¨ã€ãƒ‡ãƒ¼ã‚¿ã®ã‚³ãƒ”ãƒ¼ã‚’ä¿å­˜ã™ã‚‹ãŸã‚ã«ã€æ–°ã—ã„é ˜åŸŸå…¨ä½“ãŒãƒ’ãƒ¼ãƒ—ä¸Šã«å‰²ã‚Šå½“ã¦ã‚‰ã‚Œã¾ã™ã€‚</p>
</blockquote>
<pre><code class="language-text">                    s                                    t
      +---------+--------+----------+      +---------+--------+----------+
Stack | pointer | length | capacity |      | pointer | length | capacity |
      |  |      |   5    |    5     |      |  |      |   5    |    5     |
      +--|------+--------+----------+      +--|------+--------+----------+
         |                                    |
         |                                    |
         v                                    v
       +---+---+---+---+---+                +---+---+---+---+---+
Heap:  | H | e | l | l | o |                | H | e | l | l | o |
       +---+---+---+---+---+                +---+---+---+---+---+
</code></pre>
<p>If you're coming from a language like Java, you can think of <code>clone</code> as a way to create a deep copy of an object.</p>
<blockquote>
<p>Javaã®ã‚ˆã†ãªè¨€èªã§ã¯ã€<code>clone</code>ã‚’ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ‡ã‚£ãƒ¼ãƒ—ã‚³ãƒ”ãƒ¼ã‚’ä½œæˆã™ã‚‹æ–¹æ³•ã®ã‚ˆã†ã«è€ƒãˆã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚</p>
</blockquote>
<h2 id="implementing-clonecloneã®å®Ÿè£…"><a class="header" href="#implementing-clonecloneã®å®Ÿè£…">Implementing <code>Clone</code>ï¼ˆCloneã®å®Ÿè£…ï¼‰</a></h2>
<p>To make a type <code>Clone</code>-able, we have to implement the <code>Clone</code> trait for it.<br />
You almost always implement <code>Clone</code> by deriving it:</p>
<blockquote>
<p>å‹ã‚’<code>Clone</code>å¯èƒ½ã«ã™ã‚‹ãŸã‚ã«ã€<code>Cone</code>ãƒˆãƒ¬ã‚¤ãƒˆã‚’å®Ÿè£…ã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚
ã»ã¨ã‚“ã©å¸¸ã«ã€<code>Clone</code>ã®å°å‡ºã«ã‚ˆã£ã¦<code>Clone</code>ã‚’å®Ÿè£…ã—ã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone)]
struct MyType {
    // fields
}
<span class="boring">}</span></code></pre></pre>
<p>The compiler implements <code>Clone</code> for <code>MyType</code> as you would expect: it clones each field of <code>MyType</code> individually and
then constructs a new <code>MyType</code> instance using the cloned fields.<br />
Remember that you can use <code>cargo expand</code> (or your IDE) to explore the code generated by <code>derive</code> macros.</p>
<blockquote>
<p>ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ¼ã¯ã€æœŸå¾…ã™ã‚‹é€šã‚Šã«<code>MyType</code>ã«å¯¾ã—ã¦<code>Clone</code>ã‚’å®Ÿè£…ã—ã¾ã™ã€‚
ãã‚Œã¯ã€<code>MyType</code>ã®ãã‚Œãã‚Œã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’å€‹ã€…ã«ã‚¯ãƒ­ãƒ¼ãƒ³ã—ã¦ã€ãã®å¾Œã€ã‚¯ãƒ­ãƒ¼ãƒ³ã•ã‚ŒãŸãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’ä½¿ç”¨ã—ã¦ã€æ–°ã—ã„<code>MyType</code>ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’æ§‹ç¯‰ã—ã¾ã™ã€‚
<code>derive</code>ãƒã‚¯ãƒ­ã«ã‚ˆã£ã¦ç”Ÿæˆã•ã‚ŒãŸã‚³ãƒ¼ãƒ‰ã‚’æ¢æ±‚ã™ã‚‹ãŸã‚ã«ã€<code>cargo expand</code>ï¼ˆã¾ãŸã¯IDEï¼‰ã‚’ä½¿ç”¨ã§ãã‚‹ã“ã¨ã‚’è¦šãˆã¦ãŠã„ã¦ãã ã•ã„ã€‚</p>
</blockquote>
<h2 id="exercise-37"><a class="header" href="#exercise-37">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/04_traits/11_clone"><code>04_traits/11_clone</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="copying-values-pt-2å€¤ã‚’ã‚³ãƒ”ãƒ¼ã™ã‚‹ãã®2"><a class="header" href="#copying-values-pt-2å€¤ã‚’ã‚³ãƒ”ãƒ¼ã™ã‚‹ãã®2">Copying values, pt. 2ï¼ˆå€¤ã‚’ã‚³ãƒ”ãƒ¼ã™ã‚‹ã€ãã®2ï¼‰</a></h1>
<p>Let's consider the same example as before, but with a slight twist: using <code>u32</code> rather than <code>String</code> as a type.</p>
<blockquote>
<p>å‰ã¨åŒæ§˜ã«åŒã˜ä¾‹ã‚’è€ƒãˆã¾ã™ãŒã€å°‘ã—å¤‰æ›´ã—ã¦ã€å‹ã«<code>String</code>ã§ã¯ãªã<code>u32</code>ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn consumer(s: u32) { /* */ }

fn example() {
     let s: u32 = 5;
     consumer(s);
     let t = s + 1;
}
<span class="boring">}</span></code></pre></pre>
<p>It'll compile without errors! What's going on here? What's the difference between <code>String</code> and <code>u32</code>
that makes the latter work without <code>.clone()</code>?</p>
<blockquote>
<p>ãã‚Œã¯ã‚¨ãƒ©ãƒ¼ãªã—ã§ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã‚Œã¾ã™ã€‚ä½•ãŒèµ·ã“ã£ã¦ã„ã‚‹ã®ã§ã—ã‚‡ã†ã‹ï¼Ÿ
<code>.clone()</code>ãªã—ã§å¾Œè€…ã‚’æ©Ÿèƒ½ã•ã›ã‚‹<code>String</code>ã¨<code>u32</code>ã®é•ã„ã¯ä½•ã§ã—ã‚‡ã†ã‹ï¼Ÿ</p>
</blockquote>
<h2 id="copy"><a class="header" href="#copy"><code>Copy</code></a></h2>
<p><code>Copy</code> is another trait defined in Rust's standard library:</p>
<blockquote>
<p><code>Copy</code>ã¯ã€Rustæ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã«å®šç¾©ã•ã‚ŒãŸåˆ¥ã®ãƒˆãƒ¬ã‚¤ãƒˆã§ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Copy: Clone { }
<span class="boring">}</span></code></pre></pre>
<p>It is a marker trait, just like <code>Sized</code>.</p>
<blockquote>
<p>ãã‚Œã¯ã€ã¡ã‚‡ã†ã©<code>Sized</code>ã®ã‚ˆã†ãªãƒãƒ¼ã‚«ãƒ¼ãƒˆãƒ¬ã‚¤ãƒˆã§ã™ã€‚</p>
</blockquote>
<p>If a type implements <code>Copy</code>, there's no need to call <code>.clone()</code> to create a new instance of the type:
Rust does it <strong>implicitly</strong> for you.<br />
<code>u32</code> is an example of a type that implements <code>Copy</code>, which is why the example above compiles without errors:
when <code>consumer(s)</code> is called, Rust creates a new <code>u32</code> instance by performing a <strong>bitwise copy</strong> of <code>s</code>,
and then passes that new instance to <code>consumer</code>. It all happens behind the scenes, without you having to do anything.</p>
<blockquote>
<p>å‹ãŒ<code>Copy</code>ã‚’å®Ÿè£…ã™ã‚‹å ´åˆã€ãã®å‹ã®æ–°ã—ã„ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ä½œæˆã™ã‚‹ãŸã‚ã«<code>.clone()</code>ã‚’å‘¼ã³å‡ºã™å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚
Rustã¯ã€<strong>æš—é»™çš„ã«</strong>ãã‚Œã‚’è¡Œã„ã¾ã™ã€‚
<code>u32</code>ã¯<code>Copy</code>ã‚’å®Ÿè£…ã™ã‚‹å‹ã®ä¾‹ã§ã€ãã‚ŒãŒã€ã‚¨ãƒ©ãƒ¼ãªã—ã§ä¸Šè¨˜ä¾‹ã‚’ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã§ããŸç†ç”±ã§ã™ã€‚
<code>consumer(s)</code>ãŒå‘¼ã³å‡ºã•ã‚ŒãŸã¨ãã€Rustã¯<code>s</code>ã®<strong>ãƒ“ãƒƒãƒˆå˜ä½ã®ã‚³ãƒ”ãƒ¼</strong>ã‚’è¡Œã†ã“ã¨ã§ã€æ–°ã—ã„<code>u32</code>ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ä½œæˆã—ã¦ã€æ–°ã—ã„ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’<code>consumer</code>ã«æ¸¡ã—ã¾ã™ã€‚
ãã‚ŒãŒèƒŒå¾Œã§ç™ºç”Ÿã—ãŸå…¨ã¦ã§ã€ä½•ã‚‚ã™ã‚‹å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚</p>
</blockquote>
<h2 id="what-can-be-copyä½•ãŒcopyã«ãªã‚Œã‚‹ã®ã‹"><a class="header" href="#what-can-be-copyä½•ãŒcopyã«ãªã‚Œã‚‹ã®ã‹">What can be <code>Copy</code>?ï¼ˆä½•ãŒCopyã«ãªã‚Œã‚‹ã®ã‹ï¼Ÿï¼‰</a></h2>
<p><code>Copy</code> is not equivalent to "automatic cloning", although it implies it.<br />
Types must meet a few requirements in order to be allowed to implement <code>Copy</code>.</p>
<blockquote>
<p><code>Copy</code>ã¯ã€ã€Œè‡ªå‹•ã‚¯ãƒ­ãƒ¼ãƒ³ã€ã¨åŒç­‰ã§ã¯ã‚ã‚Šã¾ã›ã‚“ãŒã€ãã‚Œã‚’æš—ã«æ„å‘³ã—ã¾ã™ã€‚
<code>Copy</code>ã®å®Ÿè£…ã‚’è¨±å¯ã™ã‚‹ãŸã‚ã«ã€å‹ã¯ã„ãã¤ã‹ã®è¦ä»¶ã‚’æº€ãŸã•ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚</p>
</blockquote>
<p>First of all, it must implement <code>Clone</code>, since <code>Copy</code> is a subtrait of <code>Clone</code>.
This makes sense: if Rust can create a new instance of a type <em>implicitly</em>, it should
also be able to create a new instance <em>explicitly</em> by calling <code>.clone()</code>.</p>
<blockquote>
<p>ã¾ãšæœ€åˆã«ã€<code>Copy</code>ã¯<code>Clone</code>ã®ã‚µãƒ–ãƒˆãƒ¬ã‚¤ãƒˆã§ã‚ã‚‹ãŸã‚ã€å‹ã¯<code>Clone</code>ã‚’å®Ÿè£…ã—ãªãã¦ã¯ãªã‚Šã¾ã›ã‚“ã€‚
ã“ã‚Œã«ã¯æ„å‘³ãŒã‚ã‚Šã¾ã™ã€‚RustãŒã‚ã‚‹å‹ã®æ–°ã—ã„ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’<strong>æš—é»™çš„ã«</strong>ä½œæˆã§ãã‚‹å ´åˆã€ãã‚Œã¯<code>.clone()</code>ã‚’å‘¼ã³å‡ºã™ã“ã¨ã§<strong>æ˜ç¤ºçš„ã«</strong>æ–°ã—ã„ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ä½œæˆã§ãã‚‹ã¹ãã§ã™ã€‚</p>
</blockquote>
<p>That's not all, though. A few more conditions must be met:</p>
<ol>
<li>The type doesn't manage any <em>additional</em> resources (e.g. heap memory, file handles, etc.) beyond the <code>std::mem::size_of</code>
bytes that it occupies in memory.</li>
<li>The type is not a mutable reference (<code>&amp;mut T</code>).</li>
</ol>
<blockquote>
<p>ãŸã ã—ã€ãã‚ŒãŒå…¨ã¦ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ã„ãã¤ã‹ã®æ¡ä»¶ãŒæº€ãŸã•ã‚Œãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚</p>
<ol>
<li>ãã®å‹ã¯ã€ãƒ¡ãƒ¢ãƒªå†…ã«ãã‚ŒãŒå°‚æœ‰ã™ã‚‹<code>std::mem::size_of</code>ã§å¾—ã‚‰ã‚Œã‚‹ãƒã‚¤ãƒˆã‚’è¶…ãˆã¦ã€ä¾‹ãˆã°ãƒ’ãƒ¼ãƒ—ãƒ¡ãƒ¢ãƒªã€ãƒ•ã‚¡ã‚¤ãƒ«ãƒãƒ³ãƒ‰ãƒ«ãªã©ã€ä»»æ„ã®_è¿½åŠ _ãƒªã‚½ãƒ¼ã‚¹ã‚’ç®¡ç†ã§ãã¾ã›ã‚“ã€‚</li>
<li>ãã®å‹ã¯ã€å¯å¤‰å‚ç…§ï¼ˆ<code>&amp;mut T</code>ï¼‰ã§ã‚ã£ã¦ã¯ãªã‚Šã¾ã›ã‚“ã€‚</li>
</ol>
</blockquote>
<p>If both conditions are met, then Rust can safely create a new instance of the type by performing a <strong>bitwise copy</strong>
of the original instanceâ€”this is often referred to as a <code>memcpy</code> operation, after the C standard library function
that performs the bitwise copy.</p>
<blockquote>
<p>ä¸¡æ–¹ã®æ¡ä»¶ã‚’æº€ãŸã™å ´åˆã€Rustã¯ã‚ªãƒªã‚¸ãƒŠãƒ«ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®<strong>ãƒ“ãƒƒãƒˆå˜ä½ã®ã‚³ãƒ”ãƒ¼</strong>ã‚’è¡Œã†ã“ã¨ã§ã€ãã®å‹ã®æ–°ã—ã„ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’å®‰å…¨ã«ä½œæˆã§ãã¾ã™ã€‚
ã“ã‚Œã¯ã€ãƒ“ãƒƒãƒˆå˜ä½ã®ã‚³ãƒ”ãƒ¼ã‚’ã™ã‚‹Cæ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®é–¢æ•°ã«ç”±æ¥ã—ã¦ã€<code>memcpy</code>æ“ä½œã¨å‘¼ã°ã‚Œã‚‹ã“ã¨ãŒã‚ˆãã‚ã‚Šã¾ã™ã€‚</p>
</blockquote>
<h3 id="case-study-1-stringäº‹ä¾‹è§£èª¬1-string"><a class="header" href="#case-study-1-stringäº‹ä¾‹è§£èª¬1-string">Case study 1: <code>String</code>ï¼ˆäº‹ä¾‹è§£èª¬1: Stringï¼‰</a></h3>
<p><code>String</code> is a type that doesn't implement <code>Copy</code>.<br />
Why? Because it manages an additional resource: the heap-allocated memory buffer that stores the string's data.</p>
<blockquote>
<p><code>String</code>ã¯<code>Copy</code>ã‚’å®Ÿè£…ã—ã¦ã„ãªã„å‹ã§ã™ã€‚
ãªãœã§ã—ã‚‡ã†ã‹ï¼Ÿãã‚Œã¯ã€<code>String</code>ãŒæ–‡å­—åˆ—ã®ãƒ‡ãƒ¼ã‚¿ã‚’ä¿å­˜ã—ãŸãƒ’ãƒ¼ãƒ—ã«å‰²ã‚Šå½“ã¦ã‚‰ã‚ŒãŸãƒ¡ãƒ¢ãƒªãƒãƒƒãƒ•ã‚¡ãƒ¼ã‚’è¿½åŠ ãƒªã‚½ãƒ¼ã‚¹ã¨ã—ã¦ç®¡ç†ã™ã‚‹ã‹ã‚‰ã§ã™ã€‚</p>
</blockquote>
<p>Let's imagine that Rust allowed <code>String</code> to implement <code>Copy</code>.<br />
Then, when a new <code>String</code> instance is created by performing a bitwise copy of the original instance, both the original
and the new instance would point to the same memory buffer:</p>
<blockquote>
<p>RustãŒ<code>Copy</code>ã‚’å®Ÿè£…ã—ãŸ<code>String</code>ã‚’è¨±å¯ã—ãŸã“ã¨ã‚’æƒ³åƒã—ã¦ãã ã•ã„ã€‚
ãã—ã¦ã€æ–°ã—ã„<code>String</code>ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãŒã€ã‚ªãƒªã‚¸ãƒŠãƒ«ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®ãƒ“ãƒƒãƒˆå˜ä½ã®ã‚³ãƒ”ãƒ¼ã‚’å®Ÿè¡Œã—ã¦ä½œæˆã•ã‚ŒãŸã¨ãã€ã‚ªãƒªã‚¸ãƒŠãƒ«ã¨æ–°ã—ã„ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®ä¸¡æ–¹ã¯ã€åŒã˜ãƒ¡ãƒ¢ãƒªãƒãƒƒãƒ•ã‚¡ãƒ¼ã‚’æŒ‡ã—ç¤ºã—ã¾ã™ã€‚</p>
</blockquote>
<pre><code class="language-text">              s                                 copied_s
+---------+--------+----------+      +---------+--------+----------+
| pointer | length | capacity |      | pointer | length | capacity |
|  |      |   5    |    5     |      |  |      |   5    |    5     |
+--|------+--------+----------+      +--|------+--------+----------+
   |                                    |
   |                                    |
   v                                    |
 +---+---+---+---+---+                  |
 | H | e | l | l | o |                  |
 +---+---+---+---+---+                  |
   ^                                    |
   |                                    |
   +------------------------------------+
</code></pre>
<p>This is bad!
Both <code>String</code> instances would try to free the memory buffer when they go out of scope,
leading to a double-free error.
You could also create two distinct <code>&amp;mut String</code> references that point to the same memory buffer,
violating Rust's borrowing rules.</p>
<blockquote>
<p>ã“ã‚Œã¯è‰¯ããªã„ã“ã¨ã§ã™ï¼
ä¸¡æ–¹ã®<code>String</code>ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãŒã‚¹ã‚³ãƒ¼ãƒ—å¤–ã«ãªã£ãŸã¨ãã€ä¸¡æ–¹ã®<code>String</code>ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãŒãƒ¡ãƒ¢ãƒªãƒãƒƒãƒ•ã‚¡ãƒ¼ã‚’è§£æ”¾ã™ã‚‹ã“ã¨ã‚’è©¦ã¿ã€äºŒé‡é–‹æ”¾ã‚¨ãƒ©ãƒ¼ã‚’æ‹›ãã¾ã™ã€‚
ã¾ãŸã€åŒã˜ãƒ¡ãƒ¢ãƒªãƒãƒƒãƒ•ã‚¡ãƒ¼ã‚’æŒ‡ã—ç¤ºã™2ã¤ã®åˆ¥ã®<code>&amp;mut String</code>å‚ç…§ã‚’ä½œæˆã§ãã€Rustã®å€Ÿç”¨ãƒ«ãƒ¼ãƒ«ã«é•åã—ã¾ã™ã€‚</p>
</blockquote>
<h3 id="case-study-2-u32äº‹ä¾‹è§£èª¬2-u32"><a class="header" href="#case-study-2-u32äº‹ä¾‹è§£èª¬2-u32">Case study 2: <code>u32</code>ï¼ˆäº‹ä¾‹è§£èª¬2: u32ï¼‰</a></h3>
<p><code>u32</code> implements <code>Copy</code>. All integer types do, in fact.<br />
An integer is "just" the bytes that represent the number in memory. There's nothing more!
If you copy those bytes, you get another perfectly valid integer instance.
Nothing bad can happen, so Rust allows it.</p>
<blockquote>
<p><code>u32</code>ã¯<code>Copy</code>ã‚’å®Ÿè£…ã—ã¦ã„ã¾ã™ã€‚å®Ÿéš›ã€ã™ã¹ã¦ã®æ•´æ•°å‹ãŒå®Ÿè£…ã—ã¦ã„ã¾ã™ã€‚
æ•´æ•°ã¯ã€æ•°ã‚’è¡¨ç¾ã™ã‚‹ãƒ¡ãƒ¢ãƒªå†…ã®ã€Œå˜ãªã‚‹ã€ãƒã‚¤ãƒˆã§ã™ã€‚ãã‚Œä»¥ä¸Šã®ã‚‚ã®ã§ã¯ã‚ã‚Šã¾ã›ã‚“ï¼
ãã‚Œã‚‰ã®ãƒã‚¤ãƒˆã‚’ã‚³ãƒ”ãƒ¼ã—ãŸå ´åˆã€å®Œå…¨ã«æœ‰åŠ¹ãªåˆ¥ã®æ•´æ•°ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’å¾—ã‚‰ã‚Œã¾ã™ã€‚
è‰¯ããªã„ã“ã¨ã¯ä½•ã‚‚ç™ºç”Ÿã—ãªã„ãŸã‚ã€Rustã¯ãã‚Œã‚’è¨±å¯ã—ã¾ã™ã€‚</p>
</blockquote>
<h3 id="case-study-3-mut-u32äº‹ä¾‹è§£èª¬3-mut-u32"><a class="header" href="#case-study-3-mut-u32äº‹ä¾‹è§£èª¬3-mut-u32">Case study 3: <code>&amp;mut u32</code>ï¼ˆäº‹ä¾‹è§£èª¬3: &amp;mut u32ï¼‰</a></h3>
<p>When we introduced ownership and mutable borrows, we stated one rule quite clearly: there
can only ever be <em>one</em> mutable borrow of a value at any given time.<br />
That's why <code>&amp;mut u32</code> doesn't implement <code>Copy</code>, even though <code>u32</code> does.</p>
<blockquote>
<p>æ‰€æœ‰æ¨©ã¨å¯å¤‰å‚ç…§ã‚’å°å…¥ã—ãŸã¨ãã€ã¨ã¦ã‚‚æ˜ç¢ºãª1ã¤ã®ãƒ«ãƒ¼ãƒ«ã‚’è¿°ã¹ã¾ã—ãŸã€‚
ç‰¹å®šã®æ™‚ç‚¹ã§ã€å€¤ã®å¯å¤‰å‚ç…§ãŒãŸã£ãŸ1ã¤ã®ã¿å­˜åœ¨ã§ãã¾ã™ã€‚
ãã‚ŒãŒã€<code>u32</code>ãŒå®Ÿè£…ã—ã¦ã„ã‚‹ã«ã‚‚é–¢ã‚ã‚‰ãšã€<code>&amp;mut u32</code>ãŒ<code>Copy</code>ã‚’å®Ÿè£…ã—ã¦ã„ãªã„ç†ç”±ã§ã™ã€‚</p>
</blockquote>
<p>If <code>&amp;mut u32</code> implemented <code>Copy</code>, you could create multiple mutable references to
the same value and modify it in multiple places at the same time.
That'd be a violation of Rust's borrowing rules!
It follows that <code>&amp;mut T</code> never implements <code>Copy</code>, no matter what <code>T</code> is.</p>
<blockquote>
<p><code>&amp;mut u32</code>ãŒ<code>Copy</code>ã‚’å®Ÿè£…ã—ãŸå ´åˆã€åŒã˜å€¤ã¸ã®è¤‡æ•°ã®å¯å¤‰å‚ç…§ã‚’ä½œæˆã§ãã€åŒæ™‚ã«è¤‡æ•°ã®ç®‡æ‰€ã§ãã‚Œã‚’ä¿®æ­£ã§ãã¾ã™ã€‚
ãã‚Œã¯ã€Rustã®å€Ÿç”¨ãƒ«ãƒ¼ãƒ«ã«é•åã—ã¾ã™ï¼
ãã‚ŒãŒã€<code>&amp;mut T</code>ãŒ<code>Copy</code>ã‚’å®Ÿè£…ã—ãªã„ç†ç”±ã§ã€<code>T</code>ãŒä½•ã§ã‚ã‚Œãã†ã§ã™ã€‚</p>
</blockquote>
<h2 id="implementing-copycopyã®å®Ÿè£…"><a class="header" href="#implementing-copycopyã®å®Ÿè£…">Implementing <code>Copy</code>ï¼ˆCopyã®å®Ÿè£…ï¼‰</a></h2>
<p>In most cases, you don't need to manually implement <code>Copy</code>.
You can just derive it, like this:</p>
<blockquote>
<p>ã»ã¨ã‚“ã©ã®å ´åˆã§ã€æ‰‹å‹•ã§<code>Copy</code>ã‚’å®Ÿè£…ã™ã‚‹å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚
æ¬¡ã®ã‚ˆã†ã«ã€å˜ã«ãã‚Œã‚’å°å‡ºã§ãã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Copy, Clone)]
struct MyStruct {
    field: u32,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="exercise-38"><a class="header" href="#exercise-38">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/04_traits/12_copy"><code>04_traits/12_copy</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-drop-traitdropãƒˆãƒ¬ã‚¤ãƒˆ"><a class="header" href="#the-drop-traitdropãƒˆãƒ¬ã‚¤ãƒˆ">The <code>Drop</code> traitï¼ˆDropãƒˆãƒ¬ã‚¤ãƒˆï¼‰</a></h1>
<p>When we introduced <a href="04_traits/../03_ticket_v1/11_destructor.html">destructors</a>,
we mentioned that the <code>drop</code> function:</p>
<ol>
<li>reclaims the memory occupied by the type (i.e. <code>std::mem::size_of</code> bytes)</li>
<li>cleans up any additional resources that the value might be managing (e.g. the heap buffer of a <code>String</code>)</li>
</ol>
<blockquote>
<p>ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãƒ¼ã‚’å°å…¥ã—ãŸã¨ãã€<code>drop</code>é–¢æ•°ã«ã¤ã„ã¦è¨€åŠã—ã¾ã—ãŸã€‚</p>
<ol>
<li>ä¾‹ãˆã°<code>std::mem::size_of</code>ãƒã‚¤ãƒˆã§ã€ãã®å‹ã«ã‚ˆã£ã¦å°‚æœ‰ã•ã‚Œã‚‹ãƒ¡ãƒ¢ãƒªã‚’å›åã—ã¾ã™ã€‚</li>
<li>ä¾‹ãˆã°<code>String</code>ã®ãƒ’ãƒ¼ãƒ—ãƒãƒƒãƒ•ã‚¡ãƒ¼ãªã©ã€ãã®å€¤ãŒç®¡ç†ã—ã¦ã„ã‚‹ã‹ã‚‚ã—ã‚Œãªã„ä»»æ„ã®è¿½åŠ ãƒªã‚½ãƒ¼ã‚¹ã‚’ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ã—ã¾ã™ã€‚</li>
</ol>
</blockquote>
<p>Step 2. is where the <code>Drop</code> trait comes in.</p>
<blockquote>
<p>ã‚¹ãƒ†ãƒƒãƒ—2ã¯ã€<code>Drop</code>ãƒˆãƒ¬ã‚¤ãƒˆãŒç™»å ´ã™ã‚‹å ´é¢ã§ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Drop {
    fn drop(&amp;mut self);
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>Drop</code> trait is a mechanism for you to define <em>additional</em> cleanup logic for your types,
beyond what the compiler does for you automatically.<br />
Whatever you put in the <code>drop</code> method will be executed when the value goes out of scope.</p>
<blockquote>
<p><code>Drop</code>ãƒˆãƒ¬ã‚¤ãƒˆã¯ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ¼ãŒè‡ªå‹•çš„ã«è¡Œã†ã“ã¨ä»¥ä¸Šã«ã€å‹ã®_è¿½åŠ ã®_ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ãƒ­ã‚¸ãƒƒã‚¯ã‚’å®šç¾©ã™ã‚‹ãŸã‚ã®ãƒ¡ã‚«ãƒ‹ã‚ºãƒ ã§ã™ã€‚
<code>drop</code>ãƒ¡ã‚½ãƒƒãƒ‰å†…ã«å…¥ã‚ŒãŸã‚‚ã®ã¯ä½•ã§ã‚‚ã€å€¤ãŒã‚¹ã‚³ãƒ¼ãƒ—å¤–ã«ãªã£ãŸã¨ãã«å®Ÿè¡Œã•ã‚Œã¾ã™ã€‚</p>
</blockquote>
<h2 id="drop-and-copydropã¨copy"><a class="header" href="#drop-and-copydropã¨copy"><code>Drop</code> and <code>Copy</code>ï¼ˆDropã¨Copyï¼‰</a></h2>
<p>When talking about the <code>Copy</code> trait, we said that a type can't implement <code>Copy</code> if it
manages additional resources beyond the <code>std::mem::size_of</code> bytes that it occupies in memory.</p>
<blockquote>
<p><code>Copy</code>ãƒˆãƒ¬ã‚¤ãƒˆã«ã¤ã„ã¦è©±ã—ã¦ã„ã‚‹ã¨ãã€å‹ãŒãƒ¡ãƒ¢ãƒªå†…ã«å°‚æœ‰ã™ã‚‹<code>std::mem::size_of</code>ãƒã‚¤ãƒˆã‚’è¶…ãˆã‚‹è¿½åŠ ãƒªã‚½ãƒ¼ã‚¹ã‚’ç®¡ç†ã—ã¦ã„ã‚‹å ´åˆã€ãã®å‹ã¯<code>Copy</code>ã‚’å®Ÿè£…ã§ããªã„ã¨è¨€ã„ã¾ã—ãŸã€‚</p>
</blockquote>
<p>You might wonder: how does the compiler know if a type manages additional resources?
That's right: <code>Drop</code> trait implementations!<br />
If your type has an explicit <code>Drop</code> implementation, the compiler will assume
that your type has additional resources attached to it and won't allow you to implement <code>Copy</code>.</p>
<blockquote>
<p>å›°æƒ‘ã—ã¦ã„ã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ¼ã¯ã€å‹ãŒè¿½åŠ ãƒªã‚½ãƒ¼ã‚¹ã‚’ç®¡ç†ã—ã¦ã„ã‚‹ã“ã¨ã‚’ã©ã®ã‚ˆã†ã«çŸ¥ã‚‹ã®ã§ã—ã‚‡ã†ã‹ï¼Ÿ
ãã®ã¨ãŠã‚Šã§ã™ã€‚<code>Drop</code>ãƒˆãƒ¬ã‚¤ãƒˆã®å®Ÿè£…ã§ã™ï¼
å‹ãŒæ˜ç¤ºçš„ã«<code>Drop</code>å®Ÿè£…ã‚’æŒã£ã¦ã„ã‚‹å ´åˆã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ¼ã¯å‹ãŒå‹ã«ä»˜å±ã™ã‚‹è¿½åŠ ãƒªã‚½ãƒ¼ã‚¹ã‚’æŒã£ã¦ã„ã‚‹ã¨ä»®å®šã—ã¦ã€<code>Copy</code>ã‚’å®Ÿè£…ã™ã‚‹ã“ã¨ã‚’è¨±å¯ã—ã¾ã›ã‚“ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// This is a unit struct, i.e. a struct with no fields.
// ã“ã‚Œã¯ãƒ¦ãƒ‹ãƒƒãƒˆæ§‹é€ ä½“ã§ã€ã¤ã¾ã‚Šãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®ãªã„æ§‹é€ ä½“ã§ã™ã€‚
#[derive(Clone, Copy)]
struct MyType;

impl Drop for MyType {
    fn drop(&amp;mut self) {
       // We don't need to do anything here,
       // it's enough to have an "empty" Drop implementation
       // ã“ã“ã§ä½•ã‚‚ã™ã‚‹å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚
       // ã€Œç©ºã®ã€Dropå®Ÿè£…ãŒã‚ã‚Œã°ååˆ†ã§ã™ã€‚
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The compiler will complain with this error message:</p>
<blockquote>
<p>ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã¯ã€æ¬¡ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã§æ–‡å¥ã‚’è¨€ã†ã§ã—ã‚‡ã†ã€‚</p>
</blockquote>
<pre><code class="language-text">error[E0184]: the trait `Copy` cannot be implemented for this type; the type has a destructor
 --&gt; src/lib.rs:2:17
  |
2 | #[derive(Clone, Copy)]
  |                 ^^^^ `Copy` not allowed on types with destructors
</code></pre>
<h2 id="exercise-39"><a class="header" href="#exercise-39">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/04_traits/13_drop"><code>04_traits/13_drop</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wrapping-upä»•ä¸Šã’-1"><a class="header" href="#wrapping-upä»•ä¸Šã’-1">Wrapping upï¼ˆä»•ä¸Šã’ï¼‰</a></h1>
<p>We've covered quite a few different traits in this chapterâ€”and we've only scratched the surface!
It may feel like you have a lot to remember, but don't worry: you'll bump into these traits
so often when writing Rust code that they'll soon become second nature.</p>
<blockquote>
<p>ã“ã®ç« ã«ãŠã„ã¦ã€ã‹ãªã‚Šå¤šãã®ãƒˆãƒ¬ã‚¤ãƒˆã‚’èª¬æ˜ã—ã¾ã—ãŸã€‚ãã—ã¦ã¾ã è¡¨é¢ã‚’å¼•ã£æ»ã„ãŸã ã‘ã§ã™ï¼
è¦šãˆã¦ãŠãã¹ãå¤šãã®ã“ã¨ãŒã‚ã‚‹ã‚ˆã†ã«æ„Ÿã˜ã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ãŒã€å¿ƒé…ã—ãªã„ã§ãã ã•ã„ã€‚
Rustã§ã‚³ãƒ¼ãƒ‰ã‚’è¨˜è¿°ã™ã‚‹ã¨ãã€é »ç¹ã«ã“ã‚Œã‚‰ã®ãƒˆãƒ¬ã‚¤ãƒˆã«é­é‡ã™ã‚‹ãŸã‚ã€ã™ãã«ãã‚ŒãŒ2ã¤ç›®ã®ç¿’æ…£ã«ãªã‚‹ã§ã—ã‚‡ã†ã€‚</p>
</blockquote>
<h2 id="closing-thoughtsæœ€å¾Œã«è¨€ã£ã¦ãŠããŸã„ã“ã¨"><a class="header" href="#closing-thoughtsæœ€å¾Œã«è¨€ã£ã¦ãŠããŸã„ã“ã¨">Closing thoughtsï¼ˆæœ€å¾Œã«è¨€ã£ã¦ãŠããŸã„ã“ã¨ï¼‰</a></h2>
<p>Traits are powerful, but don't overuse them.<br />
A few guidelines to keep in mind:</p>
<ul>
<li>Don't make a function generic if it is always invoked with a single type. It introduces indirection in your
codebase, making it harder to understand and maintain.</li>
<li>Don't create a trait if you only have one implementation. It's a sign that the trait is not needed.</li>
<li>Implement standard traits for your types (<code>Debug</code>, <code>PartialEq</code>, etc.) whenever it makes sense.
It will make your types more idiomatic and easier to work with, unlocking a lot of functionality provided
by the standard library and ecosystem crates.</li>
<li>Implement traits from third-party crates if you need the functionality they unlock within their ecosystem.</li>
<li>Beware of making code generic solely to use mocks in your tests. The maintainability cost of this approach
can be high, and it's often better to use a different testing strategy. Check out the
<a href="https://github.com/mainmatter/rust-advanced-testing-workshop">testing masterclass</a>
for details on high-fidelity testing.</li>
</ul>
<blockquote>
<p>ãƒˆãƒ¬ã‚¤ãƒˆã¯å¼·åŠ›ã§ã™ãŒã€ãã‚Œã‚‰ã‚’ä¹±ç”¨ã—ãªã„ã§ãã ã•ã„ã€‚
æ¬¡ã®ã„ãã¤ã‹ã®ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³ã‚’å¿ƒã«ç•™ã‚ã¦ãŠã„ã¦ãã ã•ã„ã€‚</p>
<ul>
<li>å¸¸ã«å˜ä¸€ã®å‹ã§é–¢æ•°ãŒå‘¼ã³å‡ºã•ã‚Œã‚‹å ´åˆã¯ã‚¸ã‚§ãƒãƒªãƒƒã‚¯ã«ã—ãªã„ã§ãã ã•ã„ã€‚
ãã‚Œã¯ã‚³ãƒ¼ãƒ‰ãƒ™ãƒ¼ã‚¹ã«é–“æ¥æ€§ã‚’å°å…¥ã—ã¦ã€ç†è§£ã™ã‚‹ã“ã¨ã¨ç¶­æŒã™ã‚‹ã“ã¨ã‚’é›£ã—ãã—ã¾ã™ã€‚</li>
<li>å˜ä¸€ã®å®Ÿè£…ã—ã‹ãªã„å ´åˆã€ãƒˆãƒ¬ã‚¤ãƒˆã‚’ä½œæˆã—ãªã„ã§ãã ã•ã„ã€‚ãã‚Œã¯ãƒˆãƒ¬ã‚¤ãƒˆãŒå¿…è¦ã¨ã•ã‚Œãªã„åˆå›³ã§ã™ã€‚</li>
<li><code>Debug</code>ã€<code>PartialEq</code>ãªã©æ¨™æº–ãƒˆãƒ¬ã‚¤ãƒˆã‚’å‹ã«å®Ÿè£…ã™ã‚‹ã¨ãã¯ã„ã¤ã§ã‚‚ã€æ„å‘³ãŒã‚ã‚‹ã‚ˆã†ã«ã—ã¦ãã ã•ã„ã€‚
ãã‚Œã¯ã€å‹ã‚’ã‚ˆã‚Šæ…£ç”¨çš„ã«ã€ä¸€ç·’ã«æ©Ÿèƒ½ã™ã‚‹ã“ã¨ã‚’å®¹æ˜“ã«ã—ã¦ã€æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚„ã‚¨ã‚³ã‚·ã‚¹ãƒ†ãƒ ã‚¯ãƒ¬ãƒ¼ãƒˆã«ã‚ˆã£ã¦æä¾›ã•ã‚Œã‚‹å¤šãã®æ©Ÿèƒ½ã‚’è§£æ”¾ã—ã¾ã™ã€‚</li>
<li>å¿…è¦ã«å¿œã˜ã¦ã‚µãƒ¼ãƒ‰ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ¬ã‚¤ãƒˆã®ãƒˆãƒ¬ã‚¤ãƒˆã‚’å®Ÿè£…ã—ã¦ã€ãã‚Œã‚‰ã®ã‚¨ã‚³ã‚·ã‚¹ãƒ†ãƒ ãŒæŒã¤æ©Ÿèƒ½ã‚’è§£æ”¾ã—ã¦ãã ã•ã„ã€‚</li>
<li>ãƒ†ã‚¹ãƒˆã§ãƒ¢ãƒƒã‚¯ã‚’ä½¿ç”¨ã™ã‚‹ãŸã‚ã ã‘ã«ã‚³ãƒ¼ãƒ‰ã‚’ã‚¸ã‚§ãƒãƒªãƒƒã‚¯ã«ã™ã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚
ã“ã®ã‚¢ãƒ—ãƒ­ãƒ¼ãƒã®ä¿å®ˆã‚³ã‚¹ãƒˆã¯é«˜ããªã‚Šã€æ™‚ã€…ç•°ãªã‚‹ãƒ†ã‚¹ãƒˆæˆ¦ç•¥ã‚’ä½¿ç”¨ã™ã‚‹æ–¹ãŒè‰¯ã„ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚
é«˜ã„å¿ å®Ÿåº¦ã‚’ã‚‚ã¤ãƒ†ã‚¹ãƒˆã«ã¤ã„ã¦ã®è©³ç´°ã¯ã€ãƒ†ã‚¹ãƒˆãƒã‚¹ã‚¿ãƒ¼ã‚¯ãƒ©ã‚¹ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚</li>
</ul>
</blockquote>
<h2 id="testing-your-knowledgeçŸ¥è­˜ã®ãƒ†ã‚¹ãƒˆ"><a class="header" href="#testing-your-knowledgeçŸ¥è­˜ã®ãƒ†ã‚¹ãƒˆ">Testing your knowledgeï¼ˆçŸ¥è­˜ã®ãƒ†ã‚¹ãƒˆï¼‰</a></h2>
<p>Before moving on, let's go through one last exercise to consolidate what we've learned.
You'll have minimal guidance this timeâ€”just the exercise description and the tests to guide you.</p>
<blockquote>
<p>æ¬¡ã«é€²ã‚€å‰ã«ã€å­¦ã‚“ã ã“ã¨ã‚’å›ºã‚ã‚‹ãŸã‚ã«æœ€å¾Œã®æ¼”ç¿’ã‚’1ã¤è¡Œã„ã¾ã—ã‚‡ã†ã€‚
ä»Šå›ã¯ã€æœ€å°é™ã®æ¡ˆå†…ãŒã‚ã‚Šã¾ã™ã€‚ãã‚Œã¯ã€å˜ãªã‚‹æ¼”ç¿’ã®èª¬æ˜ã¨ã€ãƒ†ã‚¹ãƒˆã®æ¡ˆå†…ã§ã™ã€‚</p>
</blockquote>
<h2 id="exercise-40"><a class="header" href="#exercise-40">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/04_traits/14_outro"><code>04_traits/14_outro</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="modelling-a-ticket-pt-2ãƒã‚±ãƒƒãƒˆã®ãƒ¢ãƒ‡ãƒªãƒ³ã‚°ãã®2"><a class="header" href="#modelling-a-ticket-pt-2ãƒã‚±ãƒƒãƒˆã®ãƒ¢ãƒ‡ãƒªãƒ³ã‚°ãã®2">Modelling A Ticket, pt. 2ï¼ˆãƒã‚±ãƒƒãƒˆã®ãƒ¢ãƒ‡ãƒªãƒ³ã‚°ã€ãã®2ï¼‰</a></h1>
<p>The <code>Ticket</code> struct we worked on in the previous chapters is a good start,
but it still screams "I'm a beginner Rustacean!".</p>
<blockquote>
<p>å‰ã®ç« ã§ä½œæ¥­ã—ãŸ<code>Ticket</code>æ§‹é€ ä½“ã¯ã€è‰¯ã„ã‚¹ã‚¿ãƒ¼ãƒˆã§ã™ãŒã€ãã‚Œã§ã‚‚ã€Œç§ã¯åˆå¿ƒè€…ã®Rustaceanã§ã™ï¼ã€ã¨å«ã‚“ã§ã„ã¾ã™ã€‚</p>
</blockquote>
<p>We'll use this chapter to refine our Rust domain modelling skills.
We'll need to introduce a few more concepts along the way:</p>
<ul>
<li><code>enum</code>s, one of Rust's most powerful features for data modeling</li>
<li>The <code>Option</code> type, to model nullable values</li>
<li>The <code>Result</code> type, to model recoverable errors</li>
<li>The <code>Debug</code> and <code>Display</code> traits, for printing</li>
<li>The <code>Error</code> trait, to mark error types</li>
<li>The <code>TryFrom</code> and <code>TryInto</code> traits, for fallible conversions</li>
<li>Rust's package system, explaining what's a library, what's a binary, how to use third-party crates</li>
</ul>
<blockquote>
<p>Rustãƒ‰ãƒ¡ã‚¤ãƒ³ãƒ¢ãƒ‡ãƒªãƒ³ã‚°æŠ€è¡“ã‚’æ´—ç·´ã™ã‚‹ãŸã‚ã«ã“ã®ç« ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚
é€”ä¸­ã§ã„ãã¤ã‹ã®æ¦‚å¿µã‚’ç´¹ä»‹ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚</p>
<ul>
<li>Rustã®ãƒ‡ãƒ¼ã‚¿ãƒ¢ãƒ‡ãƒªãƒ³ã‚°ã®æœ€ã‚‚å¼·åŠ›ãªæ©Ÿèƒ½ã®1ã¤ã§ã‚ã‚‹<code>enum</code></li>
<li>nullå¯èƒ½ãªå€¤ã‚’ãƒ¢ãƒ‡ãƒ«åŒ–ã™ã‚‹<code>Option</code>å‹</li>
<li>å›å¾©å¯èƒ½ãªã‚¨ãƒ©ãƒ¼ã‚’ãƒ¢ãƒ‡ãƒ«åŒ–ã™ã‚‹<code>Result</code>å‹</li>
<li>å°å­—ã™ã‚‹ãŸã‚ã®<code>Debug</code>ã¨<code>Display</code>ãƒˆãƒ¬ã‚¤ãƒˆ</li>
<li>ã‚¨ãƒ©ãƒ¼å‹ã‚’ä½œæˆã™ã‚‹<code>Error</code>ãƒˆãƒ¬ã‚¤ãƒˆ</li>
<li>å¤±æ•—ã™ã‚‹å¯èƒ½æ€§ã®ã‚ã‚‹å¤‰æ›ç”¨ã®ãŸã‚ã®<code>TryFrom</code>ã¨<code>TryInto</code>ãƒˆãƒ¬ã‚¤ãƒˆ</li>
<li>Rustã®ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‚·ã‚¹ãƒ†ãƒ ã€ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã¨ã¯ä½•ã‹ã€ãƒã‚¤ãƒŠãƒªã¨ã¯ä½•ã‹ã€ã‚µãƒ¼ãƒ‰ãƒ‘ãƒ¼ãƒ†ã‚£ã®ã‚¯ãƒ¬ãƒ¼ãƒˆã‚’ä½¿ç”¨æ–¹æ³•ã®èª¬æ˜</li>
</ul>
</blockquote>
<h2 id="exercise-41"><a class="header" href="#exercise-41">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/05_ticket_v2/00_intro"><code>05_ticket_v2/00_intro</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enumerationsåˆ—æŒ™å‹"><a class="header" href="#enumerationsåˆ—æŒ™å‹">Enumerationsï¼ˆåˆ—æŒ™å‹ï¼‰</a></h1>
<p>Based on the validation logic you wrote <a href="05_ticket_v2/../03_ticket_v1/02_validation.html">in a previous chapter</a>,
there are only a few valid statuses for a ticket: <code>To-Do</code>, <code>InProgress</code> and <code>Done</code>.<br />
This is not obvious if we look at the <code>status</code> field in the <code>Ticket</code> struct or at the type of the <code>status</code>
parameter in the <code>new</code> method:</p>
<blockquote>
<p>å‰ã®ç« ã§è¨˜è¿°ã—ãŸæ¤œè¨¼ãƒ­ã‚¸ãƒƒã‚¯ã«åŸºã¥ã„ã¦ã€ãƒã‚±ãƒƒãƒˆã®æœ‰åŠ¹ãªçŠ¶æ…‹ã¯ã€<code>To-Do</code>ã€<code>InProgress</code>ãã—ã¦<code>Done</code>ã®ã¿ã§ã™ã€‚
<code>Ticket</code>æ§‹é€ ä½“ã®<code>status</code>ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚„<code>new</code>ãƒ¡ã‚½ãƒƒãƒ‰ã®<code>status</code>ã®å‹ã‚’è¦‹ã¦ã‚‚ã€ã“ã‚Œã¯æ˜ç¢ºã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, PartialEq)]
pub struct Ticket {
    title: String,
    description: String,
    status: String,
}

impl Ticket {
    pub fn new(title: String, description: String, status: String) -&gt; Self {
        // [...]
    }
}
<span class="boring">}</span></code></pre></pre>
<p>In both cases we're using <code>String</code> to represent the <code>status</code> field.
<code>String</code> is a very general typeâ€”it doesn't immediately convey the information that the <code>status</code> field
has a limited set of possible values. Even worse, the caller of <code>Ticket::new</code> will only find out <strong>at runtime</strong>
if the status they provided is valid or not.</p>
<blockquote>
<p>ä¸¡æ–¹ã®ã‚±ãƒ¼ã‚¹ã§ã€<code>status</code>ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’è¡¨ç¾ã™ã‚‹ãŸã‚ã«<code>String</code>ã‚’ä½¿ç”¨ã—ã¦ã„ã¾ã™ã€‚
<code>String</code>ã¯ã¨ã¦ã‚‚ä¸€èˆ¬çš„ãªå‹ã§ã€<code>status</code>ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒå¯èƒ½ãªå€¤ã®åˆ¶é™ã•ã‚ŒãŸé›†åˆã‚’æŒã£ã¦ã„ã‚‹ã¨ã„ã†æƒ…å ±ã‚’ã™ãã«ä¼ãˆã‚‹ã“ã¨ãŒã§ãã¾ã›ã‚“ã€‚
ã•ã‚‰ã«æ‚ªã„ã“ã¨ã«ã€<code>Ticket::new</code>ã®å‘¼ã³å‡ºã—å…ƒã¯ã€æä¾›ã—ãŸçŠ¶æ…‹ãŒæœ‰åŠ¹ã‹ã©ã†ã‹ã‚’<strong>ãƒ©ãƒ³ã‚¿ã‚¤ãƒ </strong>ã§ã®ã¿çŸ¥ã‚Šã¾ã™ã€‚</p>
</blockquote>
<p>We can do better than that with <strong>enumerations</strong>.</p>
<blockquote>
<p><strong>åˆ—æŒ™å‹</strong>ã‚’ä½¿ç”¨ã—ã¦ã€ãã‚Œã‚ˆã‚Šã†ã¾ãè¡Œãˆã¾ã™ã€‚</p>
</blockquote>
<h2 id="enum"><a class="header" href="#enum"><code>enum</code></a></h2>
<p>An enumeration is a type that can have a fixed set of values, called <strong>variants</strong>.<br />
In Rust, you define an enumeration using the <code>enum</code> keyword:</p>
<blockquote>
<p>åˆ—æŒ™å‹ã¯ã€<strong>ãƒãƒªã‚¢ãƒ³ãƒˆ</strong>ã¨å‘¼ã°ã‚Œã‚‹å›ºå®šã•ã‚ŒãŸå€¤ã®é›†åˆã‚’æŒã¦ã‚‹å‹ã§ã™ã€‚
Rustã«ãŠã„ã¦ã€<code>enum</code>ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’ä½¿ç”¨ã—ã¦åˆ—æŒ™å‹ã‚’å®šç¾©ã—ã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Status {
    ToDo,
    InProgress,
    Done,
}
<span class="boring">}</span></code></pre></pre>
<p><code>enum</code>, just like <code>struct</code>, defines <strong>a new Rust type</strong>.</p>
<blockquote>
<p>ã¡ã‚‡ã†ã©<code>struct</code>ã®ã‚ˆã†ã«ã€<code>enum</code>ã¯<strong>æ–°ã—ã„Rustã®å‹</strong>ã‚’å®šç¾©ã—ã¾ã™ã€‚</p>
</blockquote>
<h2 id="exercise-42"><a class="header" href="#exercise-42">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/05_ticket_v2/01_enum"><code>05_ticket_v2/01_enum</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="match"><a class="header" href="#match"><code>match</code></a></h1>
<p>You may be wonderingâ€”what can you actually <strong>do</strong> with an enum?<br />
The most common operation is to <strong>match</strong> on it.</p>
<blockquote>
<p>æˆ¸æƒ‘ã£ã¦ã„ã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚åˆ—æŒ™å‹ã§å®Ÿéš›ã«<strong>ä½•ãŒã§ãã‚‹</strong>ã®ã§ã—ã‚‡ã†ã‹ï¼Ÿ</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Status {
    ToDo,
    InProgress,
    Done
}

impl Status {
    fn is_done(&amp;self) -&gt; bool {
        match self {
            Status::Done =&gt; true,
            // The `|` operator lets you match multiple patterns.
            // It reads as "either `Status::ToDo` or `Status::InProgress`".
            // `|`æ¼”ç®—å­ã¯è¤‡æ•°ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã«ãƒãƒƒãƒã—ã¾ã™ã€‚
            // ãã‚Œã¯ã€ã€Œ`Status::ToDo`ã¾ãŸã¯`Status::InProgress`ã®ã©ã¡ã‚‰ã‹ã€ã¨èª­ã¿ã¾ã™ã€‚
            Status::InProgress | Status::ToDo =&gt; false
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>A <code>match</code> statement that lets you compare a Rust value against a series of <strong>patterns</strong>.<br />
You can think of it as a type-level <code>if</code>. If <code>status</code> is a <code>Done</code> variant, execute the first block;
if it's a <code>InProgress</code> or <code>ToDo</code> variant, execute the second block.</p>
<blockquote>
<p><code>match</code>æ–‡ã¯ã€ä¸€é€£ã®<strong>ãƒ‘ã‚¿ãƒ¼ãƒ³</strong>ã«å¯¾ã—ã¦Rustã®å€¤ã‚’æ¯”è¼ƒã•ã›ã¾ã™ã€‚
ãã‚Œã‚’å‹ãƒ¬ãƒ™ãƒ«ã®<code>if</code>ã¨è€ƒãˆã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚<code>status</code>ãŒ<code>Done</code>ãƒãƒªã‚¢ãƒ³ãƒˆã§ã‚ã‚Œã°ã€æœ€åˆã®ãƒ–ãƒ­ãƒƒã‚¯ã‚’å®Ÿè¡Œã—ã¾ã™ã€‚
ãã‚ŒãŒ<code>InProgress</code>ã¾ãŸã¯<code>ToDo</code>ãƒãƒªã‚¢ãƒ³ãƒˆã®å ´åˆã€2ç•ªç›®ã®ãƒ–ãƒ­ãƒƒã‚¯ã‚’å®Ÿè¡Œã—ã¾ã™ã€‚</p>
</blockquote>
<h2 id="exhaustivenessç¶²ç¾…çš„ã§ã‚ã‚‹ã“ã¨"><a class="header" href="#exhaustivenessç¶²ç¾…çš„ã§ã‚ã‚‹ã“ã¨">Exhaustivenessï¼ˆç¶²ç¾…çš„ã§ã‚ã‚‹ã“ã¨ï¼‰</a></h2>
<p>There's one key detail here: <code>match</code> is <strong>exhaustive</strong>. You must handle all enum variants.<br />
If you forget to handle a variant, Rust will stop you <strong>at compile-time</strong> with an error.</p>
<blockquote>
<p>ã“ã“ã«1ã¤ã®é‡è¦ãªè©³ç´°ãŒã‚ã‚Šã¾ã™ã€‚<code>match</code>ã¯<strong>ç¶²ç¾…çš„</strong>ã§ã™ã€‚ã™ã¹ã¦ã®åˆ—æŒ™å‹ã®ãƒãƒªã‚¢ãƒ³ãƒˆã‚’å‡¦ç†ã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚
ãƒãƒªã‚¢ãƒ³ãƒˆã‚’å‡¦ç†ã™ã‚‹ã“ã¨ã‚’å¿˜ã‚ŒãŸå ´åˆã€Rustã¯<strong>ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã«</strong>ã‚¨ãƒ©ãƒ¼ã§åœæ­¢ã—ã¾ã™ã€‚</p>
</blockquote>
<p>E.g. if we forget to handle the <code>ToDo</code> variant:</p>
<blockquote>
<p>ä¾‹ãˆã°ã€<code>ToDo</code>ãƒãƒªã‚¢ãƒ³ãƒˆã‚’å‡¦ç†ã™ã‚‹ã“ã¨ã‚’å¿˜ã‚ŒãŸå ´åˆãƒ»ãƒ»ãƒ»</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match self {
    Status::Done =&gt; true,
    Status::InProgress =&gt; false,
}
<span class="boring">}</span></code></pre></pre>
<p>the compiler will complain:</p>
<blockquote>
<p>ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ¼ã¯æ–‡å¥ã‚’è¨€ã†ã§ã—ã‚‡ã†ã€‚</p>
</blockquote>
<pre><code class="language-text">error[E0004]: non-exhaustive patterns: `ToDo` not covered
 --&gt; src/main.rs:5:9
  |
5 |     match status {
  |     ^^^^^^^^^^^^ pattern `ToDo` not covered
</code></pre>
<p>This is a big deal!<br />
Codebases evolve over timeâ€”you might add a new status down the line, e.g. <code>Blocked</code>. The Rust compiler
will emit an error for every single <code>match</code> statement that's missing logic for the new variant.
That's why Rust developers often sing the praises of "compiler-driven refactoring"â€”the compiler tells you
what to do next, you just have to fix what it reports.</p>
<blockquote>
<p>ã“ã‚Œã¯å¤§å•é¡Œã§ã™ï¼
ã‚³ãƒ¼ãƒ‰ãƒ™ãƒ¼ã‚¹ã¯æ™‚é–“ã¨ã¨ã‚‚ã«é€²åŒ–ã—ã¾ã™ã€‚ä¾‹ãˆã°<code>Blocked</code>ãªã©ã€å°†æ¥ã€æ–°ã—ã„çŠ¶æ…‹ã‚’è¿½åŠ ã™ã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚
Rustã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ¼ã¯ã€æ–°ã—ã„ãƒãƒªã‚¢ãƒ³ãƒˆã«å¯¾ã—ã¦ãƒ­ã‚¸ãƒƒã‚¯ãŒä¸è¶³ã—ã¦ã„ã‚‹ã“ã¨ã‚’ã€ãã‚Œãã‚Œã®å˜ä¸€ã®<code>match</code>æ–‡ã«å¯¾ã—ã¦ã‚¨ãƒ©ãƒ¼ã‚’å‡ºåŠ›ã—ã¾ã™ã€‚
ãã‚ŒãŒã€Rustã®é–‹ç™ºè€…ãŒæ™‚ã€…ã€Œã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ¼é§†å‹•ã®ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°ã€ã‚’ç§°è³›ã™ã‚‹ç†ç”±ã§ã™ã€‚
ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ¼ã¯æ¬¡ã«ä½•ã‚’ã™ã‚‹ã‹ä¼ãˆã€å˜ã«å ±å‘Šã•ã‚ŒãŸã‚‚ã®ã‚’ä¿®æ­£ã—ãªã‘ã‚Œã°ãªã‚‰ãªã„ã ã‘ã§ã™ã€‚</p>
</blockquote>
<h2 id="catch-allã™ã¹ã¦ã‚’ã‚­ãƒ£ãƒƒãƒ"><a class="header" href="#catch-allã™ã¹ã¦ã‚’ã‚­ãƒ£ãƒƒãƒ">Catch-allï¼ˆã™ã¹ã¦ã‚’ã‚­ãƒ£ãƒƒãƒï¼‰</a></h2>
<p>If you don't care about one or more variants, you can use the <code>_</code> pattern as a catch-all:</p>
<blockquote>
<p>1ã¤ä»¥ä¸Šã®ãƒãƒªã‚¢ãƒ³ãƒˆã«æ°—ã«ã—ãªã„å ´åˆã€ã™ã¹ã¦ã‚’ã‚­ãƒ£ãƒƒãƒã™ã‚‹ãŸã‚ã«<code>_</code>ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ä½¿ç”¨ã§ãã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match status {
    Status::Done =&gt; true,
    _ =&gt; false
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>_</code> pattern matches anything that wasn't matched by the previous patterns.</p>
<blockquote>
<p><code>_</code>ãƒ‘ã‚¿ãƒ¼ãƒ³ã¯ã€å‰ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã«ã‚ˆã£ã¦ãƒãƒƒãƒã—ãªã‹ã£ãŸã‚‚ã®ã«ãƒãƒƒãƒã—ã¾ã™ã€‚</p>
</blockquote>
<h2 id="exercise-43"><a class="header" href="#exercise-43">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/05_ticket_v2/02_match"><code>05_ticket_v2/02_match</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="variants-can-hold-dataãƒãƒªã‚¢ãƒ³ãƒˆã¯ãƒ‡ãƒ¼ã‚¿ã‚’ä¿æŒã§ãã‚‹"><a class="header" href="#variants-can-hold-dataãƒãƒªã‚¢ãƒ³ãƒˆã¯ãƒ‡ãƒ¼ã‚¿ã‚’ä¿æŒã§ãã‚‹">Variants can hold dataï¼ˆãƒãƒªã‚¢ãƒ³ãƒˆã¯ãƒ‡ãƒ¼ã‚¿ã‚’ä¿æŒã§ãã‚‹ï¼‰</a></h1>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Status {
    ToDo,
    InProgress,
    Done,
}
<span class="boring">}</span></code></pre></pre>
<p>Our <code>Status</code> enum is what's usually called a <strong>C-style enum</strong>.<br />
Each variant is a simple label, a bit like a named constant. You can find this kind of enum in many programming
languages, like C, C++, Java, C#, Python, etc.</p>
<blockquote>
<p><code>Status</code>åˆ—æŒ™å‹ã¯ã€é€šå¸¸<strong>Cã‚¹ã‚¿ã‚¤ãƒ«ã®åˆ—æŒ™å‹</strong>ã¨å‘¼ã°ã‚Œã¾ã™ã€‚
ãã‚Œãã‚Œã®ãƒãƒªã‚¢ãƒ³ãƒˆã¯1ã¤ã®ãƒ©ãƒ™ãƒ«ã§ã€ã™ã“ã—åå‰ä»˜ãã®å®šæ•°ã®ã‚ˆã†ã§ã™ã€‚
Cã€C++ã€Javaã€C#ã€Pythonãªã©ã®ã‚ˆã†ãªå¤šãã®ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°è¨€èªã§ã€ã“ã®ç¨®é¡ã®åˆ—æŒ™å‹ã‚’è¦‹ã¤ã‘ã‚Œã¾ã™ã€‚</p>
</blockquote>
<p>Rust enums can go further though. We can <strong>attach data to each variant</strong>.</p>
<blockquote>
<p>ã—ã‹ã—ã€Rustã®åˆ—æŒ™å‹ã¯é€²ã‚“ã§ã„ã¾ã™ã€‚<strong>ãã‚Œãã‚Œã®ãƒãƒªã‚¢ãƒ³ãƒˆã«ãƒ‡ãƒ¼ã‚¿ã‚’ä»˜å±ã§ãã¾ã™</strong>ã€‚</p>
</blockquote>
<h2 id="variantsãƒãƒªã‚¢ãƒ³ãƒˆ"><a class="header" href="#variantsãƒãƒªã‚¢ãƒ³ãƒˆ">Variantsï¼ˆãƒãƒªã‚¢ãƒ³ãƒˆï¼‰</a></h2>
<p>Let's say that we want to store the name of the person who's currently working on a ticket.<br />
We would only have this information if the ticket is in progress. It wouldn't be there for a to-do ticket or
a done ticket.
We can model this by attaching a <code>String</code> field to the <code>InProgress</code> variant:</p>
<blockquote>
<p>ç¾åœ¨ãƒã‚±ãƒƒãƒˆã‚’å‡¦ç†ã—ã¦ã„ã‚‹äººã®åå‰ã‚’ä¿å­˜ã—ãŸã„ã¨ã—ã¾ã™ã€‚
ã“ã®æƒ…å ±ã¯ã€ãƒã‚±ãƒƒãƒˆãŒé€²è¡Œä¸­ã®å ´åˆã®ã¿æŒã¦ã‚‹ã¨ã—ã¾ã™ã€‚
ã“ã‚Œã¯ã€æœªå®Œäº†ã®ãƒã‚±ãƒƒãƒˆã¾ãŸã¯å®Œäº†ã—ãŸãƒã‚±ãƒƒãƒˆã«ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚
<code>InProgress</code>ãƒãƒªã‚¢ãƒ³ãƒˆã«<code>String</code>ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’ä»˜ã‘ã‚‹ã“ã¨ã§ã€ã“ã‚Œã‚’ãƒ¢ãƒ‡ãƒ«åŒ–ã§ãã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Status {
    ToDo,
    InProgress {
        assigned_to: String,
    },
    Done,
}
<span class="boring">}</span></code></pre></pre>
<p><code>InProgress</code> is now a <strong>struct-like variant</strong>.<br />
The syntax mirrors, in fact, the one we used to define a structâ€”it's just "inlined" inside the enum, as a variant.</p>
<blockquote>
<p><code>InProgress</code>ã¯ã€ç¾åœ¨ã€<strong>æ§‹é€ ä½“ã®ã‚ˆã†ãªãƒãƒªã‚¢ãƒ³ãƒˆ</strong>ã§ã™ã€‚
å®Ÿéš›ã€æ§‹æ–‡ã¯ã€æ§‹é€ ä½“ã‚’å®šç¾©ã™ã‚‹ã¨ãã«ä½¿ç”¨ã—ãŸã‚‚ã®ã‚’åæ˜ ã—ã¦ã„ã¾ã™ã€‚ã¡ã‚‡ã†ã©ãã‚Œã¯ãƒãƒªã‚¢ãƒ³ãƒˆã¨ã—ã¦åˆ—æŒ™å‹ã®å†…éƒ¨ã‚’ã€Œã‚¤ãƒ³ãƒ©ã‚¤ãƒ³åŒ–ã€ã—ã¦ã„ã¾ã™ã€‚</p>
</blockquote>
<h2 id="accessing-variant-dataãƒãƒªã‚¢ãƒ³ãƒˆã®ãƒ‡ãƒ¼ã‚¿ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹"><a class="header" href="#accessing-variant-dataãƒãƒªã‚¢ãƒ³ãƒˆã®ãƒ‡ãƒ¼ã‚¿ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹">Accessing variant dataï¼ˆãƒãƒªã‚¢ãƒ³ãƒˆã®ãƒ‡ãƒ¼ã‚¿ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ï¼‰</a></h2>
<p>If we try to access <code>assigned_to</code> on a <code>Status</code> instance,</p>
<blockquote>
<p><code>Status</code>ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®<code>assigned_to</code>ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã“ã¨ã‚’è©¦ã¿ãŸå ´åˆã€</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let status: Status = /* */;

// This won't compile
println!("Assigned to: {}", status.assigned_to);
<span class="boring">}</span></code></pre></pre>
<p>the compiler will stop us:</p>
<blockquote>
<p>ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã¯æ­¢ã‚ã‚‹ã§ã—ã‚‡ã†ã€‚</p>
</blockquote>
<pre><code class="language-text">error[E0609]: no field `assigned_to` on type `Status`
 --&gt; src/main.rs:5:40
  |
5 |     println!("Assigned to: {}", status.assigned_to);
  |                                        ^^^^^^^^^^^ unknown field
</code></pre>
<p><code>assigned_to</code> is <strong>variant-specific</strong>, it's not available on all <code>Status</code> instances.<br />
To access <code>assigned_to</code>, we need to use <strong>pattern matching</strong>:</p>
<blockquote>
<p><code>assigned_to</code>ã¯<strong>ãƒãƒªã‚¢ãƒ³ãƒˆå›ºæœ‰</strong>ã§ã™ã€‚ãã‚Œã¯ã™ã¹ã¦ã®<code>Status</code>ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã§åˆ©ç”¨ã§ãã¾ã›ã‚“ã€‚
<code>assigned_to</code>ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ãŸã‚ã«ã€<strong>ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒãƒ³ã‚°</strong>ã‚’ä½¿ç”¨ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match status {
    Status::InProgress { assigned_to } =&gt; {
        println!("Assigned to: {}", assigned_to);
    },
    Status::ToDo | Status::Done =&gt; {
        println!("Done");
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="bindingsãƒã‚¤ãƒ³ãƒ‡ã‚£ãƒ³ã‚°"><a class="header" href="#bindingsãƒã‚¤ãƒ³ãƒ‡ã‚£ãƒ³ã‚°">Bindingsï¼ˆãƒã‚¤ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ï¼‰</a></h2>
<p>In the match pattern <code>Status::InProgress { assigned_to }</code>, <code>assigned_to</code> is a <strong>binding</strong>.<br />
We're <strong>destructuring</strong> the <code>Status::InProgress</code> variant and binding the <code>assigned_to</code> field to
a new variable, also named <code>assigned_to</code>.<br />
If we wanted, we could bind the field to a different variable name:</p>
<blockquote>
<p><code>Status::InProgress { assigned_to }</code>ã®ãƒãƒƒãƒãƒ³ã‚°ãƒ‘ã‚¿ãƒ¼ãƒ³ã«ãŠã„ã¦ã€<code>assigned_to</code>ã¯<strong>ãƒã‚¤ãƒ³ãƒ‡ã‚£ãƒ³ã‚°</strong>ã§ã™ã€‚
<code>Status::InProgress</code>ãƒãƒªã‚¢ãƒ³ãƒˆã‚’<strong>åˆ†å‰²ã—ã¦</strong>ã€æ–°ã—ã„<code>assigned_to</code>å¤‰æ•°ã«<code>assigned_to</code>ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’ãƒã‚¤ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ã—ã¦ã„ã¾ã™ã€‚
å¿…è¦ã§ã‚ã‚Œã°ã€ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’ç•°ãªã‚‹å¤‰æ•°åã«æŸç¸›ã§ãã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match status {
    Status::InProgress { assigned_to: person } =&gt; {
        println!("Assigned to: {}", person);
    },
    Status::ToDo | Status::Done =&gt; {
        println!("Done");
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="exercise-44"><a class="header" href="#exercise-44">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/05_ticket_v2/03_variants_with_data"><code>05_ticket_v2/03_variants_with_data</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="concise-branchingç°¡æ½”ãªãƒ–ãƒ©ãƒ³ãƒåˆ†ã‹ã‚Œ"><a class="header" href="#concise-branchingç°¡æ½”ãªãƒ–ãƒ©ãƒ³ãƒåˆ†ã‹ã‚Œ">Concise branchingï¼ˆç°¡æ½”ãªãƒ–ãƒ©ãƒ³ãƒåˆ†ã‹ã‚Œï¼‰</a></h1>
<p>Your solution to the previous exercise probably looks like this:</p>
<blockquote>
<p>å‰ã®æ¼”ç¿’ã®è§£ç­”ã¯ã€ãŠãã‚‰ãæ¬¡ã®ã‚ˆã†ã«ãªã£ã¦ã„ã‚‹ã§ã—ã‚‡ã†ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Ticket {
    pub fn assigned_to(&amp;self) -&gt; &amp;str {
        match &amp;self.status {
            Status::InProgress { assigned_to } =&gt; assigned_to,
            Status::Done | Status::ToDo =&gt; {
                panic!("Only `In-Progress` tickets can be assigned to someone")
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>You only care about the <code>Status::InProgress</code> variant.
Do you really need to match on all the other variants?</p>
<blockquote>
<p><code>Status::InProgress</code>ãƒãƒªã‚¢ãƒ³ãƒˆã«ã¤ã„ã¦æ°—ã«ã‹ã‘ã‚‹ã ã‘ã§ã™ã€‚
æœ¬å½“ã«ã™ã¹ã¦ã®ä»–ã®ãƒãƒªã‚¢ãƒ³ãƒˆã«ãƒãƒƒãƒã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã®ã§ã—ã‚‡ã†ã‹ï¼Ÿ</p>
</blockquote>
<p>New constructs to the rescue!</p>
<blockquote>
<p>æ–°ã—ã„æ§‹ç¯‰ç‰©ãŒæ•‘æ´ã—ã¾ã™ã€‚</p>
</blockquote>
<h2 id="if-let"><a class="header" href="#if-let"><code>if let</code></a></h2>
<p>The <code>if let</code> construct allows you to match on a single variant of an enum,
without having to handle all the other variants.</p>
<blockquote>
<p><code>if let</code>æ§‹ç¯‰ã¯ã€ä»–ã®ãƒãƒªã‚¢ãƒ³ãƒˆã™ã¹ã¦ã‚’å‡¦ç†ã™ã‚‹ã“ã¨ãªãã€åˆ—æŒ™å‹ã®1ã¤ã®ãƒãƒªã‚¢ãƒ³ãƒˆã«ãƒãƒƒãƒã•ã›ã¾ã™ã€‚</p>
</blockquote>
<p>Here's how you can use <code>if let</code> to simplify the <code>assigned_to</code> method:</p>
<blockquote>
<p><code>assigned_to</code>ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å˜ç´”åŒ–ã™ã‚‹ãŸã‚ã«ã€<code>if let</code>ã‚’ä½¿ç”¨ã™ã‚‹æ–¹æ³•ã‚’ã“ã“ã«ç¤ºã—ã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Ticket {
    pub fn assigned_to(&amp;self) -&gt; &amp;str {
        if let Status::InProgress { assigned_to } = &amp;self.status {
            assigned_to
        } else {
            panic!("Only `In-Progress` tickets can be assigned to someone");
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="letelse"><a class="header" href="#letelse"><code>let/else</code></a></h2>
<p>If the <code>else</code> branch is meant to return early (a panic counts as returning early!),
you can use the <code>let/else</code> construct:</p>
<blockquote>
<p><code>else</code>ãƒ–ãƒ©ãƒ³ãƒãŒæ—©æœŸãƒªã‚¿ãƒ¼ãƒ³ï¼ˆãƒ‘ãƒ‹ãƒƒã‚¯ã‚’æ—©æœŸãƒªã‚¿ãƒ¼ãƒ³ã¨ã—ã¦è€ƒæ…®ã—ã¾ã™ï¼‰ã‚’æ„å›³ã™ã‚‹å ´åˆã€<code>let/else</code>æ§‹ç¯‰ã‚’ä½¿ç”¨ã§ãã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Ticket {
    pub fn assigned_to(&amp;self) -&gt; &amp;str {
        let Status::InProgress { assigned_to } = &amp;self.status else {
            panic!("Only `In-Progress` tickets can be assigned to someone");
        };
        assigned_to
    }
}
<span class="boring">}</span></code></pre></pre>
<p>It allows you to assign the destructured variable without incurring
any "right drift", i.e. the variable is assigned at the same indentation level
as the code that precedes it.</p>
<blockquote>
<p>ãã‚Œã¯ã€ã€Œå³ãƒ‰ãƒªãƒ•ãƒˆã€ã‚’æ‹›ãã“ã¨ãªãã€åˆ†å‰²ã•ã‚ŒãŸå¤‰æ•°ã‚’å‰²ã‚Šå½“ã¦ã•ã›ã¾ã™ã€‚
ä¾‹ãˆã°ã€å¤‰æ•°ã¯ãã‚Œã«å…ˆç«‹ã¤ã‚³ãƒ¼ãƒ‰ã¨åŒã˜ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆãƒ¬ãƒ™ãƒ«ã§å‰²ã‚Šå½“ã¦ã‚‰ã‚Œã¾ã™ã€‚</p>
</blockquote>
<h2 id="styleã‚¹ã‚¿ã‚¤ãƒ«"><a class="header" href="#styleã‚¹ã‚¿ã‚¤ãƒ«">Styleï¼ˆã‚¹ã‚¿ã‚¤ãƒ«ï¼‰</a></h2>
<p>Both <code>if let</code> and <code>let/else</code> are idiomatic Rust constructs.<br />
Use them as you see fit to improve the readability of your code,
but don't overdo it: <code>match</code> is always there when you need it.</p>
<blockquote>
<p><code>if let</code>ã¨<code>let/else</code>ã®ä¸¡æ–¹ã¯ã€Rustã®æ…£ç”¨çš„ãªæ§‹ç¯‰ç‰©ã§ã™ã€‚
ãã‚Œã‚‰ã®ä½¿ç”¨ã¯ã€ã‚³ãƒ¼ãƒ‰ã®å¯èª­æ€§ã‚’æ”¹å–„ã™ã‚‹ãŸã‚ã«é©åˆ‡ã®ã‚ˆã†ã«è¦‹ãˆã¾ã™ãŒã€ãã‚Œã‚’éåº¦ã«ä½¿ç”¨ã—ãªã„ã§ãã ã•ã„ã€‚
<code>match</code>ã¯å¸¸ã«å¿…è¦ãªã¨ãã«ä½¿ç”¨ã§ãã¾ã™ã€‚</p>
</blockquote>
<h2 id="exercise-45"><a class="header" href="#exercise-45">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/05_ticket_v2/04_if_let"><code>05_ticket_v2/04_if_let</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nullabilitynullå¯èƒ½æ€§"><a class="header" href="#nullabilitynullå¯èƒ½æ€§">Nullabilityï¼ˆNullå¯èƒ½æ€§ï¼‰</a></h1>
<p>Our implementation of the <code>assigned</code> method is fairly blunt: panicking for to-do and done tickets is far from ideal.<br />
We can do better using <strong>Rust's <code>Option</code> type</strong>.</p>
<blockquote>
<p><code>assigned</code>ãƒ¡ã‚½ãƒƒãƒ‰ã®å®Ÿè£…ã¯ã€ã‹ãªã‚Šåˆ‡ã‚Œå‘³ãŒæ‚ªã„ã§ã™ã€‚<code>to-do</code>ã¨<code>done</code>ãƒã‚±ãƒƒãƒˆã®ãŸã‚ã«ãƒ‘ãƒ‹ãƒƒã‚¯ã™ã‚‹ã“ã¨ã¯ã€ç†æƒ³ã‹ã‚‰ã»ã©é ã„ã§ã™ã€‚
<strong>Rustã®<code>Option</code>å‹</strong>ã‚’ä½¿ç”¨ã—ã¦ã€ã†ã¾ãè¡Œãˆã¾ã™ã€‚</p>
</blockquote>
<h2 id="option"><a class="header" href="#option"><code>Option</code></a></h2>
<p><code>Option</code> is a Rust type that represents <strong>nullable values</strong>.<br />
It is an enum, defined in Rust's standard library:</p>
<blockquote>
<p><code>Option</code>ã¯<strong>nullå¯èƒ½ãªå€¤</strong>ã‚’è¡¨ç¾ã™ã‚‹Rustã®å‹ã§ã™ã€‚
ãã‚Œã¯ã€Rustæ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã«å®šç¾©ã•ã‚ŒãŸåˆ—æŒ™å‹ã§ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
    Some(T),
    None,
}
<span class="boring">}</span></code></pre></pre>
<p><code>Option</code> encodes the idea that a value might be present (<code>Some(T)</code>) or absent (<code>None</code>).<br />
It also forces you to <strong>explicitly handle both cases</strong>. You'll get a compiler error if you are working with
a nullable value and you forget to handle the <code>None</code> case.<br />
This is a significant improvement over "implicit" nullability in other languages, where you can forget to check
for <code>null</code> and thus trigger a runtime error.</p>
<blockquote>
<p><code>Option</code>ã¯ã€å€¤ãŒå­˜åœ¨ã™ã‚‹ï¼ˆ<code>Some(T)</code>ï¼‰ã€ã¾ãŸã¯å­˜åœ¨ã—ãªã„ï¼ˆ<code>None</code>ï¼‰ã®è€ƒãˆã‚’ç¬¦å·åŒ–ã—ã¾ã™ã€‚
ã¾ãŸã€ãã‚Œã¯ã€<strong>æ˜ç¤ºçš„ã«ä¸¡æ–¹ã®ã‚±ãƒ¼ã‚¹ã‚’å‡¦ç†</strong>ã™ã‚‹ã“ã¨ã‚’å¼·åˆ¶ã—ã¾ã™ã€‚
nullå¯èƒ½ãªå€¤ã§ä½œæ¥­ã—ã¦ã€<code>None</code>ã‚±ãƒ¼ã‚¹ã‚’å‡¦ç†ã™ã‚‹ã“ã¨ã‚’å¿˜ã‚ŒãŸå ´åˆã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã™ã€‚
ã“ã‚Œã¯ã€ä»–ã®è¨€èªã®ã€Œæš—é»™çš„ãªnullå¯èƒ½æ€§ã€ã‚’å¤§å¹…ã«æ”¹å–„ã—ã¦ã€ä»–ã®è¨€èªã§ã¯ã€<code>null</code>ãƒã‚§ãƒƒã‚¯ã‚’å¿˜ã‚ŒãŸç®‡æ‰€ã§ã€ãƒ©ãƒ³ã‚¿ã‚¤ãƒ ã‚¨ãƒ©ãƒ¼ã‚’ç™ºã—ã¾ã™ã€‚</p>
</blockquote>
<h2 id="options-definitionoptionã®å®šç¾©"><a class="header" href="#options-definitionoptionã®å®šç¾©"><code>Option</code>'s definitionï¼ˆOptionã®å®šç¾©ï¼‰</a></h2>
<p><code>Option</code>'s definition uses a Rust construct that you haven't seen before: <strong>tuple-like variants</strong>.</p>
<blockquote>
<p><code>Option</code>ã®å®šç¾©ã¯ã€<strong>ã‚¿ãƒ—ãƒ«ã®ã‚ˆã†ãªãƒãƒªã‚¢ãƒ³ãƒˆ</strong>ã¨ã„ã†ã€å‰ã«ç¢ºèªã—ã¦ã„ãªã„Rustã®æ§‹æˆè¦ç´ ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚</p>
</blockquote>
<h3 id="tuple-like-variantsã‚¿ãƒ—ãƒ«ã®ã‚ˆã†ãªãƒãƒªã‚¢ãƒ³ãƒˆ"><a class="header" href="#tuple-like-variantsã‚¿ãƒ—ãƒ«ã®ã‚ˆã†ãªãƒãƒªã‚¢ãƒ³ãƒˆ">Tuple-like variantsï¼ˆã‚¿ãƒ—ãƒ«ã®ã‚ˆã†ãªãƒãƒªã‚¢ãƒ³ãƒˆï¼‰</a></h3>
<p><code>Option</code> has two variants: <code>Some(T)</code> and <code>None</code>.<br />
<code>Some</code> is a <strong>tuple-like variant</strong>: it's a variant that holds <strong>unnamed fields</strong>.</p>
<blockquote>
<p><code>Option</code>ã¯ã€<code>Some(T)</code>ã¨<code>None</code>ã®2ã¤ã®ãƒãƒªã‚¢ãƒ³ãƒˆãŒã‚ã‚Šã¾ã™ã€‚
<code>Some</code>ã¯<strong>ã‚¿ãƒ—ãƒ«ã®ã‚ˆã†ãªãƒãƒªã‚¢ãƒ³ãƒˆ</strong>ã§ã€ãã‚Œã¯<strong>ç„¡åã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰</strong>ã‚’ä¿æŒã™ã‚‹ãƒãƒªã‚¢ãƒ³ãƒˆã§ã™ã€‚</p>
</blockquote>
<p>Tuple-like variants are often used when there is a single field to store, especially when we're looking at a
"wrapper" type like <code>Option</code>.</p>
<blockquote>
<p>ã‚¿ãƒ—ãƒ«ã®ã‚ˆã†ãªãƒãƒªã‚¢ãƒ³ãƒˆã¯ã€ä¿å­˜ã™ã‚‹ãŸã‚ã«1ã¤ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒã‚ã‚‹ã¨ãã€ç‰¹ã«<code>Option</code>ã®ã‚ˆã†ãªã€Œãƒ©ãƒƒãƒ‘ãƒ¼ã€å‹ã‚’ç¢ºèªã—ã¦ã„ã‚‹ã¨ãã«ã€ã‚ˆãä½¿ç”¨ã•ã‚Œã¾ã™ã€‚</p>
</blockquote>
<h3 id="tuple-like-structsã‚¿ãƒ—ãƒ«ã®ã‚ˆã†ãªæ§‹é€ ä½“"><a class="header" href="#tuple-like-structsã‚¿ãƒ—ãƒ«ã®ã‚ˆã†ãªæ§‹é€ ä½“">Tuple-like structsï¼ˆã‚¿ãƒ—ãƒ«ã®ã‚ˆã†ãªæ§‹é€ ä½“ï¼‰</a></h3>
<p>They're not specific to enumsâ€”you can define tuple-like structs too:</p>
<blockquote>
<p>ãã‚Œã‚‰ã¯åˆ—æŒ™å‹ã«ç‰¹æœ‰ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ã‚¿ãƒ—ãƒ«ã®ã‚ˆã†ãªæ§‹é€ ä½“ã‚‚å®šç¾©ã§ãã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Point(i32, i32);
<span class="boring">}</span></code></pre></pre>
<p>You can then access the two fields of a <code>Point</code> instance using their positional index:</p>
<blockquote>
<p>ãã—ã¦ã€ãã‚Œã‚‰ã®ä½ç½®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’ä½¿ç”¨ã—ã¦ã€<code>Point</code>ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®2ã¤ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«ã‚¢ã‚¯ã‚»ã‚¹ã§ãã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let point = Point(3, 4);
let x = point.0;
let y = point.1;
<span class="boring">}</span></code></pre></pre>
<h3 id="tuplesã‚¿ãƒ—ãƒ«"><a class="header" href="#tuplesã‚¿ãƒ—ãƒ«">Tuplesï¼ˆã‚¿ãƒ—ãƒ«ï¼‰</a></h3>
<p>It's weird to say that something is tuple-like when we haven't seen tuples yet!<br />
Tuples are another example of a primitive Rust type.
They group together a fixed number of values with (potentially different) types:</p>
<blockquote>
<p>ã¾ã ã‚¿ãƒ—ãƒ«ã‚’ç¢ºèªã—ã¦ã„ãªã„ã¨ãã«ã€ä½•ã‹ãŒã‚¿ãƒ—ãƒ«ã®ã‚ˆã†ã ã¨è¨€ã†ã“ã¨ã¯å¥‡å¦™ã§ã™ï¼
ã‚¿ãƒ—ãƒ«ã¯ã€ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ãªRustã®å‹ã®åˆ¥ã®ä¾‹ã§ã™ã€‚
ãã‚Œã‚‰ã¯ã€æ½œåœ¨çš„ã«ç•°ãªã‚‹å‹ã®å€¤ã®å›ºå®šæ•°ã‚’ã‚°ãƒ«ãƒ¼ãƒ—åŒ–ã—ã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Two values, same type
// 2ã¤ã®å€¤ã¯åŒã˜å‹ã§ã™ã€‚
let first: (i32, i32) = (3, 4);
// Three values, different types
// 3ã¤ã®å€¤ã¯ç•°ãªã‚‹å‹ã§ã™ã€‚
let second: (i32, u32, u8) = (-42, 3, 8);
<span class="boring">}</span></code></pre></pre>
<p>The syntax is simple: you list the types of the values between parentheses, separated by commas.
You can access the fields of a tuple using the dot notation and the field index:</p>
<blockquote>
<p>æ§‹æ–‡ã¯å˜ç´”ã§ã™ã€‚ã‚«ãƒƒã‚³ã®é–“ã«ã‚«ãƒ³ãƒã§åŒºåˆ‡ã‚‰ã‚ŒãŸå€¤ã®å‹ã‚’ãƒªã‚¹ãƒˆã—ã¾ã™ã€‚
ãƒ‰ãƒƒãƒˆè¨˜æ³•ã¨ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’ä½¿ç”¨ã—ã¦ã€ã‚¿ãƒ—ãƒ«ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«ã‚¢ã‚¯ã‚»ã‚¹ã§ãã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>assert_eq!(second.0, -42);
assert_eq!(second.1, 3);
assert_eq!(second.2, 8);
<span class="boring">}</span></code></pre></pre>
<p>Tuples are a convenient way of grouping values together when you can't be bothered to define a dedicated struct type.</p>
<blockquote>
<p>å°‚ç”¨ã®æ§‹é€ ä½“å‹ã‚’å®šç¾©ã™ã‚‹ã“ã¨ãŒé¢å€’ãªã¨ãã€ã‚¿ãƒ—ãƒ«ã¯å€¤ã‚’ã‚°ãƒ«ãƒ¼ãƒ—åŒ–ã™ã‚‹ä¾¿åˆ©ãªæ–¹æ³•ã§ã™ã€‚</p>
</blockquote>
<h2 id="exercise-46"><a class="header" href="#exercise-46">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/05_ticket_v2/05_nullability"><code>05_ticket_v2/05_nullability</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fallibilityèª¤ã‚Šã‚’é€ƒã‚Œã‚‰ã‚Œãªã„æ€§è³ª"><a class="header" href="#fallibilityèª¤ã‚Šã‚’é€ƒã‚Œã‚‰ã‚Œãªã„æ€§è³ª">Fallibilityï¼ˆèª¤ã‚Šã‚’é€ƒã‚Œã‚‰ã‚Œãªã„æ€§è³ªï¼‰</a></h1>
<p>Let's revisit the <code>Ticket::new</code> function from the previous exercise:</p>
<blockquote>
<p>å‰ã®æ¼”ç¿’ã®<code>Ticket::new</code>é–¢æ•°ã‚’å†åº¦ç¢ºèªã—ã¾ã—ã‚‡ã†ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Ticket {
    pub fn new(title: String, description: String, status: Status) -&gt; Ticket {
        if title.is_empty() {
            panic!("Title cannot be empty");
        }
        if title.len() &gt; 50 {
            panic!("Title cannot be longer than 50 bytes");
        }
        if description.is_empty() {
            panic!("Description cannot be empty");
        }
        if description.len() &gt; 500 {
            panic!("Description cannot be longer than 500 bytes");
        }

        Ticket {
            title,
            description,
            status,
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>As soon as one of the checks fails, the function panics.
This is not ideal, as it doesn't give the caller a chance to <strong>handle the error</strong>.</p>
<blockquote>
<p>1ã¤ã®æ¤œè¨¼ãŒå¤±æ•—ã—ãŸã‚‰ã™ãã«ã€é–¢æ•°ã¯ãƒ‘ãƒ‹ãƒƒã‚¯ã—ã¾ã™ã€‚
<strong>ã‚¨ãƒ©ãƒ¼ã‚’å‡¦ç†ã™ã‚‹</strong>æ©Ÿä¼šã‚’å‘¼ã³å‡ºã—å´ã«ä¸ãˆãªã„ãŸã‚ã€ã“ã‚Œã¯ç†æƒ³çš„ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚</p>
</blockquote>
<p>It's time to introduce the <code>Result</code> type, Rust's primary mechanism for error handling.</p>
<blockquote>
<p>ã‚¨ãƒ©ãƒ¼ã‚’å‡¦ç†ã™ã‚‹ãŸã‚ã«Rustã®ä¸»è¦ãªãƒ¡ã‚«ãƒ‹ã‚ºãƒ ã§ã‚ã‚‹ã€<code>Result</code>å‹ã‚’å°å…¥ã™ã‚‹ã¨ãã§ã™ã€‚</p>
</blockquote>
<h2 id="the-result-typeresultå‹"><a class="header" href="#the-result-typeresultå‹">The <code>Result</code> typeï¼ˆResultå‹ï¼‰</a></h2>
<p>The <code>Result</code> type is an enum defined in the standard library:</p>
<blockquote>
<p><code>Result</code>å‹ã¯ã€æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã«å®šç¾©ã•ã‚ŒãŸåˆ—æŒ™å‹ã§ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
<span class="boring">}</span></code></pre></pre>
<p>It has two variants:</p>
<ul>
<li><code>Ok(T)</code>: represents a successful operation. It holds <code>T</code>, the output of the operation.</li>
<li><code>Err(E)</code>: represents a failed operation. It holds <code>E</code>, the error that occurred.</li>
</ul>
<blockquote>
<p>ãã‚Œã¯2ã¤ã®ãƒãƒªã‚¢ãƒ³ãƒˆãŒã‚ã‚Šã¾ã™ã€‚</p>
<ul>
<li><code>Ok(T)</code>: æˆåŠŸã—ãŸæ“ä½œã‚’è¡¨ç¾ã—ã¾ã™ã€‚ãã‚Œã¯æ“ä½œã®å‡ºåŠ›ã§ã‚ã‚‹<code>T</code>ã‚’ä¿æŒã—ã¾ã™ã€‚</li>
<li><code>Err(E)</code>: å¤±æ•—ã—ãŸæ“ä½œã‚’è¡¨ç¾ã—ã¾ã™ã€‚ãã‚Œã¯ç™ºç”Ÿã—ãŸã‚¨ãƒ©ãƒ¼ã§ã‚ã‚‹<code>E</code>ã‚’ä¿æŒã—ã¾ã™ã€‚</li>
</ul>
</blockquote>
<p>Both <code>Ok</code> and <code>Err</code> are generic, allowing you to specify your own types for the success and error cases.</p>
<blockquote>
<p><code>Ok</code>ã¨<code>Err</code>ã®ä¸¡æ–¹ã¯ã‚¸ã‚§ãƒãƒªãƒƒã‚¯ã§ã€æˆåŠŸã¨å¤±æ•—ã®å ´åˆã®ç‹¬è‡ªã®å‹ã‚’æŒ‡å®šã§ãã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚</p>
</blockquote>
<h2 id="no-exceptionsä¾‹å¤–ã¯ãªã„"><a class="header" href="#no-exceptionsä¾‹å¤–ã¯ãªã„">No exceptionsï¼ˆä¾‹å¤–ã¯ãªã„ï¼‰</a></h2>
<p>Recoverable errors in Rust are <strong>represented as values</strong>.<br />
They're just an instance of a type, being passed around and manipulated like any other value.
This is a significant difference from other languages, such as Python or C#, where <strong>exceptions</strong> are used to signal errors.</p>
<blockquote>
<p>Rustã«ãŠã„ã¦ã€å¾©æ—§å¯èƒ½ãªã‚¨ãƒ©ãƒ¼ã¯<strong>å€¤ã¨ã—ã¦è¡¨ç¾</strong>ã•ã‚Œã¾ã™ã€‚
å˜ã«ãã‚Œã‚‰ã¯å‹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã§ã€ä»–ã®ä»»æ„ã®å€¤ã®ã‚ˆã†ã«ã€å‘¨è¾ºã«æ¸¡ã•ã‚Œã€æ“ä½œã•ã‚Œã¾ã™ã€‚
ã“ã‚Œã¯ã€<strong>ä¾‹å¤–</strong>ãŒã‚¨ãƒ©ãƒ¼ã®åˆå›³ã¨ã—ã¦ä½¿ç”¨ã•ã‚Œã‚‹Pythonã¾ãŸã¯C#ã®ã‚ˆã†ãªä»–ã®è¨€èªã¨å¤§ããç•°ãªã‚Šã¾ã™ã€‚</p>
</blockquote>
<p>Exceptions create a separate control flow path that can be hard to reason about.<br />
You don't know, just by looking at a function's signature, if it can throw an exception or not.
You don't know, just by looking at a function's signature, <strong>which</strong> exception types it can throw.<br />
You must either read the function's documentation or look at its implementation to find out.</p>
<blockquote>
<p>ä¾‹å¤–ã¯ã€ç†ç”±ã‚’çŸ¥ã‚‹ã“ã¨ãŒé›£ã—ããªã‚‹åˆ†é›¢ã—ãŸåˆ¶å¾¡ãƒ•ãƒ­ãƒ¼ã®ãƒ‘ã‚¹ã‚’ä½œæˆã—ã¾ã™ã€‚
é–¢æ•°ãŒä¾‹å¤–ã‚’æŠ•ã’ã‚‹ã‹æŠ•ã’ãªã„ã‹ã¯ã€é–¢æ•°ã®ã‚·ã‚°ãƒãƒãƒ£ãƒ¼ã‚’è¦‹ã¦ã‚‚ã‚ã‹ã‚Šã¾ã£ã›ã‚“ã€‚
é–¢æ•°ãŒã©ã®ä¾‹å¤–ã‚’æŠ•ã’ã‚‹ã‹ã¯ã€é–¢æ•°ã®ã‚·ã‚°ãƒãƒãƒ£ãƒ¼ã‚’è¦‹ã¦ã‚‚ã‚ã‹ã‚Šã¾ã›ã‚“ã€‚
ç†ç”±ã‚’è¦‹ã¤ã‘ã‚‹ãŸã‚ã«ã€é–¢æ•°ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã¾ãŸã¯ãã®å®Ÿè£…ã®ã©ã¡ã‚‰ã‹ã‚’èª­ã¾ãªãã¦ã¯ãªã‚Šã¾ã›ã‚“ã€‚</p>
</blockquote>
<p>Exception handling logic has very poor locality: the code that throws the exception is far removed from the code
that catches it, and there's no direct link between the two.</p>
<blockquote>
<p>ä¾‹å¤–å‡¦ç†ãƒ­ã‚¸ãƒƒã‚¯ã¯ã€ã¨ã¦ã‚‚è²§å¼±ãªå±€æ‰€æ€§ãŒã‚ã‚Šã¾ã™ã€‚ä¾‹å¤–ã‚’æŠ•ã’ã‚‹ã‚³ãƒ¼ãƒ‰ã¯ã€ãã‚Œã‚’å—ã‘å–ã‚‹ã‚³ãƒ¼ãƒ‰ã‹ã‚‰é ãé›¢ã‚Œã¦ãŠã‚Šã€ãã‚Œã¯2ã¤ã®é–“ã‚’ç›´æ¥çµã³ã¤ã‘ã‚‰ã‚Œã¾ã›ã‚“ã€‚</p>
</blockquote>
<h2 id="fallibility-is-encoded-in-the-type-systemèª¤ã‚Šã‚’é€ƒã‚Œã‚‰ã‚Œãªã„æ€§è³ªã¯å‹ã‚·ã‚¹ãƒ†ãƒ å†…ã«ç¬¦å·åŒ–ã•ã‚Œã‚‹"><a class="header" href="#fallibility-is-encoded-in-the-type-systemèª¤ã‚Šã‚’é€ƒã‚Œã‚‰ã‚Œãªã„æ€§è³ªã¯å‹ã‚·ã‚¹ãƒ†ãƒ å†…ã«ç¬¦å·åŒ–ã•ã‚Œã‚‹">Fallibility is encoded in the type systemï¼ˆèª¤ã‚Šã‚’é€ƒã‚Œã‚‰ã‚Œãªã„æ€§è³ªã¯å‹ã‚·ã‚¹ãƒ†ãƒ å†…ã«ç¬¦å·åŒ–ã•ã‚Œã‚‹ï¼‰</a></h2>
<p>Rust, with <code>Result</code>, forces you to <strong>encode fallibility in the function's signature</strong>.<br />
If a function can fail (and you want the caller to have a shot at handling the error), it must return a <code>Result</code>.</p>
<blockquote>
<p><code>Result</code>ã‚’æŒã¤Rustã¯ã€<strong>é–¢æ•°ã‚·ã‚°ãƒãƒãƒ£ãƒ¼ã«èª¤ã‚Šã‚’é€ƒã‚Œã‚‰ã‚Œãªã„æ€§è³ªã‚’ç¬¦å·åŒ–</strong>ã™ã‚‹ã“ã¨ã‚’å¼·åˆ¶ã—ã¾ã™ã€‚
é–¢æ•°ãŒå¤±æ•—ã™ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã€ã‚¨ãƒ©ãƒ¼ã‚’å‡¦ç†ã™ã‚‹æ©Ÿä¼šã‚’å‘¼ã³å‡ºã—å´ã«ä¸ãˆãŸã„å ´åˆã€ãã‚Œã¯<code>Result</code>ã‚’è¿”ã•ãªãã¦ã¯ãªã‚Šã¾ã›ã‚“ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Just by looking at the signature, you know that this function can fail.
// You can also inspect `ParseIntError` to see what kind of failures to expect.
// ã‚·ã‚°ãƒãƒãƒ£ãƒ¼ã‚’è¦‹ãŸã ã‘ã§ã€ã“ã®é–¢æ•°ãŒå¤±æ•—ã™ã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹ã“ã¨ãŒã‚ã‹ã‚Šã¾ã™ã€‚
// ã¾ãŸã€æœŸå¾…ã™ã‚‹å¤±æ•—ã®ç¨®é¡ãŒä½•ã‹ã‚’ç¢ºèªã™ã‚‹ãŸã‚ã«ã€`ParseIntError`ã‚’èª¿æŸ»ã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ã€‚
fn parse_int(s: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>That's the big advantage of <code>Result</code>: it makes fallibility explicit.</p>
<blockquote>
<p>ãã‚Œã¯<code>Result</code>ã®å¤§ããªåˆ©ç‚¹ã§ã™ã€‚ãã‚Œã¯èª¤ã‚Šã‚’é€ƒã‚Œã‚‰ã‚Œãªã„æ€§è³ªã‚’æ˜ç¤ºçš„ã«ã—ã¾ã™ã€‚</p>
</blockquote>
<p>Keep in mind, though, that panics exist. They aren't tracked by the type system, just like exceptions in other languages.
But they're meant for <strong>unrecoverable errors</strong> and should be used sparingly.</p>
<blockquote>
<p>ãŸã ã—ã€ãƒ‘ãƒ‹ãƒƒã‚¯ãŒå­˜åœ¨ã™ã‚‹ã“ã¨ã‚’å¿˜ã‚Œãªã„ã§ãã ã•ã„ã€‚ãã‚Œã‚‰ã¯å‹ã‚·ã‚¹ãƒ†ãƒ ã«ã‚ˆã£ã¦è¿½è·¡ã•ã‚Œãšã€ä»–ã®è¨€èªã®ä¾‹å¤–ã¨ã¡ã‚‡ã†ã©åŒã˜ã§ã™ã€‚
ã—ã‹ã—ã€ãã‚Œã‚‰ã¯<strong>å›å¾©ä¸å¯èƒ½ãªã‚¨ãƒ©ãƒ¼</strong>ã‚’æ„å›³ã—ã¦ãŠã‚Šã€æ§ãˆã‚ã«ä½¿ç”¨ã•ã‚Œã‚‹ã¹ãã§ã™ã€‚</p>
</blockquote>
<h2 id="exercise-47"><a class="header" href="#exercise-47">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/05_ticket_v2/06_fallibility"><code>05_ticket_v2/06_fallibility</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unwrappingåŒ…ã¿ã‚’è§£ã"><a class="header" href="#unwrappingåŒ…ã¿ã‚’è§£ã">Unwrappingï¼ˆåŒ…ã¿ã‚’è§£ãï¼‰</a></h1>
<p><code>Ticket::new</code> now returns a <code>Result</code> instead of panicking on invalid inputs.<br />
What does this mean for the caller?</p>
<blockquote>
<p>ç¾åœ¨ã€<code>Ticket::new</code>ã¯ã€ç„¡åŠ¹ãªå…¥åŠ›ã«å¯¾ã—ã¦<code>Result</code>ã‚’è¿”ã—ã¾ã™ã€‚
ã“ã‚Œã¯å‘¼ã³å‡ºã—å´ã«ã¨ã£ã¦ä½•ã‚’æ„å‘³ã™ã‚‹ã®ã§ã—ã‚‡ã†ã‹ï¼Ÿ</p>
</blockquote>
<h2 id="failures-cant-be-implicitly-ignoredå¤±æ•—ã¯æš—é»™çš„ã«ç„¡è¦–ã§ããªã„"><a class="header" href="#failures-cant-be-implicitly-ignoredå¤±æ•—ã¯æš—é»™çš„ã«ç„¡è¦–ã§ããªã„">Failures can't be (implicitly) ignoredï¼ˆå¤±æ•—ã¯æš—é»™çš„ã«ç„¡è¦–ã§ããªã„ï¼‰</a></h2>
<p>Unlike exceptions, Rust's <code>Result</code> forces you to <strong>handle errors at the call site</strong>.<br />
If you call a function that returns a <code>Result</code>, Rust won't allow you to implicitly ignore the error case.</p>
<blockquote>
<p>ä¾‹å¤–ã¨ç•°ãªã‚Šã€Rustã®<code>Result</code>ã¯ã€<strong>å‘¼ã³å‡ºã—å´ã§ã‚¨ãƒ©ãƒ¼ã‚’å‡¦ç†ã™ã‚‹</strong>ã“ã¨ã‚’å¼·åˆ¶ã—ã¾ã™ã€‚
<code>Result</code>ã‚’è¿”ã™é–¢æ•°ã‚’å‘¼ã³å‡ºã—ãŸå ´åˆã€Rustã¯ã‚¨ãƒ©ãƒ¼ã‚±ãƒ¼ã‚¹ã‚’æš—é»™çš„ã«ç„¡è¦–ã•ã›ã¾ã›ã‚“ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn parse_int(s: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    // ...
}

// This won't compile: we're not handling the error case.
// We must either use `match` or one of the combinators provided by `Result`
// to "unwrap" the success value or handle the error.
// ã“ã‚Œã¯ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã‚Œã¾ã›ã‚“ã€‚ã‚¨ãƒ©ãƒ¼ã‚±ãƒ¼ã‚¹ã‚’å‡¦ç†ã—ã¦ã„ãªã„ã‹ã‚‰ã§ã™ã€‚
// æˆåŠŸå€¤ã®ã€ŒåŒ…ã‚’è§£ãã€ã‹ã€ã‚¨ãƒ©ãƒ¼ã‚’å‡¦ç†ã™ã‚‹ãŸã‚ã«ã€`Result`ã«ã‚ˆã£ã¦æä¾›ã•ã‚Œã‚‹`match`ã¾ãŸã¯ã‚³ãƒ³ãƒ“ãƒãƒ¼ã‚¿ãƒ¼ã®1ã¤ã®ã©ã¡ã‚‰ã‹ã‚’ä½¿ç”¨ã—ãªãã¦ã¯ãªã‚Šã¾ã›ã‚“ã€‚
let number = parse_int("42") + 2;
<span class="boring">}</span></code></pre></pre>
<h2 id="you-got-a-result-now-whatresultã‚’å¾—ã¾ã—ãŸã§ã¯ä½•ã‚’ã™ã‚Œã°ã„ã„ã®ã§ã—ã‚‡ã†ã‹"><a class="header" href="#you-got-a-result-now-whatresultã‚’å¾—ã¾ã—ãŸã§ã¯ä½•ã‚’ã™ã‚Œã°ã„ã„ã®ã§ã—ã‚‡ã†ã‹">You got a <code>Result</code>. Now what?ï¼ˆResultã‚’å¾—ã¾ã—ãŸã€‚ã§ã¯ã€ä½•ã‚’ã™ã‚Œã°ã„ã„ã®ã§ã—ã‚‡ã†ã‹ï¼Ÿï¼‰</a></h2>
<p>When you call a function that returns a <code>Result</code>, you have two key options:</p>
<blockquote>
<p><code>Result</code>ã‚’è¿”ã™é–¢æ•°ã‚’å‘¼ã³å‡ºã—ãŸã¨ãã€ä¸»ã«2ã¤ã®é¸æŠè‚¢ãŒã‚ã‚Šã¾ã™ã€‚</p>
</blockquote>
<ul>
<li>
<p>Panic if the operation failed.
This is done using either the <code>unwrap</code> or <code>expect</code> methods.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Panics if `parse_int` returns an `Err`.
let number = parse_int("42").unwrap();
// `expect` lets you specify a custom panic message.
let number = parse_int("42").expect("Failed to parse integer");
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Destructure the <code>Result</code> using a <code>match</code> expression to deal with the error case explicitly.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match parse_int("42") {
    Ok(number) =&gt; println!("Parsed number: {}", number),
    Err(err) =&gt; eprintln!("Error: {}", err),
}
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<blockquote>
<ul>
<li>æ“ä½œãŒå¤±æ•—ã—ãŸå ´åˆãƒ‘ãƒ‹ãƒƒã‚¯ã—ã¾ã™ã€‚ã“ã‚Œã¯<code>unwrap</code>ã¾ãŸã¯<code>expect</code>ãƒ¡ã‚½ãƒƒãƒ‰ã®ã©ã¡ã‚‰ã‹ã‚’ä½¿ç”¨ã—ã¦è¡Œã„ã¾ã™ã€‚</li>
<li>æ˜ç¤ºçš„ã«ã‚¨ãƒ©ãƒ¼ã‚±ãƒ¼ã‚¹ã‚’æ‰±ã†ãŸã‚ã«ã€<code>match</code>å¼ã‚’ä½¿ç”¨ã—ã¦ã€<code>Result</code>ã‚’åˆ†è§£ã—ã¾ã™ã€‚</li>
</ul>
</blockquote>
<h2 id="exercise-48"><a class="header" href="#exercise-48">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/05_ticket_v2/07_unwrap"><code>05_ticket_v2/07_unwrap</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-enumserroråˆ—æŒ™å‹"><a class="header" href="#error-enumserroråˆ—æŒ™å‹">Error enumsï¼ˆErroråˆ—æŒ™å‹ï¼‰</a></h1>
<p>Your solution to the previous exercise may have felt awkward: matching on strings is not ideal!<br />
A colleague might rework the error messages returned by <code>Ticket::new</code> (e.g. to improve readability) and,
all of a sudden, your calling code would break.</p>
<blockquote>
<p>å‰ã®æ¼”ç¿’ã®è§£ç­”ã¯ã€æ´—ç·´ã•ã‚Œã¦ã„ãªã„ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚æ–‡å­—åˆ—ã«ãƒãƒƒãƒãƒ³ã‚°ã™ã‚‹ã“ã¨ã¯ç†æƒ³çš„ã§ã¯ã‚ã‚Šã¾ã›ã‚“ï¼
åŒåƒšã¯ã€ä¾‹ãˆã°å¯èª­æ€§ã‚’æ”¹å–„ã™ã‚‹ãŸã‚ã«<code>Ticket::new</code>ã«ã‚ˆã£ã¦è¿”ã•ã‚ŒãŸãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å†æ§‹ç¯‰ã™ã‚‹ã‹ã‚‚ã—ã‚Œãšã€çªç„¶ã‚³ãƒ¼ãƒ‰ã®å‘¼ã³å‡ºã—ã¯å£Šã‚Œã¾ã™ã€‚</p>
</blockquote>
<p>You already know the machinery required to fix this: enums!</p>
<blockquote>
<p>åˆ—æŒ™å‹ã§ã“ã‚Œã‚’ä¿®æ­£ã™ã‚‹ãŸã‚ã«è¦æ±‚ã•ã‚Œã‚‹ãƒ¡ã‚«ãƒ‹ã‚ºãƒ ã‚’ã™ã§ã«çŸ¥ã£ã¦ã„ã¾ã™ï¼</p>
</blockquote>
<h2 id="reacting-to-errorsã‚¨ãƒ©ãƒ¼ã«åå¿œã™ã‚‹"><a class="header" href="#reacting-to-errorsã‚¨ãƒ©ãƒ¼ã«åå¿œã™ã‚‹">Reacting to errorsï¼ˆã‚¨ãƒ©ãƒ¼ã«åå¿œã™ã‚‹ï¼‰</a></h2>
<p>When you want to allow the caller to behave differently based on the specific error that occurred, you can
use an enum to represent the different error cases:</p>
<blockquote>
<p>ç™ºç”Ÿã—ãŸç‰¹å®šã®ã‚¨ãƒ©ãƒ¼ã«åŸºã¥ã„ã¦ã€å‘¼ã³å‡ºã—å´ã«ç•°ãªã‚‹æŒ¯ã‚‹èˆã„ã‚’ã•ã›ãŸã„ã¨ãã€ç•°ãªã‚‹ã‚¨ãƒ©ãƒ¼ã‚±ãƒ¼ã‚¹ã‚’è¡¨ç¾ã™ã‚‹åˆ—æŒ™å‹ã‚’ä½¿ç”¨ã§ãã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// An error enum to represent the different error cases
// that may occur when parsing a `u32` from a string.
// æ–‡å­—åˆ—ã‹ã‚‰`u32`ã«ãƒ‘ãƒ¼ã‚¹ã™ã‚‹ã¨ãã«ç™ºç”Ÿã™ã‚‹ã‹ã‚‚ã—ã‚Œãªã„ç•°ãªã‚‹ã‚¨ãƒ©ãƒ¼ã‚±ãƒ¼ã‚¹ã‚’è¡¨ç¾ã™ã‚‹ã‚¨ãƒ©ãƒ¼åˆ—æŒ™å‹ã§ã™ã€‚
enum U32ParseError {
    NotANumber,
    TooLarge,
    Negative,
}
<span class="boring">}</span></code></pre></pre>
<p>Using an error enum, you're encoding the different error cases in the type systemâ€”they become part of the
signature of the fallible function.<br />
This simplifies error handling for the caller, as they can use a <code>match</code> expression to react to the different
error cases:</p>
<blockquote>
<p>ã‚¨ãƒ©ãƒ¼åˆ—æŒ™å‹ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã¯ã€å‹ã‚·ã‚¹ãƒ†ãƒ ã«ã•ã¾ã–ã¾ãªã‚¨ãƒ©ãƒ¼ã‚±ãƒ¼ã‚¹ã‚’ç¬¦å·åŒ–ã™ã‚‹ã“ã¨ã§ã™ã€‚
ãã‚Œã‚‰ã¯ã€å¤±æ•—ã™ã‚‹å¯èƒ½æ€§ã®ã‚ã‚‹é–¢æ•°ã®ã‚·ã‚°ãƒãƒãƒ£ãƒ¼ã®ä¸€éƒ¨ã«ãªã‚Šã¾ã™ã€‚
ç•°ãªã‚‹ã‚¨ãƒ©ãƒ¼ã‚±ãƒ¼ã‚¹ã«å¯¾ã—ã¦åå¿œã™ã‚‹ãŸã‚ã«<code>match</code>å¼ã‚’ä½¿ç”¨ã§ãã‚‹ãŸã‚ã€ã“ã‚Œã¯å‘¼ã³å‡ºã—å´ã®ã‚¨ãƒ©ãƒ¼å‡¦ç†ã‚’ç°¡ç´ åŒ–ã—ã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match s.parse_u32() {
    Ok(n) =&gt; n,
    Err(U32ParseError::Negative) =&gt; 0,
    Err(U32ParseError::TooLarge) =&gt; u32::MAX,
    Err(U32ParseError::NotANumber) =&gt; {
        panic!("Not a number: {}", s);
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="exercise-49"><a class="header" href="#exercise-49">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/05_ticket_v2/08_error_enums"><code>05_ticket_v2/08_error_enums</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-traiterrorãƒˆãƒ¬ã‚¤ãƒˆ"><a class="header" href="#error-traiterrorãƒˆãƒ¬ã‚¤ãƒˆ">Error traitï¼ˆErrorãƒˆãƒ¬ã‚¤ãƒˆï¼‰</a></h1>
<h2 id="error-reportingã‚¨ãƒ©ãƒ¼å ±å‘Š"><a class="header" href="#error-reportingã‚¨ãƒ©ãƒ¼å ±å‘Š">Error reportingï¼ˆã‚¨ãƒ©ãƒ¼å ±å‘Šï¼‰</a></h2>
<p>In the previous exercise you had to destructure the <code>TitleError</code> variant to extract the error message and
pass it to the <code>panic!</code> macro.<br />
This is a (rudimentary) example of <strong>error reporting</strong>: transforming an error type into a representation that can be
shown to a user, a service operator, or a developer.</p>
<blockquote>
<p>å‰ã®æ¼”ç¿’ã«ãŠã„ã¦ã€ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’æŠ½å‡ºã—ã¦ã€<code>panic!</code>ãƒã‚¯ãƒ­ã«ãã‚Œã‚’æ¸¡ã™ãŸã‚ã«ã€<code>TitleError</code>ãƒãƒªã‚¢ãƒ³ãƒˆã‚’åˆ†è§£ã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚
ã“ã‚Œã¯ã€<strong>ã‚¨ãƒ©ãƒ¼å ±å‘Š</strong>ã®åˆæ­©çš„ãªä¾‹ã§ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ã€ã‚µãƒ¼ãƒ“ã‚¹ã‚ªãƒšãƒ¬ãƒ¼ã‚¿ãƒ¼ã¾ãŸã¯é–‹ç™ºè€…ã«è¡¨ç¤ºã•ã‚Œã‚‹è¡¨ç¾ã«ã‚¨ãƒ©ãƒ¼å‹ã‚’å¤‰æ›ã—ã¦ã„ã¾ã™ã€‚</p>
</blockquote>
<p>It's not practical for each Rust developer to come up with their own error reporting strategy: it'd be a waste of time
and it wouldn't compose well across projects.
That's why Rust provides the <code>std::error::Error</code> trait.</p>
<blockquote>
<p>ãã‚Œã¯ã€ç‹¬è‡ªã®ã‚¨ãƒ©ãƒ¼å ±å‘Šæˆ¦ç•¥ã‚’æ¡ç”¨ã™ã‚‹ãã‚Œãã‚Œã®Rusté–‹ç™ºè€…ã«ã¨ã£ã¦å®Ÿç”¨çš„ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚
ãã‚Œã¯æ™‚é–“ã‚’æµªè²»ã—ã¦ã€ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆé–“ã§ã†ã¾ãæ§‹æˆã•ã‚Œã¾ã›ã‚“ã€‚
ãã‚ŒãŒã€RustãŒ<code>std::error::Error</code>ãƒˆãƒ¬ã‚¤ãƒˆã‚’æä¾›ã™ã‚‹ç†ç”±ã§ã™ã€‚</p>
</blockquote>
<h2 id="the-error-traiterrorãƒˆãƒ¬ã‚¤ãƒˆ"><a class="header" href="#the-error-traiterrorãƒˆãƒ¬ã‚¤ãƒˆ">The <code>Error</code> traitï¼ˆErrorãƒˆãƒ¬ã‚¤ãƒˆï¼‰</a></h2>
<p>There are no constraints on the type of the <code>Err</code> variant in a <code>Result</code>, but it's a good practice to use a type
that implements the <code>Error</code> trait.
<code>Error</code> is the cornerstone of Rust's error handling story:</p>
<blockquote>
<p><code>Result</code>ã®<code>Err</code>ãƒãƒªã‚¢ãƒ³ãƒˆã®å‹ã«åˆ¶ç´„ã¯ã‚ã‚Šã¾ã›ã‚“ãŒã€<code>Error</code>ãƒˆãƒ¬ã‚¤ãƒˆã‚’å®Ÿè£…ã™ã‚‹å‹ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã¯è‰¯ã„å®Ÿè·µã§ã™ã€‚
<code>Error</code>ã¯ã€Rustã®ã‚¨ãƒ©ãƒ¼å‡¦ç†ã®åŸºæœ¬ç†å¿µã§ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Slightly simplified definition of the `Error` trait
// `Error`ãƒˆãƒ¬ã‚¤ãƒˆã®å®šç¾©ã‚’å°‘ã—ç°¡ç´ åŒ–ã—ã¦ã„ã¾ã™ã€‚
pub trait Error: Debug + Display {}
<span class="boring">}</span></code></pre></pre>
<p>You might recall the <code>:</code> syntax from <a href="05_ticket_v2/../04_traits/08_sized.html">the <code>Sized</code> trait</a>â€”it's used to specify <strong>supertraits</strong>.
For <code>Error</code>, there are two supertraits: <code>Debug</code> and <code>Display</code>. If a type wants to implement <code>Error</code>, it must also
implement <code>Debug</code> and <code>Display</code>.</p>
<blockquote>
<p><code>Sized</code>ãƒˆãƒ¬ã‚¤ãƒˆã®<code>:</code>æ§‹æ–‡ã‚’æ€ã„å‡ºã—ãŸã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚
ãã‚Œã¯<strong>ã‚¹ãƒ¼ãƒ‘ãƒ¼ãƒˆãƒ¬ã‚¤ãƒˆ</strong>ã‚’æŒ‡å®šã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚
<code>Error</code>ã«ã¯ã€2ã¤ã®ã‚¹ãƒ¼ãƒ‘ãƒ¼ãƒˆãƒ¬ã‚¤ãƒˆãŒã‚ã‚Šã€ãã‚Œã‚‰ã¯<code>Debug</code>ã¨<code>Display</code>ã§ã™ã€‚
å‹ã«<code>Error</code>ã‚’å®Ÿè£…ã—ãŸã„å ´åˆã€ãã®å‹ã¯<code>Debug</code>ã¨<code>Display</code>ã‚’å®Ÿè£…ã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚</p>
</blockquote>
<h2 id="display-and-debugdisplayã¨debug"><a class="header" href="#display-and-debugdisplayã¨debug"><code>Display</code> and <code>Debug</code>ï¼ˆDisplayã¨Debugï¼‰</a></h2>
<p>We've already encountered the <code>Debug</code> trait in <a href="05_ticket_v2/../04_traits/04_derive.html">a previous exercise</a>â€”it's the trait used by
<code>assert_eq!</code> to display the values of the variables it's comparing when the assertion fails.</p>
<blockquote>
<p>å‰ã®æ¼”ç¿’ã§ã™ã§ã«<code>Debug</code>ãƒˆãƒ¬ã‚¤ãƒˆã«é­é‡ã—ã¾ã—ãŸã€‚
ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ãŒå¤±æ•—ã—ãŸã¨ãã«ã€æ¯”è¼ƒã—ã¦ã„ã‚‹å¤‰æ•°ã®å€¤ã‚’è¡¨ç¤ºã™ã‚‹ãŸã‚ã«<code>assert_eq!</code>ã«ã‚ˆã£ã¦ä½¿ç”¨ã•ã‚Œã‚‹ãƒˆãƒ¬ã‚¤ãƒˆã§ã™ã€‚</p>
</blockquote>
<p>From a "mechanical" perspective, <code>Display</code> and <code>Debug</code> are identicalâ€”they encode how a type should be converted
into a string-like representation:</p>
<blockquote>
<p>ã€Œæ©Ÿæ¢°çš„ã€ãªè¦³ç‚¹ã‹ã‚‰ã€<code>Display</code>ã¨<code>Debug</code>ã¯åŒä¸€ã§ã™ã€‚
ãã‚Œã‚‰ã¯ã€å‹ã‚’æ–‡å­—åˆ—ã®ã‚ˆã†ãªè¡¨ç¾ã«å¤‰æ›ã™ã‚‹æ–¹æ³•ã‚’ç¬¦å·åŒ–ã—ã¦ã„ã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// `Debug`
pub trait Debug {
    fn fmt(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; Result&lt;(), Error&gt;;
}

// `Display`
pub trait Display {
    fn fmt(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; Result&lt;(), Error&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p>The difference is in their <em>purpose</em>: <code>Display</code> returns a representation that's meant for "end-users",
while <code>Debug</code> provides a low-level representation that's more suitable to developers and service operators.<br />
That's why <code>Debug</code> can be automatically implemented using the <code>#[derive(Debug)]</code> attribute, while <code>Display</code>
<strong>requires</strong> a manual implementation.</p>
<blockquote>
<p>é•ã„ã¯ãã‚Œã‚‰ã® <em>ç›®çš„</em> ã§ã™ã€‚
<code>Display</code>ã¯ã€Œã‚¨ãƒ³ãƒ‰ãƒ¦ãƒ¼ã‚¶ãƒ¼ã€ã‚’æ„å›³ã—ãŸè¡¨ç¾ã‚’è¿”ã—ã¾ã™ãŒã€<code>Debug</code>ã¯é–‹ç™ºè€…ã‚„ã‚µãƒ¼ãƒ“ã‚¹ã‚ªãƒšãƒ¬ãƒ¼ã‚¿ãƒ¼ã«ã‚ˆã‚Šé©ã—ãŸä½æ°´æº–ãªè¡¨ç¾ã‚’æä¾›ã—ã¾ã™ã€‚
ãã‚ŒãŒã€<code>Debug</code>ãŒ<code>#[derive(Debug)]</code>å±æ€§ã‚’ä½¿ç”¨ã—ã¦è‡ªå‹•çš„ã«å®Ÿè£…ã§ãã‚‹ä¸€æ–¹ã§ã€<code>Display</code>ã¯æ‰‹å‹•ã®å®Ÿè£…ã‚’<strong>è¦æ±‚ã™ã‚‹</strong>ç†ç”±ã§ã™ã€‚</p>
</blockquote>
<h2 id="exercise-50"><a class="header" href="#exercise-50">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/05_ticket_v2/09_error_trait"><code>05_ticket_v2/09_error_trait</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="libraries-and-binariesãƒ©ã‚¤ãƒ–ãƒ©ãƒªã¨ãƒã‚¤ãƒŠãƒª"><a class="header" href="#libraries-and-binariesãƒ©ã‚¤ãƒ–ãƒ©ãƒªã¨ãƒã‚¤ãƒŠãƒª">Libraries and binariesï¼ˆãƒ©ã‚¤ãƒ–ãƒ©ãƒªã¨ãƒã‚¤ãƒŠãƒªï¼‰</a></h1>
<p>It took a bit of code to implement the <code>Error</code> trait for <code>TicketNewError</code>, didn't it?<br />
A manual <code>Display</code> implementation, plus an <code>Error</code> impl block.</p>
<blockquote>
<p><code>TicketNewError</code>ã«å¯¾ã—ã¦<code>Error</code>ãƒˆãƒ¬ã‚¤ãƒˆã‚’å®Ÿè£…ã™ã‚‹ãŸã‚ã«ã€å°‘ã—ã®ã‚³ãƒ¼ãƒ‰ãŒå¿…è¦ã§ã—ãŸã‹ï¼Ÿ
æ‰‹å‹•ã®<code>Display</code>ã®å®Ÿè£…ã¯ã€<code>Error</code>ã®<code>impl</code>ãƒ–ãƒ­ãƒƒã‚¯ã«åŠ ãˆã‚‰ã‚Œã¾ã—ãŸã€‚</p>
</blockquote>
<p>We can remove some of the boilerplate by using <a href="https://docs.rs/thiserror/latest/thiserror/"><code>thiserror</code></a>,
a Rust crate that provides a <strong>procedural macro</strong> to simplify the creation of custom error types.<br />
But we're getting ahead of ourselves: <code>thiserror</code> is a third-party crate, it'd be our first dependency!</p>
<blockquote>
<p>ã‚«ã‚¹ã‚¿ãƒ ã‚¨ãƒ©ãƒ¼å‹ã®ä½œæˆã‚’ç°¡ç´ åŒ–ã™ã‚‹<strong>æ‰‹ç¶šããƒã‚¯ãƒ­</strong>ã‚’æä¾›ã™ã‚‹Rustã®ã‚¯ãƒ¬ãƒ¼ãƒˆã§ã‚ã‚‹<code>thiserror</code>ã‚’ä½¿ç”¨ã—ã¦ã€ã„ãã¤ã‹ã®ãƒœã‚¤ãƒ©ãƒ¼ãƒ—ãƒ¬ãƒ¼ãƒˆã‚’å‰Šé™¤ã§ãã¾ã™ã€‚
ã—ã‹ã—ã€ç§ãŸã¡ã¯å…ˆèµ°ã£ã¦ã„ã¾ã™ã€‚<code>thiserror</code>ã¯ã‚µãƒ¼ãƒ‰ãƒ‘ãƒ¼ãƒ†ã‚£ã®ã‚¯ãƒ¬ãƒ¼ãƒˆã§ã‚ã‚Šã€ã“ã‚ŒãŒæœ€åˆã®ä¾å­˜é–¢ä¿‚ã«ãªã‚Šã¾ã™ï¼</p>
</blockquote>
<p>Let's take a step back to talk about Rust's packaging system before we dive into dependencies.</p>
<blockquote>
<p>ä¾å­˜é–¢ä¿‚ã«æ·±å…¥ã‚Šã™ã‚‹å‰ã«Rustã®ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‚·ã‚¹ãƒ†ãƒ ã«ã¤ã„ã¦è©±ã™ãŸã‚ã«ã€ä¸€æ­©å¾Œé€€ã—ã¾ã—ã‚‡ã†ã€‚</p>
</blockquote>
<h2 id="what-is-a-packageãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã¨ã¯"><a class="header" href="#what-is-a-packageãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã¨ã¯">What is a package?ï¼ˆãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã¨ã¯ï¼Ÿï¼‰</a></h2>
<p>A Rust package is defined by the <code>[package]</code> section in a <code>Cargo.toml</code> file, also known as its <strong>manifest</strong>.
Within <code>[package]</code> you can set the package's metadata, such as its name and version.</p>
<blockquote>
<p>Rustãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã¯ã€<code>Cargo.toml</code>ãƒ•ã‚¡ã‚¤ãƒ«å†…ã®<code>[package]</code>ç¯€ã«ã‚ˆã£ã¦å®šç¾©ã•ã‚Œã€<strong>ãƒãƒ‹ãƒ•ã‚§ã‚¹ãƒˆ</strong>ã¨ã—ã¦ã‚‚çŸ¥ã‚‰ã‚Œã¦ã„ã¾ã™ã€‚
<code>[package]</code>å†…ã§ã€ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã®åå‰ã‚„ãƒãƒ¼ã‚¸ãƒ§ãƒ³ãªã©ã®ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚‚è¨­å®šã§ãã¾ã™ã€‚</p>
</blockquote>
<p>Go check the <code>Cargo.toml</code> file in the directory of this section's exercise!</p>
<blockquote>
<p>ã“ã®ç¯€ã®æ¼”ç¿’ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªå†…ã®<code>Cargo.toml</code>ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚</p>
</blockquote>
<h2 id="what-is-a-crateã‚¯ãƒ¬ãƒ¼ãƒˆã¨ã¯"><a class="header" href="#what-is-a-crateã‚¯ãƒ¬ãƒ¼ãƒˆã¨ã¯">What is a crate?ï¼ˆã‚¯ãƒ¬ãƒ¼ãƒˆã¨ã¯ï¼Ÿï¼‰</a></h2>
<p>Inside a package, you can have one or more <strong>crates</strong>, also known as <strong>targets</strong>.<br />
The two most common crate types are <strong>binary crates</strong> and <strong>library crates</strong>.</p>
<blockquote>
<p>ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã®å†…éƒ¨ã§ã€<strong>ã‚¿ãƒ¼ã‚²ãƒƒãƒˆ</strong>ã¨ã‚‚çŸ¥ã‚‰ã‚Œã‚‹1ã¤ä»¥ä¸Šã®<strong>ã‚¯ãƒ¬ãƒ¼ãƒˆ</strong>ã‚’æŒã¤ã“ã¨ãŒã§ãã¾ã™ã€‚
2ã¤ã®æœ€ã‚‚ä¸€èˆ¬çš„ãªã‚¯ãƒ¬ãƒ¼ãƒˆã®ã‚¿ã‚¤ãƒ—ã¯ã€<strong>ãƒã‚¤ãƒŠãƒªãƒ¼ã‚¯ãƒ¬ãƒ¼ãƒˆ</strong>ã¨<strong>ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚¯ãƒ¬ãƒ¼ãƒˆ</strong>ã§ã™ã€‚</p>
</blockquote>
<h3 id="binariesãƒã‚¤ãƒŠãƒªãƒ¼"><a class="header" href="#binariesãƒã‚¤ãƒŠãƒªãƒ¼">Binariesï¼ˆãƒã‚¤ãƒŠãƒªãƒ¼ï¼‰</a></h3>
<p>A binary is a program that can be compiled to an <strong>executable file</strong>.<br />
It must include a function named <code>main</code>â€”the program's entry point. <code>main</code> is invoked when the program is executed.</p>
<blockquote>
<p>ãƒã‚¤ãƒŠãƒªãƒ¼ã¯ã€<strong>å®Ÿè¡Œãƒ•ã‚¡ã‚¤ãƒ«</strong>ã«ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã‚Œã‚‹ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã§ã™ã€‚
ãã‚Œã¯ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®ã‚¨ãƒ³ãƒˆãƒªãƒã‚¤ãƒ³ãƒˆã§ã‚ã‚‹<code>main</code>ã¨åä»˜ã‘ã‚‰ã‚ŒãŸé–¢æ•°ã‚’å«ã¾ãªãã¦ã¯ãªã‚Šã¾ã›ã‚“ã€‚
<code>main</code>ã¯ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒå®Ÿè¡Œã•ã‚ŒãŸã¨ãã«å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚</p>
</blockquote>
<h3 id="librariesãƒ©ã‚¤ãƒ–ãƒ©ãƒª"><a class="header" href="#librariesãƒ©ã‚¤ãƒ–ãƒ©ãƒª">Librariesï¼ˆãƒ©ã‚¤ãƒ–ãƒ©ãƒªï¼‰</a></h3>
<p>Libraries, on the other hand, are not executable on their own. You can't <em>run</em> a library,
but you can <em>import its code</em> from another package that depends on it.<br />
A library groups together code (i.e. functions, types, etc.) that can be leveraged by other packages as a <strong>dependency</strong>.</p>
<blockquote>
<p>ä¸€æ–¹ã€ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã¯ãã‚Œè‡ªèº«ã§å®Ÿè¡Œå¯èƒ½ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’<strong>å®Ÿè¡Œ</strong>ã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ãŒã€ãã‚Œã«ä¾å­˜ã™ã‚‹ä»–ã®ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‹ã‚‰<strong>ãã®ã‚³ãƒ¼ãƒ‰ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆ</strong>ã§ãã¾ã™ã€‚
ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã¯ã€<strong>ä¾å­˜é–¢ä¿‚</strong>ã¨ã—ã¦ä»–ã®ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã«ã‚ˆã£ã¦åˆ©ç”¨ã•ã‚Œã‚‹ã‚³ãƒ¼ãƒ‰ï¼ˆä¾‹ãˆã°ã€é–¢æ•°ã€å‹ãªã©ï¼‰ã‚’ä¸€ç·’ã«ã‚°ãƒ«ãƒ¼ãƒ—åŒ–ã—ã¾ã™ã€‚</p>
</blockquote>
<p>All the exercises you've solved so far have been structured as libraries, with a test suite attached to them.</p>
<blockquote>
<p>ã“ã‚Œã¾ã§ã«è§£ã„ã¦ããŸã™ã¹ã¦ã®æ¼”ç¿’ã¯ã€ãã‚Œã‚‰ã«ä»˜å±ã™ã‚‹ãƒ†ã‚¹ãƒˆã‚¹ã‚¤ãƒ¼ãƒˆã¨ä¸€ç·’ã«ã€ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã¨ã—ã¦æ§‹æˆã•ã‚Œã¦ã„ã¾ã™ã€‚</p>
</blockquote>
<h3 id="conventionsæ…£ä¾‹"><a class="header" href="#conventionsæ…£ä¾‹">Conventionsï¼ˆæ…£ä¾‹ï¼‰</a></h3>
<p>There are some conventions around Rust packages that you need to keep in mind:</p>
<ul>
<li>The package's source code is usually located in the <code>src</code> directory.</li>
<li>If there's a <code>src/lib.rs</code> file, <code>cargo</code> will infer that the package contains a library crate.</li>
<li>If there's a <code>src/main.rs</code> file, <code>cargo</code> will infer that the package contains a binary crate.</li>
</ul>
<blockquote>
<p>Rustãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã®ã¾ã‚ã‚Šã«ã€æ°—ã«ç•™ã‚ã¦ãŠãã¹ãæ…£ä¾‹ãŒã„ãã¤ã‹ã‚ã‚Šã¾ã™ã€‚</p>
<ul>
<li>ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã®ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã¯ã€é€šå¸¸<code>src</code>ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªå†…ã«é…ç½®ã•ã‚Œã¾ã™ã€‚</li>
<li><code>src/lib.rs</code>ãƒ•ã‚¡ã‚¤ãƒ«ãŒå­˜åœ¨ã™ã‚‹å ´åˆã€<code>cargo</code>ã¯ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ãŒãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚¯ãƒ¬ãƒ¼ãƒˆã‚’å«ã‚“ã§ã„ã‚‹ã¨æ¨æ¸¬ã—ã¾ã™ã€‚</li>
<li><code>src/main.rs</code>ãƒ•ã‚¡ã‚¤ãƒ«ãŒå­˜åœ¨ã™ã‚‹å ´åˆã€<code>cargo</code>ã¯ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ãŒãƒã‚¤ãƒŠãƒªãƒ¼ã‚¯ãƒ¬ãƒ¼ãƒˆã‚’å«ã‚“ã§ã„ã‚‹ã¨æ¨æ¸¬ã—ã¾ã™ã€‚</li>
</ul>
</blockquote>
<p>You can override these defaults by explicitly declaring your targets in the <code>Cargo.toml</code> fileâ€”see
<a href="https://doc.rust-lang.org/cargo/reference/cargo-targets.html#cargo-targets"><code>cargo</code>'s documentation</a> for more details.</p>
<blockquote>
<p><code>Cargo.toml</code>ãƒ•ã‚¡ã‚¤ãƒ«ã§æ˜ç¤ºçš„ã«ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚’å®£è¨€ã™ã‚‹ã“ã¨ã«ã‚ˆã£ã¦ã€ã“ã‚Œã‚‰ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚’ä¸Šæ›¸ãã§ãã¾ã™ã€‚
è©³ç´°ã¯<code>cargo</code>ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚</p>
</blockquote>
<p>Keep in mind that while a package can contain multiple crates, it can only contain one library crate.</p>
<blockquote>
<p>ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã¯è¤‡æ•°ã®ã‚¯ãƒ¬ãƒ¼ãƒˆã‚’å«ã‚€ã“ã¨ãŒã§ãã‚‹ä¸€æ–¹ã§ã€ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã¯ãŸã£ãŸ1ã¤ã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚¯ãƒ¬ãƒ¼ãƒˆã®ã¿ã‚’å«ã‚€ã“ã¨ãŒã§ãã¾ã™ã€‚</p>
</blockquote>
<h2 id="scaffolding-a-new-packageæ–°ã—ã„ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã®è¶³å ´"><a class="header" href="#scaffolding-a-new-packageæ–°ã—ã„ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã®è¶³å ´">Scaffolding a new packageï¼ˆæ–°ã—ã„ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã®è¶³å ´ï¼‰</a></h2>
<p>You can use <code>cargo</code> to scaffold a new package:</p>
<blockquote>
<p>æ–°ã—ã„ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã®è¶³å ´ã¨ã™ã‚‹ãŸã‚ã«<code>cargo</code>ã‚’ä½¿ç”¨ã§ãã¾ã™ã€‚</p>
</blockquote>
<pre><code class="language-bash">cargo new my-binary
</code></pre>
<p>This will create a new folder, <code>my-binary</code>, containing a new Rust package with the same name and a single
binary crate inside. If you want to create a library crate instead, you can use the <code>--lib</code> flag:</p>
<blockquote>
<p>ã“ã‚Œã¯ã€<code>my-binary</code>ã¨ã„ã†æ–°ã—ã„ãƒ•ã‚©ãƒ«ãƒ€ã‚’ä½œæˆã—ã¦ã€å†…éƒ¨ã«åŒã˜åå‰ã§å˜ç‹¬ã®ãƒã‚¤ãƒŠãƒªãƒ¼ã‚¯ãƒ¬ãƒ¼ãƒˆã‚’æŒã¤æ–°ã—ã„Rustãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‚’å«ã‚ã¾ã™ã€‚
ä»£ã‚ã‚Šã«ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚¯ãƒ¬ãƒ¼ãƒˆã‚’ä½œæˆã™ã‚‹å ´åˆã€<code>--lib</code>ãƒ•ãƒ©ã‚°ã‚’ä½¿ç”¨ã§ãã¾ã™ã€‚</p>
</blockquote>
<pre><code class="language-bash">cargo new my-library --lib
</code></pre>
<h2 id="exercise-51"><a class="header" href="#exercise-51">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/05_ticket_v2/10_packages"><code>05_ticket_v2/10_packages</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dependenciesä¾å­˜é–¢ä¿‚"><a class="header" href="#dependenciesä¾å­˜é–¢ä¿‚">Dependenciesï¼ˆä¾å­˜é–¢ä¿‚ï¼‰</a></h1>
<p>A package can depend on other packages by listing them in the <code>[dependencies]</code> section of its <code>Cargo.toml</code> file.<br />
The most common way to specify a dependency is by providing its name and version:</p>
<blockquote>
<p>ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã¯ã€ãã®<code>Cargo.toml</code>ãƒ•ã‚¡ã‚¤ãƒ«ã®<code>[dependencies]</code>ç¯€å†…ã«ãƒªã‚¹ãƒˆã™ã‚‹ã“ã¨ã§ã€ä»–ã®ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã«ä¾å­˜ã§ãã¾ã™ã€‚
ä¾å­˜é–¢ä¿‚ã‚’æŒ‡å®šã™ã‚‹æœ€ã‚‚ä¸€èˆ¬çš„ãªæ–¹æ³•ã¯ã€ãã®åå‰ã¨ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’æä¾›ã™ã‚‹ã“ã¨ã§ã™ã€‚</p>
</blockquote>
<pre><code class="language-toml">[dependencies]
thiserror = "1"
</code></pre>
<p>This will add <code>thiserror</code> as a dependency to your package, with a <strong>minimum</strong> version of <code>1.0.0</code>.
<code>thiserror</code> will be pulled from <a href="https://crates.io">crates.io</a>, Rust's official package registry.
When you run <code>cargo build</code>, <code>cargo</code> will go through a few stages:</p>
<ul>
<li>Dependency resolution</li>
<li>Downloading the dependencies</li>
<li>Compiling your project (your own code and the dependencies)</li>
</ul>
<blockquote>
<p>ã“ã‚Œã¯ã€<code>1.0.0</code>ã®<strong>æœ€å°</strong>ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã§ã€ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã®ä¾å­˜é–¢ä¿‚ã¨ã—ã¦<code>thiserror</code>ã‚’è¿½åŠ ã—ã¾ã™ã€‚
<code>thiserror</code>ã¯ã€Rustã®å…¬å¼ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ãƒ¬ã‚¸ã‚¹ãƒˆãƒªã§ã‚ã‚‹<code>crates.io</code>ã‹ã‚‰å¼•ãå‡ºã•ã‚Œã¾ã™ã€‚
<code>cargo build</code>ã‚’å®Ÿè¡Œã—ãŸã¨ãã€<code>cargo</code>ã¯ã„ãã¤ã‹ã®ã‚¹ãƒ†ãƒ¼ã‚¸ã‚’é€šéã—ã¾ã™ã€‚</p>
<ul>
<li>ä¾å­˜é–¢ä¿‚ã®è§£æ±º</li>
<li>ä¾å­˜é–¢ä¿‚ã®ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰</li>
<li>ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ï¼ˆç‹¬è‡ªã®ã‚³ãƒ¼ãƒ‰ã¨ä¾å­˜é–¢ä¿‚ï¼‰</li>
</ul>
</blockquote>
<p>Dependency resolution is skipped if your project has a <code>Cargo.lock</code> file and your manifest files are unchanged.
A lockfile is automatically generated by <code>cargo</code> after a successful round of dependency resolution: it contains
the exact versions of all dependencies used in your project, and is used to ensure that the same versions are
consistently used across different builds (e.g. in CI). If you're working on a project with multiple developers,
you should commit the <code>Cargo.lock</code> file to your version control system.</p>
<blockquote>
<p>ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãŒ<code>Cargo.lock</code>ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æŒã£ã¦ã„ã¦ã€ãƒãƒ‹ãƒ•ã‚§ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ãŒå¤‰æ›´ã•ã‚Œã¦ã„ãªã„å ´åˆã€ä¾å­˜é–¢ä¿‚ã®è§£æ±ºã¯ã‚¹ã‚­ãƒƒãƒ—ã•ã‚Œã¾ã™ã€‚
ãƒ­ãƒƒã‚¯ãƒ•ã‚¡ã‚¤ãƒ«ã¯ã€ä¾å­˜é–¢ä¿‚ã®è§£æ±ºã®ãƒ©ã‚¦ãƒ³ãƒ‰ãŒæˆåŠŸã—ãŸå¾Œã€<code>cargo</code>ã«ã‚ˆã£ã¦è‡ªå‹•çš„ã«ç”Ÿæˆã•ã‚Œã¾ã™ã€‚
ãƒ­ãƒƒã‚¯ãƒ•ã‚¡ã‚¤ãƒ«ã¯ã€ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã§ä½¿ç”¨ã•ã‚Œã‚‹ã™ã¹ã¦ã®ä¾å­˜é–¢ä¿‚ã®æ­£ç¢ºãªãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’å«ã¿ã€ãã‚Œã¯ã€ä¾‹ãˆã°CIãªã©ã®ç•°ãªã‚‹ãƒ“ãƒ«ãƒ‰ã§ã€åŒã˜ãƒãƒ¼ã‚·ãƒ§ãƒ³ãŒä¸€è²«ã—ã¦ä½¿ç”¨ã•ã‚Œã‚‹ã“ã¨ã‚’ç¢ºå®Ÿã«ã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚</p>
</blockquote>
<p>You can use <code>cargo update</code> to update the <code>Cargo.lock</code> file with the latest (compatible) versions of all your dependencies.</p>
<blockquote>
<p>ã™ã¹ã¦ã®ä¾å­˜é–¢ä¿‚ã®äº’æ›æ€§ã®ã‚ã‚‹æœ€æ–°ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã§<code>Cargo.lock</code>ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ›´æ–°ã™ã‚‹ãŸã‚ã«ã€<code>cargo update</code>ã‚’ä½¿ç”¨ã§ãã¾ã™ã€‚</p>
</blockquote>
<h2 id="path-dependenciesãƒ‘ã‚¹ä¾å­˜é–¢ä¿‚"><a class="header" href="#path-dependenciesãƒ‘ã‚¹ä¾å­˜é–¢ä¿‚">Path dependenciesï¼ˆãƒ‘ã‚¹ä¾å­˜é–¢ä¿‚ï¼‰</a></h2>
<p>You can also specify a dependency using a <strong>path</strong>. This is useful when you're working on multiple local packages.</p>
<blockquote>
<p><strong>ãƒ‘ã‚¹</strong>ã‚’ä½¿ç”¨ã—ã¦ä¾å­˜é–¢ä¿‚ã‚’æŒ‡å®šã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ã€‚ã“ã‚Œã¯ã€è¤‡æ•°ã®ãƒ­ãƒ¼ã‚«ãƒ«ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã§ä½œæ¥­ã—ã¦ã„ã‚‹ã¨ãã«ä¾¿åˆ©ã§ã™ã€‚</p>
</blockquote>
<pre><code class="language-toml">[dependencies]
my-library = { path = "../my-library" }
</code></pre>
<p>The path is relative to the <code>Cargo.toml</code> file of the package that's declaring the dependency.</p>
<blockquote>
<p>ãƒ‘ã‚¹ã¯ã€ä¾å­˜é–¢ä¿‚ã‚’å®£è¨€ã—ãŸãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã®<code>Cargo.toml</code>ãƒ•ã‚¡ã‚¤ãƒ«ã«å¯¾ã—ã¦ç›¸å¯¾çš„ã§ã™ã€‚</p>
</blockquote>
<h3 id="other-sourcesä»–ã®ã‚½ãƒ¼ã‚¹"><a class="header" href="#other-sourcesä»–ã®ã‚½ãƒ¼ã‚¹">Other sourcesï¼ˆä»–ã®ã‚½ãƒ¼ã‚¹ï¼‰</a></h3>
<p>Check out the <a href="https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html">Cargo documentation</a> for more
details on where you can get dependencies from and how to specify them in your <code>Cargo.toml</code> file.</p>
<blockquote>
<p>ä¾å­˜é–¢ä¿‚ã‚’å–å¾—ã§ãã‚‹å ´æ‰€ã¨ã€<code>Cargo.toml</code>ãƒ•ã‚¡ã‚¤ãƒ«å†…ã§ãã‚Œã‚‰ã‚’æŒ‡å®šã™ã‚‹æ–¹æ³•ã®è©³ç´°ã¯ã€Cargoãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚</p>
</blockquote>
<h2 id="dev-dependenciesé–‹ç™ºä¾å­˜é–¢ä¿‚"><a class="header" href="#dev-dependenciesé–‹ç™ºä¾å­˜é–¢ä¿‚">Dev dependenciesï¼ˆé–‹ç™ºä¾å­˜é–¢ä¿‚ï¼‰</a></h2>
<p>You can also specify dependencies that are only needed for developmentâ€”i.e. they only get pulled in when you're
running <code>cargo test</code>.<br />
They go in the <code>[dev-dependencies]</code> section of your <code>Cargo.toml</code> file:</p>
<blockquote>
<p>ä¾‹ãˆã°ã€<code>cargo test</code>ã‚’å®Ÿè¡Œã—ã¦ã„ã‚‹ã¨ãã®ã¿å¼•ãå‡ºã•ã‚Œã‚‹ã‚ˆã†ã«ã€é–‹ç™ºã§ã®ã¿å¿…è¦ãªä¾å­˜é–¢ä¿‚ã‚‚æŒ‡å®šã§ãã¾ã™ã€‚</p>
</blockquote>
<pre><code class="language-toml">[dev-dependencies]
static_assertions = "1.1.0"
</code></pre>
<p>We've been using a few of these throughout the book to shorten our tests.</p>
<blockquote>
<p>æœ¬æ›¸å…¨ä½“ã§ãƒ†ã‚¹ãƒˆã‚’çŸ­ç¸®ã™ã‚‹ãŸã‚ã«ã€ã“ã‚Œã‚‰ã‚’ã„ãã¤ã‹ä½¿ç”¨ã—ã¦ãã¾ã—ãŸã€‚</p>
</blockquote>
<h2 id="exercise-52"><a class="header" href="#exercise-52">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/05_ticket_v2/11_dependencies"><code>05_ticket_v2/11_dependencies</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="thiserror"><a class="header" href="#thiserror"><code>thiserror</code></a></h1>
<p>That was a bit of detour, wasn't it? But a necessary one!<br />
Let's get back on track now: custom error types and <code>thiserror</code>.</p>
<blockquote>
<p>å°‘ã—å›ã‚Šé“ã‚’ã—ã¾ã—ãŸã‹ï¼Ÿã—ã‹ã—ãã‚Œã¯å¿…è¦ã§ã—ãŸï¼
ã“ã“ã§ã€ã‚«ã‚¹ã‚¿ãƒ ã‚¨ãƒ©ãƒ¼å‹ã¨<code>thiserror</code>ã®è¿½è·¡ã«æˆ»ã‚Šã¾ã—ã‚‡ã†ã€‚</p>
</blockquote>
<h2 id="custom-error-typesã‚«ã‚¹ã‚¿ãƒ ã‚¨ãƒ©ãƒ¼å‹"><a class="header" href="#custom-error-typesã‚«ã‚¹ã‚¿ãƒ ã‚¨ãƒ©ãƒ¼å‹">Custom error typesï¼ˆã‚«ã‚¹ã‚¿ãƒ ã‚¨ãƒ©ãƒ¼å‹ï¼‰</a></h2>
<p>We've seen how to implement the <code>Error</code> trait "manually" for a custom error type.<br />
Imagine that you have to do this for most error types in your codebase. That's a lot of boilerplate, isn't it?</p>
<blockquote>
<p>ã‚«ã‚¹ã‚¿ãƒ ã‚¨ãƒ©ãƒ¼å‹ã«å¯¾ã—ã¦ã€Œæ‰‹å‹•ã§ã€<code>Error</code>ãƒˆãƒ¬ã‚¤ãƒˆã‚’å®Ÿè£…ã™ã‚‹æ–¹æ³•ã‚’ç¢ºèªã—ã¾ã—ãŸã€‚
ã‚³ãƒ¼ãƒ‰ãƒ™ãƒ¼ã‚¹ã§ã»ã¨ã‚“ã©ã®ã‚¨ãƒ©ãƒ¼å‹ã«å¯¾ã—ã¦ã“ã‚Œã‚’ã—ãªã‘ã‚Œã°ãªã‚‰ãªã„ã“ã¨ã‚’æƒ³åƒã—ã¦ãã ã•ã„ã€‚ãã‚Œã¯å¤šãã®ãƒœã‚¤ãƒ©ãƒ¼ãƒ—ãƒ¬ãƒ¼ãƒˆã§ã¯ã‚ã‚Šã¾ã›ã‚“ã‹ï¼Ÿ</p>
</blockquote>
<p>We can remove some of the boilerplate by using <a href="https://docs.rs/thiserror/latest/thiserror/"><code>thiserror</code></a>,
a Rust crate that provides a <strong>procedural macro</strong> to simplify the creation of custom error types.</p>
<blockquote>
<p>ã‚«ã‚¹ã‚¿ãƒ ã‚¨ãƒ©ãƒ¼å‹ã®ä½œæˆã‚’ç°¡ç´ åŒ–ã™ã‚‹ãŸã‚ã®<strong>æ‰‹ç¶šããƒã‚¯ãƒ­</strong>ã‚’æä¾›ã™ã‚‹Rustã‚¯ãƒ¬ãƒ¼ãƒˆã®<code>thiserror</code>ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã§ã€ã„ãã¤ã‹ã®å®šå‹æ–‡ã‚’å‰Šé™¤ã§ãã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(thiserror::Error, Debug)]
enum TicketNewError {
    #[error("{0}")]
    TitleError(String),
    #[error("{0}")]
    DescriptionError(String),
}
<span class="boring">}</span></code></pre></pre>
<h2 id="you-can-write-your-own-macrosç‹¬è‡ªã®ãƒã‚¯ãƒ­ã‚’è¨˜è¿°ã§ãã¾ã™"><a class="header" href="#you-can-write-your-own-macrosç‹¬è‡ªã®ãƒã‚¯ãƒ­ã‚’è¨˜è¿°ã§ãã¾ã™">You can write your own macrosï¼ˆç‹¬è‡ªã®ãƒã‚¯ãƒ­ã‚’è¨˜è¿°ã§ãã¾ã™ï¼‰</a></h2>
<p>All the <code>derive</code> macros we've seen so far were provided by the Rust standard library.<br />
<code>thiserror::Error</code> is the first example of a <strong>third-party</strong> <code>derive</code> macro.</p>
<blockquote>
<p>ã“ã‚Œã¾ã§ã«è¦‹ã¦ããŸã™ã¹ã¦ã®<code>derive</code>ãƒã‚¯ãƒ­ã¯ã€Rustæ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã«ã‚ˆã£ã¦æä¾›ã•ã‚Œã¦ã„ã¾ã™ã€‚
<code>thiserror::Error</code>ã¯ã€<strong>ã‚µãƒ¼ãƒ‰ãƒ‘ãƒ¼ãƒ†ã‚£</strong>ã®<code>derive</code>ãƒã‚¯ãƒ­ã®æœ€åˆã®ä¾‹ã§ã™ã€‚</p>
</blockquote>
<p><code>derive</code> macros are a subset of <strong>procedural macros</strong>, a way to generate Rust code at compile time.
We won't get into the details of how to write a procedural macro in this course, but it's important
to know that you can write your own!<br />
A topic to approach in a more advanced Rust course.</p>
<blockquote>
<p><code>derive</code>ãƒã‚¯ãƒ­ã¯ã€<strong>æ‰‹ç¶šããƒã‚¯ãƒ­</strong>ã®éƒ¨åˆ†é›†åˆã§ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã«Rustã‚³ãƒ¼ãƒ‰ã‚’ç”Ÿæˆã™ã‚‹æ–¹æ³•ã§ã™ã€‚
ã“ã®ã‚³ãƒ¼ã‚¹ã«ãŠã„ã¦ã€æ‰‹ç¶šããƒã‚¯ãƒ­ã‚’è¨˜è¿°ã™ã‚‹æ–¹æ³•ã®è©³ç´°ã«å…¥ã‚‹ã¤ã‚‚ã‚Šã¯ã‚ã‚Šã¾ã›ã‚“ãŒã€ç‹¬è‡ªã«è¨˜è¿°ã§ãã‚‹ã“ã¨ã‚’çŸ¥ã‚‹ã“ã¨ã¯é‡è¦ã§ã™ã€‚
ãã‚Œã¯ã€ã‚ˆã‚Šé«˜åº¦ãªRustã®ã‚³ãƒ¼ã‚¹ã§èª¬æ˜ã™ã‚‹ãƒˆãƒ”ãƒƒã‚¯ã§ã™ã€‚</p>
</blockquote>
<h2 id="custom-syntaxã‚«ã‚¹ã‚¿ãƒ æ§‹æ–‡"><a class="header" href="#custom-syntaxã‚«ã‚¹ã‚¿ãƒ æ§‹æ–‡">Custom syntaxï¼ˆã‚«ã‚¹ã‚¿ãƒ æ§‹æ–‡ï¼‰</a></h2>
<p>Each procedural macro can define its own syntax, which is usually explained in the crate's documentation.
In the case of <code>thiserror</code>, we have:</p>
<ul>
<li><code>#[derive(thiserror::Error)]</code>: this is the syntax to derive the <code>Error</code> trait for a custom error type, helped by <code>thiserror</code>.</li>
<li><code>#[error("{0}")]</code>: this is the syntax to define a <code>Display</code> implementation for each variant of the custom error type.
<code>{0}</code> is replaced by the zero-th field of the variant (<code>String</code>, in this case) when the error is displayed.</li>
</ul>
<blockquote>
<p>ãã‚Œãã‚Œã®æ‰‹ç¶šãƒã‚¯ãƒ­ã¯ãã‚Œç‹¬è‡ªã®æ§‹æ–‡ã‚’å®šç¾©ã§ãã€é€šå¸¸ã€ãã‚Œã¯ã‚¯ãƒ¬ãƒ¼ãƒˆã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã§èª¬æ˜ã•ã‚Œã¦ã„ã¾ã™ã€‚
<code>thiserror</code>ã®å ´åˆã€æ¬¡ã®ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚</p>
<ul>
<li><code>#[derive(thiserror::Error)]</code>: ã“ã‚Œã¯ã€<code>thiserror</code>ã«ã‚ˆã£ã¦æ”¯æ´ã•ã‚Œã‚‹ã€ã‚«ã‚¹ã‚¿ãƒ ã‚¨ãƒ©ãƒ¼å‹ã«<code>Error</code>ãƒˆãƒ¬ã‚¤ãƒˆã‚’å°å‡ºã™ã‚‹æ§‹æ–‡ã§ã™ã€‚</li>
<li><code>#[error("{0}")]</code>: ã“ã‚Œã¯ã€ã‚«ã‚¹ã‚¿ãƒ ã‚¨ãƒ©ãƒ¼å‹ã®ãã‚Œãã‚Œã®ãƒãƒªã‚¢ãƒ³ãƒˆã«å¯¾ã—ã¦<code>Display</code>ã®å®Ÿè£…ã‚’å®šç¾©ã™ã‚‹æ§‹æ–‡ã§ã™ã€‚</li>
<li><code>{0}</code>ã¯ã€ã‚¨ãƒ©ãƒ¼ãŒè¡¨ç¤ºã•ã‚Œã‚‹ã¨ãã«ã€ãƒãƒªã‚¢ãƒ³ãƒˆã®0ç•ªç›®ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ï¼ˆã“ã®å ´åˆã¯<code>String</code>ï¼‰ã«ç½®ãæ›ãˆã‚‰ã‚Œã¾ã™ã€‚</li>
</ul>
</blockquote>
<h2 id="exercise-53"><a class="header" href="#exercise-53">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/05_ticket_v2/12_thiserror"><code>05_ticket_v2/12_thiserror</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tryfrom-and-tryintotryfromã¨tryinto"><a class="header" href="#tryfrom-and-tryintotryfromã¨tryinto"><code>TryFrom</code> and <code>TryInto</code>ï¼ˆTryFromã¨TryIntoï¼‰</a></h1>
<p>In the previous chapter we looked at the <a href="05_ticket_v2/../04_traits/09_from.html"><code>From</code> and <code>Into</code> traits</a>,
Rust's idiomatic interfaces for <strong>infallible</strong> type conversions.<br />
But what if the conversion is not guaranteed to succeed?</p>
<blockquote>
<p>å‰ã®æ¼”ç¿’ã«ãŠã„ã¦ã€Rustã®<strong>å¤±æ•—ã—ãªã„</strong>å‹å¤‰æ›ã®æ…£ç”¨çš„ãªã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ã‚¤ã‚¹ã§ã‚ã‚‹ã€<code>From</code>ã¨<code>Into</code>ãƒˆãƒ¬ã‚¤ãƒˆã‚’ç¢ºèªã—ã¾ã—ãŸã€‚
ã—ã‹ã—ã€æˆåŠŸã™ã‚‹ã“ã¨ãŒä¿è¨¼ã•ã‚Œã¦ã„ãªã„å¤‰æ›ã®å ´åˆã¯ã©ã†ãªã‚‹ã§ã—ã‚‡ã†ã‹ï¼Ÿ</p>
</blockquote>
<p>We now know enough about errors to discuss the <strong>fallible</strong> counterparts of <code>From</code> and <code>Into</code>:
<code>TryFrom</code> and <code>TryInto</code>.</p>
<blockquote>
<p>ç¾åœ¨ã€<code>From</code>ã¨<code>Into</code>ã®<strong>å¤±æ•—ã™ã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹</strong>ã«å¯¾å¿œã™ã‚‹<code>TryFrom</code>ã¨<code>TryInto</code>ã«ã¤ã„ã¦è­°è«–ã§ãã‚‹ã»ã©ã€ã‚¨ãƒ©ãƒ¼ã‚’ååˆ†ã«ç†è§£ã—ã¦ã„ã¾ã™ã€‚</p>
</blockquote>
<h2 id="tryfrom-and-tryintotryfromã¨tryinto-1"><a class="header" href="#tryfrom-and-tryintotryfromã¨tryinto-1"><code>TryFrom</code> and <code>TryInto</code>ï¼ˆTryFromã¨TryIntoï¼‰</a></h2>
<p>Both <code>TryFrom</code> and <code>TryInto</code> are defined in the <code>std::convert</code> module, just like <code>From</code> and <code>Into</code>.</p>
<blockquote>
<p><code>TryFrom</code>ã¨<code>TryInto</code>ä¸¡æ–¹ã¨ã‚‚ã€ã¡ã‚‡ã†ã©<code>From</code>ã¨<code>Into</code>ã¨åŒæ§˜ã«ã€<code>std::convert</code>ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«å®šç¾©ã•ã‚Œã¦ã„ã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait TryFrom&lt;T&gt;: Sized {
    type Error;
    fn try_from(value: T) -&gt; Result&lt;Self, Self::Error&gt;;
}

pub trait TryInto&lt;T&gt;: Sized {
    type Error;
    fn try_into(self) -&gt; Result&lt;T, Self::Error&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p>The main difference between <code>From</code>/<code>Into</code> and <code>TryFrom</code>/<code>TryInto</code> is that the latter return a <code>Result</code> type.<br />
This allows the conversion to fail, returning an error instead of panicking.</p>
<blockquote>
<p><code>From</code>/<code>Into</code>ã¨<code>TryFrom</code>/<code>TryInto</code>ã®ä¸»ãªé•ã„ã¯ã€å¾Œè€…ãŒ<code>Result</code>å‹ã‚’è¿”ã™ã“ã¨ã§ã™ã€‚
ã“ã‚Œã¯ã€å¤‰æ›ãŒå¤±æ•—ã™ã‚‹ã“ã¨ã‚’è¨±å¯ã—ã¦ã€ãƒ‘ãƒ‹ãƒƒã‚¯ã®ä»£ã‚ã‚Šã«ã‚¨ãƒ©ãƒ¼ã‚’è¿”ã—ã¾ã™ã€‚</p>
</blockquote>
<h2 id="selferror"><a class="header" href="#selferror"><code>Self::Error</code></a></h2>
<p>Both <code>TryFrom</code> and <code>TryInto</code> have an associated <code>Error</code> type.
This allows each implementation to specify its own error type, ideally the most appropriate for the conversion
being attempted.</p>
<blockquote>
<p><code>TryFrom</code>ã¨<code>TryInto</code>ä¸¡æ–¹ã¯ã€é–¢é€£å‹<code>Error</code>ãŒã‚ã‚Šã¾ã™ã€‚
ã“ã‚Œã¯ã€ãã‚Œãã‚Œã®å®Ÿè£…ã«ã€å¤‰æ›ã®è©¦ã¿ã«å¯¾ã—ã¦ç†æƒ³çš„ã«æœ€ã‚‚é©åˆ‡ãªç‹¬è‡ªã®ã‚¨ãƒ©ãƒ¼å‹ã‚’æŒ‡å®šã•ã›ã¾ã™ã€‚</p>
</blockquote>
<p><code>Self::Error</code> is a way to refer to the <code>Error</code> associated type defined in the trait itself.</p>
<blockquote>
<p><code>Self::Error</code>ã¯ã€ãã‚Œè‡ªèº«ã®ãƒˆãƒ¬ã‚¤ãƒˆã«å®šç¾©ã•ã‚ŒãŸ<code>Error</code>é–¢é€£å‹ã‚’å‚ç…§ã™ã‚‹æ–¹æ³•ã§ã™ã€‚</p>
</blockquote>
<h2 id="dualityäºŒé‡æ€§"><a class="header" href="#dualityäºŒé‡æ€§">Dualityï¼ˆäºŒé‡æ€§ï¼‰</a></h2>
<p>Just like <code>From</code> and <code>Into</code>, <code>TryFrom</code> and <code>TryInto</code> are dual traits.<br />
If you implement <code>TryFrom</code> for a type, you get <code>TryInto</code> for free.</p>
<blockquote>
<p><code>From</code>ã¨<code>Into</code>ã¨åŒæ§˜ã«ã€<code>TryFrom</code>ã¨<code>TryInto</code>ã¯åŒå¯¾ãƒˆãƒ¬ã‚¤ãƒˆã§ã™ã€‚
å‹ã«<code>TryFrom</code>ã‚’å®Ÿè£…ã™ã‚‹ã¨ã€<code>TryInto</code>ãŒç„¡æ–™ã§æä¾›ã•ã‚Œã¾ã™ã€‚</p>
</blockquote>
<h2 id="exercise-54"><a class="header" href="#exercise-54">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/05_ticket_v2/13_try_from"><code>05_ticket_v2/13_try_from</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="errorsource"><a class="header" href="#errorsource"><code>Error::source</code></a></h1>
<p>There's one more thing we need to talk about to complete our coverage of the <code>Error</code> trait: the <code>source</code> method.</p>
<blockquote>
<p><code>Error</code>ãƒˆãƒ¬ã‚¤ãƒˆã®èª¬æ˜ã‚’å®Œäº†ã™ã‚‹ãŸã‚ã«ã€è©±ã™å¿…è¦ãŒã‚ã‚‹ã“ã¨ãŒã‚‚ã†1ã¤ã‚ã‚Šã¾ã™ã€‚ãã‚Œã¯<code>source</code>ãƒ¡ã‚½ãƒƒãƒ‰ã§ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Full definition this time!
// ä»Šå›ã¯å®Œå…¨ãªå®šç¾©ã§ã™ã€‚
pub trait Error: Debug + Display {
    fn source(&amp;self) -&gt; Option&lt;&amp;(dyn Error + 'static)&gt; {
        None
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>source</code> method is a way to access the <strong>error cause</strong>, if any.<br />
Errors are often chained, meaning that one error is the cause of another: you have a high-level error (e.g.
cannot connect to the database) that is caused by a lower-level error (e.g. can't resolve the database hostname).
The <code>source</code> method allows you to "walk" the full chain of errors, often used when capturing error context in logs.</p>
<blockquote>
<p><code>source</code>ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ã‚‚ã—ã‚ã‚‹å ´åˆã€<strong>ã‚¨ãƒ©ãƒ¼ã®åŸå› </strong>ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹æ–¹æ³•ã§ã™ã€‚
æ™‚ã€…ã€ã‚¨ãƒ©ãƒ¼ã¯é€£é–ã•ã‚Œã€ãã‚Œã¯1ã¤ã®ã‚¨ãƒ©ãƒ¼ãŒä»–ã®åŸå› ã«ãªã‚‹ã“ã¨ã‚’æ„å‘³ã—ã¾ã™ã€‚
ä¾‹ãˆã°ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã®ãƒ›ã‚¹ãƒˆåã‚’è§£æ±ºã§ããªã„ãªã©ã®ä½æ°´æº–ã®ã‚¨ãƒ©ãƒ¼ã«ã‚ˆã£ã¦å¼•ãèµ·ã“ã•ã‚ŒãŸã€ä¾‹ãˆã°ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã«æ¥ç¶šã§ããªã„ãªã©ã®é«˜æ°´æº–ãªã‚¨ãƒ©ãƒ¼ãŒã‚ã‚Šã¾ã™ã€‚
<code>source</code>ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ã‚¨ãƒ©ãƒ¼ã®å®Œå…¨ãªã¤ãªãŒã‚Šã‚’ã€Œæ¨ªæ–­ã€ã•ã›ã¦ã€æ™‚ã€…ãƒ­ã‚°ã§ã‚¨ãƒ©ãƒ¼ã®æ–‡è„ˆã‚’ã‚­ãƒ£ãƒ—ãƒãƒ£ãƒ¼ã™ã‚‹ã¨ãã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚</p>
</blockquote>
<h2 id="implementing-sourcesourceã®å®Ÿè£…"><a class="header" href="#implementing-sourcesourceã®å®Ÿè£…">Implementing <code>source</code>ï¼ˆsourceã®å®Ÿè£…ï¼‰</a></h2>
<p>The <code>Error</code> trait provides a default implementation that always returns <code>None</code> (i.e. no underlying cause). That's why
you didn't have to care about <code>source</code> in the previous exercises.<br />
You can override this default implementation to provide a cause for your error type.</p>
<blockquote>
<p><code>Error</code>ãƒˆãƒ¬ã‚¤ãƒˆã¯ã€ä¾‹ãˆã°æ ¹æœ¬çš„ãªåŸå› ã®ãªã„<code>None</code>ã‚’å¸¸ã«è¿”ã™ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå®Ÿè£…ã‚’æä¾›ã—ã¦ã„ã¾ã™ã€‚
ãã‚ŒãŒã€å‰ã®æ¼”ç¿’ã§<code>source</code>ã«ã¤ã„ã¦æ°—ã«ã™ã‚‹å¿…è¦ãŒãªã‹ã£ãŸç†ç”±ã§ã™ã€‚
ç‹¬è‡ªã®ã‚¨ãƒ©ãƒ¼å‹ã§åŸå› ã‚’æä¾›ã™ã‚‹ãŸã‚ã«ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå®Ÿè£…ã‚’ä¸Šæ›¸ãã§ãã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::error::Error;

#[derive(Debug)]
struct DatabaseError {
    source: std::io::Error
}

impl std::fmt::Display for DatabaseError {
    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter) -&gt; std::fmt::Result {
        write!(f, "Failed to connect to the database")
    }
}

impl std::error::Error for DatabaseError {
    fn source(&amp;self) -&gt; Option&lt;&amp;(dyn Error + 'static)&gt; {
        Some(&amp;self.source)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>In this example, <code>DatabaseError</code> wraps an <code>std::io::Error</code> as its source.
We then override the <code>source</code> method to return this source when called.</p>
<blockquote>
<p>ã“ã®ä¾‹ã«ãŠã„ã¦ã€<code>DatabaseError</code>ã¯ã€ãã®ã‚½ãƒ¼ã‚¹ã¨ã—ã¦<code>std::io::Error</code>ã‚’ãƒ©ãƒƒãƒ—ã—ã¦ã„ã¾ã™ã€‚
ãã—ã¦ã€å‘¼ã³å‡ºã•ã‚ŒãŸã¨ãã«ã€ã“ã®ã‚½ãƒ¼ã‚¹ã‚’è¿”ã™ãŸã‚ã«<code>source</code>ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä¸Šæ›¸ãã—ã¾ã™ã€‚</p>
</blockquote>
<h2 id="dyn-error--static"><a class="header" href="#dyn-error--static"><code>&amp;(dyn Error + 'static)</code></a></h2>
<p>What's this <code>&amp;(dyn Error + 'static)</code> type?<br />
Let's unpack it:</p>
<ul>
<li><code>dyn Error</code> is a <strong>trait object</strong>. It's a way to refer to any type that implements the <code>Error</code> trait.</li>
<li><code>'static</code> is a special <strong>lifetime specifier</strong>.
<code>'static</code> implies that the reference is valid for "as long as we need it", i.e. the entire program execution.</li>
</ul>
<blockquote>
<p>ã“ã®<code>&amp;(dyn Error + 'static)</code>å‹ã¯ãªã‚“ã§ã—ã‚‡ã†ã‹ï¼Ÿ
ãã‚Œã‚’åˆ†è§£ã—ã¦ã¿ã¾ã—ã‚‡ã†ã€‚</p>
<ul>
<li><code>dyn Error</code>ã¯<strong>ãƒˆãƒ¬ã‚¤ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ</strong>ã§ã™ã€‚ãã‚Œã¯ã€<code>Error</code>ãƒˆãƒ¬ã‚¤ãƒˆã‚’å®Ÿè£…ã™ã‚‹ä»»æ„ã®å‹ã‚’å‚ç…§ã™ã‚‹æ–¹æ³•ã§ã™ã€‚</li>
<li><code>'static</code>ã¯ç‰¹åˆ¥ãª<strong>ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ æ³¨é‡ˆ</strong>ã§ã™ã€‚
<code>'static</code>ã¯ã€ä¾‹ãˆã°ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®å®Ÿè¡Œå…¨ä½“ã§ãªã©ã€å‚ç…§ãŒã€Œãã‚ŒãŒå¿…è¦ã¨ã•ã‚Œã‚‹é™ã‚Šã€æœ‰åŠ¹ã§ã‚ã‚‹ã“ã¨ã‚’æš—é»™çš„ã«ç¤ºã—ã¦ã„ã¾ã™ã€‚</li>
</ul>
</blockquote>
<p>Combined: <code>&amp;(dyn Error + 'static)</code> is a reference to a trait object that implements the <code>Error</code> trait
and is valid for the entire program execution.</p>
<blockquote>
<p>çµ„ã¿åˆã‚ã›ã‚‹ã¨: <code>&amp;(dyn Error + 'static)</code>ã¯ã€<code>Error</code>ãƒˆãƒ¬ã‚¤ãƒˆã‚’å®Ÿè£…ã—ãŸãƒˆãƒ¬ã‚¤ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®å‚ç…§ã§ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®å®Ÿè¡Œå…¨ä½“ã§æœ‰åŠ¹ã§ã™ã€‚</p>
</blockquote>
<p>Don't worry too much about either of these concepts for now. We'll cover them in more detail in future chapters.</p>
<blockquote>
<p>ä»Šã®ã¨ã“ã‚ã€ã“ã‚Œã‚‰ã®æ¦‚å¿µã«ã¤ã„ã¦ã‚ã¾ã‚Šå¿ƒé…ã—ãªã„ã§ãã ã•ã„ã€‚å°†æ¥ã®ç« ã§ã‚ˆã‚Šè©³ç´°ã«ãã‚Œã‚‰ã‚’èª¬æ˜ã—ã¾ã™ã€‚</p>
</blockquote>
<h2 id="implementing-source-using-thiserrorthiserrorã‚’ä½¿ç”¨ã—ã¦sourceã‚’å®Ÿè£…ã™ã‚‹"><a class="header" href="#implementing-source-using-thiserrorthiserrorã‚’ä½¿ç”¨ã—ã¦sourceã‚’å®Ÿè£…ã™ã‚‹">Implementing <code>source</code> using <code>thiserror</code>ï¼ˆthiserrorã‚’ä½¿ç”¨ã—ã¦sourceã‚’å®Ÿè£…ã™ã‚‹ï¼‰</a></h2>
<p><code>thiserror</code> provides three ways to automatically implement <code>source</code> for your error types:</p>
<blockquote>
<p><code>thiserror</code>ã¯ã€ç‹¬è‡ªã®ã‚¨ãƒ©ãƒ¼å‹ã«å¯¾ã—ã¦<code>source</code>ã‚’è‡ªå‹•çš„ã«å®Ÿè£…ã™ã‚‹3ã¤ã®æ–¹æ³•ã‚’æä¾›ã—ã¾ã™ã€‚</p>
</blockquote>
<ul>
<li>
<p>A field named <code>source</code> will automatically be used as the source of the error.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use thiserror::Error;

#[derive(Error, Debug)]
pub enum MyError {
    #[error("Failed to connect to the database")]
    DatabaseError {
        source: std::io::Error
    }
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>A field annotated with the <code>#[source]</code> attribute will automatically be used as the source of the error.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use thiserror::Error;

#[derive(Error, Debug)]
pub enum MyError {
    #[error("Failed to connect to the database")]
    DatabaseError {
        #[source]
        inner: std::io::Error
    }
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>A field annotated with the <code>#[from]</code> attribute will automatically be used as the source of the error <strong>and</strong>
<code>thiserror</code> will automatically generate a <code>From</code> implementation to convert the annotated type into your error type.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use thiserror::Error;

#[derive(Error, Debug)]
pub enum MyError {
    #[error("Failed to connect to the database")]
    DatabaseError {
        #[from]
        inner: std::io::Error
    }
}
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<blockquote>
<ul>
<li>ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰å<code>source</code>ã¯ã€ã‚¨ãƒ©ãƒ¼ã®ã‚½ãƒ¼ã‚¹ã¨ã—ã¦è‡ªå‹•çš„ã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚</li>
<li><code>#[source]</code>å±æ€§ã§æ³¨é‡ˆã•ã‚ŒãŸãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¯ã€ã‚¨ãƒ©ãƒ¼ã®ã‚½ãƒ¼ã‚¹ã¨ã—ã¦è‡ªå‹•çš„ã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚</li>
<li><code>#[from]</code>å±æ€§ã§æ³¨é‡ˆã•ã‚ŒãŸãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¯ã€ã‚¨ãƒ©ãƒ¼ã®ã‚½ãƒ¼ã‚¹ã¨ã—ã¦è‡ªå‹•çš„ã«ä½¿ç”¨ã•ã‚Œã€<strong>ã•ã‚‰ã«</strong> <code>thiserror</code>ã¯ã€æ³¨é‡ˆã•ã‚ŒãŸå‹ã‚’ç‹¬è‡ªã®ã‚¨ãƒ©ãƒ¼å‹ã«å¤‰æ›ã™ã‚‹<code>From</code>å®Ÿè£…ã‚’è‡ªå‹•çš„ã«ç”Ÿæˆã—ã¾ã™ã€‚</li>
</ul>
</blockquote>
<h2 id="the--operatoræ¼”ç®—å­"><a class="header" href="#the--operatoræ¼”ç®—å­">The <code>?</code> operatorï¼ˆ?æ¼”ç®—å­ï¼‰</a></h2>
<p>The <code>?</code> operator is a shorthand for propagating errors.<br />
When used in a function that returns a <code>Result</code>, it will return early with an error if the <code>Result</code> is <code>Err</code>.</p>
<p>For example:</p>
<blockquote>
<p><code>?</code>æ¼”ç®—å­ã¯ã‚¨ãƒ©ãƒ¼ã‚’ä¼æ’­ã™ã‚‹ãŸã‚ã®çœç•¥è¨˜æ³•ã§ã™ã€‚
<code>Result</code>ã‚’è¿”ã™é–¢æ•°å†…ã§ä½¿ç”¨ã—ãŸã¨ãã€<code>Result</code>ãŒ<code>Err</code>ã§ã‚ã‚‹å ´åˆã€ã‚¨ãƒ©ãƒ¼ã§æ—©æœŸãƒªã‚¿ãƒ¼ãƒ³ã—ã¾ã™ã€‚</p>
<p>ä¾‹ãˆã°ãƒ»ãƒ»ãƒ»</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;

fn read_file() -&gt; Result&lt;String, std::io::Error&gt; {
    let mut file = File::open("file.txt")?;
    let mut contents = String::new();
    file.read_to_string(&amp;mut contents)?;
    Ok(contents)
}
<span class="boring">}</span></code></pre></pre>
<p>is equivalent to:</p>
<blockquote>
<p>ä¸Šè¨˜ã¯æ¬¡ã¨åŒç­‰ã§ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;

fn read_file() -&gt; Result&lt;String, std::io::Error&gt; {
    let mut file = match File::open("file.txt") {
        Ok(file) =&gt; file,
        Err(e) =&gt; {
            return Err(e);
        }
    };
    let mut contents = String::new();
    match file.read_to_string(&amp;mut contents) {
        Ok(_) =&gt; (),
        Err(e) =&gt; {
            return Err(e);
        }
    }
    Ok(contents)
}
<span class="boring">}</span></code></pre></pre>
<p>You can use the <code>?</code> operator to shorten your error handling code significantly.<br />
In particular, the <code>?</code> operator will automatically convert the error type of the fallible operation into the error type
of the function, if a conversion is possible (i.e. if there is a suitable <code>From</code> implementation)</p>
<blockquote>
<p>ã‚¨ãƒ©ãƒ¼å‡¦ç†ã‚³ãƒ¼ãƒ‰ã‚’å¤§å¹…ã«çŸ­ãã™ã‚‹ãŸã‚ã«<code>?</code>æ¼”ç®—å­ã‚’ä½¿ç”¨ã§ãã¾ã™ã€‚
ç‰¹ã«ã€<code>?</code>æ¼”ç®—å­ã¯ã€ä¾‹ãˆã°é©åˆ‡ãª<code>From</code>å®Ÿè£…ãŒã‚ã‚‹å ´åˆãªã©ã€å¤‰æ›ãŒå¯èƒ½ãªå ´åˆã€å¤±æ•—ã™ã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹æ“ä½œã®ã‚¨ãƒ©ãƒ¼å‹ã‚’é–¢æ•°ã®ã‚¨ãƒ©ãƒ¼å‹ã«è‡ªå‹•çš„ã«å¤‰æ›ã—ã¾ã™ã€‚</p>
</blockquote>
<h2 id="exercise-55"><a class="header" href="#exercise-55">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/05_ticket_v2/14_source"><code>05_ticket_v2/14_source</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wrapping-upä»•ä¸Šã’-2"><a class="header" href="#wrapping-upä»•ä¸Šã’-2">Wrapping upï¼ˆä»•ä¸Šã’ï¼‰</a></h1>
<p>When it comes to domain modelling, the devil is in the details.<br />
Rust offers a wide range of tools to help you represent the constraints of your domain directly in the type system,
but it takes some practice to get it right and write code that looks idiomatic.</p>
<blockquote>
<p>ãƒ‰ãƒ¡ã‚¤ãƒ³ãƒ¢ãƒ‡ãƒªãƒ³ã‚°ã«ãŠã„ã¦ã€æ‚ªé­”ã¯è©³ç´°ã«å®¿ã‚Šã¾ã™ã€‚
Rustã¯ã€å‹ã‚·ã‚¹ãƒ†ãƒ å†…ã«ç›´æ¥ãƒ‰ãƒ¡ã‚¤ãƒ³ã®ä¸€è²«æ€§ã‚’è¡¨ç¾ã™ã‚‹ãŸã‚ã®å¹…åºƒã„ãƒ„ãƒ¼ãƒ«ã‚’æä¾›ã—ã¦ã„ã¾ã™ãŒã€
æ­£ã—ãç†è§£ã—ã¦æ…£ç”¨çš„ãªã‚³ãƒ¼ãƒ‰ã‚’è¨˜è¿°ã™ã‚‹ãŸã‚ã«ã¯ã€ã‚ã‚‹ç¨‹åº¦ã®å®Ÿè·µãŒå¿…è¦ã§ã™ã€‚</p>
</blockquote>
<p>Let's close the chapter with one final refinement of our <code>Ticket</code> model.<br />
We'll introduce a new type for each of the fields in <code>Ticket</code> to encapsulate the respective constraints.<br />
Every time someone accesses a <code>Ticket</code> field, they'll get back a value that's guaranteed to be validâ€”i.e. a
<code>TicketTitle</code> instead of a <code>String</code>. They won't have to worry about the title being empty elsewhere in the code:
as long as they have a <code>TicketTitle</code>, they know it's valid <strong>by construction</strong>.</p>
<blockquote>
<p><code>Ticket</code>ãƒ¢ãƒ‡ãƒ«ã®æœ€å¾Œã®æ”¹è‰¯ã§ç« ã‚’çµ‚äº†ã—ã¾ã—ã‚‡ã†ã€‚
ãã‚Œãã‚Œã®åˆ¶ç´„ã‚’ã‚«ãƒ—ã‚»ãƒ«åŒ–ã™ã‚‹ãŸã‚ã«<code>Ticket</code>å†…ã®ãã‚Œãã‚Œã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«å¯¾ã—ã¦æ–°ã—ã„å‹ã‚’å°å…¥ã—ã¾ã™ã€‚
èª°ã‹ãŒ<code>Ticket</code>ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ãŸã³ã«ã€ãã‚Œã‚‰ã¯æœ‰åŠ¹ã§ã‚ã‚‹ã“ã¨ã‚’ä¿è¨¼ã•ã‚ŒãŸå€¤ã€ä¾‹ãˆã°<code>String</code>ã®ä»£ã‚ã‚Šã«<code>TicketTitle</code>ã‚’è¿”ã—ã¾ã™ã€‚
ã‚³ãƒ¼ãƒ‰ã®ä½•å‡¦ã‹ã§ã‚¿ã‚¤ãƒˆãƒ«ãŒç©ºã§ã‚ã‚‹ã“ã¨ã‚’å¿ƒé…ã™ã‚‹å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚
<code>TicketTitle</code>ãŒã‚ã‚‹é™ã‚Šã€<strong>æ§‹ç¯‰ã«ã‚ˆã£ã¦</strong>æœ‰åŠ¹ã§ã‚ã‚‹ã“ã¨ãŒã‚ã‹ã‚Šã¾ã™ã€‚</p>
</blockquote>
<p>This is just an example of how you can use Rust's type system to make your code safer and more expressive.</p>
<blockquote>
<p>ã“ã‚Œã¯ã€ã¡ã‚‡ã†ã©ã‚³ãƒ¼ãƒ‰ã‚’å®‰å…¨ãã—ã¦ã‚ˆã‚Šè¡¨ç¾ã‚’è±Šã‹ã«ã™ã‚‹ã«ã€Rustã®å‹ã‚·ã‚¹ãƒ†ãƒ ã‚’ä½¿ç”¨ã™ã‚‹æ–¹æ³•ã‚’ç¤ºã™ä¾‹ã§ã™ã€‚</p>
</blockquote>
<h2 id="further-readingå‚è€ƒè³‡æ–™-8"><a class="header" href="#further-readingå‚è€ƒè³‡æ–™-8">Further readingï¼ˆå‚è€ƒè³‡æ–™ï¼‰</a></h2>
<ul>
<li><a href="https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/">Parse, don't validate</a></li>
<li><a href="https://www.lpalmieri.com/posts/2020-12-11-zero-to-production-6-domain-modelling/">Using types to guarantee domain invariants</a></li>
</ul>
<h2 id="exercise-56"><a class="header" href="#exercise-56">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/05_ticket_v2/15_outro"><code>05_ticket_v2/15_outro</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="intro"><a class="header" href="#intro">Intro</a></h1>
<p>In the previous chapter we modelled <code>Ticket</code> in a vacuum: we defined its fields and their constraints, we learned
how to best represent them in Rust, but we didn't consider how <code>Ticket</code> fits into a larger system.
We'll use this chapter to build a simple workflow around <code>Ticket</code>, introducing a (rudimentary) management system to
store and retrieve tickets.</p>
<blockquote>
<p>å‰ã®ç« ã«ãŠã„ã¦ã€ä¸–é–“ã‹ã‚‰å­¤ç«‹ã—ã¦<code>Ticket</code>ã‚’ãƒ¢ãƒ‡ãƒªãƒ³ã‚°ã—ã¾ã—ãŸã€‚
ãã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¨ãã‚Œã‚‰ã®åˆ¶ç´„ã‚’å®šç¾©ã—ã¦ã€Rustã§ãã‚Œã‚‰ã‚’è¡¨ç¾ã™ã‚‹æœ€è‰¯ã®æ–¹æ³•ã‚’å­¦ã³ã¾ã—ãŸãŒã€å¤§ããªã‚·ã‚¹ãƒ†ãƒ ã«<code>Ticket</code>ã‚’é©ç”¨ã™ã‚‹æ–¹æ³•ã‚’è€ƒãˆã¦ã„ã¾ã›ã‚“ã€‚
ãƒã‚±ãƒƒãƒˆã‚’ä¿å­˜ã€ãã—ã¦å–å¾—ã™ã‚‹ãŸã‚ã®åŸºæœ¬çš„ãªç®¡ç†ã‚·ã‚¹ãƒ†ãƒ ã‚’å°å…¥ã—ã¦ã€<code>Ticket</code>ã«é–¢ã™ã‚‹å˜ç´”ãªãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã‚’æ§‹ç¯‰ã™ã‚‹ãŸã‚ã«ã“ã®ç« ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚</p>
</blockquote>
<p>The task will give us an opportunity to explore new Rust concepts, such as:</p>
<ul>
<li>Stack-allocated arrays</li>
<li><code>Vec</code>, a growable array type, and slices</li>
<li><code>Iterator</code> and <code>IntoIterator</code>, for iterating over collections</li>
<li>Slices (<code>&amp;[T]</code>), to work with parts of a collection</li>
<li>Lifetimes, to describe how long references are valid</li>
<li><code>HashMap</code> and <code>BTreeMap</code>, two key-value data structures</li>
<li><code>Eq</code> and <code>Hash</code>, to compare keys in a <code>HashMap</code></li>
<li><code>Ord</code> and <code>PartialOrd</code>, to work with a <code>BTreeMap</code></li>
<li><code>Index</code> and <code>IndexMut</code>, to access elements in a collection</li>
</ul>
<blockquote>
<p>ãã®ã‚¿ã‚¹ã‚¯ã¯ã€æ¬¡ã®ã‚ˆã†ãªæ–°ã—ã„Rustã®æ¦‚å¿µã‚’æ¢æ±‚ã™ã‚‹æ©Ÿä¼šã‚’ä¸ãˆã¦ãã‚Œã¾ã™ã€‚</p>
<ul>
<li>ã‚¹ã‚¿ãƒƒã‚¯ã«å‰²ã‚Šå½“ã¦ã‚‰ã‚ŒãŸé…åˆ—</li>
<li>æˆé•·å¯èƒ½ãªé…åˆ—å‹ã§ã‚ã‚‹<code>Vec</code>ã¨ã‚¹ãƒ©ã‚¤ã‚¹</li>
<li>ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã‚’åå¾©å‡¦ç†ã™ã‚‹<code>Iterator</code>ã¨<code>IntoIterator</code></li>
<li>ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã®ä¸€éƒ¨ã§å‹•ä½œã™ã‚‹ã‚¹ãƒ©ã‚¤ã‚¹ï¼ˆ<code>&amp;[T]</code>ï¼‰</li>
<li>å‚ç…§ãŒæœ‰åŠ¹ãªæœŸé–“ã‚’èª¬æ˜ã™ã‚‹ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ </li>
<li>ã‚­ãƒ¼ã¨å€¤ã®ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã§ã‚ã‚‹2ã¤ã®<code>HashMap</code>ã¨<code>BTreeMap</code></li>
<li><code>HashMap</code>å†…ã®ã‚­ãƒ¼ã‚’æ¯”è¼ƒã™ã‚‹<code>Eq</code>ã¨<code>Hash</code></li>
<li><code>BTreeMap</code>ã§å¿…è¦ãª<code>Ord</code>ã¨<code>PartialOrd</code></li>
<li>ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³å†…ã®è¦ç´ ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹<code>Index</code>ã¨<code>IndexMut</code></li>
</ul>
</blockquote>
<h2 id="exercise-57"><a class="header" href="#exercise-57">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/06_ticket_management/00_intro"><code>06_ticket_management/00_intro</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="arraysé…åˆ—"><a class="header" href="#arraysé…åˆ—">Arraysï¼ˆé…åˆ—ï¼‰</a></h1>
<p>As soon as we start talking about "ticket management" we need to think about a way to store <em>multiple</em> tickets.
In turn, this means we need to think about collections. In particular, homogeneous collections:
we want to store multiple instances of the same type.</p>
<blockquote>
<p>ã€Œãƒã‚±ãƒƒãƒˆã®ç®¡ç†ã€ã«ã¤ã„ã¦è©±ã—å§‹ã‚ã‚‹ã¨ã™ãã«ã€<em>è¤‡æ•°ã®</em> ãƒã‚±ãƒƒãƒˆã‚’ä¿å­˜ã™ã‚‹æ–¹æ³•ã«ã¤ã„ã¦è€ƒãˆå§‹ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚
æ¬¡ã«ã€ã“ã‚Œã¯ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã«ã¤ã„ã¦è€ƒãˆã‚‹å¿…è¦ãŒã‚ã‚‹ã“ã¨ã‚’æ„å‘³ã—ã¾ã™ã€‚ç‰¹ã«ã€åŒç¨®ã®ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã€åŒã˜å‹ã®è¤‡æ•°ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ä¿å­˜ã—ãŸã„ã¨æ€ã„ã¾ã™ã€‚</p>
</blockquote>
<p>What does Rust have to offer in this regard?</p>
<blockquote>
<p>ã“ã®è¦³ç‚¹ã«é–¢ã—ã¦Rustã¯ä½•ã‚’æä¾›ã™ã‚‹ã§ã—ã‚‡ã†ã‹ï¼Ÿ</p>
</blockquote>
<h2 id="arraysé…åˆ—-1"><a class="header" href="#arraysé…åˆ—-1">Arraysï¼ˆé…åˆ—ï¼‰</a></h2>
<p>A first attempt could be to use an <strong>array</strong>.<br />
Arrays in Rust are fixed-size collections of elements of the same type.</p>
<blockquote>
<p>æœ€åˆã®è©¦ã¿ã¯ã€<strong>é…åˆ—</strong>ã‚’ä½¿ã†ã“ã¨ã§ã™ã€‚
Rustã«ãŠã‘ã‚‹é…åˆ—ã¯ã€åŒã˜å‹ã®è¦ç´ ã®å›ºå®šã‚µã‚¤ã‚ºã®ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã§ã™ã€‚</p>
</blockquote>
<p>Here's how you can define an array:</p>
<blockquote>
<p>ã“ã“ã«ã€é…åˆ—ã‚’å®šç¾©ã™ã‚‹æ–¹æ³•ã‚’ç¤ºã—ã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Array type syntax: [ &lt;type&gt; ; &lt;number of elements&gt; ]
let numbers: [u32; 3] = [1, 2, 3];
<span class="boring">}</span></code></pre></pre>
<p>This creates an array of 3 integers, initialized with the values <code>1</code>, <code>2</code>, and <code>3</code>.<br />
The type of the array is <code>[u32; 3]</code>, which reads as "an array of <code>u32</code>s with a length of 3".</p>
<blockquote>
<p>ã“ã‚Œã¯ã€3ã¤ã®æ•´æ•°ã®é…åˆ—ã‚’ä½œæˆã—ã¦ã€å€¤<code>1</code>ã€<code>2</code>ã€<code>3</code>ã§åˆæœŸåŒ–ã—ã¾ã™ã€‚
é…åˆ—ã®å‹ã¯<code>[u32; 3]</code>ã§ã€ãã‚Œã¯ã€Œ3ã®é•·ã•ã‚’æŒã¤<code>u32</code>ã®é…åˆ—ã€ã¨èª­ã¿ã¾ã™ã€‚</p>
</blockquote>
<h3 id="accessing-elementsè¦ç´ ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹"><a class="header" href="#accessing-elementsè¦ç´ ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹">Accessing elementsï¼ˆè¦ç´ ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ï¼‰</a></h3>
<p>You can access elements of an array using square brackets:</p>
<blockquote>
<p>è§’æ‹¬å¼§ã‚’ä½¿ç”¨ã—ã¦é…åˆ—ã®è¦ç´ ã«ã‚¢ã‚¯ã‚»ã‚¹ã§ãã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let first = numbers[0];
let second = numbers[1];
let third = numbers[2];
<span class="boring">}</span></code></pre></pre>
<p>The index must be of type <code>usize</code>.<br />
Arrays are <strong>zero-indexed</strong>, like everything in Rust. You've seen this before with string slices and field indexing in
tuples/tuple-like variants.</p>
<blockquote>
<p>ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã¯<code>usize</code>å‹ã§ãªãã¦ã¯ãªã‚Šã¾ã›ã‚“ã€‚
Rustã«ãŠã„ã¦ã™ã¹ã¦ã®ã‚‚ã®ã¨åŒæ§˜ã«ã€é…åˆ—ã¯<strong>ã‚¼ãƒ­ãƒ™ãƒ¼ã‚¹</strong>ã§ã™ã€‚
å‰ã®æ–‡å­—åˆ—ã‚¹ãƒ©ã‚¤ã‚¹ã¨ã€ã‚¿ãƒ—ãƒ«ï¼ã‚¿ãƒ—ãƒ«ã®ã‚ˆã†ãªãƒãƒªã‚¢ãƒ³ãƒˆã«ãŠã‘ã‚‹ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã§ã“ã‚Œã‚’ç¢ºèªã—ã¾ã—ãŸã€‚</p>
</blockquote>
<h3 id="out-of-bounds-accessç¯„å›²å¤–ã‚¢ã‚¯ã‚»ã‚¹"><a class="header" href="#out-of-bounds-accessç¯„å›²å¤–ã‚¢ã‚¯ã‚»ã‚¹">Out-of-bounds accessï¼ˆç¯„å›²å¤–ã‚¢ã‚¯ã‚»ã‚¹ï¼‰</a></h3>
<p>If you try to access an element that's out of bounds, Rust will panic:</p>
<blockquote>
<p>ç¯„å›²å¤–ã®è¦ç´ ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã“ã¨ã‚’è©¦ã¿ãŸå ´åˆã€Rustã¯ãƒ‘ãƒ‹ãƒƒã‚¯ã—ã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let numbers: [u32; 3] = [1, 2, 3];
let fourth = numbers[3]; // This will panic
                         // ã“ã‚Œã¯ãƒ‘ãƒ‹ãƒƒã‚¯ã—ã¾ã™ã€‚
<span class="boring">}</span></code></pre></pre>
<p>This is enforced at runtime using <strong>bounds checking</strong>. It comes with a small performance overhead, but it's how
Rust prevents buffer overflows.<br />
In some scenarios the Rust compiler can optimize away bounds checks, especially if iterators are involvedâ€”we'll speak
more about this later on.</p>
<blockquote>
<p>ã“ã‚Œã¯<strong>å¢ƒç•Œãƒã‚§ãƒƒã‚¯</strong>ã‚’ä½¿ç”¨ã—ã¦ãƒ©ãƒ³ã‚¿ã‚¤ãƒ ã§å¼·åˆ¶ã•ã‚Œã¾ã™ã€‚
ãã‚Œã¯å°ã•ãªæ€§èƒ½ã®ã‚ªãƒ¼ãƒãƒ¼ãƒ˜ãƒƒãƒ‰ã‚’ä¼´ã„ã¾ã™ãŒã€ãã‚Œã¯RustãŒãƒãƒƒãƒ•ã‚¡ãƒ¼ã‚ªãƒ¼ãƒãƒ¼ãƒ•ãƒ­ãƒ¼ã‚’é¿ã‘ã‚‹æ–¹æ³•ã§ã™ã€‚
ã„ãã¤ã‹ã®ã‚·ãƒŠãƒªã‚ªã«ãŠã„ã¦ã€ç‰¹ã«ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ãƒ¼ã‚’å«ã‚€å ´åˆã€Rustã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ¼ã¯å¢ƒç•Œãƒã‚§ãƒƒã‚¯ã‚’æœ€é©åŒ–ã§ãã¾ã™ã€‚
ã“ã®å¾Œã§è©³ã—ãèª¬æ˜ã—ã¾ã™ã€‚</p>
</blockquote>
<p>If you don't want to panic, you can use the <code>get</code> method, which returns an <code>Option&lt;&amp;T&gt;</code>:</p>
<blockquote>
<p>ãƒ‘ãƒ‹ãƒƒã‚¯ã—ãŸããªã„å ´åˆã¯ã€<code>Option&lt;&amp;T&gt;</code>ã‚’è¿”ã™<code>get</code>ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ç”¨ã§ãã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let numbers: [u32; 3] = [1, 2, 3];
assert_eq!(numbers.get(0), Some(&amp;1));
// You get a `None` if you try to access an out-of-bounds index
// rather than a panic.
// ç¯„å›²å¤–ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã«ã‚¢ã‚¯ã‚»ã‚¹ã‚’è©¦ã¿ãŸå ´åˆã€ãƒ‘ãƒ‹ãƒƒã‚¯ã™ã‚‹ã®ã§ã¯ãªãã€`None`ã‚’å¾—ã¾ã™ã€‚
assert_eq!(numbers.get(3), None);
<span class="boring">}</span></code></pre></pre>
<h3 id="performanceæ€§èƒ½-1"><a class="header" href="#performanceæ€§èƒ½-1">Performanceï¼ˆæ€§èƒ½ï¼‰</a></h3>
<p>Since the size of an array is known at compile-time, the compiler can allocate the array on the stack.
If you run the following code:</p>
<blockquote>
<p>é…åˆ—ã®ã‚µã‚¤ã‚ºã¯ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã«ã‚ã‹ã£ã¦ã„ã‚‹ãŸã‚ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ¼ã¯ã‚¹ã‚¿ãƒƒã‚¯ã«é…åˆ—ã‚’å‰²ã‚Šå½“ã¦ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚
æ¬¡ã®ã‚³ãƒ¼ãƒ‰ã‚’å®Ÿè¡Œã™ã‚‹ã¨ãƒ»ãƒ»ãƒ»</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let numbers: [u32; 3] = [1, 2, 3];
<span class="boring">}</span></code></pre></pre>
<p>You'll get the following memory layout:</p>
<blockquote>
<p>æ¬¡ã®ãƒ¡ãƒ¢ãƒªãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆãŒå¾—ã‚‰ã‚Œã¾ã™ã€‚</p>
</blockquote>
<pre><code class="language-text">        +---+---+---+
Stack:  | 1 | 2 | 3 |
        +---+---+---+
</code></pre>
<p>In other words, the size of an array is <code>std::mem::size_of::&lt;T&gt;() * N</code>, where <code>T</code> is the type of the elements and <code>N</code> is
the number of elements.<br />
You can access and replace each element in <code>O(1)</code> time.</p>
<blockquote>
<p>è¨€ã„æ›ãˆã‚‹ã¨ã€é…åˆ—ã®ã‚µã‚¤ã‚ºã¯<code>std::mem::size_of::&lt;T&gt;() * N</code>ã§ã‚ã‚Šã€<code>T</code>ã¯è¦ç´ ã®å‹ã§ã€<code>N</code>ã¯è¦ç´ ã®æ•°ã§ã™ã€‚
<code>O(1)</code>æ™‚é–“ã§ãã‚Œãã‚Œã®è¦ç´ ã«ã‚¢ã‚¯ã‚»ã‚¹ã¾ãŸã¯å…¥ã‚Œæ›¿ãˆã§ãã¾ã™ã€‚</p>
</blockquote>
<h2 id="exercise-58"><a class="header" href="#exercise-58">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/06_ticket_management/01_arrays"><code>06_ticket_management/01_arrays</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vectorsãƒ™ã‚¯ã‚¿ãƒ¼"><a class="header" href="#vectorsãƒ™ã‚¯ã‚¿ãƒ¼">Vectorsï¼ˆãƒ™ã‚¯ã‚¿ãƒ¼ï¼‰</a></h1>
<p>Arrays' strength is also their weakness: their size must be known upfront, at compile-time.
If you try to create an array with a size that's only known at runtime, you'll get a compilation error:</p>
<blockquote>
<p>é…åˆ—ã®å¼·ã¿ã¯ã€ãã‚Œã‚‰ã®å¼±ç‚¹ã§ã‚‚ã‚ã‚Šã¾ã™ã€‚ãã‚Œã‚‰ã®ã‚µã‚¤ã‚ºã¯ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã«å‰ã‚‚ã£ã¦ã‚ã‹ã£ã¦ã„ãªãã¦ã¯ãªã‚Šã¾ã›ã‚“ã€‚
ãƒ©ãƒ³ã‚¿ã‚¤ãƒ æ™‚ã—ã‹ã‚ã‹ã‚‰ãªã„ã‚µã‚¤ã‚ºã‚’æŒã¤é…åˆ—ã‚’ä½œæˆã™ã‚‹ã“ã¨ã‚’è©¦ã¿ãŸå ´åˆã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚¨ãƒ©ãƒ¼ã‚’å¾—ã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let n = 10;
let numbers: [u32; n];
<span class="boring">}</span></code></pre></pre>
<pre><code class="language-text">error[E0435]: attempt to use a non-constant value in a constant
 --&gt; src/main.rs:3:20
  |
2 | let n = 10;
3 | let numbers: [u32; n];
  |                    ^ non-constant value
</code></pre>
<p>Arrays wouldn't work for our ticket management systemâ€”we don't know how many tickets we'll need to store at compile-time.
This is where <code>Vec</code> comes in.</p>
<blockquote>
<p>é…åˆ—ã¯ã€ãƒã‚±ãƒƒãƒˆç®¡ç†ã‚·ã‚¹ãƒ†ãƒ ã«ã¯é©ã—ã¦ã„ã¾ã›ã‚“ã€‚
ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã«ä¿å­˜ã™ã‚‹å¿…è¦ã®ã‚ã‚‹ãƒã‚±ãƒƒãƒˆã®æ•°ã‚’çŸ¥ã‚‹ã“ã¨ãŒã§ãã¾ã›ã‚“ã€‚
ã“ã“ã§<code>Vec</code>ãŒç™»å ´ã—ã¾ã™ã€‚</p>
</blockquote>
<h2 id="vec"><a class="header" href="#vec"><code>Vec</code></a></h2>
<p><code>Vec</code> is a growable array type, provided by the standard library.<br />
You can create an empty array using the <code>Vec::new</code> function:</p>
<blockquote>
<p><code>Vec</code>ã¯æˆé•·ã™ã‚‹é…åˆ—å‹ã§ã€æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã§æä¾›ã•ã‚Œã¦ã„ã¾ã™ã€‚
<code>Vec::new</code>é–¢æ•°ã‚’ä½¿ç”¨ã—ã¦ç©ºã®é…åˆ—ã‚’ä½œæˆã§ãã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut numbers: Vec&lt;u32&gt; = Vec::new();
<span class="boring">}</span></code></pre></pre>
<p>You would then push elements into the vector using the <code>push</code> method:</p>
<blockquote>
<p>ãã®å¾Œã€<code>push</code>ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ç”¨ã—ã¦ãƒ™ã‚¯ã‚¿ãƒ¼å†…ã«è¦ç´ ã‚’è¿½åŠ ã—ã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>numbers.push(1);
numbers.push(2);
numbers.push(3);
<span class="boring">}</span></code></pre></pre>
<p>New values are added to the end of the vector.<br />
You can also create an initialized vector using the <code>vec!</code> macro, if you know the values at creation time:</p>
<blockquote>
<p>æ–°ã—ã„å€¤ã¯ãƒ™ã‚¯ã‚¿ãƒ¼ã®æœ«å°¾ã«è¿½åŠ ã•ã‚Œã¾ã™ã€‚
ä½œæˆæ™‚ã«å€¤ãŒã‚ã‹ã£ã¦ã„ã‚‹å ´åˆã€<code>vec!</code>ãƒã‚¯ãƒ­ã‚’ä½¿ç”¨ã—ã¦åˆæœŸåŒ–ã•ã‚ŒãŸãƒ™ã‚¯ã‚¿ãƒ¼ã‚’ä½œæˆã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let numbers = vec![1, 2, 3];
<span class="boring">}</span></code></pre></pre>
<h2 id="accessing-elementsè¦ç´ ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹-1"><a class="header" href="#accessing-elementsè¦ç´ ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹-1">Accessing elementsï¼ˆè¦ç´ ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ï¼‰</a></h2>
<p>The syntax for accessing elements is the same as with arrays:</p>
<blockquote>
<p>è¦ç´ ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹æ§‹æ–‡ã¯ã€é…åˆ—ã¨åŒã˜ã§ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let numbers = vec![1, 2, 3];
let first = numbers[0];
let second = numbers[1];
let third = numbers[2];
<span class="boring">}</span></code></pre></pre>
<p>The index must be of type <code>usize</code>.<br />
You can also use the <code>get</code> method, which returns an <code>Option&lt;&amp;T&gt;</code>:</p>
<blockquote>
<p>ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã¯<code>usize</code>å‹ã§ãªãã¦ã¯ãªã‚Šã¾ã›ã‚“ã€‚
<code>Option&lt;&amp;T&gt;</code>ã‚’è¿”ã™<code>get</code>ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let numbers = vec![1, 2, 3];
assert_eq!(numbers.get(0), Some(&amp;1));
// You get a `None` if you try to access an out-of-bounds index
// rather than a panic.
assert_eq!(numbers.get(3), None);
<span class="boring">}</span></code></pre></pre>
<p>Access is bounds-checked, just like element access with arrays. It has O(1) complexity.</p>
<blockquote>
<p>ã‚¢ã‚¯ã‚»ã‚¹ã¯å¢ƒç•Œãƒã‚§ãƒƒã‚¯ã•ã‚Œã€ã¡ã‚‡ã†ã©é…åˆ—ã®è¦ç´ ã‚¢ã‚¯ã‚»ã‚¹ã¨åŒã˜ã§ã™ã€‚
ãã‚Œã¯ã€O(1)ã®è¤‡é›‘ã•ãŒã‚ã‚Šã¾ã™ã€‚</p>
</blockquote>
<h2 id="memory-layoutãƒ¡ãƒ¢ãƒªãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ-2"><a class="header" href="#memory-layoutãƒ¡ãƒ¢ãƒªãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ-2">Memory layoutï¼ˆãƒ¡ãƒ¢ãƒªãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆï¼‰</a></h2>
<p><code>Vec</code> is a heap-allocated data structure.<br />
When you create a <code>Vec</code>, it allocates memory on the heap to store the elements.</p>
<blockquote>
<p><code>Vec</code>ã¯ãƒ’ãƒ¼ãƒ—ã«å‰²ã‚Šå½“ã¦ã‚‰ã‚ŒãŸãƒ‡ãƒ¼ã‚¿æ§‹é€ ã§ã™ã€‚
<code>Vec</code>ã‚’ä½œæˆã™ã‚‹ã¨ãã€ãã‚Œã¯è¦ç´ ã‚’ä¿å­˜ã™ã‚‹ãŸã‚ã«ãƒ’ãƒ¼ãƒ—ã«ãƒ¡ãƒ¢ãƒªã‚’å‰²ã‚Šå½“ã¦ã¾ã™ã€‚</p>
</blockquote>
<p>If you run the following code:</p>
<blockquote>
<p>æ¬¡ã®ã‚³ãƒ¼ãƒ‰ã‚’å®Ÿè¡Œã—ãŸå ´åˆãƒ»ãƒ»ãƒ»</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut numbers = Vec::with_capacity(3);
numbers.push(1);
numbers.push(2);
<span class="boring">}</span></code></pre></pre>
<p>you'll get the following memory layout:</p>
<blockquote>
<p>æ¬¡ã®ãƒ¡ãƒ¢ãƒªãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã‚’å¾—ã¾ã™ã€‚</p>
</blockquote>
<pre><code class="language-text">      +---------+--------+----------+
Stack | pointer | length | capacity |
      |  |      |   2    |    3     |
      +--|------+--------+----------+
         |
         |
         v
       +---+---+---+
Heap:  | 1 | 2 | ? |
       +---+---+---+
</code></pre>
<p><code>Vec</code> keeps track of three things:</p>
<ul>
<li>The <strong>pointer</strong> to the heap region you reserved.</li>
<li>The <strong>length</strong> of the vector, i.e. how many elements are in the vector.</li>
<li>The <strong>capacity</strong> of the vector, i.e. the number of elements that can fit in the space reserved on the heap.</li>
</ul>
<blockquote>
<p><code>Vec</code>ã¯æ¬¡ã®3ã¤ã‚’è¿½è·¡ã—ã¾ã™ã€‚</p>
<ul>
<li>äºˆç´„ã—ãŸãƒ’ãƒ¼ãƒ—é ˜åŸŸã¸ã®<strong>ãƒã‚¤ãƒ³ã‚¿ãƒ¼</strong></li>
<li>ä¾‹ãˆã°ãƒ™ã‚¯ã‚¿ãƒ¼å†…ã«ã‚ã‚‹è¦ç´ ã®æ•°ã§ã‚ã‚‹ã€ãƒ™ã‚¯ã‚¿ãƒ¼ã®<strong>é•·ã•</strong></li>
<li>ä¾‹ãˆã°ãƒ’ãƒ¼ãƒ—ã«äºˆç´„ã•ã‚ŒãŸé ˜åŸŸã«åã‚ã‚‰ã‚Œã‚‹è¦ç´ ã®æ•°ã§ã‚ã‚‹ã€ãƒ™ã‚¯ã‚¿ãƒ¼ã®<strong>å®¹é‡</strong></li>
</ul>
</blockquote>
<p>This layout should look familiar: it's exactly the same as <code>String</code>!<br />
That's not a coincidence: <code>String</code> is defined as a vector of bytes, <code>Vec&lt;u8&gt;</code>, under the hood:</p>
<blockquote>
<p>ã“ã®ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã¯æ…£ã‚Œã¦ã„ã‚‹ã¯ãšã§ã™ã€‚ãã‚Œã¯<code>String</code>ã¨æ­£ç¢ºã«åŒã˜ã§ã™ã€‚
ã“ã‚Œã¯å¶ç„¶ã®ä¸€è‡´ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚<code>String</code>ã¯ã€å†…éƒ¨çš„ã«ãƒã‚¤ãƒˆã®ãƒ™ã‚¯ã‚¿ãƒ¼ã§ã‚ã‚‹<code>Vec&lt;u8&gt;</code>ã¨ã—ã¦å®šç¾©ã•ã‚Œã¦ã„ã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct String {
    vec: Vec&lt;u8&gt;,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="exercise-59"><a class="header" href="#exercise-59">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/06_ticket_management/02_vec"><code>06_ticket_management/02_vec</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="resizingãƒªã‚µã‚¤ã‚º"><a class="header" href="#resizingãƒªã‚µã‚¤ã‚º">Resizingï¼ˆãƒªã‚µã‚¤ã‚ºï¼‰</a></h1>
<p>We said that <code>Vec</code> is a "growable" vector type, but what does that mean?
What happens if you try to insert an element into a <code>Vec</code> that's already at maximum capacity?</p>
<blockquote>
<p><code>Vec</code>ãŒã€Œæˆé•·å¯èƒ½ãªã€ãƒ™ã‚¯ã‚¿ãƒ¼å‹ã§ã‚ã‚‹ã¨è¨€ã„ã¾ã—ãŸãŒã€ãã‚Œã¯ä½•ã‚’æ„å‘³ã™ã‚‹ã®ã§ã—ã‚‡ã†ã‹ï¼Ÿ
ã™ã§ã«æœ€å¤§å®¹é‡ã«ãªã£ã¦ã„ã‚‹<code>Vec</code>ã«è¦ç´ ã‚’æŒ¿å…¥ã™ã‚‹ã“ã¨ã‚’è©¦ã¿ãŸå ´åˆã€ä½•ãŒèµ·ã“ã‚‹ã®ã§ã—ã‚‡ã†ã‹ï¼Ÿ</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut numbers = Vec::with_capacity(3);
numbers.push(1);
numbers.push(2);
numbers.push(3); // Max capacity reachedï¼ˆæœ€å¤§å®¹é‡ã«é”ã—ãŸï¼‰
numbers.push(4); // What happens here?ï¼ˆã“ã“ã§ä½•ãŒèµ·ã“ã‚‹ã®ã‹ï¼Ÿï¼‰
<span class="boring">}</span></code></pre></pre>
<p>The <code>Vec</code> will <strong>resize</strong> itself.<br />
It will ask the allocator for a new (larger) chunk of heap memory, copy the elements over, and deallocate the old memory.</p>
<blockquote>
<p><code>Vec</code>ã¯è‡ªåˆ†è‡ªèº«ã§<strong>ãƒªã‚µã‚¤ã‚º</strong>ã—ã¾ã™ã€‚
ãƒ’ãƒ¼ãƒ—ãƒ¡ãƒ¢ãƒªã®æ–°ã—ãå¤§ããªå¡Šã‚’ã‚¢ãƒ­ã‚±ãƒ¼ã‚¿ãƒ¼ã«è¦æ±‚ã—ã¦ã€è¦ç´ ã‚’ã‚³ãƒ”ãƒ¼ã—ã¦ã€å¤ã„ãƒ¡ãƒ¢ãƒªã‚’è§£æ”¾ã—ã¾ã™ã€‚</p>
</blockquote>
<p>This operation can be expensive, as it involves a new memory allocation and copying all existing elements.</p>
<blockquote>
<p>æ–°ã—ã„å‰²ã‚Šå½“ã¦ã¨ã€æ—¢å­˜ã®è¦ç´ ã®ã™ã¹ã¦ã®ã‚³ãƒ”ãƒ¼ã‚’å·»ãè¾¼ã‚€ãŸã‚ã€ã“ã®æ“ä½œã¯ã‚³ã‚¹ãƒˆãŒé«˜ããªã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚</p>
</blockquote>
<h2 id="vecwith_capacity"><a class="header" href="#vecwith_capacity"><code>Vec::with_capacity</code></a></h2>
<p>If you have a rough idea of how many elements you'll store in a <code>Vec</code>, you can use the <code>Vec::with_capacity</code>
method to pre-allocate enough memory upfront.<br />
This can avoid a new allocation when the <code>Vec</code> grows, but it may waste memory if you overestimate actual usage.</p>
<blockquote>
<p><code>Vec</code>ã«ä¿å­˜ã™ã‚‹è¦ç´ ã®ãŠãŠã‚ˆãã®æ•°ãŒã‚ã‹ã£ã¦ã„ã‚‹å ´åˆã€å‰ã‚‚ã£ã¦ååˆ†ãªãƒ¡ãƒ¢ãƒªã‚’äº‹å‰å‰²ã‚Šå½“ã¦ã™ã‚‹ãŸã‚ã«<code>Vec::with_capacity</code>ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ç”¨ã§ãã¾ã™ã€‚
ã“ã‚Œã¯ã€<code>Vec</code>ãŒæˆé•·ã—ãŸã¨ãæ–°ã—ã„å‰²ã‚Šå½“ã¦ã‚’é¿ã‘ã‚‹ã“ã¨ãŒã§ãã¾ã™ãŒã€å®Ÿéš›ã®ä½¿ç”¨é‡ã‚’éå¤§è©•ä¾¡ã—ãŸå ´åˆã€ãƒ¡ãƒ¢ãƒªã‚’æµªè²»ã™ã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚</p>
</blockquote>
<p>Evaluate on a case-by-case basis.</p>
<blockquote>
<p>ã‚±ãƒ¼ã‚¹ã«ã‚ˆã£ã¦è©•ä¾¡ã™ã‚‹ã“ã¨ãŒåŸºæœ¬ã§ã™ã€‚</p>
</blockquote>
<h2 id="exercise-60"><a class="header" href="#exercise-60">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/06_ticket_management/03_resizing"><code>06_ticket_management/03_resizing</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iterationåå¾©æ“ä½œ"><a class="header" href="#iterationåå¾©æ“ä½œ">Iterationï¼ˆåå¾©æ“ä½œï¼‰</a></h1>
<p>During the very first exercises, you learned that Rust lets you iterate over collections using <code>for</code> loops.
We were looking at ranges at that point (e.g. <code>0..5</code>), but the same holds true for collections like arrays and vectors.</p>
<blockquote>
<p>ã¨ã¦ã‚‚å‰ã®æ–¹ã®æ¼”ç¿’ã®é–“ã€RustãŒ<code>for</code>ãƒ«ãƒ¼ãƒ—ã‚’ä½¿ç”¨ã—ã¦ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã‚’åå¾©æ“ä½œã•ã›ã‚‹ã“ã¨ã‚’å­¦ã³ã¾ã—ãŸã€‚
ãã®æ™‚ã€ä¾‹ãˆã°<code>0..5</code>ã®ã‚ˆã†ãªç¯„å›²ã‚’ç¢ºèªã—ã¾ã—ãŸãŒã€é…åˆ—ã‚„ãƒ™ã‚¯ã‚¿ãƒ¼ã®ã‚ˆã†ãªã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã«ã¤ã„ã¦ã‚‚åŒã˜ã“ã¨ãŒå½“ã¦ã¯ã¾ã‚Šã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// It works for `Vec`s
// ãã‚Œã¯`Vec`ã§æ©Ÿèƒ½ã—ã¾ã™ã€‚
let v = vec![1, 2, 3];
for n in v {
    println!("{}", n);
}

// It also works for arrays
// ãã‚Œã¯é…åˆ—ã§ã‚‚æ©Ÿèƒ½ã—ã¾ã™ã€‚
let a: [u32; 3] = [1, 2, 3];
for n in a {
    println!("{}", n);
}
<span class="boring">}</span></code></pre></pre>
<p>It's time to understand how this works under the hood.</p>
<blockquote>
<p>ç¾åœ¨ã€å†…éƒ¨ã§ã“ã‚ŒãŒæ©Ÿèƒ½ã™ã‚‹æ–¹æ³•ã‚’ç†è§£ã™ã‚‹æ™‚é–“ã§ã™ã€‚</p>
</blockquote>
<h2 id="for-desugaringforã®è„±ç³–"><a class="header" href="#for-desugaringforã®è„±ç³–"><code>for</code> desugaringï¼ˆforã®è„±ç³–ï¼‰</a></h2>
<p>Every time you write a <code>for</code> loop in Rust, the compiler <em>desugars</em> it into the following code:</p>
<blockquote>
<p>Rustã§<code>for</code>ãƒ«ãƒ¼ãƒ—ã‚’è¨˜è¿°ã™ã‚‹ãŸã³ã«ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ¼ã¯ãã‚Œã‚’æ¬¡ã®ã‚³ãƒ¼ãƒ‰ã«ã€Œè„±ç³–ã€ã—ã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut iter = IntoIterator::into_iter(v);
loop {
    match iter.next() {
        Some(n) =&gt; {
            println!("{}", n);
        }
        None =&gt; break,
    }
}
<span class="boring">}</span></code></pre></pre>
<p><code>loop</code> is another looping construct, on top of <code>for</code> and <code>while</code>.<br />
A <code>loop</code> block will run forever, unless you explicitly <code>break</code> out of it.</p>
<blockquote>
<p><code>loop</code>ã¯<code>for</code>ã¨<code>while</code>ã®ä¸Šã«ã‚ã‚‹åˆ¥ã®ãƒ«ãƒ¼ãƒ—æ§‹é€ ã§ã™ã€‚
<code>loop</code>ãƒ–ãƒ­ãƒƒã‚¯ã¯ã€ãã‚Œã‚’æ˜ç¤ºçš„ã«<code>break</code>ã™ã‚‹ã¾ã§ã€æ°¸é ã«å®Ÿè¡Œã•ã‚Œã¾ã™ã€‚</p>
</blockquote>
<h2 id="iterator-traititeratorãƒˆãƒ¬ã‚¤ãƒˆ"><a class="header" href="#iterator-traititeratorãƒˆãƒ¬ã‚¤ãƒˆ"><code>Iterator</code> traitï¼ˆIteratorãƒˆãƒ¬ã‚¤ãƒˆï¼‰</a></h2>
<p>The <code>next</code> method in the previous code snippet comes from the <code>Iterator</code> trait.
The <code>Iterator</code> trait is defined in Rust's standard library and provides a shared interface for
types that can produce a sequence of values:</p>
<blockquote>
<p>å‰ã®ã‚³ãƒ¼ãƒ‰ã‚¹ãƒ‹ãƒšãƒƒãƒˆã®<code>next</code>ãƒ¡ã‚½ãƒƒãƒ‰ã¯<code>Iterator</code>ãƒˆãƒ¬ã‚¤ãƒˆã‹ã‚‰ç”±æ¥ã—ã¾ã™ã€‚
<code>Iterator</code>ãƒˆãƒ¬ã‚¤ãƒˆã¯Rustæ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã«å®šç¾©ã•ã‚Œã€å€¤ã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚’ç”Ÿæˆã§ãã‚‹å‹ã«å¯¾ã—ã¦å…±æœ‰ã•ã‚ŒãŸã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ã‚¤ã‚¹ã‚’æä¾›ã—ã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Iterator {
    type Item;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>Item</code> associated type specifies the type of the values produced by the iterator.</p>
<blockquote>
<p><code>Item</code>é–¢é€£å‹ã¯ã€ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ãƒ¼ã«ã‚ˆã£ã¦ç”Ÿæˆã•ã‚Œã‚‹å€¤ã®å‹ã‚’æŒ‡å®šã—ã¾ã™ã€‚</p>
</blockquote>
<p><code>next</code> returns the next value in the sequence.<br />
It returns <code>Some(value)</code> if there's a value to return, and <code>None</code> when there isn't.</p>
<blockquote>
<p><code>next</code>ã¯ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®æ¬¡ã®å€¤ã‚’è¿”ã—ã¾ã™ã€‚
å€¤ãŒå­˜åœ¨ã™ã‚‹å ´åˆã«ãã‚Œã¯<code>Some(value)</code>ã‚’è¿”ã—ã€å­˜åœ¨ã—ãªã„å ´åˆã¯<code>None</code>ã‚’è¿”ã—ã¾ã™ã€‚</p>
</blockquote>
<p>Be careful: there is no guarantee that an iterator is exhausted when it returns <code>None</code>. That's only
guaranteed if the iterator implements the (more restrictive)
<a href="https://doc.rust-lang.org/std/iter/trait.FusedIterator.html"><code>FusedIterator</code></a> trait.</p>
<blockquote>
<p>ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ãƒ¼ãŒ<code>None</code>ã‚’è¿”ã—ãŸã¨ãã€ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ãƒ¼ãŒä½¿ã„æœãŸã•ã‚ŒãŸã“ã¨ã‚’ä¿è¨¼ã—ãªã„ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚
ãã‚Œã¯ã€ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ãƒ¼ãŒã‚ˆã‚Šåˆ¶é™ã•ã‚ŒãŸ<code>FusedIterator</code>ãƒˆãƒ¬ã‚¤ãƒˆã‚’å®Ÿè£…ã—ã¦ã„ã‚‹å ´åˆã®ã¿ä¿è¨¼ã•ã‚Œã¾ã™ã€‚</p>
</blockquote>
<h2 id="intoiterator-traitintoiteratorãƒˆãƒ¬ã‚¤ãƒˆ"><a class="header" href="#intoiterator-traitintoiteratorãƒˆãƒ¬ã‚¤ãƒˆ"><code>IntoIterator</code> traitï¼ˆIntoIteratorãƒˆãƒ¬ã‚¤ãƒˆï¼‰</a></h2>
<p>Not all types implement <code>Iterator</code>, but many can be converted into a type that does.<br />
That's where the <code>IntoIterator</code> trait comes in:</p>
<blockquote>
<p>ã™ã¹ã¦ã®å‹ãŒ<code>Iterator</code>ã‚’å®Ÿè£…ã—ã¦ã„ã‚‹ã‚ã‘ã§ã¯ã‚ã‚Šã¾ã›ã‚“ãŒã€å¤šãã¯ãã®å‹ã«å¤‰æ›ã§ãã¾ã™ã€‚
ã“ã“ã§<code>IntoIterator</code>ãƒˆãƒ¬ã‚¤ãƒˆãŒç™»å ´ã—ã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait IntoIterator {
    type Item;
    type IntoIter: Iterator&lt;Item = Self::Item&gt;;
    fn into_iter(self) -&gt; Self::IntoIter;
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>into_iter</code> method consumes the original value and returns an iterator over its elements.<br />
A type can only have one implementation of <code>IntoIterator</code>: there can be no ambiguity as to what <code>for</code> should desugar to.</p>
<blockquote>
<p><code>into_iter</code>ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ã‚ªãƒªã‚¸ãƒŠãƒ«ã®å€¤ã‚’æ¶ˆè²»ã—ã¦ã€ãã®è¦ç´ ã®ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ãƒ¼ã‚’è¿”ã—ã¾ã™ã€‚
å‹ã¯<code>IntoIterator</code>ã®å®Ÿè£…ã‚’1ã¤ã ã‘æŒã¤ã“ã¨ãŒã§ãã€<code>for</code>ãŒã©ã®ã‚ˆã†ã«è„±ç³–ã•ã‚Œã‚‹ã¹ãã‹ã«ã¤ã„ã¦ã®æ›–æ˜§ã•ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚</p>
</blockquote>
<p>One detail: every type that implements <code>Iterator</code> automatically implements <code>IntoIterator</code> as well.
They just return themselves from <code>into_iter</code>!</p>
<blockquote>
<p>1ã¤ã®è©³ç´°: <code>Iterator</code>ã‚’å®Ÿè£…ã™ã‚‹ã™ã¹ã¦ã®å‹ã¯ã€è‡ªå‹•çš„ã«<code>IntoIterator</code>ã‚‚åŒæ§˜ã«å®Ÿè£…ã—ã¾ã™ã€‚
ãã‚Œã‚‰ã¯å˜ã«ã€<code>into_iter</code>ã‹ã‚‰è¿”ã•ã‚ŒãŸãã‚Œã‚‰è‡ªèº«ã‚’è¿”ã—ã¾ã™ã€‚</p>
</blockquote>
<h2 id="bounds-checkså¢ƒç•Œãƒã‚§ãƒƒã‚¯"><a class="header" href="#bounds-checkså¢ƒç•Œãƒã‚§ãƒƒã‚¯">Bounds checksï¼ˆå¢ƒç•Œãƒã‚§ãƒƒã‚¯ï¼‰</a></h2>
<p>Iterating over iterators has a nice side effect: you can't go out of bounds, by design.<br />
This allows Rust to remove bounds checks from the generated machine code, making iteration faster.</p>
<blockquote>
<p>ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ãƒ¼ã®åå¾©æ“ä½œã¯ã€è‰¯ã„å‰¯ä½œç”¨ãŒã‚ã‚Šã¾ã™ã€‚è¨­è¨ˆä¸Šã€å¢ƒç•Œã‚’è¶…ãˆã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚
ã“ã‚Œã¯ã€Rustã«ç”Ÿæˆã•ã‚ŒãŸæ©Ÿæ¢°èªã‹ã‚‰å¢ƒç•Œãƒã‚§ãƒƒã‚¯ã‚’å‰Šé™¤ã™ã‚‹ã“ã¨ã‚’è¨±å¯ã™ã‚‹ãŸã‚ã€åå¾©æ“ä½œã‚’é«˜é€Ÿã«ã—ã¾ã™ã€‚</p>
</blockquote>
<p>In other words,</p>
<blockquote>
<p>è¨€ã„æ›ãˆã‚Œã°ãƒ»ãƒ»ãƒ»</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = vec![1, 2, 3];
for n in v {
    println!("{}", n);
}
<span class="boring">}</span></code></pre></pre>
<p>is usually faster than</p>
<blockquote>
<p>é€šå¸¸ã€ä¸Šè¨˜ã¯æ¬¡ã‚ˆã‚Šã‚‚æ—©ã„ã§ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = vec![1, 2, 3];
for i in 0..v.len() {
    println!("{}", v[i]);
}
<span class="boring">}</span></code></pre></pre>
<p>There are exceptions to this rule: the compiler can sometimes prove that you're not going out of bounds even
with manual indexing, thus removing the bounds checks anyway. But in general, prefer iteration to indexing
where possible.</p>
<blockquote>
<p>ã“ã®ãƒ«ãƒ¼ãƒ«ã«ã¯ä¾‹å¤–ãŒã‚ã‚Šã¾ã™ã€‚
æ™‚ã€…ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ¼ã¯ã€æ‰‹å‹•ã§ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã§æŒ‡å®šã—ã¦ã‚‚å¢ƒç•Œã‚’è¶Šãˆã¦ã„ãªã„ã“ã¨ã‚’è¨¼æ˜ã§ãã‚‹ãŸã‚ã€ãã®å ´åˆã¯å¢ƒç•Œãƒã‚§ãƒƒã‚¯ãŒå‰Šé™¤ã•ã‚Œã¾ã™ã€‚
ãŸã ã—ã€å¯èƒ½ã§ã‚ã‚Œã°ã€ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚ˆã‚Šã‚‚åå¾©å‡¦ç†ã‚’å„ªå…ˆã—ã¦ãã ã•ã„ã€‚</p>
</blockquote>
<h2 id="exercise-61"><a class="header" href="#exercise-61">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/06_ticket_management/04_iterators"><code>06_ticket_management/04_iterators</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iter"><a class="header" href="#iter"><code>.iter()</code></a></h1>
<p><code>IntoIterator</code> <strong>consumes</strong> <code>self</code> to create an iterator.</p>
<blockquote>
<p><code>IntoIterator</code>ã¯ã€ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ãƒ¼ã‚’ä½œæˆã™ã‚‹ãŸã‚ã«<code>self</code>ã‚’<strong>æ¶ˆè²»</strong>ã—ã¾ã™ã€‚</p>
</blockquote>
<p>This has its benefits: you get <strong>owned</strong> values from the iterator.
For example: if you call <code>.into_iter()</code> on a <code>Vec&lt;Ticket&gt;</code> you'll get an iterator that returns <code>Ticket</code> values.</p>
<blockquote>
<p>ã“ã‚Œã«ã¯åˆ©ç‚¹ãŒã‚ã‚Šã¾ã™ã€‚ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ãƒ¼ã‹ã‚‰å€¤ã‚’<strong>æ‰€æœ‰</strong>ã§ãã‚‹ã“ã¨ã§ã™ã€‚
ä¾‹ãˆã°ã€<code>Vec&lt;Ticket&gt;</code>ã«<code>.into_iter()</code>ã‚’å‘¼ã³å‡ºã—ãŸå ´åˆã€<code>Ticket</code>å€¤ã‚’è¿”ã™ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ãƒ¼ã‚’å¾—ã‚‰ã‚Œã¾ã™ã€‚</p>
</blockquote>
<p>That's also its downside: you can no longer use the original collection after calling <code>.into_iter()</code> on it.
Quite often you want to iterate over a collection without consuming it, looking at <strong>references</strong> to the values instead.
In the case of <code>Vec&lt;Ticket&gt;</code>, you'd want to iterate over <code>&amp;Ticket</code> values.</p>
<blockquote>
<p>ã¾ãŸã“ã‚Œã«ã¯æ¬ ç‚¹ãŒã‚ã‚Šã¾ã™ã€‚ãã‚Œã«<code>.into_iter()</code>ã‚’å‘¼ã³å‡ºã—ãŸå¾Œã€ã‚‚ã¯ã‚„ã‚ªãƒªã‚¸ãƒŠãƒ«ã®ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã‚’ä½¿ç”¨ã§ããªããªã‚‹ã“ã¨ã§ã™ã€‚
ã‹ãªã‚Šã®é »åº¦ã§ã€ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã‚’æ¶ˆè²»ã™ã‚‹ã“ã¨ãªãã€ä»£ã‚ã‚Šã«å€¤ã®<strong>å‚ç…§</strong>ã‚’ç¢ºèªã™ã‚‹ãŸã‚ã«ã€ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã‚’åå¾©æ“ä½œã—ã¦ã„ã¨ããŒã‚ã‚Šã¾ã™ã€‚
<code>Vec&lt;Ticket&gt;</code>ã®å ´åˆã€<code>&amp;Ticket</code>å€¤ã‚’åå¾©æ“ä½œã—ãŸã„ã¨æ€ã„ã¾ã™ã€‚</p>
</blockquote>
<p>Most collections expose a method called <code>.iter()</code> that returns an iterator over references to the collection's elements.
For example:</p>
<blockquote>
<p>ã»ã¨ã‚“ã©ã®ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã¯ã€ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã®è¦ç´ ã¸ã®å‚ç…§ã‚’è¿”ã™ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ãƒ¼ã‚’è¿”ã™<code>.iter()</code>ã¨å‘¼ã°ã‚Œã‚‹ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å…¬é–‹ã—ã¦ã„ã¾ã™ã€‚
ä¾‹ãˆã°ãƒ»ãƒ»ãƒ»</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let numbers: Vec&lt;u32&gt; = vec![1, 2];
// `n` has type `&amp;u32` here
for n in numbers.iter() {
    // [...]
}
<span class="boring">}</span></code></pre></pre>
<p>This pattern can be simplified by implementing <code>IntoIterator</code> for a <strong>reference to the collection</strong>.
In our example above, that would be <code>&amp;Vec&lt;Ticket&gt;</code>.<br />
The standard library does this, that's why the following code works:</p>
<blockquote>
<p>ã“ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã¯ã€<strong>ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã¸ã®å‚ç…§</strong>ã«å¯¾ã—ã¦ã€<code>IntoIterator</code>ã‚’å®Ÿè£…ã™ã‚‹ã“ã¨ã§ç°¡ç•¥åŒ–ã§ãã¾ã™ã€‚
ä¸Šè¨˜ä¾‹ã«ãŠã„ã¦ã€ãã‚Œã¯<code>&amp;Vec&lt;Ticket&gt;</code>ã§ã™ã€‚
æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã¯ã“ã‚Œã‚’è¡Œã†ãŸã‚ã€æ¬¡ã®ã‚³ãƒ¼ãƒ‰ã¯æ©Ÿèƒ½ã—ã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let numbers: Vec&lt;u32&gt; = vec![1, 2];
// `n` has type `&amp;u32` here
// We didn't have to call `.iter()` explicitly
// It was enough to use `&amp;numbers` in the `for` loop
// ã“ã“ã§`n`ã¯`&amp;u32`å‹ã§ã™ã€‚
// æ˜ç¤ºçš„ã«`.iter()`ã‚’å‘¼ã³å‡ºã™å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚
// ãã‚Œã¯`for`ãƒ«ãƒ¼ãƒ—ã§`&amp;numbers`ã‚’ä½¿ç”¨ã™ã‚‹ã ã‘ã§ååˆ†ã§ã—ãŸã€‚
for n in &amp;numbers {
    // [...]
}
<span class="boring">}</span></code></pre></pre>
<p>It's idiomatic to provide both options:</p>
<ul>
<li>An implementation of <code>IntoIterator</code> for a reference to the collection.</li>
<li>An <code>.iter()</code> method that returns an iterator over references to the collection's elements.</li>
</ul>
<blockquote>
<p>ãã‚Œã¯æ¬¡ã®ä¸¡æ–¹ã®é¸æŠè‚¢ã‚’æä¾›ã™ã‚‹ã“ã¨ã¯æ…£ç”¨çš„ã§ã™ã€‚</p>
<ul>
<li>ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã¸ã®å‚ç…§ã«å¯¾ã™ã‚‹<code>IntoIterator</code>ã®å®Ÿè£…</li>
<li>ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã®è¦ç´ ã¸ã®å‚ç…§ã«å¯¾ã™ã‚‹ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ãƒ¼ã‚’è¿”ã™<code>.iter()</code>ãƒ¡ã‚½ãƒƒãƒ‰</li>
</ul>
</blockquote>
<p>The former is convenient in <code>for</code> loops, the latter is more explicit and can be used in other contexts.</p>
<blockquote>
<p>å‰è€…ã¯<code>for</code>ãƒ«ãƒ¼ãƒ—ã§ä¾¿åˆ©ã§ã€å¾Œè€…ã¯ã‚ˆã‚Šæ˜ç¤ºçš„ã«ä»–ã®æ–‡è„ˆã§ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚</p>
</blockquote>
<h2 id="exercise-62"><a class="header" href="#exercise-62">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/06_ticket_management/05_iter"><code>06_ticket_management/05_iter</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lifetimesãƒ©ã‚¤ãƒ–ã‚¿ã‚¤ãƒ "><a class="header" href="#lifetimesãƒ©ã‚¤ãƒ–ã‚¿ã‚¤ãƒ ">Lifetimesï¼ˆãƒ©ã‚¤ãƒ–ã‚¿ã‚¤ãƒ ï¼‰</a></h1>
<p>Let's try to complete the previous exercise by adding an implementation of <code>IntoIterator</code> for <code>&amp;TicketStore</code>, for
maximum convenience in <code>for</code> loops.</p>
<blockquote>
<p><code>for</code>ãƒ«ãƒ¼ãƒ—ã‚’æœ€å¤§é™ã«ä¾¿åˆ©ã«ã™ã‚‹ãŸã‚ã«ã€<code>&amp;TicketStore</code>ã«å¯¾ã—ã¦<code>IntoIterator</code>ã®å®Ÿè£…ã‚’è¿½åŠ ã—ã¦ã€å‰ã®æ¼”ç¿’ã‚’å®Œæˆã™ã‚‹ã“ã¨ã‚’è©¦ã¿ã¾ã—ã‚‡ã†ã€‚</p>
</blockquote>
<p>Let's start by filling in the most "obvious" parts of the implementation:</p>
<blockquote>
<p>å®Ÿè£…ã®æœ€ã‚‚ã€Œæ˜ç¢ºãªã€éƒ¨åˆ†ã‚’åŸ‹ã‚ã‚‹ã“ã¨ã‹ã‚‰å§‹ã‚ã¾ã—ã‚‡ã†ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl IntoIterator for &amp;TicketStore {
    type Item = &amp;Ticket;
    type IntoIter = // What goes here?

    fn into_iter(self) -&gt; Self::IntoIter {
        self.tickets.iter()
    }
}
<span class="boring">}</span></code></pre></pre>
<p>What should <code>type IntoIter</code> be set to?<br />
Intuitively, it should be the type returned by <code>self.tickets.iter()</code>, i.e. the type returned by <code>Vec::iter()</code>.<br />
If you check the standard library documentation, you'll find that <code>Vec::iter()</code> returns an <code>std::slice::Iter</code>.
The definition of <code>Iter</code> is:</p>
<blockquote>
<p><code>type IntoIter</code>ã¯ä½•ã‚’è¨­å®šã™ã‚‹ã¹ãã§ã—ã‚‡ã†ã‹ï¼Ÿ
ç›´æ„Ÿçš„ã«ã€ãã‚Œã¯ã€<code>self.tickets.iter()</code>ã«ã‚ˆã£ã¦è¿”ã•ã‚Œã‚‹å‹ã€ä¾‹ãˆã°<code>Vec::iter()</code>ã«ã‚ˆã£ã¦è¿”ã•ã‚Œã‚‹å‹ã§ã‚ã‚‹ã¹ãã§ã™ã€‚
æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’ç¢ºèªã—ãŸå ´åˆã€<code>Vec::iter()</code>ã¯<code>std::slice::Iter</code>ã‚’è¿”ã™ã“ã¨ã‚’è¦‹ã¤ã‘ã‚‹ã¯ãšã§ã™ã€‚
<code>Iter</code>ã®å®šç¾©ã¯ãƒ»ãƒ»ãƒ»</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Iter&lt;'a, T&gt; { /* fields omitted */ }
<span class="boring">}</span></code></pre></pre>
<p><code>'a</code> is a <strong>lifetime parameter</strong>.</p>
<blockquote>
<p><code>'a</code>ã¯<strong>ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼</strong>ã§ã™ã€‚</p>
</blockquote>
<h2 id="lifetime-parametersãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼"><a class="header" href="#lifetime-parametersãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼">Lifetime parametersï¼ˆãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ï¼‰</a></h2>
<p>Lifetimes are <strong>labels</strong> used by the Rust compiler to keep track of how long a reference (either mutable or
immutable) is valid.<br />
The lifetime of a reference is constrained by the scope of the value it refers to. Rust always makes sure, at compile-time,
that references are not used after the value they refer to has been dropped, to avoid dangling pointers and use-after-free bugs.</p>
<blockquote>
<p>ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ã¯ã€å¯å¤‰ã¾ãŸã¯ä¸å¤‰å‚ç…§ãŒæœ‰åŠ¹ãªé•·ã•ã‚’è¿½è·¡ã™ã‚‹ãŸã‚ã«Rustã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ¼ã«ã‚ˆã£ã¦ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚
å‚ç…§ã®ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ã¯ã€ãã‚ŒãŒå‚ç…§ã™ã‚‹å€¤ã®ã‚¹ã‚³ãƒ¼ãƒ—ã«ã‚ˆã£ã¦åˆ¶é™ã•ã‚Œã¾ã™ã€‚
Rustã¯ã€ãƒ€ãƒ³ã‚°ãƒªãƒ³ã‚°ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã¨è§£æ”¾ã•ã‚ŒãŸå¾Œã«ä½¿ç”¨ã™ã‚‹ãƒã‚°ã‚’é¿ã‘ã‚‹ãŸã‚ã«ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã«ã€å‚ç…§ã—ã¦ã„ã‚‹å€¤ãŒãƒ‰ãƒ­ãƒƒãƒ—ã•ã‚ŒãŸå¾Œã§ã€å‚ç…§ãŒä½¿ç”¨ã•ã‚Œãªã„ã“ã¨ã‚’å¸¸ã«ç¢ºèªã—ã¾ã™ã€‚</p>
</blockquote>
<p>This should sound familiar: we've already seen these concepts in action when we discussed ownership and borrowing.
Lifetimes are just a way to <strong>name</strong> how long a specific reference is valid.</p>
<blockquote>
<p>ã“ã‚Œã¯ã€ãŠãªã˜ã¿ã®ã¯ãšã§ã™ã€‚æ‰€æœ‰æ¨©ã¨å€Ÿç”¨ã‚’è­°è«–ã—ãŸå¾Œã«ã€å®Ÿéš›ã«ã“ã‚Œã‚‰ã®æ¦‚å¿µã‚’ã™ã§ã«ç¢ºèªã—ã¾ã—ãŸã€‚
ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ã¯ã€ç‰¹å®šã®å‚ç…§ãŒæœ‰åŠ¹ãªæœŸé–“ã‚’<strong>åå‰ä»˜ã‘</strong>ã™ã‚‹å˜ãªã‚‹æ–¹æ³•ã§ã™ã€‚</p>
</blockquote>
<p>Naming becomes important when you have multiple references and you need to clarify how they <strong>relate to each other</strong>.
Let's look at the signature of <code>Vec::iter()</code>:</p>
<blockquote>
<p>è¤‡æ•°ã®å‚ç…§ãŒã‚ã‚Šã€ãã‚Œã‚‰ãŒã©ã®ã‚ˆã†ã«<strong>ãŠäº’ã„ã«é–¢é€£ã—ã¦ã„ã‚‹</strong>ã‹ã‚’æ˜ç¢ºã«ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã¨ãã€åå‰ä»˜ã‘ã¯é‡è¦ã«ãªã‚Šã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl &lt;T&gt; Vec&lt;T&gt; {
    // Slightly simplified
    // å°‘ã—ç°¡ç•¥åŒ–ã—ã¦ã‚ã‚Šã¾ã™ã€‚
    pub fn iter&lt;'a&gt;(&amp;'a self) -&gt; Iter&lt;'a, T&gt; {
        // [...]
    }
}
<span class="boring">}</span></code></pre></pre>
<p><code>Vec::iter()</code> is generic over a lifetime parameter, named <code>'a</code>.<br />
<code>'a</code> is used to <strong>tie together</strong> the lifetime of the <code>Vec</code> and the lifetime of the <code>Iter</code> returned by <code>iter()</code>.
In plain English: the <code>Iter</code> returned by <code>iter()</code> cannot outlive the <code>Vec</code> reference (<code>&amp;self</code>) it was created from.</p>
<blockquote>
<p><code>Vec::iter()</code>ã¯ã€<code>'a</code>ã¨ã„ã†åå‰ãŒä»˜ã‘ã‚‰ã‚ŒãŸã€ã‚¸ã‚§ãƒãƒªãƒƒã‚¯ãªãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ã§ã™ã€‚
<code>'a</code>ã¯ã€<code>Vec</code>ã®ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ã¨<code>iter()</code>ã«ã‚ˆã£ã¦è¿”ã•ã‚Œã‚‹<code>Iter</code>ã®ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ã‚’<strong>ä¸€ç·’ã«ç¸›ã‚Šä»˜ã‘ã‚‹</strong>ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚
ç°¡å˜ãªè‹±èªã§è¨€ãˆã°ã€<code>Iter()</code>ã«ã‚ˆã£ã¦è¿”ã•ã‚ŒãŸ<code>Iter</code>ã¯ã€ãã‚ŒãŒä½œæˆã•ã‚ŒãŸ<code>Vec</code>ã®å‚ç…§ï¼ˆ<code>&amp;self</code>ï¼‰ã‚ˆã‚Šã‚‚é•·ç”Ÿãã§ãã¾ã›ã‚“ã€‚</p>
</blockquote>
<p>This is important because <code>Vec::iter</code>, as we discussed, returns an iterator over <strong>references</strong> to the <code>Vec</code>'s elements.
If the <code>Vec</code> is dropped, the references returned by the iterator would be invalid. Rust must make sure this doesn't happen,
and lifetimes are the tool it uses to enforce this rule.</p>
<blockquote>
<p>è­°è«–ã—ãŸã‚ˆã†ã«<code>Vec::iter</code>ã¯ã€<code>Vec</code>ã®è¦ç´ ã¸ã®å‚ç…§ã‚’è¿”ã™ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ãƒ¼ã‚’è¿”ã™ãŸã‚é‡è¦ã§ã™ã€‚
<code>Vec</code>ãŒãƒ‰ãƒ­ãƒƒãƒ—ã•ã‚ŒãŸå ´åˆã€ãã®ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ãƒ¼ã«ã‚ˆã£ã¦è¿”ã•ã‚ŒãŸå‚ç…§ã¯ç„¡åŠ¹ã«ãªã‚Šã¾ã™ã€‚
Rustã¯ã€ã“ã‚ŒãŒç™ºç”Ÿã—ãªã„ã“ã¨ã‚’ç¢ºå®Ÿã«ã—ãªã‘ã‚Œã°ãªã‚‰ãšã€ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ã¯ã“ã®ãƒ«ãƒ¼ãƒ«ã‚’å¼·åˆ¶ã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã‚‹ãƒ„ãƒ¼ãƒ«ã§ã™ã€‚</p>
</blockquote>
<h2 id="lifetime-elisionãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ã®çœç•¥"><a class="header" href="#lifetime-elisionãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ã®çœç•¥">Lifetime elisionï¼ˆãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ã®çœç•¥ï¼‰</a></h2>
<p>Rust has a set of rules, called <strong>lifetime elision rules</strong>, that allow you to omit explicit lifetime annotations in many cases.
For example, <code>Vec::iter</code>'s definition looks like this in <code>std</code>'s source code:</p>
<blockquote>
<p>Rustã¯<strong>ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ã®çœç•¥ãƒ«ãƒ¼ãƒ«</strong>ã¨å‘¼ã°ã‚Œã‚‹ãƒ«ãƒ¼ãƒ«ã®é›†åˆã‚’æŒã£ã¦ãŠã‚Šã€å¤šãã®å ´åˆã§æ˜ç¤ºçš„ãªãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ æ³¨é‡ˆã‚’çœç•¥ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚
ä¾‹ãˆã°ã€<code>Vec::iter</code>ã®å®šç¾©ã¯ã€<code>std</code>ã®ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã§ã¯æ¬¡ã®ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl &lt;T&gt; Vec&lt;T&gt; {
    pub fn iter(&amp;self) -&gt; Iter&lt;'_, T&gt; {
        // [...]
    }
}
<span class="boring">}</span></code></pre></pre>
<p>No explicit lifetime parameter is present in the signature of <code>Vec::iter()</code>.
Elision rules imply that the lifetime of the <code>Iter</code> returned by <code>iter()</code> is tied to the lifetime of the <code>&amp;self</code> reference.
You can think of <code>'_</code> as a <strong>placeholder</strong> for the lifetime of the <code>&amp;self</code> reference.</p>
<blockquote>
<p><code>Vec::iter()</code>ã®ã‚·ã‚°ãƒãƒãƒ£ãƒ¼ã«ã€æ˜ç¤ºçš„ãªãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ã¯å­˜åœ¨ã—ã¾ã›ã‚“ã€‚
çœç•¥ãƒ«ãƒ¼ãƒ«ã¯ã€<code>iter()</code>ã«ã‚ˆã£ã¦è¿”ã•ã‚ŒãŸ<code>Iter</code>ã®ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ã¯ã€<code>&amp;self</code>å‚ç…§ã®ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ã«ç¸›ã‚Šä»˜ã‘ã‚‰ã‚Œã¦ã„ã‚‹ã“ã¨ã‚’æš—ç¤ºã—ã¾ã™ã€‚
<code>'_</code>ã‚’<code>&amp;self</code>å‚ç…§ã®ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ã®<strong>ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼</strong>ã¨ã—ã¦è€ƒãˆã‚Œã¾ã™ã€‚</p>
</blockquote>
<p>See the <a href="06_ticket_management/06_lifetimes.html#references">References</a> section for a link to the official documentation on lifetime elision.<br />
In most cases, you can rely on the compiler telling you when you need to add explicit lifetime annotations.</p>
<blockquote>
<p>ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ã®çœç•¥ã«é–¢ã™ã‚‹å…¬å¼ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã¸ã®ãƒªãƒ³ã‚¯ã«ã¤ã„ã¦ã¯ã€å‚ç…§ç¯€ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚
ã»ã¨ã‚“ã©ã®å ´åˆã€æ˜ç¤ºçš„ãªãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ æ³¨é‡ˆã‚’è¿½åŠ ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã¨ãã¯ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ¼ã‹ã‚‰ã®é€šçŸ¥ã«é ¼ã‚Œã¾ã™ã€‚</p>
</blockquote>
<h2 id="references"><a class="header" href="#references">References</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.iter">std::vec::Vec::iter</a></li>
<li><a href="https://doc.rust-lang.org/std/slice/struct.Iter.html">std::slice::Iter</a></li>
<li><a href="https://doc.rust-lang.org/reference/lifetime-elision.html">Lifetime elision rules</a></li>
</ul>
<h2 id="exercise-63"><a class="header" href="#exercise-63">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/06_ticket_management/06_lifetimes"><code>06_ticket_management/06_lifetimes</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="combinatorsã‚³ãƒ³ãƒ“ãƒãƒ¼ã‚¿ãƒ¼"><a class="header" href="#combinatorsã‚³ãƒ³ãƒ“ãƒãƒ¼ã‚¿ãƒ¼">Combinatorsï¼ˆã‚³ãƒ³ãƒ“ãƒãƒ¼ã‚¿ãƒ¼ï¼‰</a></h1>
<p>Iterators can do so much more than <code>for</code> loops!<br />
If you look at the documentation for the <code>Iterator</code> trait, you'll find a <strong>vast</strong> collections of
methods that you can leverage to transform, filter, and combine iterators in various ways.</p>
<blockquote>
<p>ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ãƒ¼ã¯<code>for</code>ãƒ«ãƒ¼ãƒ—ä»¥ä¸Šã®ã“ã¨ãŒã§ãã¾ã™ï¼
<code>Iterator</code>ãƒˆãƒ¬ã‚¤ãƒˆã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’ç¢ºèªã—ãŸå ´åˆã€ã•ã¾ã–ã¾ãªæ–¹æ³•ã§ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ãƒ¼ã‚’å¤‰æ›ã€ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ãã—ã¦çµåˆã—ã¦åˆ©ç”¨ã™ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰ã®<strong>è†¨å¤§ãª</strong>ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã‚’è¦‹ã¤ã‘ã‚‹ã§ã—ã‚‡ã†ã€‚</p>
</blockquote>
<p>Let's mention the most common ones:</p>
<ul>
<li><code>map</code> applies a function to each element of the iterator.</li>
<li><code>filter</code> keeps only the elements that satisfy a predicate.</li>
<li><code>filter_map</code> combines <code>filter</code> and <code>map</code> in one step.</li>
<li><code>cloned</code> converts an iterator of references into an iterator of values, cloning each element.</li>
<li><code>enumerate</code> returns a new iterator that yields <code>(index, value)</code> pairs.</li>
<li><code>skip</code> skips the first <code>n</code> elements of the iterator.</li>
<li><code>take</code> stops the iterator after <code>n</code> elements.</li>
<li><code>chain</code> combines two iterators into one.</li>
</ul>
<blockquote>
<p>æœ€ã‚‚ä¸€èˆ¬çš„ãªã‚‚ã®ã‚’è¨€åŠã—ã¾ã—ã‚‡ã†ã€‚</p>
<ul>
<li><code>map</code>ã¯ã€ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ãƒ¼ã®ãã‚Œãã‚Œã®è¦ç´ ã«é–¢æ•°ã‚’é©ç”¨ã—ã¾ã™ã€‚</li>
<li><code>filter</code>ã¯ã€è¿°èªã‚’æº€è¶³ã™ã‚‹è¦ç´ ã®ã¿ã‚’ä¿æŒã—ã¾ã™ã€‚</li>
<li><code>filter_map</code>ã¯ã€1ã‚¹ãƒ†ãƒƒãƒ—ã§<code>filter</code>ã¨<code>map</code>ã‚’çµ„ã¿åˆã‚ã›ã¾ã™ã€‚</li>
<li><code>cloned</code>ã¯ã€ãã‚Œãã‚Œã®è¦ç´ ã‚’ã‚¯ãƒ­ãƒ¼ãƒ³ã—ã¦ã€å‚ç…§ã®ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ãƒ¼ã‚’å€¤ã®ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ãƒ¼ã«å¤‰æ›ã—ã¾ã™ã€‚</li>
<li><code>enumerate</code>ã¯ã€<code>(index, value)</code>ã®ãƒšã‚¢ã‚’ç”Ÿæˆã™ã‚‹æ–°ã—ã„ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ãƒ¼ã‚’è¿”ã—ã¾ã™ã€‚</li>
<li><code>skip</code>ã¯ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ãƒ¼ã®æœ€åˆã®<code>n</code>è¦ç´ ã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ã¾ã™ã€‚</li>
<li><code>take</code>ã¯ã€<code>n</code>è¦ç´ å¾Œã«ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ãƒ¼ã‚’åœæ­¢ã—ã¾ã™ã€‚</li>
<li><code>chain</code>ã¯ã€2ã¤ã®ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ãƒ¼ã‚’1ã¤ã«çµåˆã—ã¾ã™ã€‚</li>
</ul>
</blockquote>
<p>These methods are called <strong>combinators</strong>.<br />
They are usually <strong>chained</strong> together to create complex transformations in a concise and readable way:</p>
<blockquote>
<p>ã“ã‚Œã‚‰ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯<strong>ã‚³ãƒ³ãƒ“ãƒãƒ¼ã‚¿ãƒ¼</strong>ã¨å‘¼ã°ã‚Œã¾ã™ã€‚
ãã‚Œã‚‰ã¯ã€é€šå¸¸ã€ç°¡æ½”ã§èª­ã¿ã‚„ã™ã„æ–¹æ³•ã§ã€è¤‡é›‘ãªå¤‰æ›ã‚’ä½œæˆã™ã‚‹ãŸã‚ã«ä¸€ç·’ã«<strong>é€£é–</strong>ã•ã‚Œã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let numbers = vec![1, 2, 3, 4, 5];
// The sum of the squares of the even numbers
// å¶æ•°ã®äºŒä¹—ã®åˆè¨ˆ
let outcome: u32 = numbers.iter()
    .filter(|&amp;n| n % 2 == 0)
    .map(|&amp;n| n * n)
    .sum();
<span class="boring">}</span></code></pre></pre>
<h2 id="closuresã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ãƒ¼"><a class="header" href="#closuresã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ãƒ¼">Closuresï¼ˆã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ãƒ¼ï¼‰</a></h2>
<p>What's going on with the <code>filter</code> and <code>map</code> methods above?<br />
They take <strong>closures</strong> as arguments.</p>
<blockquote>
<p>ä¸Šè¨˜ã®<code>filter</code>ã¨<code>map</code>ãƒ¡ã‚½ãƒƒãƒ‰ã¯ä½•ã‚’ã—ã¦ã„ã‚‹ã®ã§ã—ã‚‡ã†ã‹ï¼Ÿ
ãã‚Œã‚‰ã¯å¼•æ•°ã¨ã—ã¦<strong>ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ãƒ¼</strong>ã‚’å—ã‘å–ã‚Šã¾ã™ã€‚</p>
</blockquote>
<p>Closures are <strong>anonymous functions</strong>, i.e. functions that are not defined using the <code>fn</code> syntax we are used to.<br />
They are defined using the <code>|args| body</code> syntax, where <code>args</code> are the arguments and <code>body</code> is the function body.
<code>body</code> can be a block of code or a single expression.
For example:</p>
<blockquote>
<p>ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ãƒ¼ã¯<strong>åŒ¿åé–¢æ•°</strong>ã§ã™ã€‚ã¤ã¾ã‚Šã€ä½¿ç”¨ã—ã¦ããŸ<code>fn</code>æ§‹æ–‡ã‚’ä½¿ç”¨ã—ã¦å®šç¾©ã•ã‚Œãªã„é–¢æ•°ã§ã™ã€‚
ãã‚Œã‚‰ã¯<code>|args| body</code>æ§‹æ–‡ã‚’ä½¿ç”¨ã—ã¦å®šç¾©ã•ã‚Œã€<code>args</code>ã¯å¼•æ•°ã§<code>body</code>ã¯é–¢æ•°ã®æœ¬ä½“ã§ã™ã€‚
<code>body</code>ã¯ã‚³ãƒ¼ãƒ‰ã®ãƒ–ãƒ­ãƒƒã‚¯ã¾ãŸã¯ã€å˜ç‹¬ã®å¼ã«ãªã‚Šã¾ã™ã€‚
ä¾‹ãˆã°ãƒ»ãƒ»ãƒ»</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// An anonymous function that adds 1 to its argument
// å¼•æ•°ã«1ã‚’è¶³ã™åŒ¿åé–¢æ•°
let add_one = |x| x + 1;
// Could be written with a block too:
// ãƒ–ãƒ­ãƒƒã‚¯ã§è¨˜è¿°ã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ã€‚
let add_one = |x| { x + 1 };
<span class="boring">}</span></code></pre></pre>
<p>Closures can take more than one argument:</p>
<blockquote>
<p>ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ãƒ¼ã¯1ã¤ä»¥ä¸Šã®å¼•æ•°ã‚’å—ã‘å–ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let add = |x, y| x + y;
let sum = add(1, 2);
<span class="boring">}</span></code></pre></pre>
<p>They can also capture variables from their environment:</p>
<blockquote>
<p>ãã‚Œã‚‰ã¯ã€ãã‚Œã‚‰ã®ç’°å¢ƒã‹ã‚‰å¤‰æ•°ã‚’ã‚­ãƒ£ãƒ—ãƒãƒ£ãƒ¼ã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 42;
let add_x = |y| x + y;
let sum = add_x(1);
<span class="boring">}</span></code></pre></pre>
<p>If necessary, you can specify the types of the arguments and/or the return type:</p>
<blockquote>
<p>å¿…è¦ã«å¿œã˜ã¦ã€å¼•æ•°ã®å‹åŠã³æˆ»ã‚Šå€¤ã®å‹ã‚’æŒ‡å®šã§ãã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Just the input type
// å˜ãªã‚‹å¼•æ•°ã®å‹ã§ã™ã€‚
let add_one = |x: i32| x + 1;
// Or both input and output types, using the `fn` syntax
// `fn`æ§‹æ–‡ã‚’ä½¿ç”¨ã—ãŸã€å¼•æ•°ã¨å‡ºåŠ›ã®å‹ã®ä¸¡æ–¹ã§ã™ã€‚
let add_one: fn(i32) -&gt; i32 = |x| x + 1;
<span class="boring">}</span></code></pre></pre>
<h2 id="collect"><a class="header" href="#collect"><code>collect</code></a></h2>
<p>What happens when you're done transforming an iterator using combinators?<br />
You either iterate over the transformed values using a <code>for</code> loop, or you collect them into a collection.</p>
<blockquote>
<p>ã‚³ãƒ³ãƒ“ãƒãƒ¼ã‚¿ãƒ¼ã‚’ä½¿ç”¨ã—ã¦ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚’å¤‰æ›ã—ãŸå¾Œã€ä½•ãŒèµ·ã“ã‚‹ã§ã—ã‚‡ã†ã‹ï¼Ÿ
<code>for</code>ãƒ«ãƒ¼ãƒ—ã‚’ä½¿ç”¨ã—ã¦å¤‰æ›ã•ã‚ŒãŸå€¤ã‚’åå¾©å‡¦ç†ã™ã‚‹ã“ã¨ã‚‚ã€ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³å†…ã«ãã‚Œã‚‰ã‚’é›†ã‚ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ã€‚</p>
</blockquote>
<p>The latter is done using the <code>collect</code> method.<br />
<code>collect</code> consumes the iterator and collects its elements into a collection of your choice.</p>
<blockquote>
<p>å¾Œè€…ã¯ã€<code>collect</code>ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ç”¨ã—ã¦è¡Œã‚ã‚Œã¾ã™ã€‚
<code>collect</code>ã¯ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ãƒ¼ã‚’æ¶ˆè²»ã—ã¦ã€é¸æŠã—ãŸã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³å†…ã«ãã®è¦ç´ ã‚’é›†ã‚ã¾ã™ã€‚</p>
</blockquote>
<p>For example, you can collect the squares of the even numbers into a <code>Vec</code>:</p>
<blockquote>
<p>ä¾‹ãˆã°ã€<code>Vec</code>ã«å¶æ•°ã®äºŒä¹—ã‚’é›†ã‚ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let numbers = vec![1, 2, 3, 4, 5];
let squares_of_evens: Vec&lt;u32&gt; = numbers.iter()
    .filter(|&amp;n| n % 2 == 0)
    .map(|&amp;n| n * n)
    .collect();
<span class="boring">}</span></code></pre></pre>
<p><code>collect</code> is generic over its <strong>return type</strong>.<br />
Therefore you usually need to provide a type hint to help the compiler infer the correct type.
In the example above, we annotated the type of <code>squares_of_evens</code> to be <code>Vec&lt;u32&gt;</code>.
Alternatively, you can use the <strong>turbofish syntax</strong> to specify the type:</p>
<blockquote>
<p><code>collect</code>ã¯ã€ãã®<strong>æˆ»ã‚Šå€¤ã®å‹</strong>ã«å¯¾ã—ã¦ã‚¸ã‚§ãƒãƒªãƒƒã‚¯ã§ã™ã€‚
å¾“ã£ã¦ã€é€šå¸¸ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ¼ãŒæ­£ç¢ºãªå‹ã‚’æ¨è«–ã™ã‚‹ã“ã¨ã‚’åŠ©ã‘ã‚‹ãŸã‚ã«ã€å‹ãƒ’ãƒ³ãƒˆã‚’æä¾›ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚
ä¸Šè¨˜ã®ä¾‹ã«ãŠã„ã¦ã€<code>squares_of_evens</code>ã®å‹ãŒ<code>Vec&lt;u32&gt;</code>ã«ãªã‚‹ã“ã¨ã‚’æ³¨é‡ˆã—ã¾ã—ãŸã€‚
ä»£ã‚ã‚Šã«ã€å‹ã‚’æŒ‡å®šã™ã‚‹ãŸã‚ã«<strong>ã‚¿ãƒ¼ãƒœãƒ•ã‚£ãƒƒã‚·ãƒ¥æ§‹æ–‡</strong>ã‚’ä½¿ç”¨ã§ãã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let squares_of_evens = numbers.iter()
    .filter(|&amp;n| n % 2 == 0)
    .map(|&amp;n| n * n)
    // Turbofish syntax: `&lt;method_name&gt;::&lt;type&gt;()`
    // It's called turbofish because `::&lt;&gt;` looks like a fish
    // ã‚¿ãƒ¼ãƒœãƒ•ã‚£ãƒƒã‚·ãƒ¥æ§‹æ–‡: `&lt;ãƒ¡ã‚½ãƒƒãƒ‰å&gt;::&lt;å‹&gt;()`
    // `::&lt;&gt;`ãŒé­šã®ã‚ˆã†ã«è¦‹ãˆã‚‹ãŸã‚ã€ã‚¿ãƒ¼ãƒœãƒ•ã‚£ãƒƒã‚·ãƒ¥ã¨å‘¼ã°ã‚Œã¾ã™ã€‚
    .collect::&lt;Vec&lt;u32&gt;&gt;();
<span class="boring">}</span></code></pre></pre>
<h2 id="further-readingå‚è€ƒè³‡æ–™-9"><a class="header" href="#further-readingå‚è€ƒè³‡æ–™-9">Further readingï¼ˆå‚è€ƒè³‡æ–™ï¼‰</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html"><code>Iterator</code>'s documentation</a> gives you an
overview of the methods available for iterators in <code>std</code>.</li>
<li><a href="https://docs.rs/itertools/">The <code>itertools</code> crate</a> defines even <strong>more</strong> combinators for iterators.</li>
</ul>
<h2 id="exercise-64"><a class="header" href="#exercise-64">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/06_ticket_management/07_combinators"><code>06_ticket_management/07_combinators</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="impl-trait"><a class="header" href="#impl-trait"><code>impl Trait</code></a></h1>
<p><code>TicketStore::to_dos</code> returns a <code>Vec&lt;&amp;Ticket&gt;</code>.<br />
That signature introduces a new heap allocation every time <code>to_dos</code> is called, which may be unnecessary depending
on what the caller needs to do with the result.
It'd be better if <code>to_dos</code> returned an iterator instead of a <code>Vec</code>, thus empowering the caller to decide whether to
collect the results into a <code>Vec</code> or just iterate over them.</p>
<blockquote>
<p><code>TicketStore::to_dos</code>ã¯<code>Vec&lt;&amp;Ticket&gt;</code>ã‚’è¿”ã—ã¾ã™ã€‚
ãã®ã‚·ã‚°ãƒãƒãƒ£ãƒ¼ã¯ã€<code>to_dos</code>ãŒå‘¼ã°ã‚Œã‚‹ãŸã³ã«æ–°ã—ã„ãƒ’ãƒ¼ãƒ—å‰²ã‚Šå½“ã¦ã‚’æ‹›ãã€ãã‚Œã¯å‘¼ã³å‡ºã—å´ãŒçµæœã§è¡Œã†å¿…è¦ãŒã‚ã‚‹ã“ã¨ã«ã‚ˆã£ã¦ã€ä¸å¿…è¦ã«ãªã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚
<code>to_dos</code>ãŒ<code>Vec</code>ã®ä»£ã‚ã‚Šã«ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ãƒ¼ã‚’è¿”ã—ãŸã»ã†ãŒè‰¯ãã€ãã‚Œã«ã‚ˆã‚Šå‘¼ã³å‡ºã—å´ãŒ<code>Vec</code>ã«çµæœã‚’é›†ã‚ã‚‹ã‹ã€ãã‚Œã‚‰ã‚’å˜ã«åå¾©æ“ä½œã™ã‚‹ã‹æ±ºå®šã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚</p>
</blockquote>
<p>That's tricky though!
What's the return type of <code>to_dos</code>, as implemented below?</p>
<blockquote>
<p>ãŸã ã—ã€ãã‚Œã¯ãƒˆãƒªãƒƒã‚­ãƒ¼ã§ã™ã€‚
æ¬¡ã«å®Ÿè£…ã•ã‚ŒãŸ<code>to_dos</code>ã®æˆ»ã‚Šå€¤ã®å‹ã¯ä½•ã§ã—ã‚‡ã†ã‹ï¼Ÿ</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl TicketStore {
    pub fn to_dos(&amp;self) -&gt; ??? {
        self.tickets.iter().filter(|t| t.status == Status::ToDo)
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="unnameable-typesåå‰ã‚’æŒãŸãªã„å‹"><a class="header" href="#unnameable-typesåå‰ã‚’æŒãŸãªã„å‹">Unnameable typesï¼ˆåå‰ã‚’æŒãŸãªã„å‹ï¼‰</a></h2>
<p>The <code>filter</code> method returns an instance of <code>std::iter::Filter</code>, which has the following definition:</p>
<blockquote>
<p><code>filter</code>ãƒ¡ã‚½ãƒƒãƒ‰ã¯<code>std::iter::Filter</code>ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’è¿”ã—ã€ãã‚Œã¯æ¬¡ã®å®šç¾©ã‚’æŒã¡ã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Filter&lt;I, P&gt; { /* fields omitted */ }
<span class="boring">}</span></code></pre></pre>
<p>where <code>I</code> is the type of the iterator being filtered on and <code>P</code> is the predicate used to filter the elements.<br />
We know that <code>I</code> is <code>std::slice::Iter&lt;'_, Ticket&gt;</code> in this case, but what about <code>P</code>?<br />
<code>P</code> is a closure, an <strong>anonymous function</strong>. As the name suggests, closures don't have a name,
so we can't write them down in our code.</p>
<blockquote>
<p><code>I</code>ã¯ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ã•ã‚Œã‚‹ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ãƒ¼ã®å‹ã§ã€<code>P</code>ã¯è¦ç´ ã‚’ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ã™ã‚‹è¿°èªã§ã™ã€‚
ã“ã®å ´åˆã€<code>I</code>ã¯<code>std::slice::Iter&lt;'_, Ticket&gt;</code>ã§ã‚ã‚‹ã“ã¨ã‚’çŸ¥ã£ã¦ã„ã¾ã™ãŒã€<code>P</code>ã«ã¤ã„ã¦ã¯ã©ã†ã§ã—ã‚‡ã†ã‹ï¼Ÿ</p>
</blockquote>
<p>Rust has a solution for this: <strong>impl Trait</strong>.</p>
<blockquote>
<p>Rustã¯ã“ã®ãŸã‚ã®è§£æ±ºç­–ãŒã‚ã‚Šã¾ã™ã€‚ãã‚Œã¯<strong>impl Trait</strong>ã§ã™ã€‚</p>
</blockquote>
<h2 id="impl-trait-1"><a class="header" href="#impl-trait-1"><code>impl Trait</code></a></h2>
<p><code>impl Trait</code> is a feature that allows you to return a type without specifying its name.
You just declare what trait(s) the type implements, and Rust figures out the rest.</p>
<blockquote>
<p><code>impl Trait</code>ã¯ã€ãã®åå‰ã‚’æŒ‡å®šã•ã‚Œãšã«å‹ã‚’è¿”ã™ã“ã¨ãŒã§ãã‚‹æ©Ÿèƒ½ã§ã™ã€‚
å‹ãŒã©ã®ãƒˆãƒ¬ã‚¤ãƒˆã‚’å®Ÿè£…ã—ã¦ã„ã‚‹ã‹ã ã‘ã‚’å®£è¨€ã—ã¦ã€RustãŒæ®‹ã‚Šã‚’è¦‹å‡ºã—ã¾ã™ã€‚</p>
</blockquote>
<p>In this case, we want to return an iterator of references to <code>Ticket</code>s:</p>
<blockquote>
<p>ã“ã®å ´åˆã€<code>Ticket</code>ã¸ã®å‚ç…§ã®ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ãƒ¼ã‚’è¿”ã—ãŸã„ã§ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl TicketStore {
    pub fn to_dos(&amp;self) -&gt; impl Iterator&lt;Item = &amp;Ticket&gt; {
        self.tickets.iter().filter(|t| t.status == Status::ToDo)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>That's it!</p>
<blockquote>
<p>ã“ã‚Œã ã‘ã§ã™ã€‚</p>
</blockquote>
<h2 id="generic"><a class="header" href="#generic">Generic?</a></h2>
<p><code>impl Trait</code> in return position is <strong>not</strong> a generic parameter.</p>
<blockquote>
<p><code>æˆ»ã‚Šå€¤ã®ä½ç½®ã«ã‚ã‚‹</code>impl Trait`ã¯ã€ã‚¸ã‚§ãƒãƒªãƒƒã‚¯ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ã§ã¯<strong>ã‚ã‚Šã¾ã›ã‚“</strong>ã€‚</p>
</blockquote>
<p>Generics are placeholders for types that are filled in by the caller of the function.
A function with a generic parameter is <strong>polymorphic</strong>: it can be called with different types, and the compiler will generate
a different implementation for each type.</p>
<blockquote>
<p>ã‚¸ã‚§ãƒãƒªãƒƒã‚¯ã¯ã€é–¢æ•°ã®å‘¼ã³å‡ºã—å´ã«ã‚ˆã£ã¦å……å¡«ã•ã‚Œã‚‹å‹ã«å¯¾ã™ã‚‹ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼ã§ã™ã€‚
ã‚¸ã‚§ãƒãƒªãƒƒã‚¯ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ã‚’æŒã¤é–¢æ•°ã¯<strong>å¤šæ…‹æ€§</strong>ã§ã™ã€‚
ãã‚Œã¯ã€ç•°ãªã‚‹å‹ã§å‘¼ã³å‡ºã•ã‚Œã‚‹ã“ã¨ãŒã§ãã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ¼ã¯ãã‚Œãã‚Œã®æ–¹ã«å¯¾ã—ã¦ç•°ãªã‚‹å®Ÿè£…ã‚’ç”Ÿæˆã—ã¾ã™ã€‚</p>
</blockquote>
<p>That's not the case with <code>impl Trait</code>.
The return type of a function with <code>impl Trait</code> is <strong>fixed</strong> at compile time, and the compiler will generate
a single implementation for it.
This is why <code>impl Trait</code> is also called <strong>opaque return type</strong>: the caller doesn't know the exact type of the return value,
only that it implements the specified trait(s). But the compiler knows the exact type, there is no polymorphism involved.</p>
<blockquote>
<p><code>impl Trait</code>ã®å ´åˆã¯ãã†ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚
<code>impl Trait</code>ã‚’æŒã¤é–¢æ•°ã®æˆ»ã‚Šå€¤ã®å‹ã¯ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã«<strong>å›ºå®š</strong>ã•ã‚Œã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ¼ã¯ãã‚Œã«å¯¾ã—ã¦å˜ä¸€ã®å®Ÿè£…ã‚’ç”Ÿæˆã—ã¾ã™ã€‚
ã“ã‚ŒãŒã€<code>impl Trait</code>ãŒ<strong>ä¸é€æ˜ãªæˆ»ã‚Šå€¤å‹</strong>ã¨ã‚‚å‘¼ã°ã‚Œã‚‹ç†ç”±ã§ã™ã€‚
å‘¼ã³å‡ºã—å´ã¯æˆ»ã‚Šå€¤ã®æ­£ç¢ºãªå‹ã‚’çŸ¥ã‚Šã¾ã›ã‚“ãŒã€ãã‚ŒãŒæŒ‡å®šã•ã‚ŒãŸãƒˆãƒ¬ã‚¤ãƒˆã‚’å®Ÿè£…ã—ã¦ã„ã‚‹ã“ã¨ã®ã¿ã‚’çŸ¥ã£ã¦ã„ã¾ã™ã€‚
ã—ã‹ã—ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ¼ã¯æ­£ç¢ºãªå‹ã‚’çŸ¥ã£ã¦ãŠã‚Šã€å¤šæ…‹æ€§ã¯ç™ºç”Ÿã—ã¾ã›ã‚“ã€‚</p>
</blockquote>
<h2 id="rpit"><a class="header" href="#rpit">RPIT</a></h2>
<p>If you read RFCs or deep-dives about Rust, you might come across the acronym <strong>RPIT</strong>.<br />
It stands for <strong>"Return Position Impl Trait"</strong> and refers to the use of <code>impl Trait</code> in return position.</p>
<blockquote>
<p>Rustã«é–¢ã™ã‚‹RFCã¾ãŸã¯æ·±ã„æ¢æ±‚ã‚’ã‚’èª­ã‚“ã§ã„ã‚‹å ´åˆã€<strong>RPIT</strong>ã¨ã„ã†é ­å­—èªã«å‡ºãã‚ã™ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚
ãã‚Œã¯ã€<strong>ã€Œæˆ»ã‚Šå€¤ã®ä½ç½®ã®Impl Traitã€</strong> ã‹ã‚‰ãªã‚Šã€æˆ»ã‚Šå€¤ã®ä½ç½®ã§<code>impl Trait</code>ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã‚’ç¤ºã—ã¦ã„ã¾ã™ã€‚</p>
</blockquote>
<h2 id="exercise-65"><a class="header" href="#exercise-65">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/06_ticket_management/08_impl_trait"><code>06_ticket_management/08_impl_trait</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="impl-trait-in-argument-positionå¼•æ•°ã®ä½ç½®ã«ã‚ã‚‹impl-trait"><a class="header" href="#impl-trait-in-argument-positionå¼•æ•°ã®ä½ç½®ã«ã‚ã‚‹impl-trait"><code>impl Trait</code> in argument positionï¼ˆå¼•æ•°ã®ä½ç½®ã«ã‚ã‚‹impl Traitï¼‰</a></h1>
<p>In the previous section, we saw how <code>impl Trait</code> can be used to return a type without specifying its name.<br />
The same syntax can also be used in <strong>argument position</strong>:</p>
<blockquote>
<p>å‰ã®ç¯€ã«ãŠã„ã¦ã€ãã®åå‰ã‚’æŒ‡å®šã—ãªã„ã§å‹ã‚’è¿”ã™ãŸã‚ã«<code>impl Trait</code>ã‚’ä½¿ç”¨ã™ã‚‹æ–¹æ³•ã‚’ç¢ºèªã—ã¾ã—ãŸã€‚
åŒã˜æ§‹æ–‡ã¯ã€<strong>å¼•æ•°ã®ä½ç½®</strong>ã§ã‚‚ä½¿ç”¨ã§ãã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn print_iter(iter: impl Iterator&lt;Item = i32&gt;) {
    for i in iter {
        println!("{}", i);
    }
}
<span class="boring">}</span></code></pre></pre>
<p><code>print_iter</code> takes an iterator of <code>i32</code>s and prints each element.<br />
When used in <strong>argument position</strong>, <code>impl Trait</code> is equivalent to a generic parameter with a trait bound:</p>
<blockquote>
<p><code>print_iter</code>ã¯ã€<code>i32</code>ã®ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ãƒ¼ã‚’å—ã‘å–ã‚Šã€ãã‚Œãã‚Œã®è¦ç´ ã‚’å‡ºåŠ›ã—ã¾ã™ã€‚
<strong>å¼•æ•°ã®ä½ç½®</strong>ã§ä½¿ç”¨ã•ã‚ŒãŸå ´åˆã€<code>impl Trait</code>ã¯ãƒˆãƒ¬ã‚¤ãƒˆå¢ƒç•Œã‚’æŒã¤ã‚¸ã‚§ãƒãƒªãƒƒã‚¯ãªãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ã¨åŒã˜ã§ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn print_iter&lt;T&gt;(iter: T)
where
    T: Iterator&lt;Item = i32&gt;
{
    for i in iter {
        println!("{}", i);
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="downsidesæ¬ ç‚¹"><a class="header" href="#downsidesæ¬ ç‚¹">Downsidesï¼ˆæ¬ ç‚¹ï¼‰</a></h2>
<p>As a rule of thumb, prefer generics over <code>impl Trait</code> in argument position.<br />
Generics allow the caller to explicitly specify the type of the argument, using the turbofish syntax (<code>::&lt;&gt;</code>),
which can be useful for disambiguation. That's not the case with <code>impl Trait</code>.</p>
<blockquote>
<p>çµŒé¨“å‰‡ã¨ã—ã¦ã€å¼•æ•°ã®ä½ç½®ã«<code>impl Trait</code>ã‚ˆã‚Šã‚‚ã‚¸ã‚§ãƒãƒªãƒƒã‚¯ã‚’å¥½ã‚€ã‚ˆã†ã«ã—ã¦ãã ã•ã„ã€‚
ã‚¸ã‚§ãƒãƒªãƒƒã‚¯ã¯ã€ã‚¿ãƒ¼ãƒœãƒ•ã‚£ãƒƒã‚·ãƒ¥æ§‹æ–‡ï¼ˆ<code>::&lt;&gt;</code>ï¼‰ã‚’ä½¿ç”¨ã—ã¦ã€å‘¼ã³å‡ºã—å´ã«å¼•æ•°ã®å‹ã‚’æ˜ç¤ºçš„ã«æŒ‡å®šã§ãã‚‹ã‚ˆã†ã«ã—ã¦ã€æ›–æ˜§ã•ã‚’è§£æ¶ˆã™ã‚‹ãŸã‚ã«å½¹ç«‹ã¡ã¾ã™ã€‚
ãã‚Œã¯<code>impl Trait</code>ã‚’ä½¿ç”¨ã—ãŸã‚±ãƒ¼ã‚¹ã«ã¯å½“ã¦ã¯ã¾ã‚Šã¾ã›ã‚“ã€‚</p>
</blockquote>
<h2 id="exercise-66"><a class="header" href="#exercise-66">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/06_ticket_management/09_impl_trait_2"><code>06_ticket_management/09_impl_trait_2</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="slicesã‚¹ãƒ©ã‚¤ã‚¹"><a class="header" href="#slicesã‚¹ãƒ©ã‚¤ã‚¹">Slicesï¼ˆã‚¹ãƒ©ã‚¤ã‚¹ï¼‰</a></h1>
<p>Let's go back to the memory layout of a <code>Vec</code>:</p>
<blockquote>
<p><code>Vec</code>ã®ãƒ¡ãƒ¢ãƒªãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã«æˆ»ã‚Šã¾ã—ã‚‡ã†ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut numbers = Vec::with_capacity(3);
numbers.push(1);
numbers.push(2);
<span class="boring">}</span></code></pre></pre>
<pre><code class="language-text">      +---------+--------+----------+
Stack | pointer | length | capacity |
      |  |      |   2    |    3     |
      +--|------+--------+----------+
         |
         |
         v
       +---+---+---+
Heap:  | 1 | 2 | ? |
       +---+---+---+
</code></pre>
<p>We already remarked how <code>String</code> is just a <code>Vec&lt;u8&gt;</code> in disguise.<br />
The similarity should prompt you to ask: "What's the equivalent of <code>&amp;str</code> for <code>Vec</code>?"</p>
<blockquote>
<p><code>String</code>ãŒå˜ãªã‚‹<code>Vec&lt;u8&gt;</code>ã®å¤‰è£…ã§ã‚ã‚‹ã“ã¨ã‚’ã™ã§ã«è¿°ã¹ã¾ã—ãŸã€‚
ã“ã®é¡ä¼¼æ€§ã¯ã€ã€Œ<code>Vec</code>ã«å¯¾ã—ã¦<code>&amp;str</code>ã«ç›¸å½“ã™ã‚‹ã‚‚ã®ã¯ãªã‚“ã§ã™ã‹ï¼Ÿã€ã¨è³ªå•ã™ã‚‹ã“ã¨ã‚’ä¿ƒã™ã¯ãšã§ã™ã€‚</p>
</blockquote>
<h2 id="t"><a class="header" href="#t"><code>&amp;[T]</code></a></h2>
<p><code>[T]</code> is a <strong>slice</strong> of a contiguous sequence of elements of type <code>T</code>.<br />
It's most commonly used in its borrowed form, <code>&amp;[T]</code>.</p>
<blockquote>
<p><code>[T]</code>ã¯ã€å‹<code>T</code>ã®è¦ç´ ã®é€£ç¶šã—ãŸã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®<strong>ã‚¹ãƒ©ã‚¤ã‚¹</strong>ã§ã™ã€‚
ãã‚Œã¯ã€ãã®å€Ÿç”¨ã•ã‚ŒãŸå½¢å¼ã§ã‚ã‚‹<code>&amp;[T]</code>ã¨ã—ã¦æœ€ã‚‚ä¸€èˆ¬çš„ã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚</p>
</blockquote>
<p>There are various ways to create a slice reference from a <code>Vec</code>:</p>
<blockquote>
<p><code>Vec</code>ã‹ã‚‰ã‚¹ãƒ©ã‚¤ã‚¹å‚ç…§ã‚’ä½œæˆã™ã‚‹æ–¹æ³•ãŒã„ãã¤ã‹ã‚ã‚Šã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let numbers = vec![1, 2, 3];
// Via index syntax
// ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹æ§‹æ–‡ã‚’ä»‹ã—ã¦
let slice: &amp;[i32] = &amp;numbers[..];
// Via a method
// ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä»‹ã—ã¦
let slice: &amp;[i32] = numbers.as_slice();
// Or for a subset of the elements
// ã¾ãŸã€è¦ç´ ã®ã‚µãƒ–ã‚»ãƒƒãƒˆã®å ´åˆ
let slice: &amp;[i32] = &amp;numbers[1..];
<span class="boring">}</span></code></pre></pre>
<p><code>Vec</code> implements the <code>Deref</code> trait using <code>[T]</code> as the target type, so you can use slice methods on a <code>Vec</code> directly
thanks to deref coercion:</p>
<blockquote>
<p><code>Vec</code>ã¯ã€ç›®çš„ã®å‹ã¨ã—ã¦<code>[T]</code>ã‚’ä½¿ç”¨ã—ãŸ<code>Deref</code>ãƒˆãƒ¬ã‚¤ãƒˆã‚’å®Ÿè£…ã—ã¦ã„ã‚‹ãŸã‚ã€å‚ç…§å¤–ã—å‹å¼·åˆ¶ã®ãŠã‹ã’ã¦ã€ã‚¹ãƒ©ã‚¤ã‚¹ãƒ¡ã‚½ãƒƒãƒ‰ã«ç›´æ¥<code>Vec</code>ã‚’ä½¿ç”¨ã§ãã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let numbers = vec![1, 2, 3];
// Surprise, surprise: `iter` is not a method on `Vec`!
// It's a method on `&amp;[T]`, but you can call it on a `Vec`
// thanks to deref coercion.
// é©šãã€é©šã: `iter`ã¯`Vec`ã®ãƒ¡ã‚½ãƒƒãƒ‰ã§ã¯ã‚ã‚Šã¾ã›ã‚“ï¼
// ãã‚Œã¯`&amp;[T]`ã®ãƒ¡ã‚½ãƒƒãƒ‰ã§ã™ãŒã€å‚ç…§å¤–ã—å‹å¼·åˆ¶ã®ãŠã‹ã’ã§`Vec`ã§ãã‚Œã‚’å‘¼ã³å‡ºã›ã¾ã™ã€‚
let sum: i32 = numbers.iter().sum();
<span class="boring">}</span></code></pre></pre>
<h3 id="memory-layoutãƒ¡ãƒ¢ãƒªãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ-3"><a class="header" href="#memory-layoutãƒ¡ãƒ¢ãƒªãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ-3">Memory layoutï¼ˆãƒ¡ãƒ¢ãƒªãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆï¼‰</a></h3>
<p>A <code>&amp;[T]</code> is a <strong>fat pointer</strong>, just like <code>&amp;str</code>.<br />
It consists of a pointer to the first element of the slice and the length of the slice.</p>
<blockquote>
<p><code>&amp;[T]</code>ã¯ã€ã¡ã‚‡ã†ã©<code>&amp;str</code>ã®ã‚ˆã†ã«<strong>ãƒ•ã‚¡ãƒƒãƒˆãƒã‚¤ãƒ³ã‚¿ãƒ¼</strong>ã§ã™ã€‚
ãã‚Œã¯ã€ã‚¹ãƒ©ã‚¤ã‚¹ã®æœ€åˆã®è¦ç´ ã‚’æŒ‡ã—ç¤ºã™ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã¨ã€ã‚¹ãƒ©ã‚¤ã‚¹ã®é•·ã•ã§æ§‹æˆã•ã‚Œã¦ã„ã¾ã™ã€‚</p>
</blockquote>
<p>If you have a <code>Vec</code> with three elements:</p>
<blockquote>
<p>3ã¤ã®è¦ç´ ã‚’æŒã¤<code>Vec</code>ãŒã‚ã‚‹å ´åˆãƒ»ãƒ»ãƒ»</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let numbers = vec![1, 2, 3];
<span class="boring">}</span></code></pre></pre>
<p>and then create a slice reference:</p>
<blockquote>
<p>ãã—ã¦ã€ã‚¹ãƒ©ã‚¤ã‚¹ã®å‚ç…§ã‚’ä½œæˆã™ã‚‹ã¨ãƒ»ãƒ»ãƒ»</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let slice: &amp;[i32] = &amp;numbers[1..];
<span class="boring">}</span></code></pre></pre>
<p>you'll get this memory layout:</p>
<blockquote>
<p>æ¬¡ã®ãƒ¡ãƒ¢ãƒªãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆãŒå¾—ã‚‰ã‚Œã¾ã™ã€‚</p>
</blockquote>
<pre><code class="language-text">                  numbers                          slice
      +---------+--------+----------+      +---------+--------+
Stack | pointer | length | capacity |      | pointer | length |
      |    |    |   3    |    4     |      |    |    |   2    |
      +----|----+--------+----------+      +----|----+--------+
           |                                    |
           |                                    |
           v                                    |
         +---+---+---+---+                      |
Heap:    | 1 | 2 | 3 | ? |                      |
         +---+---+---+---+                      |
               ^                                |
               |                                |
               +--------------------------------+
</code></pre>
<h3 id="vect-vs-t"><a class="header" href="#vect-vs-t"><code>&amp;Vec&lt;T&gt;</code> vs <code>&amp;[T]</code></a></h3>
<p>When you need to pass an immutable reference to a <code>Vec</code> to a function, prefer <code>&amp;[T]</code> over <code>&amp;Vec&lt;T&gt;</code>.<br />
This allows the function to accept any kind of slice, not necessarily one backed by a <code>Vec</code>.</p>
<blockquote>
<p>é–¢æ•°ã«<code>Vec</code>ã¸ã®ä¸å¤‰å‚ç…§ã‚’æ¸¡ã™å¿…è¦ãŒã‚ã‚‹ã¨ãã€<code>&amp;Vec&lt;T&gt;</code>ã‚ˆã‚Šã‚‚<code>&amp;[T]</code>ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚
ã“ã‚Œã¯ã€å¿…ãš<code>Vec</code>ã«ã‚ˆã£ã¦ã‚µãƒ¼ãƒãƒ¼ãƒˆã•ã‚Œã‚‹ç‰©ã«é™ã‚‰ãšã€é–¢æ•°ã«ä»»æ„ã®ç¨®é¡ã®ã‚¹ãƒ©ã‚¤ã‚¹ã«ã‚¢ã‚¯ã‚»ã‚¹ã§ãã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚</p>
</blockquote>
<p>For example, you can then pass a subset of the elements in a <code>Vec</code>.
But it goes further than thatâ€”you could also pass a <strong>slice of an array</strong>:</p>
<blockquote>
<p>ä¾‹ãˆã°ã€<code>Vec</code>ã®è¦ç´ ã®éƒ¨åˆ†é›†åˆã‚’æ¸¡ã™ã“ã¨ãŒã§ãã¾ã™ã€‚
ã—ã‹ã—ã€ãã‚Œã¯ãã‚Œä»¥ä¸Šã®ã“ã¨ã§ã™ã€‚<strong>é…åˆ—ã®ã‚¹ãƒ©ã‚¤ã‚¹</strong>ã‚‚æ¸¡ã™ã“ã¨ãŒã§ãã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let array = [1, 2, 3];
let slice: &amp;[i32] = &amp;array;
<span class="boring">}</span></code></pre></pre>
<p>Array slices and <code>Vec</code> slices are the same type: they're fat pointers to a contiguous sequence of elements.
In the case of arrays, the pointer points to the stack rather than the heap, but that doesn't matter
when it comes to using the slice.</p>
<blockquote>
<p>é…åˆ—ã®ã‚¹ãƒ©ã‚¤ã‚¹ã¨<code>Vec</code>ã®ã‚¹ãƒ©ã‚¤ã‚¹ã¯åŒã˜å‹ã§ã™ã€‚ãã‚Œã‚‰ã¯é€£ç¶šã—ãŸè¦ç´ ã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã¸ã®ãƒ•ã‚¡ãƒƒãƒˆãƒã‚¤ãƒ³ã‚¿ãƒ¼ã§ã™ã€‚
é…åˆ—ã®å ´åˆã€ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã¯ãƒ’ãƒ¼ãƒ—ã§ã¯ãªãã‚¹ã‚¿ãƒƒã‚¯ã‚’æŒ‡ã—ç¤ºã—ã¾ã™ãŒã€ã‚¹ãƒ©ã‚¤ã‚¹ã‚’ä½¿ç”¨ã™ã‚‹éš›ã¯å•é¡Œã‚ã‚Šã¾ã›ã‚“ã€‚</p>
</blockquote>
<h2 id="exercise-67"><a class="header" href="#exercise-67">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/06_ticket_management/10_slices"><code>06_ticket_management/10_slices</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mutable-sliceså¯å¤‰ã‚¹ãƒ©ã‚¤ã‚¹"><a class="header" href="#mutable-sliceså¯å¤‰ã‚¹ãƒ©ã‚¤ã‚¹">Mutable slicesï¼ˆå¯å¤‰ã‚¹ãƒ©ã‚¤ã‚¹ï¼‰</a></h1>
<p>Every time we've talked about slice types (like <code>str</code> and <code>[T]</code>), we've used their immutable borrow form (<code>&amp;str</code> and <code>&amp;[T]</code>).<br />
But slices can also be mutable!</p>
<blockquote>
<p><code>str</code>ã¨<code>[T]</code>ã®ã‚ˆã†ãªã‚¹ãƒ©ã‚¤ã‚¹å‹ã«ã¤ã„ã¦è©±ã™ãŸã³ã«ã€<code>&amp;str</code>ã¨<code>&amp;[T]</code>ã®ã‚ˆã†ãªãã‚Œã‚‰ã®ä¸å¤‰å€Ÿç”¨ã‚’ä½¿ç”¨ã—ã¦ãã¾ã—ãŸã€‚
ã—ã‹ã—ã€ã‚¹ãƒ©ã‚¤ã‚¹ã¯å¯å¤‰ã«ã‚‚ãªã‚Œã¾ã™ã€‚</p>
</blockquote>
<p>Here's how you create a mutable slice:</p>
<blockquote>
<p>ã“ã“ã«ã€å¯å¤‰ã‚¹ãƒ©ã‚¤ã‚¹ã‚’ä½œæˆã™ã‚‹æ–¹æ³•ã‚’ç¤ºã—ã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut numbers = vec![1, 2, 3];
let slice: &amp;mut [i32] = &amp;mut numbers;
<span class="boring">}</span></code></pre></pre>
<p>You can then modify the elements in the slice:</p>
<blockquote>
<p>ãã®å¾Œã€ã‚¹ãƒ©ã‚¤ã‚¹å†…ã®è¦ç´ ã‚’ä¿®æ­£ã§ãã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>slice[0] = 42;
<span class="boring">}</span></code></pre></pre>
<p>This will change the first element of the <code>Vec</code> to <code>42</code>.</p>
<blockquote>
<p>ã“ã‚Œã¯ã€<code>Vec</code>ã®å…ˆé ­ã®è¦ç´ ã‚’<code>42</code>ã«å¤‰æ›´ã—ã¾ã™ã€‚</p>
</blockquote>
<h2 id="limitationsåˆ¶é™äº‹é …-1"><a class="header" href="#limitationsåˆ¶é™äº‹é …-1">Limitationsï¼ˆåˆ¶é™äº‹é …ï¼‰</a></h2>
<p>When working with immutable borrows, the recommendation was clear: prefer slice references over references to
the owned type (e.g. <code>&amp;[T]</code> over <code>&amp;Vec&lt;T&gt;</code>).<br />
That's <strong>not</strong> the case with mutable borrows.</p>
<blockquote>
<p>ä¸å¤‰å€Ÿç”¨ã§ä½œæ¥­ã™ã‚‹ã¨ãã€æ¨å¥¨ã¯æ˜ç¢ºã§ã—ãŸã€‚
ä¾‹ãˆã°ã€<code>&amp;Vec&lt;T&gt;</code>ã‚ˆã‚Šã‚‚<code>&amp;[T]</code>ã®ã‚ˆã†ã«ã€æ‰€æœ‰ã•ã‚ŒãŸå‹ã®å‚ç…§ã‚ˆã‚Šã‚‚ã€ã‚¹ãƒ©ã‚¤ã‚¹å‚ç…§ã‚’é¸æŠã™ã‚‹ã“ã¨ã§ã™ã€‚
ã—ã‹ã—ã€å¯å¤‰å€Ÿç”¨ã®å ´åˆã¯<strong>ãã†ã§ã¯ã‚ã‚Šã¾ã›ã‚“</strong>ã€‚</p>
</blockquote>
<p>Consider this scenario:</p>
<blockquote>
<p>æ¬¡ã®ã‚·ãƒŠãƒªã‚ªã‚’è€ƒãˆã¦ãã ã•ã„ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut numbers = Vec::with_capacity(2);
let mut slice: &amp;mut [i32] = &amp;mut numbers;
slice.push(1);
<span class="boring">}</span></code></pre></pre>
<p>It won't compile!<br />
<code>push</code> is a method on <code>Vec</code>, not on slices. This is the manifestation of a more general principle: Rust won't
allow you to add or remove elements from a slice. You will only be able to modify/replace the elements that are
already there.</p>
<blockquote>
<p>ã“ã‚Œã¯ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã‚Œã¾ã›ã‚“ã€‚
<code>push</code>ã¯<code>Vec</code>ã®ãƒ¡ã‚½ãƒƒãƒ‰ã§ã€ã‚¹ãƒ©ã‚¤ã‚¹ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ã“ã‚Œã¯ã‚ˆã‚Šä¸€èˆ¬çš„ãªåŸå‰‡ã®ç¾ã‚Œã§ã™ã€‚
Rustã¯ã€ã‚¹ãƒ©ã‚¤ã‚¹ã‹ã‚‰è¦ç´ ã‚’è¿½åŠ ã¾ãŸã¯å‰Šé™¤ã•ã›ã¾ã›ã‚“ã€‚
ï¼ˆå¯å¤‰ã‚¹ãƒ©ã‚¤ã‚¹ã¯ã€ï¼‰ã™ã§ã«å­˜åœ¨ã™ã‚‹è¦ç´ ã®ã¿ã‚’ä¿®æ­£ï¼ç½®ãæ›ãˆã§ãã¾ã™ã€‚</p>
</blockquote>
<p>In this regard, a <code>&amp;mut Vec</code> or a <code>&amp;mut String</code> are strictly more powerful than a <code>&amp;mut [T]</code> or a <code>&amp;mut str</code>.<br />
Choose the type that best fits based on the operations you need to perform.</p>
<blockquote>
<p>ã“ã®è¦³ç‚¹ã‹ã‚‰ã€<code>&amp;mut Vec</code>ã¾ãŸã¯<code>&amp;mut String</code>ã¯ã€<code>&amp;mut [T]</code>ã¾ãŸã¯<code>&amp;mut str</code>ã‚ˆã‚Šã‚‚éå¸¸ã«å¼·åŠ›ã§ã™ã€‚
å®Ÿè¡Œã™ã‚‹å¿…è¦ãŒã‚ã‚‹æ“ä½œã«åŸºã¥ã„ã¦ã€æœ€é©ãªå‹ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚</p>
</blockquote>
<h2 id="exercise-68"><a class="header" href="#exercise-68">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/06_ticket_management/11_mutable_slices"><code>06_ticket_management/11_mutable_slices</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ticket-idsãƒã‚±ãƒƒãƒˆã®id"><a class="header" href="#ticket-idsãƒã‚±ãƒƒãƒˆã®id">Ticket idsï¼ˆãƒã‚±ãƒƒãƒˆã®IDï¼‰</a></h1>
<p>Let's think again about our ticket management system.<br />
Our ticket model right now looks like this:</p>
<blockquote>
<p>ãƒã‚±ãƒƒãƒˆç®¡ç†ã‚·ã‚¹ãƒ†ãƒ ã«ã¤ã„ã¦å†ã³è€ƒãˆã¾ã—ã‚‡ã†ã€‚
ç¾åœ¨ã€ãƒã‚±ãƒƒãƒˆãƒ¢ãƒ‡ãƒ«ã¯æ¬¡ã®ã‚ˆã†ã«ãªã£ã¦ã„ã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Ticket {
    pub title: TicketTitle,
    pub description: TicketDescription,
    pub status: Status
}
<span class="boring">}</span></code></pre></pre>
<p>One thing is missing here: an <strong>identifier</strong> to uniquely identify a ticket.<br />
That identifier should be unique for each ticket. That can be guaranteed by generating it automatically when
a new ticket is created.</p>
<blockquote>
<p>ã“ã“ã§1ã¤æ¬ ã‘ã¦ã„ã‚‹ã‚‚ã®ãŒã‚ã‚Šã¾ã™ã€‚ãƒã‚±ãƒƒãƒˆã‚’ä¸€æ„ã«è­˜åˆ¥ã™ã‚‹<strong>è­˜åˆ¥å­</strong>ã§ã™ã€‚
ãã®è­˜åˆ¥å­ã¯ãã‚Œãã‚Œã®ãƒã‚±ãƒƒãƒˆã§ä¸€æ„ã«ãªã‚‹ã¹ãã§ã™ã€‚
ãã‚Œã¯ã€æ–°ã—ã„ãƒã‚±ãƒƒãƒˆãŒä½œæˆã•ã‚ŒãŸã¨ãã€è‡ªå‹•çš„ã«è­˜åˆ¥å­ãŒç”Ÿæˆã•ã‚Œã‚‹ã“ã¨ã«ã‚ˆã‚Šä¿è¨¼ã•ã‚Œã¾ã™ã€‚</p>
</blockquote>
<h2 id="refining-the-modelãƒ¢ãƒ‡ãƒ«ã‚’æ´—ç·´ã™ã‚‹"><a class="header" href="#refining-the-modelãƒ¢ãƒ‡ãƒ«ã‚’æ´—ç·´ã™ã‚‹">Refining the modelï¼ˆãƒ¢ãƒ‡ãƒ«ã‚’æ´—ç·´ã™ã‚‹ï¼‰</a></h2>
<p>Where should the id be stored?<br />
We could add a new field to the <code>Ticket</code> struct:</p>
<blockquote>
<p>IDã‚’ã©ã“ã«ä¿å­˜ã™ã‚‹ã¹ãã§ã—ã‚‡ã†ã‹ï¼Ÿ
<code>Ticket</code>æ§‹é€ ä½“ã«æ–°ã—ã„ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’è¿½åŠ ã§ãã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Ticket {
    pub id: TicketId,
    pub title: TicketTitle,
    pub description: TicketDescription,
    pub status: Status
}
<span class="boring">}</span></code></pre></pre>
<p>But we don't know the id before creating the ticket. So it can't be there from the get-go.<br />
It'd have to be optional:</p>
<blockquote>
<p>ã—ã‹ã—ã€ãƒã‚±ãƒƒãƒˆã‚’ä½œæˆã™ã‚‹å‰ã«IDã¯ã‚ã‹ã‚Šã¾ã›ã‚“ã€‚ã‚ˆã£ã¦ã€æœ€åˆã‹ã‚‰ãã“ã«ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚
ãã‚Œã¯ã€ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Ticket {
    pub id: Option&lt;TicketId&gt;,
    pub title: TicketTitle,
    pub description: TicketDescription,
    pub status: Status
}
<span class="boring">}</span></code></pre></pre>
<p>That's also not idealâ€”we'd have to handle the <code>None</code> case every single time we retrieve a ticket from the store,
even though we know that the id should always be there once the ticket has been created.</p>
<blockquote>
<p>ãã‚Œã‚‚ã¾ãŸç†æƒ³çš„ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ãƒã‚±ãƒƒãƒˆã‚’ã‚¹ãƒˆã‚¢ã‹ã‚‰å–å¾—ã™ã‚‹ãŸã³ã«ã€ä¸€æ—¦ã€ãƒã‚±ãƒƒãƒˆãŒä½œæˆã•ã‚ŒãŸã‚‰ã€IDãŒå¸¸ã«å­˜åœ¨ã™ã‚‹ã“ã¨ã‚’çŸ¥ã£ã¦ã„ã‚‹ã«ã‚‚é–¢ã‚ã‚‰ãšã€<code>None</code>ã®ã‚±ãƒ¼ã‚¹ã‚’å‡¦ç†ã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚</p>
</blockquote>
<p>The best solution is to have two different ticket <strong>states</strong>, represented by two separate types:
a <code>TicketDraft</code> and a <code>Ticket</code>:</p>
<blockquote>
<p>æœ€å–„ã®è§£æ±ºç­–ã¯ã€<code>TicketDraft</code>ã¨<code>Ticket</code>ã®2ã¤ã®ç•°ãªã‚‹å‹ã«ã‚ˆã£ã¦è¡¨ç¾ã•ã‚Œã‚‹ã€2ã¤ã®ãƒã‚±ãƒƒãƒˆã®<strong>çŠ¶æ…‹</strong>ã‚’æŒã¤ã“ã¨ã§ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct TicketDraft {
    pub title: TicketTitle,
    pub description: TicketDescription
}

pub struct Ticket {
    pub id: TicketId,
    pub title: TicketTitle,
    pub description: TicketDescription,
    pub status: Status
}
<span class="boring">}</span></code></pre></pre>
<p>A <code>TicketDraft</code> is a ticket that hasn't been created yet. It doesn't have an id, and it doesn't have a status.<br />
A <code>Ticket</code> is a ticket that has been created. It has an id and a status.<br />
Since each field in <code>TicketDraft</code> and <code>Ticket</code> embeds its own constraints, we don't have to duplicate logic
across the two types.</p>
<blockquote>
<p><code>TicketDraft</code>ã¯ã€ã¾ã ä½œæˆã•ã‚Œã¦ã„ãªã„ãƒã‚±ãƒƒãƒˆã§ã™ã€‚ãã‚Œã¯IDã‚’æŒãŸãšã€ã¾ãŸçŠ¶æ…‹ã‚‚æŒã¡ã¾ã›ã‚“ã€‚
<code>Ticket</code>ã¯ã€ä½œæˆã•ã‚ŒãŸãƒã‚±ãƒƒãƒˆã§ã™ã€‚ãã‚Œã¯IDã¨çŠ¶æ…‹ã‚’æŒã¡ã¾ã™ã€‚
<code>TicketDraft</code>ã¨<code>Ticket</code>ã®ãã‚Œãã‚Œã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¯ã€ãã‚Œç‹¬è‡ªã®åˆ¶ç´„ã‚’åŸ‹ã‚è¾¼ã‚“ã§ã„ã‚‹ãŸã‚ã€2ã¤ã®å‹ã®é–“ã§ãƒ­ã‚¸ãƒƒã‚¯ã‚’é‡è¤‡ã—ãªã„ã‚ˆã†ã«ã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚</p>
</blockquote>
<h2 id="exercise-69"><a class="header" href="#exercise-69">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/06_ticket_management/12_two_states"><code>06_ticket_management/12_two_states</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="indexingã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹"><a class="header" href="#indexingã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹">Indexingï¼ˆã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ï¼‰</a></h1>
<p><code>TicketStore::get</code> returns an <code>Option&lt;&amp;Ticket&gt;</code> for a given <code>TicketId</code>.<br />
We've seen before how to access elements of arrays and vectors using Rust's
indexing syntax:</p>
<blockquote>
<p><code>TicketStore::get</code>ã¯ã€ç‰¹å®šã®<code>TicketId</code>ã«å¯¾ã—ã¦<code>Option&lt;&amp;Ticket&gt;</code>ã‚’è¿”ã—ã¾ã™ã€‚
å‰ã«ã€Rustã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹æ§‹æ–‡ã‚’ä½¿ç”¨ã—ã¦ã€é…åˆ—ã¨ãƒ™ã‚¯ã‚¿ãƒ¼ã®è¦ç´ ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹æ–¹æ³•ã‚’ç¢ºèªã—ã¾ã—ãŸã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = vec![0, 1, 2];
assert_eq!(v[0], 0);
<span class="boring">}</span></code></pre></pre>
<p>How can we provide the same experience for <code>TicketStore</code>?<br />
You guessed right: we need to implement a trait, <code>Index</code>!</p>
<blockquote>
<p><code>TicketStore</code>ã«å¯¾ã—ã¦åŒã˜çµŒé¨“ã‚’ã©ã®ã‚ˆã†ã«æä¾›ã§ãã‚‹ã§ã—ã‚‡ã†ã‹ï¼Ÿ
æ­£ã—ã„æ¨æ¸¬ã§ã™ã€‚<code>Index</code>ãƒˆãƒ¬ã‚¤ãƒˆã‚’å®Ÿè£…ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚</p>
</blockquote>
<h2 id="index"><a class="header" href="#index"><code>Index</code></a></h2>
<p>The <code>Index</code> trait is defined in Rust's standard library:</p>
<blockquote>
<p><code>Index</code>ãƒˆãƒ¬ã‚¤ãƒˆã¯ã€Rustæ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã«å®šç¾©ã•ã‚Œã¦ã„ã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Slightly simplified
// å°‘ã—ç°¡ç´ åŒ–ã•ã‚Œã¦ã„ã¾ã™ã€‚
pub trait Index&lt;Idx&gt;
{
    type Output;

    // Required method
    // è¦æ±‚ã•ã‚ŒãŸãƒ¡ã‚½ãƒƒãƒ‰ã§ã™ã€‚
    fn index(&amp;self, index: Idx) -&gt; &amp;Self::Output;
}
<span class="boring">}</span></code></pre></pre>
<p>It has:</p>
<ul>
<li>One generic parameter, <code>Idx</code>, to represent the index type</li>
<li>One associated type, <code>Output</code>, to represent the type we retrieved using the index</li>
</ul>
<blockquote>
<p>ãã‚Œã¯æ¬¡ã‚’æŒã£ã¦ã„ã¾ã™ã€‚</p>
<ul>
<li>ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã®å‹ã‚’è¡¨ç¾ã™ã‚‹<code>Idx</code>ã¨ã„ã†1ã¤ã®ã‚¸ã‚§ãƒãƒªãƒƒã‚¯ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼</li>
<li>ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’ä½¿ç”¨ã—ã¦å–å¾—ã•ã‚Œã‚‹å‹ã‚’è¡¨ç¾ã™ã‚‹é–¢é€£å‹ã®<code>Output</code></li>
</ul>
</blockquote>
<p>Notice how the <code>index</code> method doesn't return an <code>Option</code>. The assumption is that
<code>index</code> will panic if you try to access an element that's not there, as it happens
for array and vec indexing.</p>
<blockquote>
<p><code>index</code>ãƒ¡ã‚½ãƒƒãƒ‰ãŒ<code>Option</code>ã‚’è¿”ã•ãªã„ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚
æƒ³å®šã¯ã€é…åˆ—ã‚„ãƒ™ã‚¯ã‚¿ãƒ¼ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã«å¯¾ã—ã¦ç™ºç”Ÿã—ãŸã‚ˆã†ã«ã€å­˜åœ¨ã—ãªã„è¦ç´ ã«ã‚¢ã‚¯ã‚»ã‚¹ã‚’è©¦ã¿ãŸå ´åˆã€<code>index</code>ãŒãƒ‘ãƒ‹ãƒƒã‚¯ã™ã‚‹ã“ã¨ã§ã™ã€‚</p>
</blockquote>
<h2 id="exercise-70"><a class="header" href="#exercise-70">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/06_ticket_management/13_index"><code>06_ticket_management/13_index</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mutable-indexingå¯å¤‰ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹"><a class="header" href="#mutable-indexingå¯å¤‰ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹">Mutable indexingï¼ˆå¯å¤‰ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ï¼‰</a></h1>
<p><code>Index</code> allows read-only access. It doesn't let you mutate the value you
retrieved.</p>
<blockquote>
<p><code>Index</code>ã¯èª­ã¿è¾¼ã¿å°‚ç”¨ã‚¢ã‚¯ã‚»ã‚¹ã‚’è¨±å¯ã—ã¾ã™ã€‚ãã‚Œã¯å–å¾—ã—ãŸå€¤ã‚’å¤‰æ›´ã•ã›ã¾ã›ã‚“ã€‚</p>
</blockquote>
<h2 id="indexmut"><a class="header" href="#indexmut"><code>IndexMut</code></a></h2>
<p>If you want to allow mutability, you need to implement the <code>IndexMut</code> trait.</p>
<blockquote>
<p>å¤‰ç•°æ€§ã‚’è¨±å¯ã—ãŸã„å ´åˆã€<code>IndexMut</code>ãƒˆãƒ¬ã‚¤ãƒˆã‚’å®Ÿè£…ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Slightly simplified
pub trait IndexMut&lt;Idx&gt;: Index&lt;Idx&gt;
{
    // Required method
    fn index_mut(&amp;mut self, index: Idx) -&gt; &amp;mut Self::Output;
}
<span class="boring">}</span></code></pre></pre>
<p><code>IndexMut</code> can only be implemented if the type already implements <code>Index</code>,
since it unlocks an <em>additional</em> capability.</p>
<blockquote>
<p><code>IndexMut</code>ã¯ã€ãã‚ŒãŒ <em>è¿½åŠ </em> èƒ½åŠ›ã‚’ã‚¢ãƒ³ãƒ­ãƒƒã‚¯ã™ã‚‹ãŸã‚ã€å‹ãŒã™ã§ã«<code>Index</code>ã‚’å®Ÿè£…ã—ã¦ã„ã‚‹å ´åˆã«ã®ã¿å®Ÿè£…ã§ãã¾ã™ã€‚</p>
</blockquote>
<h2 id="exercise-71"><a class="header" href="#exercise-71">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/06_ticket_management/14_index_mut"><code>06_ticket_management/14_index_mut</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hashmap"><a class="header" href="#hashmap"><code>HashMap</code></a></h1>
<p>Our implementation of <code>Index</code>/<code>IndexMut</code> is not ideal: we need to iterate over the entire
<code>Vec</code> to retrieve a ticket by id; the algorithmic complexity is <code>O(n)</code>, where
<code>n</code> is the number of tickets in the store.</p>
<blockquote>
<p><code>Index</code>/<code>IndexMut</code>ã®å®Ÿè£…ã¯ç†æƒ³çš„ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚
IDã«ã‚ˆã£ã¦ãƒã‚±ãƒƒãƒˆã‚’å–å¾—ã™ã‚‹ãŸã‚ã«ã€<code>Vec</code>å…¨ä½“ã‚’åå¾©æ“ä½œã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚
ãã®ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã®è¤‡é›‘ã•ã¯<code>O(n)</code>ã§ã€<code>n</code>ã¯ã‚¹ãƒˆã‚¢å†…ã®ãƒã‚±ãƒƒãƒˆã®æ•°ã§ã™ã€‚</p>
</blockquote>
<p>We can do better by using a different data structure for storing tickets: a <code>HashMap&lt;K, V&gt;</code>.</p>
<blockquote>
<p>ãƒã‚±ãƒƒãƒˆã‚’æ ¼ç´ã™ã‚‹ãŸã‚ã«ç•°ãªã‚‹ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã§ã‚ã‚‹<code>HashMap&lt;K, V&gt;</code>ã‚’ä½¿ç”¨ã—ã¦ã€ã‚ˆã‚Šè‰¯ãè¡Œã†ã“ã¨ãŒã§ãã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

// Type inference lets us omit an explicit type signature (which
// would be `HashMap&lt;String, String&gt;` in this example).
// å‹æ¨è«–ã¯ã€æ˜ç¤ºçš„ãªå‹ã®ã‚·ã‚°ãƒãƒãƒ£ãƒ¼ã‚’çœç•¥ã§ãã‚‹ã‚ˆã†ã«ã—ã¦ã€ã“ã®ä¾‹ã§ã¯`HashMap&lt;String, String&gt;`ã«ãªã‚Šã¾ã™ã€‚
let mut book_reviews = HashMap::new();

book_reviews.insert(
    "Adventures of Huckleberry Finn".to_string(),
    "My favorite book.".to_string(),
);
<span class="boring">}</span></code></pre></pre>
<p><code>HashMap</code> works with key-value pairs. It's generic over both: <code>K</code> is the generic
parameter for the key type, while <code>V</code> is the one for the value type.</p>
<blockquote>
<p><code>HashMap</code>ã¯ã€ã‚­ãƒ¼ã¨å€¤ã®ãƒšã‚¢ã§æ©Ÿèƒ½ã—ã¾ã™ã€‚ãã‚Œã¯ä¸¡æ–¹ã¨ã‚‚ã‚¸ã‚§ãƒãƒªãƒƒã‚¯ã§ã™ã€‚
<code>K</code>ã¯ã‚­ãƒ¼å‹ã®ã‚¸ã‚§ãƒãƒªãƒƒã‚¯ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ã§ã€<code>V</code>ã¯å€¤å‹ã®ã‚¸ã‚§ãƒãƒªãƒƒã‚¯ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ã§ã™ã€‚</p>
</blockquote>
<p>The expected cost of insertions, retrievals and removals is <strong>constant</strong>, <code>O(1)</code>.
That sounds perfect for our usecase, doesn't it?</p>
<blockquote>
<p>æŒ¿å…¥ã€å–å¾—ãã—ã¦å‰Šé™¤ã®æœŸå¾…ã•ã‚Œã‚‹ã‚³ã‚¹ãƒˆã¯<strong>ä¸€å®š</strong>ã§ã€<code>O(1)</code>ã§ã™ã€‚
ãƒ¦ãƒ¼ã‚¹ã‚±ãƒ¼ã‚¹ã«ã¨ã£ã¦å®Œç’§ã§ã™ã‚ˆã­ï¼Ÿ</p>
</blockquote>
<h2 id="key-requirementsã‚­ãƒ¼ã®è¦æ±‚äº‹é …"><a class="header" href="#key-requirementsã‚­ãƒ¼ã®è¦æ±‚äº‹é …">Key requirementsï¼ˆã‚­ãƒ¼ã®è¦æ±‚äº‹é …ï¼‰</a></h2>
<p>There are no trait bounds on <code>HashMap</code>'s struct definition, but you'll find some
on its methods. Let's look at <code>insert</code>, for example:</p>
<blockquote>
<p><code>HashMap</code>æ§‹é€ ä½“ã®å®šç¾©ã¯ãƒˆãƒ¬ã‚¤ãƒˆåˆ¶ç´„ãŒã‚ã‚Šã¾ã›ã‚“ãŒã€ãã®ãƒ¡ã‚½ãƒƒãƒ‰ã§ã„ãã¤ã‹ç¢ºèªã§ãã¾ã™ã€‚
ä¾‹ã¨ã—ã¦ã€<code>insert</code>ã‚’ç¢ºèªã—ã¾ã—ã‚‡ã†ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Slightly simplified
impl&lt;K, V&gt; HashMap&lt;K, V&gt;
where
    K: Eq + Hash,
{
    pub fn insert(&amp;mut self, k: K, v: V) -&gt; Option&lt;V&gt; {
        // [...]
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The key type must implement the <code>Eq</code> and <code>Hash</code> traits.<br />
Let's dig into those two.</p>
<blockquote>
<p>ã‚­ãƒ¼å‹ã¯ã€<code>Eq</code>ã¨<code>Hash</code>ãƒˆãƒ¬ã‚¤ãƒˆã‚’å®Ÿè£…ã—ãªãã¦ã¯ãªã‚Šã¾ã›ã‚“ã€‚
ãã‚Œã‚‰2ã¤ã®æ·±å €ã‚Šã—ã¾ã—ã‚‡ã†ã€‚</p>
</blockquote>
<h2 id="hash"><a class="header" href="#hash"><code>Hash</code></a></h2>
<p>A hashing function (or hasher) maps a potentially infinite set of a values (e.g.
all possible strings) to a bounded range (e.g. a <code>u64</code> value).<br />
There are many different hashing functions around, each with different properties
(speed, collision risk, reversibility, etc.).</p>
<blockquote>
<p>ãƒãƒƒã‚·ãƒ¥é–¢æ•°ã¾ãŸã¯ãƒãƒƒã‚·ãƒ£ãƒ¼ã¯ã€ä¾‹ãˆã°ã™ã¹ã¦ã®è€ƒãˆã‚‰ã‚Œã‚‹æ–‡å­—åˆ—ãªã©æ½œåœ¨çš„ãªå€¤ã®ç„¡é™é›†åˆã‚’ã€ä¾‹ãˆã°<code>u64</code>å€¤ãªã©ã®åˆ¶é™ã•ã‚ŒãŸç¯„å›²ã«ãƒãƒƒãƒ”ãƒ³ã‚°ã—ã¾ã™ã€‚
å¤šãã®ç•°ãªã‚‹ãƒãƒƒã‚·ãƒ¥é–¢æ•°ãŒã‚ã‚Šã€ãã‚Œãã‚Œã¯ç•°ãªã‚‹ç‰¹å¾´ã‚’æŒã£ã¦ã„ã¾ã™ï¼ˆæ—©ã•ã€è¡çªãƒªã‚¹ã‚¯ã€å¯é€†æ€§ãªã©ï¼‰ã€‚</p>
</blockquote>
<p>A <code>HashMap</code>, as the name suggests, uses a hashing function behind the scene.
It hashes your key and then uses that hash to store/retrieve the associated value.
This strategy requires the key type must be hashable, hence the <code>Hash</code> trait bound on <code>K</code>.</p>
<blockquote>
<p>åå‰ãŒç¤ºå”†ã™ã‚‹é€šã‚Š<code>HashMap</code>ã¯ã€èƒŒå¾Œã§ãƒãƒƒã‚·ãƒ¥é–¢æ•°ã‚’ä½¿ç”¨ã—ã¦ã„ã¾ã™ã€‚
ãã‚Œã¯ã‚­ãƒ¼ã‚’ãƒãƒƒã‚·ãƒ¥åŒ–ã—ã¦ã€é–¢é€£ã—ãŸå€¤ã‚’ä¿å­˜ï¼å–å¾—ã™ã‚‹ãŸã‚ã«ãã®ãƒãƒƒã‚·ãƒ¥ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚
ã“ã®æˆ¦ç•¥ã¯ã€ã‚­ãƒ¼å‹ãŒãƒãƒƒã‚·ãƒ¥å¯èƒ½ã§ãªãã¦ã¯ãªã‚‰ãšã€ãã®ãŸã‚<code>Hash</code>ãƒˆãƒ¬ã‚¤ãƒˆãŒ<code>K</code>ã«åˆ¶ç´„ã•ã‚Œã¦ã„ã¾ã™ã€‚</p>
</blockquote>
<p>You can find the <code>Hash</code> trait in the <code>std::hash</code> module:</p>
<blockquote>
<p><code>Hash</code>ãƒˆãƒ¬ã‚¤ãƒˆã¯<code>std::hash</code>ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ã‚ã‚Šã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Hash {
    // Required method
    fn hash&lt;H&gt;(&amp;self, state: &amp;mut H)
       where H: Hasher;
}
<span class="boring">}</span></code></pre></pre>
<p>You will rarely implement <code>Hash</code> manually. Most of the times you'll derive it:</p>
<blockquote>
<p>ã¾ã‚Œã«æ‰‹å‹•ã§<code>Hash</code>ã‚’å®Ÿè£…ã—ã¾ã™ã€‚ã»ã¨ã‚“ã©ã®å ´åˆã€ãã‚Œã‚’å°å‡ºã—ã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Hash)]
struct Person {
    id: u32,
    name: String,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="eq"><a class="header" href="#eq"><code>Eq</code></a></h2>
<p><code>HashMap</code> must be able to compare keys for equality. This is particularly important
when dealing with hash collisionsâ€”i.e. when two different keys hash to the same value.</p>
<blockquote>
<p><code>HashMap</code>ã¯ã€ç­‰ä¾¡æ€§ã®ãŸã‚ã«ã‚­ãƒ¼ã‚’æ¯”è¼ƒã§ããªãã¦ã¯ãªã‚Šã¾ã›ã‚“ã€‚
ä¾‹ãˆã°2ã¤ã®ç•°ãªã‚‹ã‚­ãƒ¼ãŒåŒã˜å€¤ã«ãƒãƒƒã‚·ãƒ¥åŒ–ã•ã‚Œã€ãƒãƒƒã‚·ãƒ¥ã®è¡çªã‚’æ‰±ã†ã¨ãã€ã“ã‚Œã¯ç‰¹ã«é‡è¦ã«ãªã‚Šã¾ã™ã€‚</p>
</blockquote>
<p>You may wonder: isn't that what the <code>PartialEq</code> trait is for? Almost!<br />
<code>PartialEq</code> is not enough for <code>HashMap</code> because it doesn't guarantee reflexivity, i.e. <code>a == a</code> is always <code>true</code>.<br />
For example, floating point numbers (<code>f32</code> and <code>f64</code>) implement <code>PartialEq</code>,
but they don't satisfy the reflexivity property: <code>f32::NAN == f32::NAN</code> is <code>false</code>.<br />
Reflexivity is crucial for <code>HashMap</code> to work correctly: without it, you wouldn't be able to retrieve a value
from the map using the same key you used to insert it.</p>
<blockquote>
<p>å›°æƒ‘ã—ã¦ã„ã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚ãã®ãŸã‚ã®<code>PartialEq</code>ãƒˆãƒ¬ã‚¤ãƒˆã§ã¯ãªã„ã§ã—ã‚‡ã†ã‹ï¼Ÿã»ã¼ãã†ã§ã™ï¼
ä¾‹ãˆã°ã€<code>a == a</code>ãŒå¸¸ã«<code>true</code>ã§ã‚ã‚‹ãªã©ã€<code>PartialEq</code>ã¯åå°„æ€§ã‚’ä¿è¨¼ã—ãªã„ãŸã‚ã€<code>HashMap</code>ã«ã¯ååˆ†ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚
ä¾‹ãˆã°ã€æµ®å‹•å°æ•°ç‚¹æ•°ï¼ˆ<code>f32</code>ã¨<code>f64</code>ï¼‰ã¯<code>PartialEq</code>ã‚’å®Ÿè£…ã—ã¦ã„ã¾ã™ãŒã€<code>f32::NAN == f32::NAN</code>ãŒ<code>å½</code>ã«ãªã‚‹ã‚ˆã†ã«ã€ãã‚Œã‚‰ã¯åå°„æ€§ã®ç‰¹å¾´ã‚’æº€ãŸã—ã¦ã„ã¾ã›ã‚“ã€‚
åå°„æ€§ã¯ã€<code>HashMap</code>ãŒæ­£ç¢ºã«å‹•ä½œã™ã‚‹ãŸã‚ã«æ¥µã‚ã¦é‡è¦ã§ã™ã€‚
ãã‚Œï¼ˆåå°„æ€§ï¼‰ãªã—ã§ã€æŒ¿å…¥ã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã—ãŸåŒã˜ã‚­ãƒ¼ã‚’ä½¿ç”¨ã—ã¦ã€ãƒãƒƒãƒ—ã‹ã‚‰å€¤ã‚’å–ã‚Šå‡ºã™ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚</p>
</blockquote>
<p>The <code>Eq</code> trait extends <code>PartialEq</code> with the reflexivity property:</p>
<blockquote>
<p><code>Eq</code>ãƒˆãƒ¬ã‚¤ãƒˆã¯ã€åå°„æ€§ã®ç‰¹æ€§ã‚’æŒã¤<code>PartialEq</code>ã‚’æ‹¡å¼µã—ã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Eq: PartialEq {
    // No additional methods
}
<span class="boring">}</span></code></pre></pre>
<p>It's a marker trait: it doesn't add any new methods, it's just a way for you to say to the compiler
that the equality logic implemented in <code>PartialEq</code> is reflexive.</p>
<blockquote>
<p>ãã‚Œã¯ãƒãƒ¼ã‚«ãƒ¼ãƒˆãƒ¬ã‚¤ãƒˆã§ã™ã€‚ãã‚Œã¯ä»»æ„ã®æ–°ã—ã„ãƒ¡ã‚½ãƒƒãƒ‰ã‚’è¿½åŠ ã›ãšã€<code>PartialEq</code>å†…ã«å®Ÿè£…ã•ã‚ŒãŸç­‰ä¾¡æ€§ãƒ­ã‚¸ãƒƒã‚¯ãŒåå°„æ€§ã§ã‚ã‚‹ã“ã¨ã‚’ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ¼ã«ä¼ãˆã‚‹å˜ãªã‚‹æ–¹æ³•ã§ã™ã€‚</p>
</blockquote>
<p>You can derive <code>Eq</code> automatically when you derive <code>PartialEq</code>:</p>
<blockquote>
<p><code>PartialEq</code>ã‚’å°å‡ºã™ã‚‹ã¨ãã€<code>Eq</code>ã‚’è‡ªå‹•ã§å°å‡ºã§ãã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(PartialEq, Eq)]
struct Person {
    id: u32,
    name: String,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="eq-and-hash-are-linkedeqã¨hashã¯ãƒªãƒ³ã‚¯ã•ã‚Œã¦ã„ã‚‹"><a class="header" href="#eq-and-hash-are-linkedeqã¨hashã¯ãƒªãƒ³ã‚¯ã•ã‚Œã¦ã„ã‚‹"><code>Eq</code> and <code>Hash</code> are linkedï¼ˆEqã¨Hashã¯ãƒªãƒ³ã‚¯ã•ã‚Œã¦ã„ã‚‹ï¼‰</a></h2>
<p>There is an implicit contract between <code>Eq</code> and <code>Hash</code>: if two keys are equal, their hashes must be equal too.
This is crucial for <code>HashMap</code> to work correctly. If you break this contract, you'll get nonsensical results
when using <code>HashMap</code>.</p>
<blockquote>
<p>æš—é»™çš„ãªå¥‘ç´„ãŒ<code>Eq</code>ã¨<code>Hash</code>é–“ã«ã‚ã‚Šã¾ã™ã€‚2ã¤ã®ã‚­ãƒ¼ãŒç­‰ã—ã„å ´åˆã€ãã‚Œã‚‰ã®ãƒãƒƒã‚·ãƒ¥ã‚‚ç­‰ã—ããªã‚‰ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚
ã“ã‚ŒãŒã€<code>HashMap</code>ãŒæ­£ç¢ºã«å‹•ä½œã™ã‚‹ãŸã‚ã«æ¥µã‚ã¦é‡è¦ã§ã™ã€‚
ã“ã®å¥‘ç´„ã‚’ç ´ã£ãŸå ´åˆã€<code>HashMap</code>ã‚’ä½¿ç”¨ã—ãŸã¨ãã€ç„¡æ„å‘³ãªçµæœãŒå¾—ã‚‰ã‚Œã¾ã™ã€‚</p>
</blockquote>
<h2 id="exercise-72"><a class="header" href="#exercise-72">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/06_ticket_management/15_hashmap"><code>06_ticket_management/15_hashmap</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="orderingé †åº"><a class="header" href="#orderingé †åº">Orderingï¼ˆé †åºï¼‰</a></h1>
<p>By moving from a <code>Vec</code> to a <code>HashMap</code> we have improved the performance of our ticket management system,
and simplified our code in the process.<br />
It's not all roses, though. When iterating over a <code>Vec</code>-backed store, we could be sure that the tickets
would be returned in the order they were added.<br />
That's not the case with a <code>HashMap</code>: you can iterate over the tickets, but the order is random.</p>
<blockquote>
<p><code>Vec</code>ã‹ã‚‰<code>HashMap</code>ã¸ã®ç§»è¡Œã«ã‚ˆã‚Šã€ãƒã‚±ãƒƒãƒˆç®¡ç†ã‚·ã‚¹ãƒ†ãƒ ã®æ€§èƒ½ã‚’æ”¹å–„ã—ã¦ã€ãã®éç¨‹ã§ã‚³ãƒ¼ãƒ‰ã‚’ç°¡ç´ åŒ–ã—ã¾ã—ãŸã€‚
ãŸã ã—ã€ã™ã¹ã¦ãŒãƒãƒ©è‰²ã¨ã¯é™ã‚Šã¾ã›ã‚“ã€‚<code>Vec</code>ã«è£ä»˜ã‘ã•ã‚ŒãŸã‚¹ãƒˆã‚¢ã‚’åå¾©æ“ä½œã™ã‚‹ã¨ãã€ãƒã‚±ãƒƒãƒˆãŒè¿½åŠ ã•ã‚ŒãŸé †ç•ªã§è¿”ã•ã‚Œã‚‹ã“ã¨ã‚’ç¢ºä¿¡ã§ãã¾ã—ãŸã€‚
<code>HashMap</code>ã§ã¯ãã‚Œã¯å½“ã¦ã¯ã¾ã‚Šã¾ã›ã‚“ã€‚ãƒã‚±ãƒƒãƒˆã‚’åå¾©æ“ä½œã§ãã¾ã™ãŒã€é †åºã¯ãƒ©ãƒ³ãƒ€ãƒ ã§ã™ã€‚</p>
</blockquote>
<p>We can recover a consistent ordering by switching from a <code>HashMap</code> to a <code>BTreeMap</code>.</p>
<blockquote>
<p><code>HashMap</code>ã‹ã‚‰<code>BTreeMap</code>ã«åˆ‡ã‚Šæ›¿ãˆã‚‹ã“ã¨ã§ã€é †ç•ªã®ä¸€è²«æ€§ã‚’å›å¾©ã§ãã¾ã™ã€‚</p>
</blockquote>
<h2 id="btreemap"><a class="header" href="#btreemap"><code>BTreeMap</code></a></h2>
<p>A <code>BTreeMap</code> guarantees that entries are sorted by their keys.<br />
This is useful when you need to iterate over the entries in a specific order, or if you need to
perform range queries (e.g. "give me all tickets with an id between 10 and 20").</p>
<blockquote>
<p><code>BTreeMap</code>ã¯ã€ã‚¨ãƒ³ãƒˆãƒªãƒ¼ãŒãã‚Œã‚‰ã®ã‚­ãƒ¼ã«ã‚ˆã£ã¦ä¸¦ã¹æ›¿ãˆã•ã‚Œã‚‹ã“ã¨ã‚’ä¿è¨¼ã—ã¾ã™ã€‚
ç‰¹å®šã®é †ç•ªã§ã‚¨ãƒ³ãƒˆãƒªãƒ¼ã‚’åå¾©æ“ä½œã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã¨ãã€ã¾ãŸã¯ã€ä¾‹ãˆã°ã€10ã¨20ã®é–“ã®IDã‚’æŒã¤ã™ã¹ã¦ã®ãƒã‚±ãƒƒãƒˆã‚’å–å¾—ã™ã‚‹ãªã©ã€ç¯„å›²ã‚¯ã‚¨ãƒªã‚’å®Ÿè¡Œã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã¨ãã€ã“ã‚Œã¯ä¾¿åˆ©ã§ã™ã€‚</p>
</blockquote>
<p>Just like <code>HashMap</code>, you won't find trait bounds on the definition of <code>BTreeMap</code>.
But you'll find trait bounds on its methods. Let's look at <code>insert</code>:</p>
<blockquote>
<p>ã¡ã‚‡ã†ã©<code>HashMap</code>ã¨åŒæ§˜ã«ã€<code>BTreeMap</code>ã®å®šç¾©ã«ãƒˆãƒ¬ã‚¤ãƒˆåˆ¶ç´„ã‚’è¦‹ã¤ã‘ã‚Œãªã„ã§ã—ã‚‡ã†ã€‚
ã—ã‹ã—ã€ãã®ãƒ¡ã‚½ãƒƒãƒ‰ã«ãƒˆãƒ¬ã‚¤ãƒˆåˆ¶ç´„ã‚’è¦‹ã¤ã‘ã‚‹ã§ã—ã‚‡ã†ã€‚<code>insert</code>ã‚’ç¢ºèªã—ã¾ã—ã‚‡ã†ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// `K` and `V` stand for the key and value types, respectively,
// just like in `HashMap`.
// `K`ã¨`V`ã¯ã€ã¡ã‚‡ã†ã©`HashMap`ã¨åŒæ§˜ã«ã€ãã‚Œãã‚Œã‚­ãƒ¼ã¨å€¤ã®å‹ã‚’è¡¨ã—ã¾ã™ã€‚
impl&lt;K, V&gt; BTreeMap&lt;K, V&gt; {
    pub fn insert(&amp;mut self, key: K, value: V) -&gt; Option&lt;V&gt;
    where
        K: Ord,
    {
        // implementation
    }
}
<span class="boring">}</span></code></pre></pre>
<p><code>Hash</code> is no longer required. Instead, the key type must implement the <code>Ord</code> trait.</p>
<blockquote>
<p><code>Hash</code>ã¯ã‚‚ã¯ã‚„è¦æ±‚ã•ã‚Œã¾ã›ã‚“ã€‚ä»£ã‚ã‚Šã«ã€ã‚­ãƒ¼å‹ã¯<code>Ord</code>ãƒˆãƒ¬ã‚¤ãƒˆã‚’å®Ÿè£…ã—ãªãã¦ã¯ãªã‚Šã¾ã›ã‚“ã‚“ã€‚</p>
</blockquote>
<h2 id="ord"><a class="header" href="#ord"><code>Ord</code></a></h2>
<p>The <code>Ord</code> trait is used to compare values.<br />
While <code>PartialEq</code> is used to compare for equality, <code>Ord</code> is used to compare for ordering.</p>
<blockquote>
<p><code>Ord</code>ãƒˆãƒ¬ã‚¤ãƒˆã¯å€¤ã‚’æ¯”è¼ƒã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚
<code>PartialEq</code>ãŒç­‰ä¾¡æ€§ã‚’æ¯”è¼ƒã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã‚‹ä¸€æ–¹ã§ã€<code>Ord</code>ã¯é †åºã‚’æ¯”è¼ƒã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚</p>
</blockquote>
<p>It's defined in <code>std::cmp</code>:</p>
<blockquote>
<p>ãã‚Œã¯<code>std::cmp</code>ã§å®šç¾©ã•ã‚Œã¦ã„ã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Ord: Eq + PartialOrd {
    fn cmp(&amp;self, other: &amp;Self) -&gt; Ordering;
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>cmp</code> method returns an <code>Ordering</code> enum, which can be one
of <code>Less</code>, <code>Equal</code>, or <code>Greater</code>.<br />
<code>Ord</code> requires that two other traits are implemented: <code>Eq</code> and <code>PartialOrd</code>.</p>
<blockquote>
<p><code>cmp</code>ãƒ¡ã‚½ãƒƒãƒ‰ã¯<code>Ordering</code>åˆ—æŒ™å‹ã‚’è¿”ã—ã€ãã‚Œã¯<code>Less</code>ã€<code>Equal</code>ã€ã¾ãŸã¯<code>Greater</code>ã®ã„ãšã‚Œã‹ã«ãªã‚Šã¾ã™ã€‚
<code>Ord</code>ã¯ã€<code>Eq</code>ã¨<code>PartialOrd</code>ã®2ã¤ã®ä»–ã®ãƒˆãƒ¬ã‚¤ãƒˆãŒå®Ÿè£…ã•ã‚Œã¦ã„ã‚‹ã“ã¨ã‚’è¦æ±‚ã—ã¾ã™ã€‚</p>
</blockquote>
<h2 id="partialord"><a class="header" href="#partialord"><code>PartialOrd</code></a></h2>
<p><code>PartialOrd</code> is a weaker version of <code>Ord</code>, just like <code>PartialEq</code> is a weaker version of <code>Eq</code>.
You can see why by looking at its definition:</p>
<blockquote>
<p><code>PartialOrd</code>ã¯<code>Ord</code>ã®å¼±ã„ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã§ã€ã¡ã‚‡ã†ã©<code>PartialEq</code>ãŒ<code>Eq</code>ã®å¼±ã„ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã§ã‚ã‚‹ã“ã¨ã¨åŒã˜ã§ã™ã€‚
ãã®å®šç¾©ã‚’ç¢ºèªã™ã‚‹ã“ã¨ã§ã€ç†ç”±ãŒã‚ã‹ã‚Šã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait PartialOrd: PartialEq {
    fn partial_cmp(&amp;self, other: &amp;Self) -&gt; Option&lt;Ordering&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p><code>PartialOrd::partial_cmp</code> returns an <code>Option</code>â€”it is not guaranteed that two values can
be compared.<br />
For example, <code>f32</code> doesn't implement <code>Ord</code> because <code>NaN</code> values are not comparable,
the same reason why <code>f32</code> doesn't implement <code>Eq</code>.</p>
<blockquote>
<p><code>PartialOrd::partial_cmp</code>ã¯<code>Option</code>ã‚’è¿”ã—ã¾ã™ã€‚ãã‚Œã¯ã€2ã¤ã®å€¤ãŒæ¯”è¼ƒã§ãã‚‹ã“ã¨ã‚’ä¿è¨¼ã—ã¾ã›ã‚“ã€‚
ä¾‹ãˆã°ã€<code>NaN</code>å€¤ã¯æ¯”è¼ƒå¯èƒ½ã§ãªã„ãŸã‚ã€<code>f32</code>ã¯<code>Ord</code>ã‚’å®Ÿè£…ã—ã¦ãŠã‚‰ãšã€åŒã˜ç†ç”±ã§<code>f32</code>ã¯<code>Eq</code>ã‚’å®Ÿè£…ã—ã¦ã„ã¾ã›ã‚“ã€‚</p>
</blockquote>
<h2 id="implementing-ord-and-partialordordã¨partialordã®å®Ÿè£…"><a class="header" href="#implementing-ord-and-partialordordã¨partialordã®å®Ÿè£…">Implementing <code>Ord</code> and <code>PartialOrd</code>ï¼ˆOrdã¨PartialOrdã®å®Ÿè£…ï¼‰</a></h2>
<p>Both <code>Ord</code> and <code>PartialOrd</code> can be derived for your types:</p>
<blockquote>
<p><code>Ord</code>ã¨<code>PartialOrd</code>ä¸¡æ–¹ã¯ã€å‹ã‹ã‚‰å°å‡ºã§ãã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// You need to add `Eq` and `PartialEq` too,
// since `Ord` requires them.
// `Ord`ãŒè¦æ±‚ã™ã‚‹ãŸã‚ã€`Eq`ã¨`PartialEq`ã‚’è¿½åŠ ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚
#[derive(Eq, PartialEq, Ord, PartialOrd)]
struct TicketId(u64);
<span class="boring">}</span></code></pre></pre>
<p>If you choose (or need) to implement them manually, be careful:</p>
<ul>
<li><code>Ord</code> and <code>PartialOrd</code> must be consistent with <code>Eq</code> and <code>PartialEq</code>.</li>
<li><code>Ord</code> and <code>PartialOrd</code> must be consistent with each other.</li>
</ul>
<blockquote>
<p>æ‰‹å‹•ã§ãã‚Œã‚‰ã‚’å®Ÿè£…ã™ã‚‹ã“ã¨ã‚’é¸æŠã¾ãŸã¯å¿…è¦ãŒã‚ã‚‹å ´åˆã€æ¬¡ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚</p>
<ul>
<li><code>Ord</code>ã¨<code>PartialOrd</code>ã¯ã€<code>Eq</code>ã¨<code>PartialEq</code>ã¨ä¸€è²«æ€§ã‚’æŒãŸãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚</li>
<li><code>Ord</code>ã¨<code>PartialOrd</code>ã¯ã€ãã‚Œãã‚Œã¨ä¸€è²«æ€§ã‚’æŒãŸã›ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚</li>
</ul>
</blockquote>
<h2 id="exercise-73"><a class="header" href="#exercise-73">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/06_ticket_management/16_btreemap"><code>06_ticket_management/16_btreemap</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introå°å…¥"><a class="header" href="#introå°å…¥">Introï¼ˆå°å…¥ï¼‰</a></h1>
<p>One of Rust's big promises is <em>fearless concurrency</em>: making it easier to write safe, concurrent programs.
We haven't seen much of that yet. All the work we've done so far has been single-threaded.
Time to change that!</p>
<blockquote>
<p>Rustã®å¤§ããªç´„æŸã¯ã€ <em>æã‚Œã‚’çŸ¥ã‚‰ãªã„åŒæ™‚ä¸¦è¡Œ</em> ã§ã™ã€‚ãã‚Œã¯å®‰å…¨ã«ä¸¦åŒæ™‚ä¸¦è¡Œãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’è¨˜è¿°ã§ãã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚
ã“ã‚Œã¾ã§ã‚ã¾ã‚Šç¢ºèªã¦ãã¾ã›ã‚“ã§ã—ãŸã€‚ã“ã‚Œã¾ã§ã«è¡Œã£ã¦ããŸã™ã¹ã¦ã®ä½œæ¥­ã¯å˜ä¸€ã‚¹ãƒ¬ãƒƒãƒ‰ã§ã—ãŸã€‚
ãã‚Œã‚’å¤‰ãˆã‚‹æ™‚ãŒãã¾ã—ãŸï¼</p>
</blockquote>
<p>In this chapter we'll make our ticket store multithreaded.<br />
We'll have the opportunity to touch most of Rust's core concurrency features, including:</p>
<ul>
<li>Threads, using the <code>std::thread</code> module</li>
<li>Message passing, using channels</li>
<li>Shared state, using <code>Arc</code>, <code>Mutex</code> and <code>RwLock</code></li>
<li><code>Send</code> and <code>Sync</code>, the traits that encode Rust's concurrency guarantees</li>
</ul>
<blockquote>
<p>ã“ã®ç« ã«ãŠã„ã¦ã€ãƒãƒ«ãƒã‚¹ãƒ¬ãƒƒãƒ‰ãªãƒã‚±ãƒƒãƒˆã‚¹ãƒˆã‚¢ã‚’ä½œæˆã—ã¾ã™ã€‚
æ¬¡ã®ã‚ˆã†ãªRustã®ä¸»è¦ãªåŒæ™‚ä¸¦è¡Œæ©Ÿèƒ½ã®ã»ã¨ã‚“ã©ã«è§¦ã‚Œã‚‹æ©Ÿä¼šã‚’æŒã¡ã¾ã™ã€‚</p>
<ul>
<li><code>std::thread</code>ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ä½¿ç”¨ã—ãŸã‚¹ãƒ¬ãƒƒãƒ‰</li>
<li>ãƒãƒ£ãƒãƒ«ã‚’ä½¿ç”¨ã—ãŸãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é€ä¿¡</li>
<li><code>Arc</code>ã€<code>Mutex</code>ãã—ã¦<code>RwLock</code>ã‚’ä½¿ç”¨ã—ãŸå…±æœ‰ã•ã‚ŒãŸçŠ¶æ…‹</li>
<li>Rustã®åŒæ™‚ä¸¦è¡Œæ€§ã®ä¿è¨¼ã‚’ç¬¦å·åŒ–ã™ã‚‹<code>Send</code>ã¨<code>Sync</code>ãƒˆãƒ¬ã‚¤ãƒˆ</li>
</ul>
</blockquote>
<p>We'll also discuss various design patterns for multithreaded systems and some of their trade-offs.</p>
<blockquote>
<p>ã¾ãŸã€ãƒãƒ«ãƒã‚¹ãƒ¬ãƒƒãƒ‰ã‚·ã‚¹ãƒ†ãƒ ã®ãŸã‚ã®ã•ã¾ã–ã¾ãªãƒ‡ã‚¶ã‚¤ãƒ³ãƒ‘ã‚¿ãƒ¼ãƒ³ã¨ã€ãã‚Œã‚‰ã®ã„ãã¤ã‹ã®äºŒå¾‹èƒŒåã«ã¤ã„ã¦ã‚‚è­°è«–ã—ã¾ã™ã€‚</p>
</blockquote>
<h2 id="exercise-74"><a class="header" href="#exercise-74">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/07_threads/00_intro"><code>07_threads/00_intro</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="threadsã‚¹ãƒ¬ãƒƒãƒ‰"><a class="header" href="#threadsã‚¹ãƒ¬ãƒƒãƒ‰">Threadsï¼ˆã‚¹ãƒ¬ãƒƒãƒ‰ï¼‰</a></h1>
<p>Before we start writing multithreaded code, let's take a step back and talk about what threads are
and why we might want to use them.</p>
<blockquote>
<p>ãƒãƒ«ãƒã‚¹ãƒ¬ãƒƒãƒ‰ãªã‚³ãƒ¼ãƒ‰ã®è¨˜è¿°ã‚’é–‹å§‹ã™ã‚‹å‰ã«ã€ä¸€æ­©æˆ»ã£ã¦ã‚¹ãƒ¬ãƒƒãƒ‰ã¨ã¯ä½•ã‹ã€ãã—ã¦ãã‚Œã‚‰ã‚’ä½¿ç”¨ã—ãŸã„ç†ç”±ã«ã¤ã„ã¦è©±ã—ã¾ã—ã‚‡ã†ã€‚</p>
</blockquote>
<h2 id="what-is-a-threadã‚¹ãƒ¬ãƒƒãƒ‰ã¨ã¯"><a class="header" href="#what-is-a-threadã‚¹ãƒ¬ãƒƒãƒ‰ã¨ã¯">What is a thread?ï¼ˆã‚¹ãƒ¬ãƒƒãƒ‰ã¨ã¯ï¼Ÿï¼‰</a></h2>
<p>A <strong>thread</strong> is an execution context managed by the underlying operating system.<br />
Each thread has its own stack, instruction pointer, and program counter.</p>
<blockquote>
<p><strong>ã‚¹ãƒ¬ãƒƒãƒ‰</strong>ã¯ã€åŸºç¤ã¨ãªã‚‹ã‚ªãƒšãƒ¬ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ ã«ã‚ˆã£ã¦ç®¡ç†ã•ã‚ŒãŸå®Ÿè¡Œã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã§ã™ã€‚
ãã‚Œãã‚Œã®ã‚¹ãƒ¬ãƒƒãƒ‰ã¯ãã‚Œç‹¬è‡ªã®ã‚¹ã‚¿ãƒƒã‚¯ã€å‘½ä»¤ãƒã‚¤ãƒ³ã‚¿ãƒ¼ãã—ã¦ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼ã‚’æŒã¡ã¾ã™ã€‚</p>
</blockquote>
<blockquote>
<p>å‘½ä»¤ãƒã‚¤ãƒ³ã‚¿ãƒ¼â‰’ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼ï¼Ÿ</p>
</blockquote>
<p>A single <strong>process</strong> can manage multiple threads.
These threads share the same memory space, which means they can access the same data.</p>
<blockquote>
<p>å˜ä¸€<strong>ãƒ—ãƒ­ã‚»ã‚¹</strong>ã¯ã€è¤‡æ•°ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã‚’ç®¡ç†ã§ãã¾ã™ã€‚
ã“ã‚Œã‚‰ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã¯ã€åŒã˜ãƒ¡ãƒ¢ãƒªç©ºé–“ã‚’å…±æœ‰ã™ã‚‹ãŸã‚ã€ãã‚Œã‚‰ã¯åŒã˜ãƒ‡ãƒ¼ã‚¿ã«ã‚¢ã‚¯ã‚»ã‚¹ã§ãã‚‹ã“ã¨ã‚’æ„å‘³ã—ã¾ã™ã€‚</p>
</blockquote>
<p>Threads are a <strong>logical</strong> construct. In the end, you can only run one set of instructions
at a time on a CPU core, the <strong>physical</strong> execution unit.<br />
Since there can be many more threads than there are CPU cores, the operating system's
<strong>scheduler</strong> is in charge of deciding which thread to run at any given time,
partitioning CPU time among them to maximize throughput and responsiveness.</p>
<blockquote>
<p>ã‚¹ãƒ¬ãƒƒãƒ‰ã¯<strong>è«–ç†çš„ãª</strong>æ§‹æˆè¦ç´ ã§ã™ã€‚æœ€çµ‚çš„ã«ã€<strong>ç‰©ç†çš„ãª</strong>å®Ÿè¡Œãƒ¦ãƒ‹ãƒƒãƒˆã§ã‚ã‚‹CPUã‚³ã‚¢ã§ä¸€åº¦ã«1ã¤ã®å‘½ä»¤ã‚»ãƒƒãƒˆã—ã‹å®Ÿè¡Œã§ãã¾ã›ã‚“ã€‚
CPUã‚³ã‚¢ã‚ˆã‚Šã‚‚å¤šãã®ã‚¹ãƒ¬ãƒƒãƒ‰ãŒå­˜åœ¨ã§ãã‚‹ãŸã‚ã€ã‚ªãƒšãƒ¬ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ ã®<strong>ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ©ãƒ¼</strong>ã¯ã€ç‰¹å®šã®æ™‚é–“ã«å®Ÿè¡Œã™ã‚‹ã‚¹ãƒ¬ãƒƒãƒ‰ã‚’æ±ºå®šã™ã‚‹è²¬ä»»ãŒã‚ã‚Šã€æœ€å¤§ã®ã‚¹ãƒ«ãƒ¼ãƒ—ãƒƒãƒˆã¨å¿œç­”æ€§ã‚’ç¢ºä¿ã™ã‚‹ãŸã‚ã«ã€ã‚¹ãƒ¬ãƒƒãƒ‰é–“ã§CPUæ™‚é–“ã‚’åˆ†é…ã—ã¾ã™ã€‚</p>
</blockquote>
<h2 id="main"><a class="header" href="#main"><code>main</code></a></h2>
<p>When a Rust program starts, it runs on a single thread, the <strong>main thread</strong>.<br />
This thread is created by the operating system and is responsible for running the <code>main</code>
function.</p>
<blockquote>
<p>Rustãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒé–‹å§‹ã—ãŸã¨ãã€ãã‚Œã¯<strong>ãƒ¡ã‚¤ãƒ³ã‚¹ãƒ¬ãƒƒãƒ‰</strong>ã¨ã„ã†å˜ä¸€ã‚¹ãƒ¬ãƒƒãƒ‰ã§å®Ÿè¡Œã•ã‚Œã¾ã™ã€‚
ã“ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã¯ã‚ªãƒšãƒ¬ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ ã«ã‚ˆã£ã¦ä½œæˆã•ã‚Œã€<code>main</code>é–¢æ•°ã‚’å®Ÿè¡Œã™ã‚‹è²¬ä»»ãŒã‚ã‚Šã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::time::Duration;

fn main() {
    loop {
        thread::sleep(Duration::from_secs(2));
        println!("Hello from the main thread!");
    }
}</code></pre></pre>
<h2 id="stdthread"><a class="header" href="#stdthread"><code>std::thread</code></a></h2>
<p>Rust's standard library provides a module, <code>std::thread</code>, that allows you to create
and manage threads.</p>
<blockquote>
<p>Rustæ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã¯ã€ã‚¹ãƒ¬ãƒƒãƒ‰ã‚’ä½œæˆã¾ãŸã¯ç®¡ç†ã™ã‚‹<code>std::thread</code>ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’æä¾›ã—ã¾ã™ã€‚</p>
</blockquote>
<h3 id="spawn"><a class="header" href="#spawn"><code>spawn</code></a></h3>
<p>You can use <code>std::thread::spawn</code> to create new threads and execute code on them.</p>
<p>For example:</p>
<blockquote>
<p>æ–°ã—ã„ã‚¹ãƒ¬ãƒƒãƒ‰ã‚’ä½œæˆã—ã¦ã€ãã‚Œã‚‰ã®ä¸Šã§ã‚³ãƒ¼ãƒ‰ã‚’å®Ÿè¡Œã™ã‚‹ãŸã‚ã«<code>std::thread::spawn</code>ã‚’ä½¿ç”¨ã§ãã¾ã™ã€‚</p>
<p>ä¾‹ãˆã°ãƒ»ãƒ»ãƒ»</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        loop {
            thread::sleep(Duration::from_secs(1));
            println!("Hello from a thread!");
        }
    });

    loop {
        thread::sleep(Duration::from_secs(2));
        println!("Hello from the main thread!");
    }
}</code></pre></pre>
<p>If you execute this program on the <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=afedf7062298ca8f5a248bc551062eaa">Rust playground</a>
you'll see that the main thread and the spawned thread run concurrently.<br />
Each thread makes progress independently of the other.</p>
<blockquote>
<p>ã“ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’Rust playgroundã§å®Ÿè¡Œã—ãŸå ´åˆã€ãƒ¡ã‚¤ãƒ³ã‚¹ãƒ¬ãƒƒãƒ‰ã¨ç”Ÿã¿å‡ºã•ã‚ŒãŸã‚¹ãƒ¬ãƒƒãƒ‰ãŒåŒæ™‚ä¸¦è¡Œã§å®Ÿè¡Œã™ã‚‹ã“ã¨ã‚’ç¢ºèªã§ãã¾ã™ã€‚
ãã‚Œãã‚Œã®ã‚¹ãƒ¬ãƒƒãƒ‰ã¯ã€ä»–ã¨ç‹¬ç«‹ã—ã¦é€²è¡Œã—ã¾ã™ã€‚</p>
</blockquote>
<blockquote>
<p>ã“ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯ã€<code>main</code>é–¢æ•°æœ«å°¾ã«ã‚ã‚‹ç„¡é™ãƒ«ãƒ¼ãƒ—ã‚’æŠœã‘ã‚‹ã“ã¨ãŒãªã„ãŸã‚ã€æ°¸é ã«å®Ÿè¡Œã‚’ç¶™ç¶šã™ã‚‹ã€‚</p>
</blockquote>
<h3 id="process-terminationãƒ—ãƒ­ã‚»ã‚¹ã®çµ‚äº†"><a class="header" href="#process-terminationãƒ—ãƒ­ã‚»ã‚¹ã®çµ‚äº†">Process terminationï¼ˆãƒ—ãƒ­ã‚»ã‚¹ã®çµ‚äº†ï¼‰</a></h3>
<p>When the main thread finishes, the overall process will exit.<br />
A spawned thread will continue running until it finishes or the main thread finishes.</p>
<blockquote>
<p>ãƒ¡ã‚¤ãƒ³ã‚¹ãƒ¬ãƒƒãƒ‰ãŒçµ‚äº†ã—ãŸã¨ãã€ãƒ—ãƒ­ã‚»ã‚¹å…¨ä½“ãŒçµ‚äº†ã—ã¾ã™ã€‚
ç”Ÿã¿å‡ºã•ã‚ŒãŸã‚¹ãƒ¬ãƒƒãƒ‰ã¯ã€ãã‚ŒãŒçµ‚äº†ã™ã‚‹ã€ã¾ãŸã¯ãƒ¡ã‚¤ãƒ³ã‚¹ãƒ¬ãƒƒãƒ‰ãŒçµ‚äº†ã™ã‚‹ã¾ã§å®Ÿè¡Œã‚’ç¶šã‘ã¾ã™ã€‚</p>
</blockquote>
<blockquote>
<p>æ¬¡ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯ã€<code>main</code>é–¢æ•°æœ«å°¾ã«ã‚ã‚‹5ç§’é–“ã®ã‚¹ãƒªãƒ¼ãƒ—ãŒçµ‚ã‚ã‚‹ã¨ã€<code>main</code>é–¢æ•°ãŒçµ‚äº†ã™ã‚‹ãŸã‚ã€ç„¡é™ãƒ«ãƒ¼ãƒ—ã«å…¥ã‚‹åˆ¥ã‚¹ãƒ¬ãƒƒãƒ‰ã‚‚åŒæ™‚ã«çµ‚äº†ã™ã‚‹ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        loop {
            thread::sleep(Duration::from_secs(1));
            println!("Hello from a thread!");
        }
    });

    thread::sleep(Duration::from_secs(5));
}</code></pre></pre>
<p>In the example above, you can expect to see the message "Hello from a thread!" printed roughly five times.<br />
Then the main thread will finish (when the <code>sleep</code> call returns), and the spawned thread will be terminated
since the overall process exits.</p>
<blockquote>
<p>ä¸Šè¨˜ä¾‹ã«ãŠã„ã¦ã€å¤§ã¾ã‹ã«5ï¸å›è¡¨ç¤ºã•ã‚Œã‚‹ã€ŒHello from a thread!ã€ã‚’è¦‹ã‚‹ã“ã¨ã‚’æœŸå¾…ã§ãã¾ã™ã€‚
ãã—ã¦ã€<code>sleep</code>å‘¼ã³å‡ºã—ãŒæˆ»ã£ãŸã¨ãã€ãƒ¡ã‚¤ãƒ³ã‚¹ãƒ¬ãƒƒãƒ‰ãŒçµ‚äº†ã—ã¦ã€ãƒ—ãƒ­ã‚»ã‚¹å…¨ä½“ãŒçµ‚äº†ã™ã‚‹ãŸã‚ã€ç”Ÿã¿å‡ºã•ã‚ŒãŸã‚¹ãƒ¬ãƒƒãƒ‰ã‚‚çµ‚äº†ã—ã¾ã™ã€‚</p>
</blockquote>
<h3 id="join"><a class="header" href="#join"><code>join</code></a></h3>
<p>You can also wait for a spawned thread to finish by calling the <code>join</code> method on the <code>JoinHandle</code> that <code>spawn</code> returns.</p>
<blockquote>
<p><code>spawn</code>ãŒè¿”ã™<code>JoinHandle</code>ã«å¯¾ã—ã¦<code>join</code>ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã™ã“ã¨ã§ã€ç”Ÿã¿å‡ºã•ã‚ŒãŸã‚¹ãƒ¬ãƒƒãƒ‰ãŒçµ‚äº†ã™ã‚‹ã¾ã§å¾…ã¤ã“ã¨ã‚‚ã§ãã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">use std::thread;
fn main() {
    let handle = thread::spawn(|| {
        println!("Hello from a thread!");
    });

    handle.join().unwrap();
}</code></pre></pre>
<p>In this example, the main thread will wait for the spawned thread to finish before exiting.<br />
This introduces a form of <strong>synchronization</strong> between the two threads: you're guaranteed to see the message
"Hello from a thread!" printed before the program exits, because the main thread won't exit
until the spawned thread has finished.</p>
<blockquote>
<p>ã“ã®ä¾‹ã«ãŠã„ã¦ã€ãƒ¡ã‚¤ãƒ³ã‚¹ãƒ¬ãƒƒãƒ‰ã¯çµ‚äº†ã™ã‚‹å‰ã«ç”Ÿã¿å‡ºã•ã‚ŒãŸã‚¹ãƒ¬ãƒƒãƒ‰ãŒçµ‚äº†ã™ã‚‹ã¾ã§å¾…ã¡ã¾ã™ã€‚
ã“ã‚Œã¯ã€2ã¤ã®ã‚¹ãƒ¬ãƒƒãƒ‰é–“ã«<strong>åŒæœŸ</strong>ã®å½¢å¼ã‚’å°å…¥ã—ã¾ã™ã€‚
ç”Ÿã¿å‡ºã•ã‚ŒãŸã‚¹ãƒ¬ãƒƒãƒ‰ãŒçµ‚äº†ã™ã‚‹ã¾ã§ã€ãƒ¡ã‚¤ãƒ³ã‚¹ãƒ¬ãƒƒãƒ‰ãŒçµ‚äº†ã—ãªã„ãŸã‚ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒçµ‚äº†ã™ã‚‹å‰ã«ã€ŒHello from a thread!ã€ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¦‹ã‚‹ã“ã¨ãŒä¿è¨¼ã•ã‚Œã¾ã™ã€‚</p>
</blockquote>
<h2 id="exercise-75"><a class="header" href="#exercise-75">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/07_threads/01_threads"><code>07_threads/01_threads</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="static"><a class="header" href="#static"><code>'static</code></a></h1>
<p>If you tried to borrow a slice from the vector in the previous exercise,
you probably got a compiler error that looks something like this:</p>
<blockquote>
<p>å‰ã®æ¼”ç¿’ã«ãŠã„ã¦ã€ãƒ™ã‚¯ã‚¿ãƒ¼ã‹ã‚‰ã‚¹ãƒ©ã‚¤ã‚¹ã‚’å€Ÿç”¨ã™ã‚‹ã“ã¨ã‚’è©¦ã¿ãŸå ´åˆã€ãŠãã‚‰ãæ¬¡ã®ã‚ˆã†ãªã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚</p>
</blockquote>
<pre><code class="language-text">error[E0597]: `v` does not live long enough
   |
11 | pub fn sum(v: Vec&lt;i32&gt;) -&gt; i32 {
   |            - binding `v` declared here
...
15 |     let right = &amp;v[split_point..];
   |                  ^ borrowed value does not live long enough
16 |     let left_handle = thread::spawn(move || left.iter().sum::&lt;i32&gt;());
   |                        ------------------------------------------------
                          argument requires that `v` is borrowed for `'static`
19 | }
   |  - `v` dropped here while still borrowed
</code></pre>
<p><code>argument requires that v is borrowed for 'static</code>, what does that mean?</p>
<blockquote>
<p><code>argument requires that v is borrowed for 'static</code>ã¯ã€ä½•ã‚’æ„å‘³ã—ã¦ã„ã‚‹ã®ã§ã—ã‚‡ã†ã‹ï¼Ÿ</p>
</blockquote>
<p>The <code>'static</code> lifetime is a special lifetime in Rust.<br />
It means that the value will be valid for the entire duration of the program.</p>
<blockquote>
<p>Rustã«ãŠã„ã¦ã€<code>'static</code>ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ã¯ç‰¹åˆ¥ãªãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ã§ã™ã€‚
ãã‚Œã¯ã€ãã®å€¤ãŒãƒ—ãƒ­ã‚°ãƒ©ãƒ å…¨ä½“ã®é–“ã§æœ‰åŠ¹ã§ã‚ã‚‹ã“ã¨ã‚’æ„å‘³ã—ã¾ã™ã€‚</p>
</blockquote>
<h2 id="detached-threadsãƒ‡ã‚¿ãƒƒãƒã•ã‚ŒãŸã‚¹ãƒ¬ãƒƒãƒ‰"><a class="header" href="#detached-threadsãƒ‡ã‚¿ãƒƒãƒã•ã‚ŒãŸã‚¹ãƒ¬ãƒƒãƒ‰">Detached threadsï¼ˆãƒ‡ã‚¿ãƒƒãƒã•ã‚ŒãŸã‚¹ãƒ¬ãƒƒãƒ‰ï¼‰</a></h2>
<p>A thread launched via <code>thread::spawn</code> can <strong>outlive</strong> the thread that spawned it.<br />
For example:</p>
<blockquote>
<p><code>thread::spawn</code>ã‚’ä»‹ã—ã¦èµ·å‹•ã•ã‚ŒãŸã‚¹ãƒ¬ãƒƒãƒ‰ã¯ã€ãã‚Œã‚’ç”Ÿæˆã—ãŸã‚¹ãƒ¬ãƒƒãƒ‰ã‚ˆã‚Šã‚‚<strong>é•·ç”Ÿã</strong>ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚
ä¾‹ãˆã°ãƒ»ãƒ»ãƒ»</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::thread;

fn f() {
    thread::spawn(|| {
        thread::spawn(|| {
            loop {
                thread::sleep(std::time::Duration::from_secs(1));
                println!("Hello from the detached thread!");
            }
        });
    });
}
<span class="boring">}</span></code></pre></pre>
<p>In this example, the first spawned thread will in turn spawn
a child thread that prints a message every second.<br />
The first thread will then finish and exit. When that happens,
its child thread will <strong>continue running</strong> for as long as the
overall process is running.<br />
In Rust's lingo, we say that the child thread has <strong>outlived</strong>
its parent.</p>
<blockquote>
<p>ã“ã®ä¾‹ã«ãŠã„ã¦ã€æœ€åˆã«ç”Ÿã¿å‡ºã•ã‚ŒãŸã‚¹ãƒ¬ãƒƒãƒ‰ã¯ã€æ¬¡ã€…ã«æ¯ç§’ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤ºã™ã‚‹å­ã‚¹ãƒ¬ãƒƒãƒ‰ã‚’ç”Ÿã¿å‡ºã—ã¾ã™ã€‚
ãã—ã¦ã€æœ€åˆã®ã‚¹ãƒ¬ãƒƒãƒ‰ã¯å®Œäº†ã—ã¦çµ‚äº†ã—ã¾ã™ã€‚
ãã‚ŒãŒç™ºç”Ÿã—ãŸã¨ãã€å­ã‚¹ãƒ¬ãƒƒãƒ‰ã¯å…¨ä½“ã®ãƒ—ãƒ­ã‚»ã‚¹ãŒå®Ÿè¡Œã•ã‚Œã¦ã„ã‚‹é™ã‚Š<strong>ç¶™ç¶šã—ã¦å®Ÿè¡Œ</strong>ã—ã¾ã™ã€‚
Rustã®å°‚é–€ç”¨èªã«ãŠã„ã¦ã€å­ã‚¹ãƒ¬ãƒƒãƒ‰ã¯ãã®è¦ªã‚ˆã‚Šã‚‚<strong>é•·ç”Ÿãã—ã¦ã„ã‚‹</strong>ã¨ã„ã„ã¾ã™ã€‚</p>
</blockquote>
<blockquote>
<p>é–¢æ•°<code>f</code>ã‚’<code>main</code>é–¢æ•°ã«ã—ãŸå ´åˆã€è¦ªã‚¹ãƒ¬ãƒƒãƒ‰ãŒçµ‚äº†ã—ã¦ã‚‚ã€<code>main</code>é–¢æ•°ãŒçµ‚äº†ã—ã¦ã„ãªã„å¾®å°ãªæ™‚é–“ãŒã‚ã‚‹ã€‚
ãã®å¾®å°æ™‚é–“å†…ã§ã€å­ã‚¹ãƒ¬ãƒƒãƒ‰ã¯å®Ÿè¡Œã‚’ç¶™ç¶šã™ã‚‹ã€‚</p>
</blockquote>
<h2 id="static-lifetimestaticãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ "><a class="header" href="#static-lifetimestaticãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ "><code>'static</code> lifetimeï¼ˆ'staticãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ï¼‰</a></h2>
<p>Since a spawned thread can:</p>
<ul>
<li>outlive the thread that spawned it (its parent thread)</li>
<li>run until the program exits</li>
</ul>
<blockquote>
<p>ç”Ÿã¿å‡ºã•ã‚ŒãŸã‚¹ãƒ¬ãƒƒãƒ‰ã¯æ¬¡ãŒã§ãã‚‹ãŸã‚ãƒ»ãƒ»ãƒ»</p>
<ul>
<li>ãã‚Œã‚’ç”Ÿæˆã—ãŸè¦ªã‚¹ãƒ¬ãƒƒãƒ‰ã‚ˆã‚Šã‚‚é•·ç”Ÿãã™ã‚‹ã€‚</li>
<li>ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒçµ‚äº†ã™ã‚‹ã¾ã§å®Ÿè¡Œã™ã‚‹ã€‚</li>
</ul>
</blockquote>
<p>it must not borrow any values that might be dropped before the program exits;
violating this constraint would expose us to a use-after-free bug.<br />
That's why <code>std::thread::spawn</code>'s signature requires that the closure passed to it
has the <code>'static</code> lifetime:</p>
<blockquote>
<p>ãã‚Œï¼ˆå­ã‚¹ãƒ¬ãƒƒãƒ‰ï¼‰ã¯ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒçµ‚äº†ã™ã‚‹å‰ã«ãƒ‰ãƒ­ãƒƒãƒ—ã•ã‚Œã‚‹ã‹ã‚‚ã—ã‚Œãªã„å€¤ã‚’å€Ÿç”¨ã—ã¦ã¯ãªã‚Šã¾ã›ã‚“ã€‚
ã“ã®åˆ¶ç´„ã«é•åã™ã‚‹ã“ã¨ã¯ã€ã€Œè§£æ”¾ã•ã‚ŒãŸå¾Œã«ä½¿ç”¨ã™ã‚‹ã€ãƒã‚°ã‚’ã•ã‚‰ã‘å‡ºã—ã¾ã™ã€‚
ãã‚ŒãŒã€<code>std::thread::spawn</code>ã®ã‚·ã‚°ãƒãƒãƒ£ãƒ¼ãŒ<code>'static</code>ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ã‚’æŒã¤ãã‚Œï¼ˆå€¤ï¼‰ã‚’æ¸¡ã•ã‚Œã‚‹ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ãƒ¼ã‚’è¦æ±‚ã—ã¦ã„ã‚‹ç†ç”±ã§ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt;
where
    F: FnOnce() -&gt; T + Send + 'static,
    T: Send + 'static
{
    // [..]
}
<span class="boring">}</span></code></pre></pre>
<h2 id="static-is-not-just-about-referencesstaticã¯å˜ã«å‚ç…§ã«ã¤ã„ã¦ã ã‘ã§ã¯ã‚ã‚Šã¾ã›ã‚“"><a class="header" href="#static-is-not-just-about-referencesstaticã¯å˜ã«å‚ç…§ã«ã¤ã„ã¦ã ã‘ã§ã¯ã‚ã‚Šã¾ã›ã‚“"><code>'static</code> is not (just) about referencesï¼ˆ'staticã¯ï¼ˆå˜ã«ï¼‰å‚ç…§ã«ã¤ã„ã¦ã ã‘ã§ã¯ã‚ã‚Šã¾ã›ã‚“ï¼‰</a></h2>
<p>All values in Rust have a lifetime, not just references.</p>
<blockquote>
<p>Rustã«ãŠã„ã¦ã€å‚ç…§ã ã‘ã§ãªãã€ã™ã¹ã¦ã®å€¤ãŒãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ã‚’æŒã£ã¦ã„ã¾ã™ã€‚</p>
</blockquote>
<p>In particular, a type that owns its data (like a <code>Vec</code> or a <code>String</code>)
satisfies the <code>'static</code> constraint: if you own it, you can keep working with it
for as long as you want, even after the function that originally created it
has returned.</p>
<blockquote>
<p>ç‰¹ã«ã€<code>Vec</code>ã¾ãŸã¯<code>String</code>ã®ã‚ˆã†ãªãƒ‡ãƒ¼ã‚¿ã‚’æ‰€æœ‰ã™ã‚‹å‹ã¯ã€<code>'static</code>åˆ¶ç´„ã‚’æº€ãŸã—ã¾ã™ã€‚
ãã‚Œã‚’æ‰€æœ‰ã—ãŸå ´åˆã€ãã‚Œã‚’ä½œæˆã—ãŸé–¢æ•°ãŒæˆ»ã£ãŸå¾Œã§ã‚‚ã€æœ›ã‚€ã ã‘ãã‚Œã¨ä¸€ç·’ã«ä½œæ¥­ã‚’ç¶šã‘ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚</p>
</blockquote>
<blockquote>
<p><code>Vec</code>ãŒ<code>T</code>ã®å‚ç…§ã§ã‚ã‚‹<code>&amp;T</code>ã‚’æ ¼ç´ã™ã‚‹å ´åˆã€<code>&amp;T</code>è‡ªä½“ã®æ‰€æœ‰æ¨©ã‚’ã‚‚ã¡ã€<code>&amp;T</code>ãŒå‚ç…§ã™ã‚‹<code>T</code>ã¯<code>'static</code>ã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚‹ã€‚</p>
</blockquote>
<p>You can thus interpret <code>'static</code> as a way to say:</p>
<ul>
<li>Give me an owned value</li>
<li>Give me a reference that's valid for the entire duration of the program</li>
</ul>
<blockquote>
<p>ã‚ˆã£ã¦ã€<code>'static</code>ã¯æ¬¡ã®ã‚ˆã†ã«è§£é‡ˆã§ãã¾ã™ã€‚</p>
<ul>
<li>æ‰€æœ‰ã—ãŸå€¤ã‚’ä¸ãˆã¦ãã‚Œã‚‹</li>
<li>ãƒ—ãƒ­ã‚°ãƒ©ãƒ å…¨ä½“ã®æœŸé–“ã§æœ‰åŠ¹ãªå‚ç…§ã‚’ä¸ãˆã¦ãã‚Œã‚‹</li>
</ul>
</blockquote>
<p>The first approach is how you solved the issue in the previous exercise:
by allocating new vectors to hold the left and right parts of the original vector,
which were then moved into the spawned threads.</p>
<blockquote>
<p>æœ€åˆã®æ–¹æ³•ã¯ã€ä»¥å‰ã®æ¼”ç¿’ã®å•é¡Œã‚’è§£æ±ºã—ãŸæ–¹æ³•ã¨åŒã˜ã§ã€ã‚ªãƒªã‚¸ãƒŠãƒ«ã®ãƒ™ã‚¯ã‚¿ãƒ¼ã®å·¦ã¨å³ã®éƒ¨åˆ†ã‚’ä¿æŒã™ã‚‹ãŸã‚ã«æ–°ã—ã„ãƒ™ã‚¯ã‚¿ãƒ¼ã‚’å‰²ã‚Šå½“ã¦ã€ãã‚Œã‚‰ã‚’ç”Ÿã¿å‡ºã•ã‚ŒãŸã‚¹ãƒ¬ãƒƒãƒ‰å†…ã«ç§»å‹•ã—ã¾ã—ãŸã€‚</p>
</blockquote>
<h2 id="static-referencesstaticå‚ç…§"><a class="header" href="#static-referencesstaticå‚ç…§"><code>'static</code> referencesï¼ˆ'staticå‚ç…§ï¼‰</a></h2>
<p>Let's talk about the second case, references that are valid for the entire
duration of the program.</p>
<blockquote>
<p>2ã¤ç›®ã®ã‚±ãƒ¼ã‚¹ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ å…¨ä½“ã®é–“ã§æœ‰åŠ¹ãªå‚ç…§ã«ã¤ã„ã¦è©±ã—ã¾ã—ã‚‡ã†ã€‚</p>
</blockquote>
<h3 id="static-dataé™çš„ãªãƒ‡ãƒ¼ã‚¿"><a class="header" href="#static-dataé™çš„ãªãƒ‡ãƒ¼ã‚¿">Static dataï¼ˆé™çš„ãªãƒ‡ãƒ¼ã‚¿ï¼‰</a></h3>
<p>The most common case is a reference to <strong>static data</strong>, such as string literals:</p>
<blockquote>
<p>æœ€ã‚‚ä¸€èˆ¬çš„ãªã‚±ãƒ¼ã‚¹ã¯ã€æ–‡å­—åˆ—ãƒªãƒ†ãƒ©ãƒ«ã®ã‚ˆã†ãª<strong>é™çš„ãƒ‡ãƒ¼ã‚¿</strong>ã¸ã®å‚ç…§ã§ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s: &amp;'static str = "Hello world!";
<span class="boring">}</span></code></pre></pre>
<p>Since string literals are known at compile-time, Rust stores them <em>inside</em> your executable,
in a region known as <strong>read-only data segment</strong>.
All references pointing to that region will therefore be valid for as long as
the program runs; they satisfy the <code>'static</code> contract.</p>
<blockquote>
<p>æ–‡å­—åˆ—ãƒªãƒ†ãƒ©ãƒ«ã¯ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã«ã‚ã‹ã‚‹ãŸã‚ã€Rustã¯å®Ÿè¡Œå½¢å¼ã® <em>å†…éƒ¨</em> ã«ã‚ã‚‹<strong>èª­ã¿è¾¼ã¿å°‚ç”¨ãƒ‡ãƒ¼ã‚¿ã‚»ã‚°ãƒ¡ãƒ³ãƒˆ</strong>ã¨ã—ã¦çŸ¥ã‚‰ã‚Œã‚‹é ˜åŸŸã«ãã‚Œã‚‰ã‚’ä¿å­˜ã—ã¾ã™ã€‚</p>
</blockquote>
<h2 id="further-readingå‚è€ƒè³‡æ–™-10"><a class="header" href="#further-readingå‚è€ƒè³‡æ–™-10">Further readingï¼ˆå‚è€ƒè³‡æ–™ï¼‰</a></h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Data_segment">The data segment</a></li>
</ul>
<h2 id="exercise-76"><a class="header" href="#exercise-76">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/07_threads/02_static"><code>07_threads/02_static</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="leaking-dataãƒ‡ãƒ¼ã‚¿ã®ãƒªãƒ¼ã‚¯"><a class="header" href="#leaking-dataãƒ‡ãƒ¼ã‚¿ã®ãƒªãƒ¼ã‚¯">Leaking dataï¼ˆãƒ‡ãƒ¼ã‚¿ã®ãƒªãƒ¼ã‚¯ï¼‰</a></h1>
<p>The main concern around passing references to spawned threads is use-after-free bugs:
accessing data using a pointer to a memory region that's already been freed/de-allocated.<br />
If you're working with heap-allocated data, you can avoid the issue by
telling Rust that you'll never reclaim that memory: you choose to <strong>leak memory</strong>,
intentionally.</p>
<blockquote>
<p>ç”Ÿã¿å‡ºã—ãŸã‚¹ãƒ¬ãƒƒãƒ‰ã«å‚ç…§ã‚’æ¸¡ã™ã“ã¨ã«é–¢ã™ã‚‹ä¸»è¦ãªæ‡¸å¿µã¯ã€ã™ã§ã«è§£æ”¾ï¼å‰²ã‚Šå½“ã¦ã‚’è§£é™¤ã•ã‚ŒãŸãƒ¡ãƒ¢ãƒªé ˜åŸŸã¸ã®ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã‚’ä½¿ç”¨ã—ãŸãƒ‡ãƒ¼ã‚¿ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã€Œé–‹æ”¾ã—ãŸå¾Œã«ä½¿ç”¨ã™ã‚‹ã€ãƒã‚°ã§ã™ã€‚
ãƒ’ãƒ¼ãƒ—ã«å‰²ã‚Šå½“ã¦ã‚‰ã‚ŒãŸãƒ‡ãƒ¼ã‚¿ã‚’æ‰±ã£ã¦ã„ã‚‹å ´åˆã€ãã®ãƒ¡ãƒ¢ãƒªã‚’æ±ºã—ã¦å›åã—ãªã„ã“ã¨ã‚’Rustã«ä¼ãˆã‚‹ã“ã¨ã§ã€ãã®å•é¡Œã‚’å›é¿ã§ãã¾ã™ã€‚
ã¤ã¾ã‚Šã€<strong>ãƒ¡ãƒ¢ãƒªãƒ¼ãƒªãƒ¼ã‚¯</strong>ã™ã‚‹ã“ã¨ã‚’æ„å›³çš„ã«é¸æŠã—ã¾ã™ã€‚</p>
</blockquote>
<p>This can be done, for example, using the <code>Box::leak</code> method from Rust's standard library:</p>
<blockquote>
<p>ä¾‹ãˆã°ã€Rustæ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®<code>Box::leak</code>ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ç”¨ã—ã¦ã€ã“ã‚Œã‚’è¡Œãˆã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Allocate a `u32` on the heap, by wrapping it in a `Box`.
// `Box`å†…ã«ãƒ©ãƒƒãƒ—ã™ã‚‹ã“ã¨ã§ã€ãƒ’ãƒ¼ãƒ—ã«`u32`ã‚’å‰²ã‚Šå½“ã¦ã¾ã™ã€‚
let x = Box::new(41u32);
// Tell Rust that you'll never free that heap allocation
// using `Box::leak`. You can thus get back a 'static reference.
// `Box::leak`ã‚’ä½¿ç”¨ã—ã¦ã€ãã®ãƒ’ãƒ¼ãƒ—å‰²ã‚Šå½“ã¦ã‚’æ±ºã—ã¦è§£æ”¾ã—ãªã„ã“ã¨ã‚’Rustã«ä¼ãˆã¾ã™ã€‚
// ã‚ˆã£ã¦ã€`'staticå‚ç…§ã‚’å¾—ã‚‰ã‚Œã¾ã™ã€‚
let static_ref: &amp;'static mut u32 = Box::leak(x);
<span class="boring">}</span></code></pre></pre>
<h2 id="data-leakage-is-process-scopedãƒ‡ãƒ¼ã‚¿ãƒªãƒ¼ã‚¯ã¯ãƒ—ãƒ­ã‚»ã‚¹ã‚¹ã‚³ãƒ¼ãƒ—ã§ã™"><a class="header" href="#data-leakage-is-process-scopedãƒ‡ãƒ¼ã‚¿ãƒªãƒ¼ã‚¯ã¯ãƒ—ãƒ­ã‚»ã‚¹ã‚¹ã‚³ãƒ¼ãƒ—ã§ã™">Data leakage is process-scopedï¼ˆãƒ‡ãƒ¼ã‚¿ãƒªãƒ¼ã‚¯ã¯ãƒ—ãƒ­ã‚»ã‚¹ã‚¹ã‚³ãƒ¼ãƒ—ã§ã™ï¼‰</a></h2>
<p>Leaking data is dangerous: if you keep leaking memory, you'll eventually
run out and crash with an out-of-memory error.</p>
<blockquote>
<p>ãƒ‡ãƒ¼ã‚¿ã‚’ãƒªãƒ¼ã‚¯ã•ã›ã‚‹ã“ã¨ã¯å±é™ºã§ã™ã€‚
ãƒªãƒ¼ã‚¯ã—ãŸãƒ¡ãƒ¢ãƒªã‚’ç¶­æŒã™ã‚‹å ´åˆã€æœ€çµ‚çš„ã«ãƒ¡ãƒ¢ãƒªãŒå°½ãã¦ã€ã‚¢ã‚¦ãƒˆã‚ªãƒ–ãƒ¡ãƒ¢ãƒªãƒ¼ã‚¨ãƒ©ãƒ¼ã§ã‚¯ãƒ©ãƒƒã‚·ãƒ¥ã—ã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// If you leave this running for a while,
// it'll eventually use all the available memory.
// ã—ã°ã‚‰ãã“ã‚Œã‚’å®Ÿè¡Œã—ãŸå ´åˆã€æœ€çµ‚çš„ã«ã™ã¹ã¦ã®åˆ©ç”¨å¯èƒ½ãªãƒ¡ãƒ¢ãƒªã‚’ä½¿ç”¨ã—ã¾ã™ã€‚
fn oom_trigger() {
    loop {
        let v: Vec&lt;usize&gt; = Vec::with_capacity(1024);
        v.leak();
    }
}
<span class="boring">}</span></code></pre></pre>
<p>At the same time, memory leaked via <code>leak</code> method is not truly forgotten.<br />
The operating system can map each memory region to the process responsible for it.
When the process exits, the operating system will reclaim that memory.</p>
<blockquote>
<p>åŒæ™‚ã«ã€<code>leak</code>ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä»‹ã—ãŸãƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯ã¯ã€å®Œå…¨ã«å¿˜ã‚Œå»ã‚‰ã‚Œã‚‹ã‚ã‘ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚
ã‚ªãƒšãƒ¬ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ ã¯ã€ãã‚Œãã‚Œã®ãƒ¡ãƒ¢ãƒªé ˜åŸŸã¨ã€ãã‚Œã«è²¬ä»»ãŒã‚ã‚‹ãƒ—ãƒ­ã‚»ã‚¹ã‚’ãƒãƒƒãƒ—ã§ãã¾ã™ã€‚
ãƒ—ãƒ­ã‚»ã‚¹ãŒçµ‚äº†ã—ãŸã¨ãã€ã‚ªãƒšãƒ¬ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ ã¯ãã®ãƒ¡ãƒ¢ãƒªã‚’å›åã—ã¾ã™ã€‚</p>
</blockquote>
<p>Keeping this in mind, it can be OK to leak memory when:</p>
<ul>
<li>The amount of memory you need to leak is not unbounded/known upfront, or</li>
<li>Your process is short-lived and you're confident you won't exhaust
all the available memory before it exits</li>
</ul>
<blockquote>
<p>ã“ã‚Œã‚’å¿µé ­ã«ç½®ã„ã¦ã€ãƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯ãŒè¨±å®¹ã•ã‚Œã‚‹å ´åˆã¯æ¬¡ã®ã¨ãŠã‚Šã§ã™ã€‚</p>
<ul>
<li>ãƒªãƒ¼ã‚¯ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ãƒ¡ãƒ¢ãƒªãƒ¼ã®é‡ãŒç„¡åˆ¶é™ã§ãªã„ã‹ã€äº‹å‰ã«ã‚ã‹ã£ã¦ã„ã‚‹å ´åˆã€ã¾ãŸã¯ãƒ»ãƒ»ãƒ»</li>
<li>ãƒ—ãƒ­ã‚»ã‚¹ãŒçŸ­å‘½ã§ã€ãã‚ŒãŒçµ‚äº†ã™ã‚‹å‰ã«åˆ©ç”¨å¯èƒ½ãªãƒ¡ãƒ¢ãƒªã‚’ã™ã¹ã¦ä½¿ã„æœãŸã•ãªã„è‡ªä¿¡ãŒã‚ã‚‹å ´åˆ</li>
</ul>
</blockquote>
<p>"Let the OS deal with it" is a perfectly valid memory management strategy
if your usecase allows for it.</p>
<blockquote>
<p>ãƒ¦ãƒ¼ã‚¹ã‚±ãƒ¼ã‚¹ãŒãã‚Œï¼ˆä¸Šè¨˜ï¼‰ã«å¾“ã†å ´åˆã€ã€ŒOSã«ãã‚Œã‚’å‡¦ç†ã•ã›ã‚‹ã€ã¯ã€å®Œå…¨ã«å¦¥å½“ãªãƒ¡ãƒ¢ãƒªç®¡ç†æˆ¦ç•¥ã§ã™ã€‚</p>
</blockquote>
<h2 id="exercise-77"><a class="header" href="#exercise-77">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/07_threads/03_leak"><code>07_threads/03_leak</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scoped-threadsã‚¹ã‚³ãƒ¼ãƒ—ã§åˆ¶é™ã•ã‚ŒãŸã‚¹ãƒ¬ãƒƒãƒ‰"><a class="header" href="#scoped-threadsã‚¹ã‚³ãƒ¼ãƒ—ã§åˆ¶é™ã•ã‚ŒãŸã‚¹ãƒ¬ãƒƒãƒ‰">Scoped threadsï¼ˆã‚¹ã‚³ãƒ¼ãƒ—ã§åˆ¶é™ã•ã‚ŒãŸã‚¹ãƒ¬ãƒƒãƒ‰ï¼‰</a></h1>
<p>All the lifetime issues we discussed so far have a common source:
the spawned thread can outlive its parent.<br />
We can sidestep this issue by using <strong>scoped threads</strong>.</p>
<blockquote>
<p>ã“ã‚Œã¾ã§ã«è­°è«–ã—ãŸã™ã¹ã¦ã®ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ã®å•é¡Œã¯ã€ã‚ˆãã‚ã‚‹åŸå› ã‚’æŒã£ã¦ã„ã¾ã™ã€‚
ãã‚Œã¯ã€ç”Ÿã¿å‡ºã•ã‚ŒãŸã‚¹ãƒ¬ãƒƒãƒ‰ã¯ã€ãã®è¦ªã‚ˆã‚Šã‚‚é•·ç”Ÿãã§ãã‚‹ã“ã¨ã§ã™ã€‚
<strong>ã‚¹ã‚³ãƒ¼ãƒ—ã§åˆ¶é™ã•ã‚ŒãŸã‚¹ãƒ¬ãƒƒãƒ‰</strong>ã‚’ä½¿ç”¨ã—ã¦ã€ã“ã®å•é¡Œã‚’å›é¿ã§ãã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = vec![1, 2, 3];
let midpoint = v.len() / 2;

std::thread::scope(|scope| {
    scope.spawn(|| {
        let first = &amp;v[..midpoint];
        println!("Here's the first half of v: {first:?}");
    });
    scope.spawn(|| {
        let second = &amp;v[midpoint..];
        println!("Here's the second half of v: {second:?}");
    });
});

println!("Here's v: {v:?}");
<span class="boring">}</span></code></pre></pre>
<p>Let's unpack what's happening.</p>
<blockquote>
<p>ä½•ãŒèµ·ã“ã£ã¦ã„ã‚‹ã‹èª¿ã¹ã¦ã¿ã¾ã—ã‚‡ã†ã€‚</p>
</blockquote>
<h2 id="scope"><a class="header" href="#scope"><code>scope</code></a></h2>
<p>The <code>std::thread::scope</code> function creates a new <strong>scope</strong>.<br />
<code>std::thread::scope</code> takes as input a closure, with a single argument: a <code>Scope</code> instance.</p>
<blockquote>
<p><code>std::thread::scope</code>é–¢æ•°ã¯æ–°ã—ã„<strong>ã‚¹ã‚³ãƒ¼ãƒ—</strong>ã‚’ä½œæˆã—ã¾ã™ã€‚
<code>std::thread::scope</code>ã¯ã€å…¥åŠ›ã¨ã—ã¦<code>Scope</code>ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’å˜ä¸€ã®å¼•æ•°ã«ã‚‚ã¤ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ãƒ¼ã‚’å—ã‘å–ã‚Šã¾ã™ã€‚</p>
</blockquote>
<h2 id="scoped-spawnsã‚¹ã‚³ãƒ¼ãƒ—ã§åˆ¶é™ã•ã‚ŒãŸç”Ÿã¿å‡ºã—"><a class="header" href="#scoped-spawnsã‚¹ã‚³ãƒ¼ãƒ—ã§åˆ¶é™ã•ã‚ŒãŸç”Ÿã¿å‡ºã—">Scoped spawnsï¼ˆã‚¹ã‚³ãƒ¼ãƒ—ã§åˆ¶é™ã•ã‚ŒãŸç”Ÿã¿å‡ºã—ï¼‰</a></h2>
<p><code>Scope</code> exposes a <code>spawn</code> method.<br />
Unlike <code>std::thread::spawn</code>, all threads spawned using a <code>Scope</code> will be
<strong>automatically joined</strong> when the scope ends.</p>
<blockquote>
<p><code>Scope</code>ã¯<code>spawn</code>ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å…¬é–‹ã—ã¾ã™ã€‚
<code>std::thread::spawn</code>ã¨ç•°ãªã‚Šã€<code>Scope</code>ã‚’ä½¿ç”¨ã—ã¦ç”Ÿã¿å‡ºã•ã‚ŒãŸã™ã¹ã¦ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã¯ã€ã‚¹ã‚³ãƒ¼ãƒ—ãŒçµ‚äº†ã—ãŸã¨ã<strong>è‡ªå‹•çš„ã«çµåˆ</strong>ã•ã‚Œã¾ã™ã€‚</p>
</blockquote>
<blockquote>
<p><code>Scope</code>å†…ã§ç”Ÿã¿å‡ºã•ã‚ŒãŸã‚¹ãƒ¬ãƒƒãƒ‰ã¯çµåˆã€ã¤ã¾ã‚Šã‚¹ãƒ¬ãƒƒãƒ‰ã®çµ‚äº†ã‚’å¾…ã¤ã€‚
ã‚ˆã£ã¦ã€<code>Scope</code>ã¨åŒã˜ã‚¹ã‚³ãƒ¼ãƒ—ã«ã‚ã‚‹å¤‰æ•°ã¯ã€<code>Scope</code>ã¨åŒã˜ã ã‘ç”Ÿå­˜ã™ã‚‹ãŸã‚ã€<code>Scope</code>å†…ã§ç”Ÿã¿å‡ºã•ã‚ŒãŸã‚¹ãƒ¬ãƒƒãƒ‰ã§è‡ªç”±ã«å‚ç…§ã§ãã‚‹ã€‚</p>
</blockquote>
<p>If we were to "translate" the previous example to <code>std::thread::spawn</code>,
it'd look like this:</p>
<blockquote>
<p>å‰ã®ä¾‹ã‚’<code>std::thread::spawn</code>ã«ã€Œç¿»è¨³ã€ã™ã‚‹ã¨ã€æ¬¡ã®ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = vec![1, 2, 3];
let midpoint = v.len() / 2;

let handle1 = std::thread::spawn(|| {
    let first = &amp;v[..midpoint];
    println!("Here's the first half of v: {first:?}");
});
let handle2 = std::thread::spawn(|| {
    let second = &amp;v[midpoint..];
    println!("Here's the second half of v: {second:?}");
});

handle1.join().unwrap();
handle2.join().unwrap();

println!("Here's v: {v:?}");
<span class="boring">}</span></code></pre></pre>
<h2 id="borrowing-from-the-environmentç’°å¢ƒã‹ã‚‰å€Ÿç”¨ã™ã‚‹"><a class="header" href="#borrowing-from-the-environmentç’°å¢ƒã‹ã‚‰å€Ÿç”¨ã™ã‚‹">Borrowing from the environmentï¼ˆç’°å¢ƒã‹ã‚‰å€Ÿç”¨ã™ã‚‹ï¼‰</a></h2>
<p>The translated example wouldn't compile, though: the compiler would complain
that <code>&amp;v</code> can't be used from our spawned threads since its lifetime isn't
<code>'static</code>.</p>
<blockquote>
<p>ãŸã ã—ã€ç¿»è¨³ã—ãŸä¾‹ã¯ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã‚Œã¾ã›ã‚“ã€‚
ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ¼ã¯ã€<code>&amp;v</code>ã®ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ãŒ<code>'static</code>ã§ãªã„ãŸã‚ã€ç”Ÿã¿å‡ºã—ãŸã‚¹ãƒ¬ãƒƒãƒ‰ã§ãã‚Œã‚’ä½¿ç”¨ã§ããªã„ã“ã¨ã«æ–‡å¥ã‚’è¨€ã†ã§ã—ã‚‡ã†ã€‚</p>
</blockquote>
<p>That's not an issue with <code>std::thread::scope</code>â€”you can <strong>safely borrow from the environment</strong>.</p>
<blockquote>
<p>ãã‚Œã¯ã€<code>std::thread::scope</code>ã§å•é¡Œã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚<strong>ç’°å¢ƒã‹ã‚‰å®‰å…¨ã«å€Ÿç”¨</strong>ã§ãã¾ã™ã€‚</p>
</blockquote>
<p>In our example, <code>v</code> is created before the spawning points.
It will only be dropped <em>after</em> <code>scope</code> returns. At the same time,
all threads spawned inside <code>scope</code> are guaranteed to finish <em>before</em> <code>scope</code> returns,
therefore there is no risk of having dangling references.</p>
<blockquote>
<p>ä¾‹ã«ãŠã„ã¦ã€<code>v</code>ã¯ç”Ÿã¿å‡ºã•ã‚ŒãŸåœ°ç‚¹ã®å‰ã«ä½œæˆã•ã‚Œã¾ã™ã€‚
ãã‚Œã¯ã€<code>scope</code>ãŒæˆ»ã£ãŸ <em>å¾Œ</em> ã«ã®ã¿ãƒ‰ãƒ­ãƒƒãƒ—ã•ã‚Œã¾ã™ã€‚
ãã‚Œã¨åŒæ™‚ã«ã€<code>scope</code>å†…ã§ç”Ÿæˆã•ã‚ŒãŸã™ã¹ã¦ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã¯ã€<code>scope</code>ãŒæˆ»ã‚‹ <em>å‰</em> ã«çµ‚äº†ã™ã‚‹ã“ã¨ãŒä¿è¨¼ã•ã‚Œã¦ã„ã‚‹ãŸã‚ã€ãƒ€ãƒ³ã‚°ãƒªãƒ³ã‚°å‚ç…§ã‚’æŒã¤ãƒªã‚¹ã‚¯ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚</p>
</blockquote>
<p>The compiler won't complain!</p>
<blockquote>
<p>ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ¼ã¯æ–‡å¥ã‚’è¨€ã„ã¾ã›ã‚“ã€‚</p>
</blockquote>
<h2 id="exercise-78"><a class="header" href="#exercise-78">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/07_threads/04_scoped_threads"><code>07_threads/04_scoped_threads</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="channelsãƒãƒ£ãƒãƒ«"><a class="header" href="#channelsãƒãƒ£ãƒãƒ«">Channelsï¼ˆãƒãƒ£ãƒãƒ«ï¼‰</a></h1>
<p>All our spawned threads have been fairly short-lived so far.<br />
Get some input, run a computation, return the result, shut down.</p>
<blockquote>
<p>ã“ã‚Œã¾ã§ç”Ÿã¿å‡ºã—ãŸã‚¹ãƒ¬ãƒƒãƒ‰ã¯ã€ã‹ãªã‚ŠçŸ­å‘½ã§ã—ãŸã€‚
ä½•ã‚‰ã‹ã®å…¥åŠ›ã‚’å—ã‘å–ã‚Šã€è¨ˆç®—ã‚’å®Ÿè¡Œã—ã¦ã€çµæœã‚’è¿”ã—ã¦ã€çµ‚äº†ã—ã¾ã™ã€‚</p>
</blockquote>
<p>For our ticket management system, we want to do something different:
a client-server architecture.</p>
<blockquote>
<p>ãƒã‚±ãƒƒãƒˆç®¡ç†ã‚·ã‚¹ãƒ†ãƒ ã§ã¯ã€é•ã£ãŸã“ã¨ã‚’è¡Œã†ã¤ã‚‚ã‚Šã§ã™ã€‚
ãã‚Œã¯ã€ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚µãƒ¼ãƒãƒ¼ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ãƒ¼ã§ã™ã€‚</p>
</blockquote>
<p>We will have <strong>one long-running server thread</strong>, responsible for managing
our state, the stored tickets.</p>
<blockquote>
<p><strong>1ã¤ã®é•·æ™‚é–“å®Ÿè¡Œã™ã‚‹ã‚µãƒ¼ãƒãƒ¼ã‚¹ãƒ¬ãƒƒãƒ‰</strong>ã‚’ã‚‚ã¡ã€çŠ¶æ…‹ã‚’ç®¡ç†ã™ã‚‹è²¬ä»»ã‚’æŒã¡ã€ãƒã‚±ãƒƒãƒˆã‚’ä¿å­˜ã—ã¾ã™ã€‚</p>
</blockquote>
<p>We will then have <strong>multiple client threads</strong>.<br />
Each client will be able to send <strong>commands</strong> and <strong>queries</strong> to
the stateful thread, in order to change its state (e.g. add a new ticket)
or retrieve information (e.g. get the status of a ticket).<br />
Client threads will run concurrently.</p>
<blockquote>
<p>ãã—ã¦ã€<strong>è¤‡æ•°ã®ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚¹ãƒ¬ãƒƒãƒ‰</strong>ã‚’æŒã¡ã¾ã™ã€‚
ãã‚Œãã‚Œã®ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã¯ã€æ–°ã—ã„ãƒã‚±ãƒƒãƒˆã‚’è¿½åŠ ã—ã¦çŠ¶æ…‹ã‚’å¤‰æ›´ã™ã‚‹ã€ã¾ãŸãƒã‚±ãƒƒãƒˆã®çŠ¶æ…‹ã‚’å–å¾—ã™ã‚‹ãŸã‚ã«ã€çŠ¶æ…‹ã‚’æŒã£ãŸã‚¹ãƒ¬ãƒƒãƒ‰ã«<strong>ã‚³ãƒãƒ³ãƒ‰</strong>ã¨<strong>ã‚¯ã‚¨ãƒª</strong>ã‚’é€ä¿¡ã—ã¾ã™ã€‚
ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚¹ãƒ¬ãƒƒãƒ‰ã¯ã€åŒæ™‚ä¸¦è¡Œã§å®Ÿè¡Œã—ã¾ã™ã€‚</p>
</blockquote>
<h2 id="communicationã‚³ãƒŸãƒ¥ãƒ‹ã‚±ãƒ¼ã‚·ãƒ§ãƒ³"><a class="header" href="#communicationã‚³ãƒŸãƒ¥ãƒ‹ã‚±ãƒ¼ã‚·ãƒ§ãƒ³">Communicationï¼ˆã‚³ãƒŸãƒ¥ãƒ‹ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ï¼‰</a></h2>
<p>So far we've only had very limited parent-child communication:</p>
<ul>
<li>The spawned thread borrowed/consumed data from the parent context</li>
<li>The spawned thread returned data to the parent when joined</li>
</ul>
<blockquote>
<p>ã“ã‚Œã¾ã§ã€ã¨ã¦ã‚‚é™å®šã•ã‚ŒãŸè¦ªã¨å­ã®ã‚³ãƒŸãƒ¥ãƒ‹ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã—ã‹ã‚ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚</p>
<ul>
<li>ç”Ÿã¿å‡ºã—ãŸã‚¹ãƒ¬ãƒƒãƒ‰ã¯ã€è¦ªã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‹ã‚‰ã®ãƒ‡ãƒ¼ã‚¿ã‚’å€Ÿç”¨ï¼æ¶ˆè²»ã—ã¾ã—ãŸã€‚</li>
<li>ç”Ÿã¿å‡ºã—ãŸã‚¹ãƒ¬ãƒƒãƒ‰ã¯ã€çµåˆã•ã‚ŒãŸã¨ãã€è¦ªã«ãƒ‡ãƒ¼ã‚¿ã‚’è¿”ã—ã¾ã—ãŸã€‚</li>
</ul>
</blockquote>
<p>This isn't enough for a client-server design.<br />
Clients need to be able to send and receive data from the server thread
<em>after</em> it has been launched.</p>
<blockquote>
<p>ã“ã‚Œã¯ã€ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆãƒ»ã‚µãƒ¼ãƒãƒ¼ã®ååˆ†ãªè¨­è¨ˆã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚
ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã¯ã€ãã‚ŒãŒèµ·å‹•ã—ãŸ <em>å¾Œ</em> ã§ã€ã‚µãƒ¼ãƒãƒ¼ã‚¹ãƒ¬ãƒƒãƒ‰ã«ãƒ‡ãƒ¼ã‚¿ã‚’é€ä¿¡ã¾ãŸã¯å—ä¿¡ã§ãã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚</p>
</blockquote>
<p>We can solve the issue using <strong>channels</strong>.</p>
<blockquote>
<p><strong>ãƒãƒ£ãƒãƒ«</strong>ã‚’ä½¿ç”¨ã—ã¦ã€ãã®å•é¡Œã‚’è§£æ±ºã§ãã¾ã™ã€‚</p>
</blockquote>
<h2 id="channelsãƒãƒ£ãƒãƒ«-1"><a class="header" href="#channelsãƒãƒ£ãƒãƒ«-1">Channelsï¼ˆãƒãƒ£ãƒãƒ«ï¼‰</a></h2>
<p>Rust's standard library provides <strong>multi-producer, single-consumer</strong> (mpsc) channels
in its <code>std::sync::mpsc</code> module.<br />
There are two channel flavours: bounded and unbounded. We'll stick to the unbounded
version for now, but we'll discuss the pros and cons later on.</p>
<blockquote>
<p>Rustæ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã¯<strong>ãƒãƒ«ãƒãƒ—ãƒ­ãƒ‡ãƒ¥ãƒ¼ã‚µãƒ¼ã€ã‚·ãƒ³ã‚°ãƒ«ã‚³ãƒ³ã‚·ãƒ¥ãƒ¼ãƒãƒ¼</strong>ï¼ˆmpscï¼‰ãƒãƒ£ãƒãƒ«ã‚’ã€<code>std::sync::mpsc</code>ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§æä¾›ã—ã¦ã„ã¾ã™ã€‚
2ã¤ã®ãƒãƒ£ãƒãƒ«ã®ç¨®é¡ãŒã‚ã‚Šã¾ã™ã€‚ãã‚Œã¯åˆ¶é™ã•ã‚ŒãŸã‚‚ã®ã¨åˆ¶é™ã•ã‚Œã¦ã„ãªã„ã‚‚ã®ã§ã™ã€‚
ç¾æ™‚ç‚¹ã§ã€åˆ¶é™ã•ã‚Œã¦ã„ãªã„ã‚‚ã®ã«å›ºåŸ·ã—ã¾ã™ãŒã€å¾Œã§åˆ©ç‚¹ã¨æ¬ ç‚¹ã‚’è­°è«–ã™ã‚‹äºˆå®šã§ã™ã€‚</p>
</blockquote>
<p>Channel creation looks like this:</p>
<blockquote>
<p>ãƒãƒ£ãƒãƒ«ã®ä½œæˆã¯æ¬¡ã®ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::mpsc::channel;

let (sender, receiver) = channel();
<span class="boring">}</span></code></pre></pre>
<p>You get a sender and a receiver.<br />
You call <code>send</code> on the sender to push data into the channel.<br />
You call <code>recv</code> on the receiver to pull data from the channel.</p>
<blockquote>
<p>é€ä¿¡è€…ã¨å—ä¿¡è€…ã‚’å–å¾—ã—ã¾ã™ã€‚
ãƒãƒ£ãƒãƒ«ã«ãƒ‡ãƒ¼ã‚¿ã‚’ã„ã‚Œã‚‹ãŸã‚ã«ã€é€ä¿¡è€…ã§<code>send</code>ã‚’å‘¼ã³å‡ºã—ã¾ã™ã€‚
ãƒãƒ£ãƒãƒ«ã‹ã‚‰ãƒ‡ãƒ¼ã‚¿ã‚’å¼•ãå‡ºã™ãŸã‚ã«ã€å—ä¿¡è€…ã§<code>recv</code>ã‚’å‘¼ã³å‡ºã—ã¾ã™ã€‚</p>
</blockquote>
<h3 id="multiple-sendersè¤‡æ•°ã®é€ä¿¡è€…"><a class="header" href="#multiple-sendersè¤‡æ•°ã®é€ä¿¡è€…">Multiple sendersï¼ˆè¤‡æ•°ã®é€ä¿¡è€…ï¼‰</a></h3>
<p><code>Sender</code> is clonable: we can create multiple senders (e.g. one for
each client thread) and they will all push data into the same channel.</p>
<blockquote>
<p><code>Sender</code>ã¯ã‚¯ãƒ­ãƒ¼ãƒ³å¯èƒ½ã§ã™ã€‚ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚¹ãƒ¬ãƒƒãƒ‰ãã‚Œãã‚Œã«1ã¤ã®é€ä¿¡è€…ãªã©ã€è¤‡æ•°ã®é€ä¿¡è€…ã‚’ä½œæˆã§ãã€ãã‚Œã‚‰ã¯åŒã˜ãƒãƒ£ãƒãƒ«ã«ãƒ‡ãƒ¼ã‚¿ã‚’å…¥ã‚Œã¾ã™ã€‚</p>
</blockquote>
<p><code>Receiver</code>, instead, is not clonable: there can only be a single receiver
for a given channel.</p>
<blockquote>
<p>ä»£ã‚ã‚Šã«<code>Receiver</code>ã¯ã‚¯ãƒ­ãƒ¼ãƒ³ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ç‰¹å®šã®ãƒãƒ£ãƒãƒ«ã«å˜ç‹¬ã®å—ä¿¡è€…ã®ã¿å­˜åœ¨ã§ãã¾ã™ã€‚</p>
</blockquote>
<p>That's what <strong>mpsc</strong> (multi-producer single-consumer) stands for!</p>
<blockquote>
<p>ãã‚ŒãŒ<strong>mpsc</strong>ï¼ˆãƒãƒ«ãƒãƒ—ãƒ­ãƒ‡ãƒ¥ãƒ¼ã‚µãƒ¼ã‚·ãƒ³ã‚°ãƒ«ã‚³ãƒ³ã‚·ãƒ¥ãƒ¼ãƒãƒ¼ï¼‰ã®æ„å‘³ã§ã™ï¼</p>
</blockquote>
<h3 id="message-typeãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®å‹"><a class="header" href="#message-typeãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®å‹">Message typeï¼ˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®å‹ï¼‰</a></h3>
<p>Both <code>Sender</code> and <code>Receiver</code> are generic over a type parameter <code>T</code>.<br />
That's the type of the <em>messages</em> that can travel on our channel.</p>
<blockquote>
<p><code>Sender</code>ã¨<code>Receiver</code>ä¸¡æ–¹ã¯ã€å‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼<code>T</code>ã«å¯¾ã—ã¦ã‚¸ã‚§ãƒãƒªãƒƒã‚¯ã§ã™ã€‚
ãã‚Œã¯ã€ãƒãƒ£ãƒãƒ«ã‚’æ—…è¡Œã™ã‚‹ <em>ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸</em> ã®å‹ã§ã™ã€‚</p>
</blockquote>
<p>It could be a <code>u64</code>, a struct, an enum, etc.</p>
<blockquote>
<p>ãã‚Œï¼ˆ<code>T</code>ï¼‰ã¯ã€<code>u64</code>ã€æ§‹é€ ä½“ã€åˆ—æŒ™å‹ãªã©ã§ã™ã€‚</p>
</blockquote>
<h3 id="errorsã‚¨ãƒ©ãƒ¼"><a class="header" href="#errorsã‚¨ãƒ©ãƒ¼">Errorsï¼ˆã‚¨ãƒ©ãƒ¼ï¼‰</a></h3>
<p>Both <code>send</code> and <code>recv</code> can fail.<br />
<code>send</code> returns an error if the receiver has been dropped.<br />
<code>recv</code> returns an error if all senders have been dropped and the channel is empty.</p>
<blockquote>
<p><code>send</code>ã¨<code>recv</code>ä¸¡æ–¹ã¨ã‚‚å¤±æ•—ã™ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚
<code>send</code>ã¯ã€å—ä¿¡è€…ãŒãƒ‰ãƒ­ãƒƒãƒ—ã•ã‚Œã¦ã„ãŸå ´åˆã€ã‚¨ãƒ©ãƒ¼ã‚’è¿”ã—ã¾ã™ã€‚
<code>recv</code>ã¯ã€ã™ã¹ã¦ã®é€ä¿¡è€…ãŒãƒ‰ãƒ­ãƒƒãƒ—ã•ã‚Œã¦ã„ã¦ã€ãƒãƒ£ãƒãƒ«ãŒç©ºã®å ´åˆã€ã‚¨ãƒ©ãƒ¼ã‚’è¿”ã—ã¾ã™ã€‚</p>
</blockquote>
<p>In other words, <code>send</code> and <code>recv</code> error when the channel is effectively closed.</p>
<blockquote>
<p>ã¤ã¾ã‚Šã€ãƒãƒ£ãƒãƒ«ãŒå®Ÿè³ªçš„ã«é–‰ã˜ã‚‰ã‚ŒãŸã¨ãã€<code>send</code>ã¨<code>recv</code>ã¯ã‚¨ãƒ©ãƒ¼ã¯å¤±æ•—ã—ã¾ã™ã€‚</p>
</blockquote>
<h2 id="exercise-79"><a class="header" href="#exercise-79">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/07_threads/05_channels"><code>07_threads/05_channels</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interior-mutabilityå†…éƒ¨å¯å¤‰æ€§"><a class="header" href="#interior-mutabilityå†…éƒ¨å¯å¤‰æ€§">Interior mutabilityï¼ˆå†…éƒ¨å¯å¤‰æ€§ï¼‰</a></h1>
<p>Let's take a moment to reason about the signature of <code>Sender</code>'s <code>send</code>:</p>
<blockquote>
<p><code>Sender</code>ã®<code>send</code>ã®ã‚·ã‚°ãƒãƒãƒ£ãƒ¼ã«ã¤ã„ã¦ç†ç”±ã‚’è€ƒãˆã‚‹ç¬é–“ã§ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; Sender&lt;T&gt; {
    pub fn send(&amp;self, t: T) -&gt; Result&lt;(), SendError&lt;T&gt;&gt; {
        // [...]
    }
}
<span class="boring">}</span></code></pre></pre>
<p><code>send</code> takes <code>&amp;self</code> as its argument.<br />
But it's clearly causing a mutation: it's adding a new message to the channel.
What's even more interesting is that <code>Sender</code> is cloneable: we can have multiple instances of <code>Sender</code>
trying to modify the channel state <strong>at the same time</strong>, from different threads.</p>
<blockquote>
<p><code>send</code>ã¯ãã®å¼•æ•°ã¨ã—ã¦<code>&amp;self</code>ã‚’å—ã‘å–ã‚Šã¾ã™ã€‚
ã—ã‹ã—ã€ãã‚Œã¯æ˜ã‚‰ã‹ã«å¤‰ç•°ã‚’èµ·ã“ã—ã¾ã™ã€‚ãã‚Œã¯ã€ãƒãƒ£ãƒãƒ«ã«æ–°ã—ã„ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¿½åŠ ã™ã‚‹ã‹ã‚‰ã§ã™ã€‚
ã‚ˆã‚Šèˆˆå‘³æ·±ã„ã“ã¨ã¯ã€<code>Sender</code>ãŒã‚¯ãƒ­ãƒ¼ãƒ³å¯èƒ½ãªã“ã¨ã§ã™ã€‚
ç•°ãªã‚‹ã‚¹ãƒ¬ãƒƒãƒ‰ã§<strong>åŒæ™‚ã«</strong>ãƒãƒ£ãƒãƒ«ã®çŠ¶æ…‹ã‚’å¤‰æ›´ã™ã‚‹ã“ã¨ã‚’è©¦ã¿ã‚‹ã€è¤‡æ•°ã®<code>Sender</code>ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’æŒã¦ã¾ã™ã€‚</p>
</blockquote>
<p>That's the key property we are using to build this client-server architecture. But why does it work?
Doesn't it violate Rust's rules about borrowing? How are we performing mutations via an <em>immutable</em> reference?</p>
<blockquote>
<p>ãã‚Œã¯ã€ã“ã®ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚µãƒ¼ãƒãƒ¼ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ãƒ¼ã‚’æ§‹ç¯‰ã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã—ãŸé‡è¦ãªç‰¹å¾´ã§ã™ã€‚
ã—ã‹ã—ã€ãã‚Œã¯ãªãœæ©Ÿèƒ½ã™ã‚‹ã®ã§ã—ã‚‡ã†ã‹ï¼Ÿ
ãã‚Œã¯ã€Rustã®å€Ÿç”¨ãƒ«ãƒ¼ãƒ«ã‚’ç ´ã£ã¦ã„ã¾ã›ã‚“ã‹ï¼Ÿ
<em>ä¸å¤‰</em> å‚ç…§ã‚’ä»‹ã—ã¦ã€ã©ã®ã‚ˆã†ã«å¤‰ç•°ã‚’è¡Œã£ã¦ã„ã‚‹ã®ã§ã—ã‚‡ã†ã‹ï¼Ÿ</p>
</blockquote>
<h2 id="shared-rather-than-immutable-referencesä¸å¤‰å‚ç…§ã§ã¯ãªãå…±æœ‰"><a class="header" href="#shared-rather-than-immutable-referencesä¸å¤‰å‚ç…§ã§ã¯ãªãå…±æœ‰">Shared rather than immutable referencesï¼ˆä¸å¤‰å‚ç…§ã§ã¯ãªãå…±æœ‰ï¼‰</a></h2>
<p>When we introduced the borrow-checker, we named the two types of references we can have in Rust:</p>
<ul>
<li>immutable references (<code>&amp;T</code>)</li>
<li>mutable references (<code>&amp;mut T</code>)</li>
</ul>
<blockquote>
<p>å€Ÿç”¨ãƒã‚§ãƒƒã‚«ãƒ¼ã‚’ç´¹ä»‹ã—ãŸã¨ãã€Rustã§æŒã¦ã‚‹2ç¨®é¡ã®å‚ç…§ã‚’åä»˜ã‘ã¾ã—ãŸã€‚</p>
<ul>
<li>ä¸å¤‰å‚ç…§ï¼ˆ<code>&amp;T</code>ï¼‰</li>
<li>å¯å¤‰å‚ç…§ï¼ˆ<code>&amp;mut T</code>ï¼‰</li>
</ul>
</blockquote>
<p>It would have been more accurate to name them:</p>
<ul>
<li>shared references (<code>&amp;T</code>)</li>
<li>exclusive references (<code>&amp;mut T</code>)</li>
</ul>
<blockquote>
<p>ãã‚Œã‚‰ã¯ã‚ˆã‚Šæ­£ç¢ºãªåå‰ãŒä»˜ã‘ã‚‰ã‚Œã¦ã„ã¾ã™ã€‚</p>
<ul>
<li>å…±æœ‰å‚ç…§ï¼ˆ<code>&amp;T</code>ï¼‰</li>
<li>æ’ä»–å‚ç…§ï¼ˆ<code>&amp;mut T</code>ï¼‰</li>
</ul>
</blockquote>
<p>Immutable/mutable is a mental model that works for the vast majority of cases, and it's a great one to get started
with Rust. But it's not the whole story, as you've just seen: <code>&amp;T</code> doesn't actually guarantee that the data it
points to is immutable.<br />
Don't worry, though: Rust is still keeping its promises.
It's just that the terms are a bit more nuanced than they might seem at first.</p>
<blockquote>
<p>ä¸å¤‰ï¼å¯å¤‰ã¯ã€ã»ã¨ã‚“ã©ã®å¤§åŠã®ã‚±ãƒ¼ã‚¹ã§æ©Ÿèƒ½ã™ã‚‹ä¾¡å€¤è¦³ï¼ˆãƒ¡ãƒ³ã‚¿ãƒ«ãƒ¢ãƒ‡ãƒ«ï¼‰ã§ã‚ã‚Šã€Rustã‚’å§‹ã‚ã‚‹æœ€é©ãªã‚‚ã®ã§ã™ã€‚
ã—ã‹ã—ã€ãã‚Œã¯å…¨ä½“ã®ã‚¹ãƒˆãƒ¼ãƒªãƒ¼ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ã¡ã‚‡ã†ã©è¦‹ãŸã‚ˆã†ã«ã€<code>&amp;T</code>ã¯ãã‚ŒãŒæŒ‡ã—ç¤ºã™ãƒ‡ãƒ¼ã‚¿ãŒä¸å¤‰ã§ã‚ã‚‹ã“ã¨ã‚’ã€å®Ÿéš›ã«ä¿è¨¼ã—ã¦ã„ã¾ã›ã‚“ã€‚
ãŸã ã—ã€å¿ƒé…ã—ãªã„ã§ãã ã•ã„ã€‚Rustã¯ã¾ã ãã®ç´„æŸã‚’å®ˆã£ã¦ã„ã¾ã™ã€‚
ãã‚Œã‚‰ã‚’æœ€åˆã«è¦‹ãŸã¨ãã‚ˆã‚Šã‚‚ã€ç”¨èªãŒå°‘ã—ã‚ˆã‚Šå¾®å¦™ã«ãªã£ãŸã ã‘ã§ã™ã€‚</p>
</blockquote>
<h2 id="unsafecell"><a class="header" href="#unsafecell"><code>UnsafeCell</code></a></h2>
<p>Whenever a type allows you to mutate data through a shared reference, you're dealing with <strong>interior mutability</strong>.</p>
<blockquote>
<p>å…±æœ‰å‚ç…§ã‚’ä»‹ã—ã¦å‹ãŒãƒ‡ãƒ¼ã‚¿ã‚’å¤‰æ›´ã§ãã‚‹ã‚ˆã†ã«ã—ãŸã¨ãã¯ã„ã¤ã§ã‚‚ã€<strong>å†…éƒ¨å¯å¤‰æ€§</strong>ã‚’æ‰±ã£ã¦ã„ã¾ã™ã€‚</p>
</blockquote>
<p>By default, the Rust compiler assumes that shared references are immutable. It <strong>optimises your code</strong> based on that assumption.<br />
The compiler can reorder operations, cache values, and do all sorts of magic to make your code faster.</p>
<blockquote>
<p>ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã€Rustã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ¼ã¯ã€å…±æœ‰å‚ç…§ãŒä¸å¤‰ã§ã‚ã‚‹ã¨ä»®å®šã—ã¾ã™ã€‚
ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ¼ã¯ãã®ä»®å®šã«åŸºã¥ã„ã¦ã€<strong>ã‚³ãƒ¼ãƒ‰ã‚’æœ€é©åŒ–</strong>ã—ã¾ã™ã€‚
ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ¼ã¯ã€æ“ä½œã‚’å†é…ç½®ã€å€¤ã‚’ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã€ãã—ã¦ã€ã‚³ãƒ¼ãƒ‰ã‚’æ—©ãã™ã‚‹ãŸã‚ã«ã‚ã‚‰ã‚†ã‚‹ç¨®é¡ã®é­”æ³•ã‚’ã‹ã‘ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚</p>
</blockquote>
<p>You can tell the compiler "No, this shared reference is actually mutable" by wrapping the data in an <code>UnsafeCell</code>.<br />
Every time you see a type that allows interior mutability, you can be certain that <code>UnsafeCell</code> is involved,
either directly or indirectly.<br />
Using <code>UnsafeCell</code>, raw pointers and <code>unsafe</code> code, you can mutate data through shared references.</p>
<blockquote>
<p><code>UnsafeCell</code>å†…ã«ãƒ‡ãƒ¼ã‚¿ã‚’ãƒ©ãƒƒãƒ—ã™ã‚‹ã“ã¨ã§ã€ã€Œã„ã„ãˆã€ã“ã®å…±æœ‰å‚ç…§ã¯ã€å®Ÿéš›ã«ã¯å¤‰æ›´å¯èƒ½ã§ã™ã€ã¨ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ¼ã«ä¼ãˆã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚
å†…éƒ¨å¯å¤‰æ€§ã‚’è¨±å¯ã™ã‚‹å‹ã‚’è¦‹ã‚‹ãŸã³ã«ã€<code>UnsafeCell</code>ãŒé–¢ä¸ã—ã¦ã„ã‚‹ã“ã¨ã‚’ç¢ºä¿¡ã§ãã¾ã™ã€‚
<code>UnsafeCell</code>ã€ç”Ÿãƒã‚¤ãƒ³ã‚¿ãƒ¼ãã—ã¦<code>unsafe</code>ã‚³ãƒ¼ãƒ‰ã‚’ä½¿ç”¨ã—ã¦ã€å…±æœ‰å‚ç…§ã‚’ä»‹ã—ã¦ãƒ‡ãƒ¼ã‚¿ã‚’å¤‰æ›´ã§ãã¾ã™ã€‚</p>
</blockquote>
<p>Let's be clear, though: <code>UnsafeCell</code> isn't a magic wand that allows you to ignore the borrow-checker!<br />
<code>unsafe</code> code is still subject to Rust's rules about borrowing and aliasing.
It's an (advanced) tool that you can leverage to build <strong>safe abstractions</strong> whose safety can't be directly expressed
in Rust's type system. Whenever you use the <code>unsafe</code> keyword you're telling the compiler:
"I know what I'm doing, I won't violate your invariants, trust me."</p>
<blockquote>
<p>ãŸã ã—ã€æ˜ç¢ºã«ã—ã¾ã—ã‚‡ã†ã€‚<code>UnsafeCell</code>ã¯ã€å€Ÿç”¨ãƒã‚§ãƒƒã‚«ãƒ¼ã‚’ç„¡è¦–ã•ã›ã‚‹é­”æ³•ã®æ–ã§ã¯ã‚ã‚Šã¾ã›ã‚“ï¼
<code>unsafe</code>ã‚³ãƒ¼ãƒ‰ã¯ã€ã¾ã å€Ÿç”¨ã¨ã‚¨ã‚¤ãƒªã‚¢ã‚¹ã«é–¢ã™ã‚‹Rustã®ãƒ«ãƒ¼ãƒ«ã®å¯¾è±¡ã§ã™ã€‚
ãã‚Œã¯ã€Rustã®å‹ã‚·ã‚¹ãƒ†ãƒ å†…ã§ã€å®‰å…¨æ€§ã‚’ç›´æ¥è¡¨ç¾ã§ããªã„<strong>å®‰å…¨ãªæŠ½è±¡åŒ–</strong>ã‚’æ§‹ç¯‰ã™ã‚‹ãŸã‚ã«åˆ©ç”¨ã§ãã‚‹é«˜åº¦ãªãƒ„ãƒ¼ãƒ«ã§ã™ã€‚
<code>unsafe</code>ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’ä½¿ç”¨ã™ã‚‹ã¨ãã¯ã„ã¤ã§ã‚‚ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ¼ã«æ¬¡ã‚’ä¼ãˆã¦ã„ã¾ã™ã€‚
ã€Œç§ã¯ä½•ã‚’ã—ã¦ã„ã‚‹ã‹ç†è§£ã—ã¦ã„ã¾ã™ã€‚ã‚ãªãŸã®ä¸å¤‰æ¡ä»¶ã‚’ç ´ã‚‹ã¤ã‚‚ã‚Šã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ä¿¡ã˜ã¦ãã ã•ã„ã€‚ã€</p>
</blockquote>
<p>Every time you call an <code>unsafe</code> function, there will be documentation explaining its <strong>safety preconditions</strong>:
under what circumstances it's safe to execute its <code>unsafe</code> block. You can find the ones for <code>UnsafeCell</code>
<a href="https://doc.rust-lang.org/std/cell/struct.UnsafeCell.html">in <code>std</code>'s documentation</a>.</p>
<blockquote>
<p><code>unsafe</code>é–¢æ•°ã‚’å‘¼ã³å‡ºã™ãŸã³ã«ã€ãã®<code>unsafe</code>ãƒ–ãƒ­ãƒƒã‚¯ã‚’å®Ÿè¡Œã™ã‚‹å®‰å…¨ãªç’°å¢ƒã®ä¸‹ã§ã€ãã®<strong>å®‰å…¨æ€§ã®å‰ææ¡ä»¶</strong>ã‚’èª¬æ˜ã™ã‚‹ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆãŒã‚ã‚Šã¾ã™ã€‚
æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®<code>UnsafeCell</code>ã§è¦‹ã¤ã‘ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚</p>
</blockquote>
<p>We won't be using <code>UnsafeCell</code> directly in this course, nor will we be writing <code>unsafe</code> code.
But it's important to know that it's there, why it exists and how it relates to the types you use
every day in Rust.</p>
<blockquote>
<p>ã“ã®ã‚³ãƒ¼ã‚¹ã«ãŠã„ã¦ã€<code>UnsafeCell</code>ã‚’ç›´æ¥ä½¿ç”¨ã—ã¾ã›ã‚“ã—ã€<code>unsafe</code>ã‚³ãƒ¼ãƒ‰ã‚’æ›¸ãã“ã¨ã‚‚ã‚ã‚Šã¾ã›ã‚“ã€‚
ã—ã‹ã—ã€Rustå†…ã«ãªãœãã‚ŒãŒå­˜åœ¨ã—ã¦ã€ãã‚ŒãŒã©ã®ã‚ˆã†ã«æ¯æ—¥ä½¿ç”¨ã™ã‚‹å‹ã«é–¢é€£ã™ã‚‹ã®ã‹ã‚’ç†è§£ã™ã‚‹ã“ã¨ã¯é‡è¦ã§ã™ã€‚</p>
</blockquote>
<h2 id="key-exampleséµã¨ãªã‚‹ä¾‹"><a class="header" href="#key-exampleséµã¨ãªã‚‹ä¾‹">Key examplesï¼ˆéµã¨ãªã‚‹ä¾‹ï¼‰</a></h2>
<p>Let's go through a couple of important <code>std</code> types that leverage interior mutability.<br />
These are types that you'll encounter somewhat often in Rust code, especially if you peek under the hood of
some the libraries you use.</p>
<blockquote>
<p>å†…éƒ¨å¯å¤‰æ€§ã‚’åˆ©ç”¨ã™ã‚‹é‡è¦ãª<code>std</code>ã®å‹ã®çµ„ã‚’ç¢ºèªã—ã¾ã—ã‚‡ã†ã€‚
ç‰¹ã«ä½¿ç”¨ã™ã‚‹ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®å†…éƒ¨ã‚’è¦—ã„ãŸå ´åˆã€Rustã‚³ãƒ¼ãƒ‰ã§ã‹ãªã‚Šé »ç¹ã«é­é‡ã™ã‚‹å‹ãŒã‚ã‚Šã¾ã™ã€‚</p>
</blockquote>
<h3 id="reference-countingå‚ç…§ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼"><a class="header" href="#reference-countingå‚ç…§ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼">Reference countingï¼ˆå‚ç…§ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼ï¼‰</a></h3>
<p><code>Rc</code> is a reference-counted pointer.<br />
It wraps around a value and keeps track of how many references to the value exist.
When the last reference is dropped, the value is deallocated.<br />
The value wrapped in an <code>Rc</code> is immutable: you can only get shared references to it.</p>
<blockquote>
<p><code>Rc</code>ã¯å‚ç…§ã‚’ã‚«ã‚¦ãƒ³ãƒˆã™ã‚‹ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã§ã™ã€‚
ãã‚Œã¯å€¤ã‚’ãƒ©ãƒƒãƒ—ã—ã¦ã€ãã®å€¤ã¸ã®å‚ç…§ãŒå­˜åœ¨ã™ã‚‹æ•°ã‚’è¿½è·¡ã—ã¾ã™ã€‚
æœ€å¾Œã®å‚ç…§ãŒãƒ‰ãƒ­ãƒƒãƒ—ã•ã‚ŒãŸã¨ãã€ãã®å€¤ã¯è§£æ”¾ã•ã‚Œã¾ã™ã€‚
<code>Rc</code>ã«ãƒ©ãƒƒãƒ—ã•ã‚ŒãŸå€¤ã¯ä¸å¤‰ã§ã™ã€‚ãã‚Œã‹ã‚‰å…±æœ‰å‚ç…§ã®ã¿å¾—ã‚‰ã‚Œã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::rc::Rc;

let a: Rc&lt;String&gt; = Rc::new("My string".to_string());
// Only one reference to the string data exists.
// ãã®æ–‡å­—åˆ—ãƒ‡ãƒ¼ã‚¿ã¸ã®å‚ç…§ãŒå”¯ä¸€å­˜åœ¨ã—ã¾ã™ã€‚
assert_eq!(Rc::strong_count(&amp;a), 1);

// When we call `clone`, the string data is not copied!
// Instead, the reference count for `Rc` is incremented.
// `clone`ã‚’å‘¼ã³å‡ºã—ãŸã¨ãã€æ–‡å­—åˆ—ãƒ‡ãƒ¼ã‚¿ã¯ã‚³ãƒ”ãƒ¼ã•ã‚Œã¾ã›ã‚“ï¼
// ä»£ã‚ã‚Šã«ã€`Rc`ã®å‚ç…§ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼ãŒå¢—åŠ ã•ã‚Œã¾ã™ã€‚
let b = Rc::clone(&amp;a);
assert_eq!(Rc::strong_count(&amp;a), 2);
assert_eq!(Rc::strong_count(&amp;b), 2);
// ^ Both `a` and `b` point to the same string data
//   and share the same reference counter.
// `a`ã¨`b`ä¸¡æ–¹ã¯ã€åŒã˜æ–‡å­—åˆ—ãƒ‡ãƒ¼ã‚¿ã‚’æŒ‡ã—ç¤ºã—ã¦ã€åŒã˜å‚ç…§ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼ã‚’å…±æœ‰ã—ã¦ã„ã¾ã™ã€‚
<span class="boring">}</span></code></pre></pre>
<p><code>Rc</code> uses <code>UnsafeCell</code> internally to allow shared references to increment and decrement the reference count.</p>
<blockquote>
<p><code>Rc</code>ã¯ã€å…±æœ‰å‚ç…§ãŒå‚ç…§ã®æ•°ã‚’å¢—ã‚„ã—ãŸã‚Šæ¸›ã‚‰ã—ãŸã‚Šã™ã‚‹ãŸã‚ã«ã€å†…éƒ¨ã§<code>UnsafeCell</code>ã‚’ä½¿ç”¨ã—ã¦ã„ã¾ã™ã€‚</p>
</blockquote>
<blockquote>
<p>ä¸Šè¨˜ä¾‹ã®<code>Rc</code>å‹ã®å¤‰æ•°<code>a</code>ã¨<code>b</code>ã¯<code>mut</code>ã§ãªã„ãŸã‚ä¸å¤‰ã§ã‚ã‚‹ã€‚
ã—ã‹ã—ã€<code>a</code>ã¨<code>b</code>ãŒå…±æœ‰ã™ã‚‹å‚ç…§ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼ã‚’å¤‰æ›´ã™ã‚‹ãŸã‚ã«ã€å†…éƒ¨ã§<code>UnsafeCell</code>ã‚’ä½¿ç”¨ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã€‚</p>
</blockquote>
<h3 id="refcell"><a class="header" href="#refcell"><code>RefCell</code></a></h3>
<p><code>RefCell</code> is one of the most common examples of interior mutability in Rust.
It allows you to mutate the value wrapped in a <code>RefCell</code> even if you only have an
immutable reference to the <code>RefCell</code> itself.</p>
<blockquote>
<p><code>RefCell</code>ã¯ã€Rustã«ãŠã„ã¦å†…éƒ¨å¯å¤‰æ€§ã®æœ€ã‚‚ä¸€èˆ¬çš„ãªä¾‹ã®1ã¤ã§ã™ã€‚
ãã‚Œã¯ã€<code>RefCell</code>è‡ªèº«ã¸ã®ä¸å¤‰å‚ç…§ã‚’æŒã£ã¦ã„ãŸå ´åˆã§ã‚‚ã€<code>RefCell</code>å†…ã«ãƒ©ãƒƒãƒ—ã—ãŸå€¤ã‚’å¤‰æ›´ã•ã›ã¾ã™ã€‚</p>
</blockquote>
<p>This is done via <strong>runtime borrow checking</strong>.
The <code>RefCell</code> keeps track of the number (and type) of references to the value it contains at runtime.
If you try to borrow the value mutably while it's already borrowed immutably,
the program will panic, ensuring that Rust's borrowing rules are always enforced.</p>
<blockquote>
<p>ã“ã‚Œã¯ã€<strong>ãƒ©ãƒ³ã‚¿ã‚¤ãƒ å€Ÿç”¨ãƒã‚§ãƒƒã‚«ãƒ¼</strong>ã‚’ä»‹ã—ã¦è¡Œã‚ã‚Œã¾ã™ã€‚
<code>RefCell</code>ã¯ã€ãƒ©ãƒ³ã‚¿ã‚¤ãƒ ã§ãã‚ŒãŒå«ã‚€å€¤ã¸ã®å‚ç…§ã®æ•°ï¼ˆã¨å‹ï¼‰ã‚’è¿½è·¡ã—ã¾ã™ã€‚
å€¤ãŒã™ã§ã«ä¸å¤‰ã§å€Ÿç”¨ã•ã‚Œã¦ã„ã‚‹é–“ã«ã€å€¤ã‚’å¯å¤‰ã§å€Ÿç”¨ã™ã‚‹ã“ã¨ã‚’è©¦ã¿ãŸå ´åˆã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯ãƒ‘ãƒ‹ãƒƒã‚¯ã—ã¦ã€Rustã®å€Ÿç”¨ãƒ«ãƒ¼ãƒ«ãŒå¸¸ã«å¼·åˆ¶ã•ã‚Œã‚‹ã“ã¨ã‚’ä¿è¨¼ã—ã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::cell::RefCell;

let x = RefCell::new(42);

let y = x.borrow(); // Immutable borrowï¼ˆä¸å¤‰å€Ÿç”¨ï¼‰
let z = x.borrow_mut(); // Panics! There is an active immutable borrow.ï¼ˆãƒ‘ãƒ‹ãƒƒã‚¯ã—ã¾ã™ï¼ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªä¸å¤‰å€Ÿç”¨ãŒã‚ã‚Šã¾ã™ï¼‰
<span class="boring">}</span></code></pre></pre>
<h2 id="exercise-80"><a class="header" href="#exercise-80">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/07_threads/06_interior_mutability"><code>07_threads/06_interior_mutability</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="two-way-communicationåŒæ–¹å‘é€šä¿¡"><a class="header" href="#two-way-communicationåŒæ–¹å‘é€šä¿¡">Two-way communicationï¼ˆåŒæ–¹å‘é€šä¿¡ï¼‰</a></h1>
<p>In our current client-server implementation, communication flows in one direction: from the client to the server.<br />
The client has no way of knowing if the server received the message, executed it successfully, or failed.
That's not ideal.</p>
<blockquote>
<p>ç¾åœ¨ã®ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚µãƒ¼ãƒãƒ¼ã®å®Ÿè£…ã«ãŠã„ã¦ã€é€šä¿¡ã®æµã‚Œã¯ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‹ã‚‰ã‚µãƒ¼ãƒãƒ¼ã¸å‘ã‹ã†ä¸€æ–¹å‘ã§ã™ã€‚
ã‚µãƒ¼ãƒãƒ¼ãŒãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å—ã‘å–ã£ãŸå ´åˆã€æ­£å¸¸ã«å®Ÿè¡Œã•ã‚ŒãŸã‹ãã‚Œã¨ã‚‚å¤±æ•—ã—ãŸã‹ã€ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã¯çŸ¥ã‚‹æ–¹æ³•ãŒã‚ã‚Šã¾ã›ã‚“ã€‚
ã“ã‚Œã¯ç†æƒ³çš„ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚</p>
</blockquote>
<p>To solve this issue, we can introduce a two-way communication system.</p>
<blockquote>
<p>ã“ã®å•é¡Œã‚’è§£æ±ºã™ã‚‹ãŸã‚ã«ã€åŒæ–¹å‘é€šä¿¡ã‚·ã‚¹ãƒ†ãƒ ã‚’å°å…¥ã§ãã¾ã™ã€‚</p>
</blockquote>
<h2 id="response-channelå¿œç­”ãƒãƒ£ãƒãƒ«"><a class="header" href="#response-channelå¿œç­”ãƒãƒ£ãƒãƒ«">Response channelï¼ˆå¿œç­”ãƒãƒ£ãƒãƒ«ï¼‰</a></h2>
<p>We need a way for the server to send a response back to the client.<br />
There are various ways to do this, but the simplest option is to include a <code>Sender</code> channel in
the message that the client sends to the server. After processing the message, the server can use
this channel to send a response back to the client.</p>
<blockquote>
<p>ã‚µãƒ¼ãƒãƒ¼ãŒã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã«å¿œç­”ã‚’é€ä¿¡ã™ã‚‹æ–¹æ³•ãŒå¿…è¦ã§ã™ã€‚
ã“ã‚Œã‚’è¡Œã†æ§˜ã€…ãªæ–¹æ³•ãŒã‚ã‚Šã¾ã™ãŒã€æœ€ã‚‚å˜ç´”ãªé¸æŠè‚¢ã¯ã€ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆãŒã‚µãƒ¼ãƒãƒ¼ã«é€ä¿¡ã™ã‚‹ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å†…ã«<code>Sender</code>ãƒãƒ£ãƒãƒ«ã‚’å«ã‚ã‚‹ã“ã¨ã§ã™ã€‚
ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å‡¦ç†ã—ãŸå¾Œã€ã‚µãƒ¼ãƒãƒ¼ã¯ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã«ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’é€ä¿¡ã™ã‚‹ãŸã‚ã«ã€ã“ã®ãƒãƒ£ãƒãƒ«ã‚’ä½¿ç”¨ã§ãã¾ã™ã€‚</p>
</blockquote>
<p>This is a fairly common pattern in Rust applications built on top of message-passing primitives.</p>
<blockquote>
<p>ã“ã‚Œã¯ã€ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒ‘ãƒƒã‚·ãƒ³ã‚°æ§‹æˆè¦ç´ ã®ä¸Šã«æ§‹ç¯‰ã•ã‚ŒãŸRustã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®ä¸­ã§ã€ã‹ãªã‚Šä¸€èˆ¬çš„ãªãƒ‘ã‚¿ãƒ¼ãƒ³ã§ã™ã€‚</p>
</blockquote>
<h2 id="exercise-81"><a class="header" href="#exercise-81">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/07_threads/07_ack"><code>07_threads/07_ack</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a-dedicated-client-typeå°‚ç”¨ã®clientå‹"><a class="header" href="#a-dedicated-client-typeå°‚ç”¨ã®clientå‹">A dedicated <code>Client</code> typeï¼ˆå°‚ç”¨ã®Clientå‹ï¼‰</a></h1>
<p>All the interactions from the client side have been fairly low-level: you have to
manually create a response channel, build the command, send it to the server, and
then call <code>recv</code> on the response channel to get the response.</p>
<blockquote>
<p>ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå´ã‹ã‚‰ã®ã™ã¹ã¦ã®ç›¸äº’ä½œç”¨ã¯ã€ã‹ãªã‚Šä½æ°´æº–ã§ã—ãŸã€‚
æ‰‹å‹•ã§ãƒ¬ã‚¹ãƒãƒ³ã‚¹ç”¨ã®ãƒãƒ£ãƒãƒ«ã‚’ä½œæˆã—ã¦ã€ã‚³ãƒãƒ³ãƒ‰ã‚’æ§‹ç¯‰ã€ãã‚Œï¼ˆãƒ¬ã‚¹ãƒãƒ³ã‚¹ç”¨ã®ãƒãƒ£ãƒãƒ«ï¼‰ã‚’ã‚µãƒ¼ãƒãƒ¼ã«é€ä¿¡ã€ãã—ã¦ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’å¾—ã‚‹ãŸã‚ã«ãƒ¬ã‚¹ãƒãƒ³ã‚¹ç”¨ã®ãƒãƒ£ãƒãƒ«ã«<code>recv</code>ã‚’å‘¼ã³å‡ºã•ãªãã¦ã¯ãªã‚Šã¾ã›ã‚“ã€‚</p>
</blockquote>
<p>This is a lot of boilerplate code that could be abstracted away, and that's
exactly what we're going to do in this exercise.</p>
<blockquote>
<p>ã“ã‚Œã¯ã€æŠ½è±¡åŒ–ã§ãã‚‹å¤šãã®å®šå‹ã‚³ãƒ¼ãƒ‰ã§ã€ã•ã«ãã‚ŒãŒã“ã®æ¼”ç¿’ã§è¡Œã†ã“ã¨ã§ã™ã€‚</p>
</blockquote>
<blockquote>
<p>é€šå¸¸ã®é€šä¿¡ã‚’è¡Œã†ãƒãƒ£ãƒãƒ«ã®ä»–ã«ã€ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã¯ã‚³ãƒãƒ³ãƒ‰ã‚’é€ä¿¡ã™ã‚‹ã¨ãã«ã€ã‚µãƒ¼ãƒãƒ¼ãŒãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’è¿”ã™ãŸã‚ã®åˆ¥ãƒãƒ£ãƒãƒ«ã‚’ä½œæˆã—ã¦ã€ãã®é€ä¿¡å´ã‚’ã‚³ãƒãƒ³ãƒ‰ã«å«ã‚ã¦ã‚µãƒ¼ãƒãƒ¼ã«é€ä¿¡ã™ã‚‹ã€‚
ã‚µãƒ¼ãƒãƒ¼ã¯ã€ã‚³ãƒãƒ³ãƒ‰ã‚’å‡¦ç†å¾Œã€ã‚³ãƒãƒ³ãƒ‰ã«å«ã¾ã‚ŒãŸé€ä¿¡ãƒãƒ£ãƒãƒ«ã‚’ä½¿ç”¨ã—ã¦ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã«ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’è¿”ã™ã€‚
ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã¯ã€ä½œæˆã—ãŸåˆ¥ãƒãƒ£ãƒãƒ«ã®å—ä¿¡ãƒãƒ£ãƒãƒ«ã§ã‚µãƒ¼ãƒãƒ¼ã‹ã‚‰é€ä¿¡ã•ã‚Œã‚‹ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’å—ä¿¡ã™ã‚‹ã€‚</p>
</blockquote>
<h2 id="exercise-82"><a class="header" href="#exercise-82">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/07_threads/08_client"><code>07_threads/08_client</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bounded-vs-unbounded-channelsåˆ¶é™ã•ã‚ŒãŸãƒãƒ£ãƒãƒ«ã¨éåˆ¶é™ãƒãƒ£ãƒãƒ«"><a class="header" href="#bounded-vs-unbounded-channelsåˆ¶é™ã•ã‚ŒãŸãƒãƒ£ãƒãƒ«ã¨éåˆ¶é™ãƒãƒ£ãƒãƒ«">Bounded vs unbounded channelsï¼ˆåˆ¶é™ã•ã‚ŒãŸãƒãƒ£ãƒãƒ«ã¨éåˆ¶é™ãƒãƒ£ãƒãƒ«ï¼‰</a></h1>
<p>So far we've been using unbounded channels.<br />
You can send as many messages as you want, and the channel will grow to accommodate them.<br />
In a multi-producer single-consumer scenario, this can be problematic: if the producers
enqueues messages at a faster rate than the consumer can process them, the channel will
keep growing, potentially consuming all available memory.</p>
<blockquote>
<p>ã“ã‚Œã¾ã§ã€éåˆ¶é™ãƒãƒ£ãƒãƒ«ã‚’ä½¿ç”¨ã—ã¦ãã¾ã—ãŸã€‚
æœ›ã‚€ã ã‘å¤šãã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’é€ä¿¡ã§ãã€ãƒãƒ£ãƒãƒ«ã¯ãã‚Œã‚‰ã‚’åå®¹ã™ã‚‹ãŸã‚ã«æˆé•·ã—ã¾ã™ã€‚
ãƒãƒ«ãƒãƒ—ãƒ­ãƒ‡ãƒ¥ãƒ¼ã‚µãƒ¼ã‚·ãƒ³ã‚°ãƒ«ã‚³ãƒ³ã‚·ãƒ¥ãƒ¼ãƒãƒ¼ã‚·ãƒŠãƒªã‚ªã§ã¯ã€ã“ã‚Œã¯å•é¡Œã«ãªã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚
ãƒ—ãƒ­ãƒ‡ãƒ¥ãƒ¼ã‚µãƒ¼ãŒã€ã‚³ãƒ³ã‚·ãƒ¥ãƒ¼ãƒãƒ¼ãŒãã‚Œã‚‰ã‚’å‡¦ç†ã™ã‚‹ã‚ˆã‚Šã‚‚æ—©ããƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ã‚­ãƒ¥ãƒ¼ã«å…¥ã‚ŒãŸå ´åˆã€ãƒãƒ£ãƒãƒ«ã¯æˆé•·ã—ç¶šã‘ã€åˆ©ç”¨å¯èƒ½ãªãƒ¡ãƒ¢ãƒªã‚’ã™ã¹ã¦æ¶ˆè²»ã™ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚</p>
</blockquote>
<p>Our recommendation is to <strong>never</strong> use an unbounded channel in a production system.<br />
You should always enforce an upper limit on the number of messages that can be enqueued using a
<strong>bounded channel</strong>.</p>
<blockquote>
<p>ãƒ—ãƒ­ãƒ€ã‚¯ã‚·ãƒ§ãƒ³ã‚·ã‚¹ãƒ†ãƒ ã«ãŠã‘ã‚‹æ¨å¥¨äº‹é …ã¯ã€<strong>æ±ºã—ã¦</strong>éåˆ¶é™ãƒãƒ£ãƒãƒ«ã‚’ä½¿ç”¨ã—ãªã„ã“ã¨ã§ã™ã€‚
<strong>åˆ¶é™ã•ã‚ŒãŸãƒãƒ£ãƒãƒ«</strong>ã‚’ä½¿ç”¨ã—ã¦ã€å¸¸ã«ã‚­ãƒ¥ãƒ¼ã«å…¥ã‚Œã‚‰ã‚Œã‚‹ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®ä¸Šé™ã‚’å¼·åˆ¶ã™ã‚‹ã¹ãã§ã™ã€‚</p>
</blockquote>
<h2 id="bounded-channelsåˆ¶é™ã•ã‚ŒãŸãƒãƒ£ãƒãƒ«"><a class="header" href="#bounded-channelsåˆ¶é™ã•ã‚ŒãŸãƒãƒ£ãƒãƒ«">Bounded channelsï¼ˆåˆ¶é™ã•ã‚ŒãŸãƒãƒ£ãƒãƒ«ï¼‰</a></h2>
<p>A bounded channel has a fixed capacity.<br />
You can create one by calling <code>sync_channel</code> with a capacity greater than zero:</p>
<blockquote>
<p>åˆ¶é™ã•ã‚ŒãŸãƒãƒ£ãƒãƒ«ã¯å›ºå®šã•ã‚ŒãŸå®¹é‡ã‚’æŒã¡ã¾ã™ã€‚
ã‚¼ãƒ­ã‚ˆã‚Šå¤§ãã„å®¹é‡ã§<code>sync_channel</code>ã‚’å‘¼ã³å‡ºã™ã“ã¨ã§ã€ãã‚Œã‚’ä½œæˆã§ãã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::mpsc::sync_channel;

let (sender, receiver) = sync_channel(10);
<span class="boring">}</span></code></pre></pre>
<p><code>receiver</code> has the same type as before, <code>Receiver&lt;T&gt;</code>.<br />
<code>sender</code>, instead, is an instance of <code>SyncSender&lt;T&gt;</code>.</p>
<blockquote>
<p><code>receiver</code>ã¯ã€å‰ã®<code>Receiver&lt;T&gt;</code>ã¨åŒã˜å‹ã‚’æŒã¡ã€ä»£ã‚ã‚Šã«<code>sender</code>ã¯<code>SyncSender&lt;T&gt;</code>ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã§ã™ã€‚</p>
</blockquote>
<h3 id="sending-messagesãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®é€ä¿¡"><a class="header" href="#sending-messagesãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®é€ä¿¡">Sending messagesï¼ˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®é€ä¿¡ï¼‰</a></h3>
<p>You have two different methods to send messages through a <code>SyncSender</code>:</p>
<ul>
<li><code>send</code>: if there is space in the channel, it will enqueue the message and return <code>Ok(())</code>.<br />
If the channel is full, it will block and wait until there is space available.</li>
<li><code>try_send</code>: if there is space in the channel, it will enqueue the message and return <code>Ok(())</code>.<br />
If the channel is full, it will return <code>Err(TrySendError::Full(value))</code>, where <code>value</code> is the message that couldn't be sent.</li>
</ul>
<blockquote>
<p><code>SyncSender</code>ã‚’ä»‹ã—ã¦ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’é€ä¿¡ã™ã‚‹2ã¤ã®ç•°ãªã‚‹ãƒ¡ã‚½ãƒƒãƒ‰ãŒã‚ã‚Šã¾ã™ã€‚</p>
<ul>
<li><code>send</code>: ãƒãƒ£ãƒãƒ«å†…ã«ç©ºããŒã‚ã‚‹å ´åˆã€ãã‚Œã¯ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ã‚­ãƒ¥ãƒ¼ã«å…¥ã‚Œã¦<code>Ok(())</code>ã‚’è¿”ã—ã¾ã™ã€‚
ãƒãƒ£ãƒãƒ«ãŒã„ã£ã±ã„ã®å ´åˆã€ãã‚Œã¯ãƒ–ãƒ­ãƒƒã‚¯ã—ã¦ã€åˆ©ç”¨å¯èƒ½ãªç©ºããŒã§ãã‚‹ã¾ã§å¾…æ©Ÿã—ã¾ã™ã€‚</li>
<li><code>try_send</code>: ãƒãƒ£ãƒãƒ«å†…ã«ç©ºããŒã‚ã‚‹å ´åˆã€ãã‚Œã¯ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ã‚­ãƒ¥ãƒ¼ã«å…¥ã‚Œã¦<code>Ok(())</code>ã‚’è¿”ã—ã¾ã™ã€‚
ãƒãƒ£ãƒãƒ«ãŒã„ã£ã±ã„ã®å ´åˆã€ãã‚Œã¯<code>Err(TrySendError::Full(value))</code>ã‚’è¿”ã—ã¦ã€è¿”ã•ã‚Œã‚‹<code>value</code>ã¯é€ä¿¡ã•ã‚Œãªã‹ã£ãŸãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã§ã™ã€‚</li>
</ul>
</blockquote>
<p>Depending on your use case, you might want to use one or the other.</p>
<blockquote>
<p>ãƒ¦ãƒ¼ã‚¹ã‚±ãƒ¼ã‚¹ã«åˆã‚ã›ã¦ã€ã©ã¡ã‚‰ã‹ã‚’ä½¿ç”¨ã§ãã¾ã™ã€‚</p>
</blockquote>
<h3 id="backpressureé€†åœ§"><a class="header" href="#backpressureé€†åœ§">Backpressureï¼ˆé€†åœ§ï¼‰</a></h3>
<p>The main advantage of using bounded channels is that they provide a form of <strong>backpressure</strong>.<br />
They force the producers to slow down if the consumer can't keep up.
The backpressure can then propagate through the system, potentially affecting the whole architecture and
preventing end users from overwhelming the system with requests.</p>
<blockquote>
<p>åˆ¶é™ã•ã‚ŒãŸãƒãƒ£ãƒãƒ«ã‚’ä½¿ç”¨ã™ã‚‹ä¸»ãªåˆ©ç‚¹ã¯ã€ãã‚Œã‚‰ãŒ<strong>é€†åœ§</strong>ã®å½¢å¼ã‚’æä¾›ã™ã‚‹ã“ã¨ã§ã™ã€‚
ãã‚Œã‚‰ï¼ˆé€†åœ§ï¼‰ã¯ã€ã‚³ãƒ³ã‚·ãƒ¥ãƒ¼ãƒãƒ¼ï¼ˆã‚µãƒ¼ãƒãƒ¼ï¼‰ãŒã¤ã„ã¦ã„ã‘ãªããªã£ãŸå ´åˆã€é…ãã™ã‚‹ã“ã¨ã‚’ãƒ—ãƒ­ãƒ‡ãƒ¥ãƒ¼ã‚µãƒ¼ï¼ˆã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆï¼‰ã«å¼·åˆ¶ã—ã¾ã™ã€‚
ãã—ã¦ã€é€†åœ§ã¯ã‚·ã‚¹ãƒ†ãƒ ã‚’ä»‹ã—ã¦ä¼æ’­ã§ãã€å…¨ä½“ã®ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ãƒ¼ã«å½±éŸ¿ã‚’ä¸ãˆã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã€ã‚¨ãƒ³ãƒ‰ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒãƒªã‚¯ã‚¨ã‚¹ãƒˆã§ã‚·ã‚¹ãƒ†ãƒ ã‚’åœ§å€’ã™ã‚‹ã“ã¨ã‚’å›é¿ã—ã¾ã™ã€‚</p>
</blockquote>
<h2 id="exercise-83"><a class="header" href="#exercise-83">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/07_threads/09_bounded"><code>07_threads/09_bounded</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="update-operationsæ›´æ–°æ“ä½œ"><a class="header" href="#update-operationsæ›´æ–°æ“ä½œ">Update operationsï¼ˆæ›´æ–°æ“ä½œï¼‰</a></h1>
<p>So far we've implemented only insertion and retrieval operations.<br />
Let's see how we can expand the system to provide an update operation.</p>
<blockquote>
<p>ã“ã‚Œã¾ã§ã€æŒ¿å…¥ã¨å–å¾—æ“ä½œã®ã¿ã‚’å®Ÿè£…ã—ã¦ãã¾ã—ãŸã€‚
æ›´æ–°æ“ä½œã‚’æä¾›ã™ã‚‹ãŸã‚ã«ã‚·ã‚¹ãƒ†ãƒ ã‚’æ‹¡å¼µã™ã‚‹æ–¹æ³•ã‚’ç¢ºèªã—ã¾ã—ã‚‡ã†ã€‚</p>
</blockquote>
<h2 id="legacy-updateså¾“æ¥ã®æ›´æ–°"><a class="header" href="#legacy-updateså¾“æ¥ã®æ›´æ–°">Legacy updatesï¼ˆå¾“æ¥ã®æ›´æ–°ï¼‰</a></h2>
<p>In the non-threaded version of the system, updates were fairly straightforward: <code>TicketStore</code> exposed a
<code>get_mut</code> method that allowed the caller to obtain a mutable reference to a ticket, and then modify it.</p>
<blockquote>
<p>ã‚·ã‚¹ãƒ†ãƒ ã®éã‚¹ãƒ¬ãƒƒãƒ‰ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã«ãŠã„ã¦ã€æ›´æ–°ã¯ã‹ãªã‚Šç°¡å˜ã§ã™ã€‚
<code>TicketStore</code>ã¯ã€å‘¼ã³å‡ºã—å´ã«ãƒã‚±ãƒƒãƒˆã®å¯å¤‰å‚ç…§ã‚’å–å¾—ã™ã‚‹<code>get_mut</code>ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å…¬é–‹ã—ã€ãã—ã¦ãã‚Œã‚’æ›´æ–°ã—ã¾ã™ã€‚</p>
</blockquote>
<h2 id="multithreaded-updatesãƒãƒ«ãƒã‚¹ãƒ¬ãƒƒãƒ‰ãªæ›´æ–°"><a class="header" href="#multithreaded-updatesãƒãƒ«ãƒã‚¹ãƒ¬ãƒƒãƒ‰ãªæ›´æ–°">Multithreaded updatesï¼ˆãƒãƒ«ãƒã‚¹ãƒ¬ãƒƒãƒ‰ãªæ›´æ–°ï¼‰</a></h2>
<p>The same strategy won't work in the current multi-threaded version,
because the mutable reference would have to be sent over a channel. The borrow checker would
stop us, because <code>&amp;mut Ticket</code> doesn't satisfy the <code>'static</code> lifetime requirement of <code>SyncSender::send</code>.</p>
<blockquote>
<p>å¯å¤‰å‚ç…§ã¯ãƒãƒ£ãƒãƒ«ã‚’é€šã˜ã¦é€ä¿¡ã•ã‚Œãªãã¦ã¯ãªã‚‰ãªã„ãŸã‚ã€ç¾åœ¨ã®ãƒãƒ«ãƒã‚¹ãƒ¬ãƒƒãƒ‰ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã«ãŠã„ã¦ç¾åœ¨ã®æˆ¦ç•¥ã¯æ©Ÿèƒ½ã—ã¾ã›ã‚“ã€‚
<code>&amp;mut Ticket</code>ã¯<code>SyncSender::send</code>ã®<code>'static</code>ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ è¦æ±‚ã‚’æº€è¶³ã—ãªã„ãŸã‚ã€å€Ÿç”¨ãƒã‚§ãƒƒã‚«ãƒ¼ã¯åœæ­¢ã•ã›ã¾ã™ã€‚</p>
</blockquote>
<p>There are a few ways to work around this limitation. We'll explore a few of them in the following exercises.</p>
<blockquote>
<p>ã“ã®åˆ¶é™ã‚’å›é¿ã™ã‚‹ã„ãã¤ã‹ã®æ–¹æ³•ãŒã‚ã‚Šã¾ã™ã€‚
æ¬¡ã®æ¼”ç¿’ã§ãã‚Œã‚‰ã®ã„ãã¤ã‹ã‚’æ¢æ±‚ã™ã‚‹äºˆå®šã§ã™ã€‚</p>
</blockquote>
<h3 id="patchingãƒ‘ãƒƒãƒ"><a class="header" href="#patchingãƒ‘ãƒƒãƒ">Patchingï¼ˆãƒ‘ãƒƒãƒï¼‰</a></h3>
<p>We can't send a <code>&amp;mut Ticket</code> over a channel, therefore we can't mutate on the client-side.<br />
Can we mutate on the server-side?</p>
<blockquote>
<p>ãƒãƒ£ãƒãƒ«ã§<code>&amp;mut Ticket</code>ã‚’é€ä¿¡ã§ããªã„ãŸã‚ã€ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå´ã§ãƒã‚±ãƒƒãƒˆã‚’å¤‰æ›´ã§ãã¾ã›ã‚“ã€‚
ã‚µãƒ¼ãƒãƒ¼å´ã§å¤‰æ›´ã§ãã‚‹ã§ã—ã‚‡ã†ã‹ï¼Ÿ</p>
</blockquote>
<p>We can, if we tell the server what needs to be changed. In other words, if we send a <strong>patch</strong> to the server:</p>
<blockquote>
<p>ã‚µãƒ¼ãƒãƒ¼ã«å¤‰æ›´ã—ãªãã¦ã¯ãªã‚‰ãªã„ã‚‚ã®ã‚’ä¼ãˆã‚Œã°ã§ãã¾ã™ã€‚
è¨€ã„æ›ãˆã‚Œã°ã€<strong>ãƒ‘ãƒƒãƒ</strong>ã‚’ã‚µãƒ¼ãƒãƒ¼ã«é€ä¿¡ã™ã‚‹å ´åˆã§ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct TicketPatch {
    id: TicketId,
    title: Option&lt;TicketTitle&gt;,
    description: Option&lt;TicketDescription&gt;,
    status: Option&lt;TicketStatus&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>id</code> field is mandatory, since it's required to identify the ticket that needs to be updated.<br />
All other fields are optional:</p>
<ul>
<li>If a field is <code>None</code>, it means that the field should not be changed.</li>
<li>If a field is <code>Some(value)</code>, it means that the field should be changed to <code>value</code>.</li>
</ul>
<blockquote>
<p><code>id</code>ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¯å¿…é ˆãªãŸã‚ã€ãã‚Œã¯æ›´æ–°ã•ã‚Œãªã‘ã‚Œã°ãªã‚‰ãªã„ãƒã‚±ãƒƒãƒˆã‚’è­˜åˆ¥ã™ã‚‹ãŸã‚ã«è¦æ±‚ã•ã‚Œã¾ã™ã€‚
ä»–ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã™ã¹ã¦ã¯ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã§ã™ã€‚</p>
<ul>
<li>ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒ<code>None</code>ã®å ´åˆã€ãã‚Œã¯ãã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒå¤‰æ›´ã•ã‚Œã‚‹ã¹ãã§ãªã„ã“ã¨ã‚’æ„å‘³ã—ã¾ã™ã€‚</li>
<li>ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒ<code>Some(value)</code>ã®å ´åˆã€ãã‚Œã¯ãã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒ<code>value</code>ã«å¤‰æ›´ã•ã‚Œã‚‹ã¹ãã§ã‚ã‚‹ã“ã¨ã‚’æ„å‘³ã—ã¾ã™ã€‚</li>
</ul>
</blockquote>
<h2 id="exercise-84"><a class="header" href="#exercise-84">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/07_threads/10_patch"><code>07_threads/10_patch</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="locks-send-and-arcãƒ­ãƒƒã‚¯sendãã—ã¦arc"><a class="header" href="#locks-send-and-arcãƒ­ãƒƒã‚¯sendãã—ã¦arc">Locks, <code>Send</code> and <code>Arc</code>ï¼ˆãƒ­ãƒƒã‚¯ã€Sendãã—ã¦Arcï¼‰</a></h1>
<p>The patching strategy you just implemented has a major drawback: it's racy.<br />
If two clients send patches for the same ticket roughly at same time, the server will apply them in an arbitrary order.
Whoever enqueues their patch last will overwrite the changes made by the other client.</p>
<blockquote>
<p>ã¡ã‚‡ã†ã©å®Ÿè£…ã—ãŸãƒ‘ãƒƒãƒæˆ¦ç•¥ã¯å¤§ããªæ¬ ç‚¹ãŒã‚ã‚Šã¾ã™ã€‚ãã‚Œã¯éš›ã©ã„ã§ã™ã€‚
2ã¤ã®ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆãŒã»ã¼åŒæ™‚ã«åŒã˜ãƒã‚±ãƒƒãƒˆã«ãƒ‘ãƒƒãƒã‚’é€ä¿¡ã—ãŸå ´åˆã€ã‚µãƒ¼ãƒãƒ¼ã¯ä»»æ„ã®é †åºã§ãã‚Œã‚‰ã‚’é©ç”¨ã—ã¾ã™ã€‚
æœ€å¾Œã«ãã‚Œã‚‰ã®ãƒ‘ãƒƒãƒã‚’ã‚­ãƒ¥ãƒ¼ã«å…¥ã‚ŒãŸã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆãŒã€ä»–ã®ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã«ã‚ˆã£ã¦è¡Œã‚ã‚ŒãŸå¤‰æ›´ã‚’ä¸Šæ›¸ãã—ã¾ã™ã€‚</p>
</blockquote>
<h2 id="version-numbersãƒãƒ¼ã‚¸ãƒ§ãƒ³ç•ªå·"><a class="header" href="#version-numbersãƒãƒ¼ã‚¸ãƒ§ãƒ³ç•ªå·">Version numbersï¼ˆãƒãƒ¼ã‚¸ãƒ§ãƒ³ç•ªå·ï¼‰</a></h2>
<p>We could try to fix this by using a <strong>version number</strong>.<br />
Each ticket gets assigned a version number upon creation, set to <code>0</code>.<br />
Whenever a client sends a patch, they must include the current version number of the ticket alongside the
desired changes. The server will only apply the patch if the version number matches the one it has stored.</p>
<blockquote>
<p><strong>ãƒãƒ¼ã‚¸ãƒ§ãƒ³ç•ªå·</strong>ã‚’ä½¿ç”¨ã—ã¦ã€ã“ã‚Œã‚’ä¿®æ­£ã™ã‚‹ã“ã¨ã‚’è©¦ã¿ã¾ã™ã€‚
ãã‚Œãã‚Œã®ãƒã‚±ãƒƒãƒˆã¯ã€ä½œæˆæ™‚ã«<code>0</code>ã«è¨­å®šã•ã‚ŒãŸãƒãƒ¼ã‚¸ãƒ§ãƒ³ç•ªå·ã‚’å‰²ã‚Šå½“ã¦ã‚‰ã‚Œã¾ã™ã€‚
ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆãŒãƒ‘ãƒƒãƒã‚’é€ä¿¡ã—ãŸã¨ãã¯ã„ã¤ã§ã‚‚ã€ãã‚Œã‚‰ï¼ˆãƒ‘ãƒƒãƒï¼‰ã¯å¸Œæœ›ã™ã‚‹å¤‰æ›´ã¨ä¸€ç·’ã«ã€ãƒã‚±ãƒƒãƒˆã®ç¾åœ¨ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ç•ªå·ã‚’å«ã¾ãªãã¦ã¯ãªã‚Šã¾ã›ã‚“ã€‚
ã‚µãƒ¼ãƒãƒ¼ã¯ã€ãƒãƒ¼ã‚¸ãƒ§ãƒ³ç•ªå·ãŒãã‚Œï¼ˆã‚µãƒ¼ãƒãƒ¼ï¼‰ãŒä¿å­˜ã—ãŸã‚‚ã®ã¨ä¸€è‡´ã—ãŸå ´åˆã«ã®ã¿ãƒ‘ãƒƒãƒã‚’é©ç”¨ã—ã¾ã™ã€‚</p>
</blockquote>
<p>In the scenario described above, the server would reject the second patch, because the version number would
have been incremented by the first patch and thus wouldn't match the one sent by the second client.</p>
<blockquote>
<p>ä¸Šè¨˜ã§èª¬æ˜ã—ãŸã‚·ãƒŠãƒªã‚ªã«ãŠã„ã¦ã€ãƒãƒ¼ã‚¸ãƒ§ãƒ³ç•ªå·ã¯æœ€åˆã®ãƒ‘ãƒƒãƒã«ã‚ˆã£ã¦ã„å¢—åŠ ã•ã‚Œã¦ãŠã‚Šã€2ç•ªç›®ã®ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã«ã‚ˆã£ã¦é€ä¿¡ã•ã‚ŒãŸãƒãƒ¼ã‚¸ãƒ§ãƒ³ç•ªå·ã¨ä¸€è‡´ã—ãªã„ãŸã‚ã€ã‚µãƒ¼ãƒãƒ¼ã¯2ç•ªç›®ã®ãƒ‘ãƒƒãƒã‚’æ‹’å¦ã—ã¾ã™ã€‚</p>
</blockquote>
<p>This approach is fairly common in distributed systems (e.g. when client and servers don't share memory),
and it is known as <strong>optimistic concurrency control</strong>.<br />
The idea is that most of the time, conflicts won't happen, so we can optimize for the common case.
You know enough about Rust by now to implement this strategy on your own as a bonus exercise, if you want to.</p>
<blockquote>
<p>ã“ã®æ–¹æ³•ã¯ã€ä¾‹ãˆã°ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã¨ã‚µãƒ¼ãƒãƒ¼ãŒãƒ¡ãƒ¢ãƒªã‚’å…±æœ‰ã—ã¦ã„ãªã„ãªã©ã®åˆ†æ•£ã‚·ã‚¹ãƒ†ãƒ ã§ã¨ã¦ã‚‚ä¸€èˆ¬çš„ã§ã€<strong>æ¥½è¦³çš„åŒæ™‚å®Ÿè¡Œåˆ¶å¾¡</strong>ã¨ã—ã¦çŸ¥ã‚‰ã‚Œã¦ã„ã¾ã™ã€‚
ãã®ã‚¢ã‚¤ãƒ‡ã‚¢ã¯ã€ã»ã¨ã‚“ã©ã®æ™‚é–“ã§è¡çªãŒç™ºç”Ÿã—ãªã„ãŸã‚ã€ä¸€èˆ¬çš„ãªã‚±ãƒ¼ã‚¹ã§æœ€é©åŒ–ã§ãã¾ã™ã€‚
ãã‚ãã‚Rustã‚’ååˆ†ã«ç†è§£ã—ãŸé ƒã§ã‚ã‚‹ãŸã‚ã€å¸Œæœ›ã™ã‚‹å ´åˆã€ãƒœãƒ¼ãƒŠã‚¹ã®æ¼”ç¿’ã¨ã—ã¦è‡ªèº«ã§ã“ã®æˆ¦ç•¥ã‚’å®Ÿè£…ã—ã¦ãã ã•ã„ã€‚</p>
</blockquote>
<h2 id="lockingãƒ­ãƒƒã‚¯"><a class="header" href="#lockingãƒ­ãƒƒã‚¯">Lockingï¼ˆãƒ­ãƒƒã‚¯ï¼‰</a></h2>
<p>We can also fix the race condition by introducing a <strong>lock</strong>.<br />
Whenever a client wants to update a ticket, they must first acquire a lock on it. While the lock is active,
no other client can modify the ticket.</p>
<blockquote>
<p>ã¾ãŸã€<strong>ãƒ­ãƒƒã‚¯</strong>ã‚’å°å…¥ã™ã‚‹ã“ã¨ã§ã€ç«¶åˆçŠ¶æ…‹ã‚’ä¿®æ­£ã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ã€‚
ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆãŒãƒã‚±ãƒƒãƒˆã‚’æ›´æ–°ã—ãŸã„ã¨ãã¯ã„ã¤ã§ã‚‚ã€ãã‚Œã‚‰ï¼ˆã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆï¼‰ã¯ã€æœ€åˆã«ãã‚Œï¼ˆãƒã‚±ãƒƒãƒˆï¼‰ã®ãƒ­ãƒƒã‚¯ã‚’å–å¾—ã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚
ãƒ­ãƒƒã‚¯ãŒæœ‰åŠ¹ãªé–“ã€ä»–ã®ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã¯ãƒã‚±ãƒƒãƒˆã‚’ä¿®æ­£ã§ãã¾ã›ã‚“ã€‚</p>
</blockquote>
<p>Rust's standard library provides two different locking primitives: <code>Mutex&lt;T&gt;</code> and <code>RwLock&lt;T&gt;</code>.<br />
Let's start with <code>Mutex&lt;T&gt;</code>. It stands for <strong>mut</strong>ual <strong>ex</strong>clusion, and it's the simplest kind of lock:
it allows only one thread to access the data, no matter if it's for reading or writing.</p>
<blockquote>
<p>Rustæ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã¯ã€<code>Mutex&lt;T&gt;</code>ã¨<code>RwLock&lt;T&gt;</code>ã®2ã¤ã®ç•°ãªã‚‹ãƒ­ãƒƒã‚¯ã®æ§‹æˆè¦ç´ ã‚’æä¾›ã—ã¦ã„ã¾ã™ã€‚
<code>Mutex&lt;T&gt;</code>ã‹ã‚‰å§‹ã‚ã¾ã—ã‚‡ã†ã€‚ãã‚Œã¯<strong>å¯å¤‰</strong>ã§<strong>æ’ä»–</strong>ã‚’è¡¨ã—ã¦ã„ã¦ã€ãã‚Œã¯æœ€ã‚‚å˜ç´”ãªç¨®é¡ã®ãƒ­ãƒƒã‚¯ã§ã™ã€‚
ãã‚Œã¯ã€èª­ã¿è¾¼ã¿ã¾ãŸã¯æ›¸ãè¾¼ã¿ã«é–¢ã‚ã‚‰ãšã€ãƒ‡ãƒ¼ã‚¿ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ã‚’ãŸã£ãŸ1ã¤ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã ã‘è¨±å¯ã—ã¾ã™ã€‚</p>
</blockquote>
<p><code>Mutex&lt;T&gt;</code> wraps the data it protects, and it's therefore generic over the type of the data.<br />
You can't access the data directly: the type system forces you to acquire a lock first using either <code>Mutex::lock</code> or
<code>Mutex::try_lock</code>. The former blocks until the lock is acquired, the latter returns immediately with an error if the lock
can't be acquired.<br />
Both methods return a guard object that dereferences to the data, allowing you to modify it. The lock is released when
the guard is dropped.</p>
<blockquote>
<p><code>Mutex&lt;T&gt;</code>ã¯ã€ãã‚ŒãŒä¿è­·ã™ã‚‹ãƒ‡ãƒ¼ã‚¿ã‚’ãƒ©ãƒƒãƒ—ã™ã‚‹ãŸã‚ã€ãã‚Œã¯ãƒ‡ãƒ¼ã‚¿å‹ã«å¯¾ã—ã¦ã‚¸ã‚§ãƒãƒªãƒƒã‚¯ã§ã™ã€‚
ç›´æ¥ãƒ‡ãƒ¼ã‚¿ã«ã‚¢ã‚¯ã‚»ã‚¹ã§ãã¾ã›ã‚“ã€‚å‹ã‚·ã‚¹ãƒ†ãƒ ã¯ã€<code>Mutex::lock</code>ã¾ãŸã¯<code>Mutex::try_lock</code>ã®ã©ã¡ã‚‰ã‹ã‚’ä½¿ç”¨ã—ã¦ã€æœ€åˆã«ãƒ­ãƒƒã‚¯ã‚’ç²å¾—ã™ã‚‹ã“ã¨ã‚’å¼·åˆ¶ã—ã¾ã™ã€‚
å‰è€…ã¯ãƒ­ãƒƒã‚¯ãŒç²å¾—ã•ã‚Œã‚‹ã¾ã§ãƒ–ãƒ­ãƒƒã‚¯ã—ã¦ã€å¾Œè€…ã¯ãƒ­ãƒƒã‚¯ãŒç²å¾—ã§ããªã„å ´åˆã€å³åº§ã«ã‚¨ãƒ©ãƒ¼ã‚’è¿”ã—ã¾ã™ã€‚
ä¸¡æ–¹ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ãƒ‡ãƒ¼ã‚¿ã¸ã®å‚ç…§ã‚’å¤–ã™ã‚¬ãƒ¼ãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã—ã€ãã‚Œï¼ˆãƒ‡ãƒ¼ã‚¿ï¼‰ã‚’å¤‰æ›´ã§ãã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚
ãƒ­ãƒƒã‚¯ã¯ã€ã‚¬ãƒ¼ãƒ‰ãŒãƒ‰ãƒ­ãƒƒãƒ—ã•ã‚ŒãŸã¨ãã«ã€è§£æ”¾ã•ã‚Œã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::Mutex;

// An integer protected by a mutex lock
// ãƒŸãƒ¥ãƒ¼ãƒ†ãƒƒã‚¯ã‚¹ãƒ­ãƒƒã‚¯ã«ã‚ˆã£ã¦ä¿è­·ã•ã‚ŒãŸæ•´æ•°ã§ã™ã€‚
let lock = Mutex::new(0);

// Acquire a lock on the mutex
// ãƒŸãƒ¥ãƒ¼ãƒ†ãƒƒã‚¯ã‚¹ã®ãƒ­ãƒƒã‚¯ã‚’ç²å¾—ã—ã¾ã™ã€‚
let mut guard = lock.lock().unwrap();

// Modify the data through the guard,
// leveraging its `Deref` implementation
// ã‚¬ãƒ¼ãƒ‰ã®`Deref`å®Ÿè£…ã‚’åˆ©ç”¨ã—ã¦ã€ã‚¬ãƒ¼ãƒ‰ã‚’ä»‹ã—ã¦ãƒ‡ãƒ¼ã‚¿ã‚’ä¿®æ­£ã—ã¾ã™ã€‚
*guard += 1;

// The lock is released when `data` goes out of scope
// This can be done explicitly by dropping the guard
// or happen implicitly when the guard goes out of scope
// `data`ãŒã‚¹ã‚³ãƒ¼ãƒ—å¤–ã«ãªã£ãŸã¨ãã€ãƒ­ãƒƒã‚¯ã¯è§£æ”¾ã•ã‚Œã¾ã™ã€‚
// ã“ã‚Œã¯ã€ã‚¬ãƒ¼ãƒ‰ã‚’ãƒ‰ãƒ­ãƒƒãƒ—ã™ã‚‹ã“ã¨ã«ã‚ˆã£ã¦æ˜ç¤ºã«è¡Œã†ã‹ã€ã‚¬ãƒ¼ãƒ‰ãŒã‚¹ã‚³ãƒ¼ãƒ—å¤–ã«ãªã£ãŸã¨ãã«æš—é»™çš„ã«ç™ºç”Ÿã—ã¾ã™ã€‚
drop(guard)
<span class="boring">}</span></code></pre></pre>
<h2 id="locking-granularityãƒ­ãƒƒã‚¯ã®ç²’åº¦"><a class="header" href="#locking-granularityãƒ­ãƒƒã‚¯ã®ç²’åº¦">Locking granularityï¼ˆãƒ­ãƒƒã‚¯ã®ç²’åº¦ï¼‰</a></h2>
<p>What should our <code>Mutex</code> wrap?<br />
The simplest option would be the wrap the entire <code>TicketStore</code> in a single <code>Mutex</code>.<br />
This would work, but it would severely limit the system's performance: you wouldn't be able to read tickets in parallel,
because every read would have to wait for the lock to be released.<br />
This is known as <strong>coarse-grained locking</strong>.</p>
<blockquote>
<p>ä½•ã‚’<code>Mutex</code>ã§ãƒ©ãƒƒãƒ—ã™ã‚‹ã¹ãã§ã—ã‚‡ã†ã‹ï¼Ÿ
å˜ç´”ãªé¸æŠè‚¢ã¯ã€<code>TicketStore</code>å…¨ä½“ã‚’å˜ä¸€ã®<code>Mutex</code>ã§ãƒ©ãƒƒãƒ—ã™ã‚‹ã“ã¨ã§ã™ã€‚
ã“ã‚Œã¯æ©Ÿèƒ½ã—ã¾ã™ãŒã€ã‚·ã‚¹ãƒ†ãƒ ã®æ€§èƒ½ã‚’è‘—ã—ãåˆ¶é™ã—ã¾ã™ã€‚
ã™ã¹ã¦ã®èª­ã¿è¾¼ã¿ã¯ãƒ­ãƒƒã‚¯ã®è§£æ”¾ã‚’å¾…ãŸãªã‘ã‚Œã°ãªã‚‰ãªã„ãŸã‚ã€ä¸¦åˆ—ã—ã¦ãƒã‚±ãƒƒãƒˆã‚’èª­ã‚€ã“ã¨ãŒã§ããªããªã‚Šã¾ã™ã€‚
ã“ã‚Œã¯ã€<strong>ç²—ã„ç²’åº¦ã®ãƒ­ãƒƒã‚¯</strong>ã¨ã—ã¦çŸ¥ã‚‰ã‚Œã¦ã„ã¾ã™ã€‚</p>
</blockquote>
<p>It would be better to use <strong>fine-grained locking</strong>, where each ticket is protected by its own lock.
This way, clients can keep working with tickets in parallel, as long as they aren't trying to access the same ticket.</p>
<blockquote>
<p>ãã‚Œãã‚Œã®ãƒã‚±ãƒƒãƒˆãŒãã‚Œè‡ªèº«ã‚’ãƒ­ãƒƒã‚¯ã™ã‚‹ã“ã¨ã«ã‚ˆã£ã¦ä¿è­·ã™ã‚‹ã€<strong>é©åˆ‡ãªç²’åº¦ã®ãƒ­ãƒƒã‚¯</strong>ã‚’ä½¿ç”¨ã—ãŸã»ã†ãŒè‰¯ã„ã§ã™ã€‚
ã“ã®æ–¹æ³•ã§ã¯ã€ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã¯ã€åŒã˜ãƒã‚±ãƒƒãƒˆã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã“ã¨ã‚’è©¦ã¿ãªã„é™ã‚Šã€ä¸¦åˆ—ã§ãƒã‚±ãƒƒãƒˆã‚’æ“ä½œã—ç¶šã‘ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// The new structure, with a lock for each ticket
// ãã‚Œãã‚Œã®ãƒã‚±ãƒƒãƒˆã®ãƒ­ãƒƒã‚¯ã‚’æŒã¤æ–°ã—ã„æ§‹é€ ä½“ã§ã™ã€‚
struct TicketStore {
    tickets: BTreeMap&lt;TicketId, Mutex&lt;Ticket&gt;&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>This approach is more efficient, but it has a downside: <code>TicketStore</code> has to become <strong>aware</strong> of the multithreaded
nature of the system; up until now, <code>TicketStore</code> has been blissfully ignoring the existence of threads.<br />
Let's go for it anyway.</p>
<blockquote>
<p>ã“ã®æ–¹æ³•ã¯ã‚ˆã‚ŠåŠ¹ç‡çš„ã§ã™ãŒæ¬ ç‚¹ãŒã‚ã‚Šã¾ã™ã€‚
<code>TicketStore</code>ã¯ã‚·ã‚¹ãƒ†ãƒ ã®ãƒãƒ«ãƒã‚¹ãƒ¬ãƒƒãƒ‰æ€§ã«<strong>æ°—ä»˜ã</strong>ã‚ˆã†ã«ãªã‚‰ãªãã¦ã¯ãªã‚Šã¾ã›ã‚“ã€‚
ã“ã‚Œã¾ã§ã€<code>TicketStore</code>ã¯ã‚¹ãƒ¬ãƒƒãƒ‰ã®å­˜åœ¨ã‚’ç©ã‚„ã‹ã«ç„¡è¦–ã—ã¦ãã¾ã—ãŸã€‚
ã¨ã«ã‹ããã‚Œã‚’ã‚„ã£ã¦ã¿ã¾ã—ã‚‡ã†ã€‚</p>
</blockquote>
<h2 id="who-holds-the-lockèª°ãŒãƒ­ãƒƒã‚¯ã‚’ä¿æŒã™ã‚‹ã®ã‹"><a class="header" href="#who-holds-the-lockèª°ãŒãƒ­ãƒƒã‚¯ã‚’ä¿æŒã™ã‚‹ã®ã‹">Who holds the lock?ï¼ˆèª°ãŒãƒ­ãƒƒã‚¯ã‚’ä¿æŒã™ã‚‹ã®ã‹ï¼Ÿï¼‰</a></h2>
<p>For the whole scheme to work, the lock must be passed to the client that wants to modify the ticket.<br />
The client can then directly modify the ticket (as if they had a <code>&amp;mut Ticket</code>) and release the lock when they're done.</p>
<blockquote>
<p>å…¨ä½“ã®ã‚¹ã‚­ãƒ¼ãƒ ãŒæ©Ÿèƒ½ã™ã‚‹ãŸã‚ã«ã€ãƒ­ãƒƒã‚¯ã¯ãã®ãƒã‚±ãƒƒãƒˆã‚’ä¿®æ­£ã—ãŸã„ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã«æ¸¡ã•ã‚Œãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚
ãã—ã¦ã€ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã¯ã€<code>&amp;mut Ticket</code>ã‚’æŒã£ã¦ã„ã‚‹å ´åˆã€ãƒã‚±ãƒƒãƒˆã‚’ç›´æ¥ä¿®æ­£ã—ã¦ã€çµ‚äº†ã—ãŸã¨ãã«ãƒ­ãƒƒã‚¯ã‚’è§£æ”¾ã§ãã¾ã™ã€‚</p>
</blockquote>
<p>This is a bit tricky.<br />
We can't send a <code>Mutex&lt;Ticket&gt;</code> over a channel, because <code>Mutex</code> is not <code>Clone</code> and
we can't move it out of the <code>TicketStore</code>. Could we send the <code>MutexGuard</code> instead?</p>
<blockquote>
<p>ã“ã‚Œã¯å°‘ã—ãƒˆãƒªãƒƒã‚­ãƒ¼ã§ã™ã€‚
<code>Mutex</code>ã¯<code>Clone</code>ã§ãªãã€<code>TicketStore</code>ã®å¤–ã«ç§»å‹•ã§ããªã„ãŸã‚ã€ãƒãƒ£ãƒãƒ«ã‚’ä»‹ã—ã¦<code>Mutex&lt;Ticket&gt;</code>ã‚’é€ä¿¡ã™ã‚‹ã“ã¨ãŒã§ãã¾ã›ã‚“ã€‚
ä»£ã‚ã‚Šã«<code>MutexGuard</code>ã‚’é€ä¿¡ã§ãã‚‹ã§ã—ã‚‡ã†ã‹ï¼Ÿ</p>
</blockquote>
<p>Let's test the idea with a small example:</p>
<blockquote>
<p>å°ã•ãªä¾‹ã§ãã®ã‚¢ã‚¤ãƒ‡ã‚¢ã‚’ãƒ†ã‚¹ãƒˆã—ã¾ã—ã‚‡ã†ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">use std::thread::spawn;
use std::sync::Mutex;
use std::sync::mpsc::sync_channel;

fn main() {
    let lock = Mutex::new(0);
    let (sender, receiver) = sync_channel(1);
    let guard = lock.lock().unwrap();

    spawn(move || {
        receiver.recv().unwrap();
    });

    // Try to send the guard over the channel
    // to another thread
    // ãƒãƒ£ãƒãƒ«ã‚’ä»‹ã—ã¦ã€ä»–ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã«ã‚¬ãƒ¼ãƒ‰ã‚’é€ä¿¡ã™ã‚‹ã“ã¨ã‚’è©¦ã¿ã¾ã™ã€‚
    sender.send(guard);
}</code></pre></pre>
<p>The compiler is not happy with this code:</p>
<blockquote>
<p>ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ¼ã¯ã“ã®ã‚³ãƒ¼ãƒ‰ã«æº€è¶³ã—ã¦ã„ã¾ã›ã‚“ã€‚</p>
</blockquote>
<pre><code class="language-text">error[E0277]: `MutexGuard&lt;'_, i32&gt;` cannot be sent between threads safely
   --&gt; src/main.rs:10:7
    |
10  |   spawn(move || {
    |  _-----_^
    | | |
    | | required by a bound introduced by this call
11  | |     receiver.recv().unwrap();
12  | | });
    | |_^ `MutexGuard&lt;'_, i32&gt;` cannot be sent between threads safely
    |
    = help: the trait `Send` is not implemented for `MutexGuard&lt;'_, i32&gt;`, which is required by `{closure@src/main.rs:10:7: 10:14}: Send`
    = note: required for `std::sync::mpsc::Receiver&lt;MutexGuard&lt;'_, i32&gt;&gt;` to implement `Send`
note: required because it's used within this closure
</code></pre>
<p><code>MutexGuard&lt;'_, i32&gt;</code> is not <code>Send</code>: what does it mean?</p>
<blockquote>
<p><code>MutexGuard&lt;'_, i32&gt;</code>ã¯<code>Send</code>ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ãã‚Œã¯ä½•ã‚’æ„å‘³ã™ã‚‹ã®ã§ã—ã‚‡ã†ã‹ï¼Ÿ</p>
</blockquote>
<h2 id="send"><a class="header" href="#send"><code>Send</code></a></h2>
<p><code>Send</code> is a marker trait that indicates that a type can be safely transferred from one thread to another.<br />
<code>Send</code> is also an auto-trait, just like <code>Sized</code>; it's automatically implemented (or not implemented) for your type
by the compiler, based on its definition.<br />
You can also implement <code>Send</code> manually for your types, but it requires <code>unsafe</code> since you have to guarantee that the
type is indeed safe to send between threads for reasons that the compiler can't automatically verify.</p>
<blockquote>
<p><code>Send</code>ã¯ã€ã‚ã‚‹ã‚¹ãƒ¬ãƒƒãƒ‰ã‹ã‚‰ä»–ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã«å®‰å…¨ã«è»¢é€ã§ãã‚‹å‹ã‚’ç¤ºã™ãƒãƒ¼ã‚«ãƒ¼ãƒˆãƒ¬ã‚¤ãƒˆã§ã™ã€‚
ã¾ãŸ<code>Send</code>ã¯ã€ã¡ã‚‡ã†ã©<code>Sized</code>ã¨åŒæ§˜ã«è‡ªå‹•ãƒˆãƒ¬ã‚¤ãƒˆã§ã™ã€‚
ãã‚Œï¼ˆ<code>Send</code>ï¼‰ã¯ã€ãã®ï¼ˆå‹ï¼‰ã®å®šç¾©ã«åŸºã¥ã„ã¦ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ¼ã«ã‚ˆã£ã¦è‡ªå‹•çš„ã«å®Ÿè£…ã•ã‚Œã¾ã™ï¼ˆã¾ãŸã¯å®Ÿè£…ã•ã‚Œã¾ã›ã‚“ï¼‰ã€‚
ã¾ãŸã€å‹ã«æ‰‹å‹•ã§<code>Send</code>ã‚’å®Ÿè£…ã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ãŒã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ¼ã¯è‡ªå‹•ã§æ¤œè¨¼ã§ããšã€å‹ãŒç¢ºå®Ÿã«ã‚¹ãƒ¬ãƒƒãƒ‰é–“ã‚’å®‰å…¨ã«é€ä¿¡ã§ãã‚‹ã“ã¨ã‚’ä¿è¨¼ã—ãªãã¦ã¯ãªã‚‰ãªã„ãŸã‚ã€<code>unsafe</code>ãŒè¦æ±‚ã•ã‚Œã¾ã™ã€‚</p>
</blockquote>
<blockquote>
<p><code>Send</code>ã‚’å®Ÿè£…ã—ãŸå‹ã¯ã€ã‚¹ãƒ¬ãƒƒãƒ‰é–“ã§å®‰å…¨ã«ç§»å‹•ï¼ˆãƒ ãƒ¼ãƒ–ï¼‰ã§ãã‚‹ã€‚
ã¾ãŸã€<code>Sync</code>ã‚’å®Ÿè£…ã—ãŸå‹ã¯ã€è¤‡æ•°ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã‹ã‚‰å®‰å…¨ã«å‚ç…§ã§ãã‚‹ã€‚</p>
<p>ä¾‹ãˆã°ã€<code>&amp;T</code>ãŒ<code>Send</code>ã§ã‚ã‚‹å ´åˆã€<code>T</code>ã¯<code>Sync</code>ã§ã‚ã‚‹ã€‚ä¾‹ã¨ã—ã¦ã¯ã€<code>T</code>ãŒä¸å¤‰ãªå€¤ãªå ´åˆã§ã‚ã‚‹ã€‚</p>
<p>å‹<code>T</code>ãŒ<code>Sync</code>ã§ã‚ã‚‹å ´åˆã€è¤‡æ•°ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã‹ã‚‰å®‰å…¨ã«å‚ç…§ã§ãã‚‹ã¨ã„ã†ã“ã¨ã¯ã€<code>&amp;T</code>ãŒ<code>Send</code>ã§ã‚ã‚‹ã“ã¨ã‚’æ„å‘³ã™ã‚‹ã€‚
ãã—ã¦ã€<code>&amp;T</code>ãŒ<code>Send</code>ã§ã‚ã‚Œã°ã€<code>&amp;T</code>ã¯ã‚¹ãƒ¬ãƒƒãƒ‰é–“ã‚’ç§»å‹•ï¼ˆãƒ ãƒ¼ãƒ–ï¼‰ã§ãã‚‹ã€‚</p>
</blockquote>
<h3 id="channel-requirementsãƒãƒ£ãƒãƒ«ã®è¦æ±‚äº‹é …"><a class="header" href="#channel-requirementsãƒãƒ£ãƒãƒ«ã®è¦æ±‚äº‹é …">Channel requirementsï¼ˆãƒãƒ£ãƒãƒ«ã®è¦æ±‚äº‹é …ï¼‰</a></h3>
<p><code>Sender&lt;T&gt;</code>, <code>SyncSender&lt;T&gt;</code> and <code>Receiver&lt;T&gt;</code> are <code>Send</code> if and only if <code>T</code> is <code>Send</code>.<br />
That's because they are used to send values between threads, and if the value itself is not <code>Send</code>, it would be
unsafe to send it between threads.</p>
<blockquote>
<p><code>Sender&lt;T&gt;</code>ã€<code>SyncSender&lt;T&gt;</code>ãã—ã¦<code>Receive&lt;T&gt;</code>ã¯<code>Send</code>ã§ã€ã‹ã¤<code>T</code>ãŒ<code>Send</code>ã§ã‚ã‚‹å ´åˆã®ã¿<code>Send</code>ã§ã™ã€‚
ãã‚Œã¯ã€ãã‚Œã‚‰ãŒã‚¹ãƒ¬ãƒƒãƒ‰é–“ã§å€¤ã‚’é€ä¿¡ã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã‚‹ã“ã¨ãŒç†ç”±ã§ã€ãã®å€¤è‡ªèº«ãŒ<code>Send</code>ã§ãªã„å ´åˆã€ã‚¹ãƒ¬ãƒƒãƒ‰é–“ã§ãã‚Œã‚’å®‰å…¨ã«é€ä¿¡ã§ããªã„ã‹ã‚‰ã§ã™ã€‚</p>
</blockquote>
<h3 id="mutexguard"><a class="header" href="#mutexguard"><code>MutexGuard</code></a></h3>
<p><code>MutexGuard</code> is not <code>Send</code> because the underlying operating system primitives that <code>Mutex</code> uses to implement
the lock require (on some platforms) that the lock must be released by the same thread that acquired it.<br />
If we were to send a <code>MutexGuard</code> to another thread, the lock would be released by a different thread, which would
lead to undefined behavior.</p>
<blockquote>
<p><code>MutexGuard</code>ã¯ã€
<code>Mutex</code>ãŒãƒ­ãƒƒã‚¯ã‚’å®Ÿè£…ã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã™ã‚‹åŸºç›¤ã¨ãªã‚‹ã‚ªãƒšãƒ¬ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ ã®æ§‹æˆè¦ç´ ã¯ã€ï¼ˆã„ãã¤ã‹ã®ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã§ï¼‰ãƒ­ãƒƒã‚¯ãŒãã‚Œã‚’ç²å¾—ã—ãŸåŒã˜ã‚¹ãƒ¬ãƒƒãƒ‰ã«ã‚ˆã£ã¦è§£æ”¾ã•ã‚Œãªãã¦ã¯ãªã‚‰ãªã„ã“ã¨ã‚’è¦æ±‚ã—ã¾ã™ã€‚
ä»–ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã«<code>MutexGuard</code>ã‚’é€ä¿¡ã—ãŸå ´åˆã€ãƒ­ãƒƒã‚¯ã¯ç•°ãªã‚‹ã‚¹ãƒ¬ãƒƒãƒ‰ã«ã‚ˆã£ã¦è§£æ”¾ã•ã‚Œã‚‹ã“ã¨ã«ãªã‚Šã€ãã‚Œã¯æœªå®šç¾©ãªå‹•ä½œã‚’å¼•ãèµ·ã“ã—ã¾ã™ã€‚</p>
</blockquote>
<h2 id="our-challengesèª²é¡Œ"><a class="header" href="#our-challengesèª²é¡Œ">Our challengesï¼ˆèª²é¡Œï¼‰</a></h2>
<p>Summing it up:</p>
<ul>
<li>We can't send a <code>MutexGuard</code> over a channel. So we can't lock on the server-side and then modify the ticket on the
client-side.</li>
<li>We can send a <code>Mutex</code> over a channel because it's <code>Send</code> as long as the data it protects is <code>Send</code>, which is the
case for <code>Ticket</code>.
At the same time, we can't move the <code>Mutex</code> out of the <code>TicketStore</code> nor clone it.</li>
</ul>
<blockquote>
<p>ã¾ã¨ã‚ã‚‹ã¨ãƒ»ãƒ»ãƒ»</p>
<ul>
<li>ãƒãƒ£ãƒãƒ«ã‚’ä»‹ã—ã¦<code>MutexGuard</code>ã‚’é€ä¿¡ã§ãã¾ã›ã‚“ã€‚ã‚ˆã£ã¦ã€ã‚µãƒ¼ãƒãƒ¼å´ã§ãƒ­ãƒƒã‚¯ã—ã¦ã€ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå´ã§ãƒã‚±ãƒƒãƒˆã‚’ä¿®æ­£ã§ãã¾ã›ã‚“ã€‚</li>
<li><code>Mutex</code>ã¯ã€ãã‚ŒãŒä¿è­·ã™ã‚‹ãƒ‡ãƒ¼ã‚¿ãŒ<code>Send</code>ã§ã‚ã‚‹é™ã‚Š<code>Send</code>ã§ã€ãã‚Œã¯<code>Ticket</code>ã®å ´åˆã§ã‚ã‚Šã€ãƒãƒ£ãƒãƒ«ã‚’ä»‹ã—ã¦<code>Mutex</code>ã‚’é€ä¿¡ã§ãã¾ã™ã€‚
åŒæ™‚ã«ã€<code>TicketStore</code>ã®å¤–å´ã«<code>Mutex</code>ã‚’ç§»å‹•ã§ããšã€ãã‚Œã‚’ã‚¯ãƒ­ãƒ¼ãƒ³ã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã›ã‚“ã€‚</li>
</ul>
</blockquote>
<p>How can we solve this conundrum?<br />
We need to look at the problem from a different angle.
To lock a <code>Mutex</code>, we don't need an owned value. A shared reference is enough, since <code>Mutex</code> uses internal mutability:</p>
<blockquote>
<p>ã©ã®ã‚ˆã†ã«ã“ã®é›£å•ã‚’è§£æ±ºã§ãã‚‹ã§ã—ã‚‡ã†ã‹ï¼Ÿ
ç•°ãªã‚‹è§’åº¦ã‹ã‚‰å•é¡Œã‚’çœºã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚
<code>Mutex</code>ã‚’ãƒ­ãƒƒã‚¯ã™ã‚‹ãŸã‚ã«ã€å€¤ã‚’æ‰€æœ‰ã™ã‚‹å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚<code>Mutex</code>ã¯å†…éƒ¨å¯å¤‰æ€§ã‚’ä½¿ç”¨ã™ã‚‹ãŸã‚ã€å…±æœ‰å‚ç…§ã§ååˆ†ã§ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; Mutex&lt;T&gt; {
    // `&amp;self`, not `self`!
    // `self`ã§ã¯ãªã`&amp;self`ã§ã™ï¼
    pub fn lock(&amp;self) -&gt; LockResult&lt;MutexGuard&lt;'_, T&gt;&gt; {
        // Implementation details
    }
}
<span class="boring">}</span></code></pre></pre>
<p>It is therefore enough to send a shared reference to the client.<br />
We can't do that directly, though, because the reference would have to be <code>'static</code> and that's not the case.<br />
In a way, we need an "owned shared reference". It turns out that Rust has a type that fits the bill: <code>Arc</code>.</p>
<blockquote>
<p>ã‚ˆã£ã¦ã€ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã«å…±æœ‰å‚ç…§ã‚’é€ä¿¡ã™ã‚‹ã ã‘ã§ååˆ†ã§ã™ã€‚
ãã‚Œã‚’ç›´æ¥è¡Œã†ã“ã¨ã¯ã§ãã¾ã›ã‚“ãŒã€ãã®å‚ç…§ã¯<code>'static</code>ã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã€ãã‚Œã¯ãã®å ´åˆã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚
ã‚ã‚‹æ„å‘³ã§ã€ã€Œæ‰€æœ‰ã—ãŸå…±æœ‰å‚ç…§ã€ãŒå¿…è¦ã§ã™ã€‚ãã‚Œã¯ã€RustãŒãã®è¦ä»¶ã‚’æº€ãŸã™å‹<code>Arc</code>ã‚’æŒã£ã¦ã„ã‚‹ã“ã¨ãŒã‚ã‹ã‚Šã¾ã™ã€‚</p>
</blockquote>
<h2 id="arc-to-the-rescueæ•‘ã†ãŸã‚ã®arc"><a class="header" href="#arc-to-the-rescueæ•‘ã†ãŸã‚ã®arc"><code>Arc</code> to the rescueï¼ˆæ•‘ã†ãŸã‚ã®Arcï¼‰</a></h2>
<p><code>Arc</code> stands for <strong>atomic reference counting</strong>.<br />
<code>Arc</code> wraps around a value and keeps track of how many references to the value exist.
When the last reference is dropped, the value is deallocated.<br />
The value wrapped in an <code>Arc</code> is immutable: you can only get shared references to it.</p>
<blockquote>
<p><code>Arc</code>ã¯<strong>ã‚¢ãƒˆãƒŸãƒƒã‚¯ãªå‚ç…§ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼</strong>ã‚’è¡¨ã—ã¦ã„ã¾ã™ã€‚
<code>Arc</code>ã¯å€¤ã‚’ãƒ©ãƒƒãƒ—ã—ã¦ã€å€¤ã¸ã®å‚ç…§ãŒã©ã‚Œã ã‘å­˜åœ¨ã™ã‚‹ã‹è¿½è·¡ã—ã¾ã™ã€‚
æœ€å¾Œã®å‚ç…§ãŒãƒ‰ãƒ­ãƒƒãƒ—ã•ã‚ŒãŸã¨ãã€ãã®å€¤ã¯ãƒ‰ãƒ­ãƒƒãƒ—ã•ã‚Œã¾ã™ã€‚
<code>Arc</code>å†…ã«ãƒ©ãƒƒãƒ—ã•ã‚ŒãŸå€¤ã¯ä¸å¤‰ã§ã™ã€‚ãã®å…±æœ‰å‚ç…§ã®ã¿å¾—ã‚‰ã‚Œã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::Arc;

let data: Arc&lt;u32&gt; = Arc::new(0);
let data_clone = Arc::clone(&amp;data);

// `Arc&lt;T&gt;` implements `Deref&lt;T&gt;`, so can convert
// a `&amp;Arc&lt;T&gt;` to a `&amp;T` using deref coercion
// `Arc&lt;T&gt;`ã¯`Deref&lt;T&gt;`ã‚’å®Ÿè£…ã—ã¦ã„ã‚‹ãŸã‚ã€å‚ç…§å¤–ã—å‹å¼·åˆ¶ã‚’ä½¿ç”¨ã—ã¦`&amp;Arc&lt;T&gt;`ã‚’`&amp;T`ã«å¤‰æ›ã§ãã¾ã™ã€‚
let data_ref: &amp;u32 = &amp;data;
<span class="boring">}</span></code></pre></pre>
<p>If you're having a dÃ©jÃ  vu moment, you're right: <code>Arc</code> sounds very similar to <code>Rc</code>, the reference-counted pointer we
introduced when talking about interior mutability. The difference is thread-safety: <code>Rc</code> is not <code>Send</code>, while <code>Arc</code> is.
It boils down to the way the reference count is implemented: <code>Rc</code> uses a "normal" integer, while <code>Arc</code> uses an
<strong>atomic</strong> integer, which can be safely shared and modified across threads.</p>
<blockquote>
<p>ãƒ‡ã‚¸ãƒ£ãƒ–ã‚’æ„Ÿã˜ãŸå ´åˆã€ãã‚Œã¯æ­£ã—ã„ã§ã™ã€‚
<code>Arc</code>ã¯<code>Rc</code>ã«ã¨ã¦ã‚‚ä¼¼ã¦ã„ã‚‹ã‚ˆã†ã«èã“ãˆã¦ã€<code>Rc</code>ã¯å†…éƒ¨å¯å¤‰æ€§ã«ã¤ã„ã¦è©±ã—ã¦ã„ãŸã¨ãã«å°å…¥ã—ãŸå‚ç…§ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼ã®ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã§ã™ã€‚
é•ã„ã¯ã‚¹ãƒ¬ãƒƒãƒ‰ã‚»ãƒ¼ãƒ•ã§ã™ã€‚<code>Rc</code>ã¯<code>Send</code>ã§ã¯ãªãã€<code>Arc</code>ã¯<code>Send</code>ã§ã™ã€‚
ãã‚Œã¯ã€å‚ç…§ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼ã‚’å®Ÿè£…ã™ã‚‹æ–¹æ³•ã‚’è¦ç´„ã—ã¦ã„ã¾ã™ã€‚
<code>Rc</code>ã¯ã€Œæ™®é€šã®ã€æ•´æ•°ã‚’ä½¿ç”¨ã—ã¦ã„ã‚‹ä¸€æ–¹ã§ã€<code>Arc</code>ã¯<strong>ã‚¢ãƒˆãƒŸãƒƒã‚¯ãª</strong>æ•´æ•°ã‚’ä½¿ç”¨ã—ã¦ã„ã¦ã€ãã‚Œã¯ã‚¹ãƒ¬ãƒƒãƒ‰ã‚’ã¾ãŸã„ã§å®‰å…¨ã«å…±æœ‰ã—ã¦å¤‰æ›´ã§ãã¾ã™ã€‚</p>
</blockquote>
<h2 id="arcmutext"><a class="header" href="#arcmutext"><code>Arc&lt;Mutex&lt;T&gt;&gt;</code></a></h2>
<p>If we pair <code>Arc</code> with <code>Mutex</code>, we finally get a type that:</p>
<ul>
<li>Can be sent between threads, because:
<ul>
<li><code>Arc</code> is <code>Send</code> if <code>T</code> is <code>Send</code>, and</li>
<li><code>Mutex</code> is <code>Send</code> if <code>T</code> is <code>Send</code>.</li>
<li><code>T</code> is <code>Ticket</code>, which is <code>Send</code>.</li>
</ul>
</li>
<li>Can be cloned, because <code>Arc</code> is <code>Clone</code> no matter what <code>T</code> is.
Cloning an <code>Arc</code> increments the reference count, the data is not copied.</li>
<li>Can be used to modify the data it wraps, because <code>Arc</code> lets you get a shared
reference to <code>Mutex&lt;T&gt;</code> which can in turn be used to acquire a lock.</li>
</ul>
<blockquote>
<p><code>Arc</code>ã¨<code>Mutex</code>ã§çµ„ã¿åˆã‚ã›ãŸå ´åˆã€æœ€çµ‚çš„ã«æ¬¡ã®å‹ãŒå¾—ã‚‰ã‚Œã¾ã™ã€‚</p>
<ul>
<li>ã‚¹ãƒ¬ãƒƒãƒ‰é–“ã§é€ä¿¡ã§ãã¾ã™ã€‚ãªãœãªã‚‰ãƒ»ãƒ»ãƒ»
<ul>
<li><code>T</code>ãŒ<code>Send</code>ã§ã‚ã‚‹å ´åˆã€<code>Arc</code>ã¯<code>Send</code>ã§ãƒ»ãƒ»ãƒ»</li>
<li><code>T</code>ãŒ<code>Send</code>ã§ã‚ã‚‹å ´åˆã€<code>Mutex</code>ã¯<code>Send</code>ã§ã™ã€‚</li>
<li><code>T</code>ã¯<code>Ticket</code>ã§ã€ãã‚Œã¯<code>Send</code>ã§ã™ã€‚</li>
</ul>
</li>
<li><code>T</code>ã«é–¢ã‚ã‚‰ãšã€<code>Arc</code>ã¯<code>Clone</code>ã§ã‚ã‚‹ãŸã‚ã€ã‚¯ãƒ­ãƒ¼ãƒ³ã§ãã¾ã™ã€‚
<code>Arc</code>ã®ã‚¯ãƒ­ãƒ¼ãƒ³ã¯ã€å‚ç…§ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼ã‚’å¢—ã‚„ã—ã€ãã®ãƒ‡ãƒ¼ã‚¿ã¯ã‚³ãƒ”ãƒ¼ã•ã‚Œã¾ã›ã‚“ã€‚</li>
<li>ãã‚Œï¼ˆ<code>Arc</code>ï¼‰ãŒãƒ©ãƒƒãƒ—ã—ãŸãƒ‡ãƒ¼ã‚¿ã‚’å¤‰æ›´ã§ãã¾ã™ã€‚
ãªãœãªã‚‰ã€<code>Arc</code>ã¯<code>Mutex&lt;T&gt;</code>ã¸ã®å…±æœ‰å‚ç…§ã‚’å¾—ã‚‰ã‚Œã‚‹ã‚ˆã†ã«ã—ã¦ã€æ¬¡ã«ãã‚Œï¼ˆ<code>Mutex&lt;T&gt;</code>ï¼‰ã¯ãƒ­ãƒƒã‚¯ã‚’ç²å¾—ã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚</li>
</ul>
</blockquote>
<p>We have all the pieces we need to implement the locking strategy for our ticket store.</p>
<blockquote>
<p>ãƒã‚±ãƒƒãƒˆã‚¹ãƒˆã‚¢ç”¨ã«ãƒ­ãƒƒã‚¯æˆ¦ç•¥ã‚’å®Ÿè£…ã™ã‚‹ãŸã‚ã«å¿…è¦ãªã™ã¹ã¦ã®è¦ç´ ãŒæƒã„ã¾ã—ãŸã€‚</p>
</blockquote>
<h2 id="further-readingå‚è€ƒè³‡æ–™-11"><a class="header" href="#further-readingå‚è€ƒè³‡æ–™-11">Further readingï¼ˆå‚è€ƒè³‡æ–™ï¼‰</a></h2>
<ul>
<li>We won't be covering the details of atomic operations in this course, but you can find more information
<a href="https://doc.rust-lang.org/std/sync/atomic/index.html">in the <code>std</code> documentation</a> as well as in the
<a href="https://marabos.nl/atomics/">"Rust atomics and locks" book</a>.</li>
</ul>
<h2 id="exercise-85"><a class="header" href="#exercise-85">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/07_threads/11_locks"><code>07_threads/11_locks</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="readers-and-writersãƒªãƒ¼ãƒ€ãƒ¼ã¨ãƒ©ã‚¤ã‚¿ãƒ¼"><a class="header" href="#readers-and-writersãƒªãƒ¼ãƒ€ãƒ¼ã¨ãƒ©ã‚¤ã‚¿ãƒ¼">Readers and writersï¼ˆãƒªãƒ¼ãƒ€ãƒ¼ã¨ãƒ©ã‚¤ã‚¿ãƒ¼ï¼‰</a></h1>
<p>Our new <code>TicketStore</code> works, but its read performance is not great: there can only be one client at a time
reading a specific ticket, because <code>Mutex&lt;T&gt;</code> doesn't distinguish between readers and writers.</p>
<blockquote>
<p>æ–°ã—ã„<code>TicketStore</code>ã¯æ©Ÿèƒ½ã—ã¾ã™ãŒã€èª­ã¿è¾¼ã¿æ€§èƒ½ã¯ã‚ã¾ã‚Šè‰¯ãã‚ã‚Šã¾ã›ã‚“ã€‚
<code>Mutex&lt;T&gt;</code>ã¯ãƒªãƒ¼ãƒ€ãƒ¼ã¨ãƒ©ã‚¤ã‚¿ãƒ¼ã‚’åŒºåˆ¥ã—ãªã„ãŸã‚ã€ç‰¹å®šã®ãƒã‚±ãƒƒãƒˆã‚’èª­ã¿è¾¼ã‚€ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã¯ä¸€åº¦ã«1ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã—ã‹ã„ã¾ã›ã‚“ã€‚</p>
</blockquote>
<p>We can solve the issue by using a different locking primitive: <code>RwLock&lt;T&gt;</code>.<br />
<code>RwLock&lt;T&gt;</code> stands for <strong>read-write lock</strong>. It allows <strong>multiple readers</strong> to access the data simultaneously,
but only one writer at a time.</p>
<blockquote>
<p>ç•°ãªã‚‹ãƒ­ãƒƒã‚¯æ§‹æˆè¦ç´ ã®<code>RwLock&lt;T&gt;</code>ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã§ã€ãã®å•é¡Œã‚’è§£æ±ºã§ãã¾ã™ã€‚
<code>RwLock&lt;T&gt;</code>ã¯ã€<strong>èª­ã¿æ›¸ããƒ­ãƒƒã‚¯</strong>ã‚’è¡¨ã—ã¦ã„ã¾ã™ã€‚
ãã‚Œã¯ã€åŒæ™‚ã«<strong>è¤‡æ•°ãƒªãƒ¼ãƒ€ãƒ¼</strong>ã‚’ãƒ‡ãƒ¼ã‚¿ã«ã‚¢ã‚¯ã‚»ã‚¹ã•ã›ã¾ã™ãŒã€ä¸€åº¦ã«1ã¤ã®ãƒ©ã‚¤ã‚¿ãƒ¼ã®ã¿ã‚¢ã‚¯ã‚»ã‚¹ã•ã›ã¾ã™ã€‚</p>
</blockquote>
<p><code>RwLock&lt;T&gt;</code> has two methods to acquire a lock: <code>read</code> and <code>write</code>.<br />
<code>read</code> returns a guard that allows you to read the data, while <code>write</code> returns a guard that allows you to modify it.</p>
<blockquote>
<p><code>RwLock&lt;T&gt;</code>ã¯ã€<code>read</code>ã¨<code>write</code>ã®2ã¤ã®ãƒ­ãƒƒã‚¯ã‚’ç²å¾—ã™ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰ãŒã‚ã‚Šã¾ã™ã€‚
<code>read</code>ã¯ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿å–ã‚Šã•ã›ã‚‹ã‚¬ãƒ¼ãƒ‰ã‚’è¿”ã—ã€<code>write</code>ã¯ãã‚Œã‚’ä¿®æ­£ã•ã›ã‚‹ã‚¬ãƒ¼ãƒ‰ã‚’è¿”ã—ã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::RwLock;

// An integer protected by a read-write lock
// èª­ã¿æ›¸ããƒ­ãƒƒã‚¯ã«ã‚ˆã£ã¦ä¿è­·ã•ã‚ŒãŸæ•´æ•°ã§ã™ã€‚
let lock = RwLock::new(0);

// Acquire a read lock on the RwLock
// RwLockã®èª­ã¿è¾¼ã¿å°‚ç”¨ãƒ­ãƒƒã‚¯ã‚’ç²å¾—ã—ã¾ã™ã€‚
let guard1 = lock.read().unwrap();

// Acquire a **second** read lock
// while the first one is still active
// æœ€åˆã®èª­ã¿è¾¼ã¿å°‚ç”¨ãƒ­ãƒƒã‚¯ãŒæœ‰åŠ¹ãªé–“ã«ã€**2ç•ªç›®ã®**èª­ã¿è¾¼ã¿å°‚ç”¨ãƒ­ãƒƒã‚¯ã‚’ç²å¾—ã—ã¾ã™ã€‚
let guard2 = lock.read().unwrap();
<span class="boring">}</span></code></pre></pre>
<h2 id="trade-offsäºŒå¾‹èƒŒå"><a class="header" href="#trade-offsäºŒå¾‹èƒŒå">Trade-offsï¼ˆäºŒå¾‹èƒŒåï¼‰</a></h2>
<p>On the surface, <code>RwLock&lt;T&gt;</code> seems like a no-brainer: it provides a superset of the functionality of <code>Mutex&lt;T&gt;</code>.
Why would you ever use <code>Mutex&lt;T&gt;</code> if you can use <code>RwLock&lt;T&gt;</code> instead?</p>
<blockquote>
<p>è¡¨é¢ä¸Šã€<code>RwLock&lt;T&gt;</code>ã¯è€ƒãˆã‚‹ã¾ã§ã‚‚ãªã„ã‚ˆã†ã«è¦‹ãˆã¾ã™ã€‚ãã‚Œã¯<code>Mutex&lt;T&gt;</code>ã®æ©Ÿèƒ½ã®ã‚¹ãƒ¼ãƒ‘ãƒ¼ã‚»ãƒƒãƒˆã‚’æä¾›ã—ã¾ã™ã€‚
ä»£ã‚ã£ã¦<code>RwLock&lt;T&gt;</code>ã‚’ä½¿ç”¨ã§ãã‚‹ã®ã«ã€ãªãœ<code>Mutex&lt;T&gt;</code>ã‚’ã¾ã ä½¿ç”¨ã™ã‚‹ã®ã§ã—ã‚‡ã†ã‹ã€‚</p>
</blockquote>
<p>There are two key reasons:</p>
<ul>
<li>Locking a <code>RwLock&lt;T&gt;</code> is more expensive than locking a <code>Mutex&lt;T&gt;</code>.<br />
This is because <code>RwLock&lt;T&gt;</code> has to keep track of the number of active readers and writers, while <code>Mutex&lt;T&gt;</code>
only has to keep track of whether the lock is held or not.
This performance overhead is not an issue if there are more readers than writers, but if the workload
is write-heavy <code>Mutex&lt;T&gt;</code> might be a better choice.</li>
<li><code>RwLock&lt;T&gt;</code> can cause <strong>writer starvation</strong>.<br />
If there are always readers waiting to acquire the lock, writers might never get a chance to run.<br />
<code>RwLock&lt;T&gt;</code> doesn't provide any guarantees about the order in which readers and writers are granted access to the lock.
It depends on the policy implemented by the underlying OS, which might not be fair to writers.</li>
</ul>
<blockquote>
<p>ä¸»ã«2ã¤ã®ç†ç”±ãŒã‚ã‚Šã¾ã™ã€‚</p>
<ul>
<li><code>RwLock&lt;T&gt;</code>ã‚’ãƒ­ãƒƒã‚¯ã™ã‚‹ã“ã¨ã¯ã€<code>Mutex&lt;T&gt;</code>ã‚’ãƒ­ãƒƒã‚¯ã™ã‚‹ã‚ˆã‚Šã‚‚ã‚³ã‚¹ãƒˆãŒé«˜ã„ã§ã™ã€‚
ã“ã‚Œã¯ã€<code>RwLock&lt;T&gt;</code>ã¯æœ‰åŠ¹ãªãƒªãƒ¼ãƒ€ãƒ¼ã¨ãƒ©ã‚¤ã‚¿ãƒ¼ã®æ•°ã‚’è¿½è·¡ã™ã‚‹ä¸€æ–¹ã§ã€<code>Mutex&lt;T&gt;</code>ã¯ãƒ­ãƒƒã‚¯ãŒä¿æŒã•ã‚Œã¦ã„ã‚‹ã‹ã©ã†ã‹ã‚’è¿½è·¡ã™ã‚‹ã ã‘ã ã‹ã‚‰ã§ã™ã€‚
ã“ã®æ€§èƒ½ã®ã‚ªãƒ¼ãƒãƒ¼ãƒ˜ãƒƒãƒ‰ã¯ã€ãƒ©ã‚¤ã‚¿ãƒ¼ã‚ˆã‚Šã‚‚ãƒªãƒ¼ãƒ€ãƒ¼ã®ã»ã†ãŒå¤šã„å ´åˆã¯å•é¡Œã«ãªã‚Šã¾ã›ã‚“ãŒã€ãƒ¯ãƒ¼ã‚¯ãƒ­ãƒ¼ãƒ‰ãŒãƒ©ã‚¤ã‚¿ãƒ¼é‡è¦–ã®å ´åˆã€<code>Mutex&lt;T&gt;</code>ãŒè‰¯ã„é¸æŠã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚</li>
<li><code>RwLock&lt;T&gt;</code>ã¯<strong>ãƒ©ã‚¤ã‚¿ãƒ¼ã®é£¢é¤“</strong>ã‚’å¼•ãèµ·ã“ã™å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚
ãƒ­ãƒƒã‚¯ã‚’ç²å¾—ã™ã‚‹ãŸã‚ã«å¸¸ã«ãƒªãƒ¼ãƒ€ãƒ¼ãŒå¾…æ©Ÿã—ã¦ã„ã‚‹å ´åˆã€ãƒ©ã‚¤ã‚¿ãƒ¼ã¯å®Ÿè¡Œã™ã‚‹æ©Ÿä¼šã‚’å¾—ã‚‰ã‚Œãªã„ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚
<code>RwLock&lt;T&gt;</code>ã¯ã€ãƒªãƒ¼ãƒ€ãƒ¼ã¨ãƒ©ã‚¤ã‚¿ãƒ¼ãŒãƒ­ãƒƒã‚¯ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹æ¨©é™ã‚’ä¸ãˆã‚‹é †åºã‚’ä¿è¨¼ã—ã¾ã›ã‚“ã€‚
ãã‚Œã¯ã€åŸºç›¤ã¨ãªã‚‹OSã«ã‚ˆã£ã¦å®Ÿè£…ã•ã‚ŒãŸæ–¹é‡ã«ä¾å­˜ã—ã¦ã€ãƒ©ã‚¤ã‚¿ãƒ¼ã«ã¨ã£ã¦å…¬å¹³ã§ãªã„ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚</li>
</ul>
</blockquote>
<p>In our case, we can expect the workload to be read-heavy (since most clients will be reading tickets, not modifying them),
so <code>RwLock&lt;T&gt;</code> is a good choice.</p>
<blockquote>
<p>ãƒã‚±ãƒƒãƒˆç®¡ç†ã‚·ã‚¹ãƒ†ãƒ ã®å ´åˆã€ã»ã¨ã‚“ã©ã®ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã¯ãƒã‚±ãƒƒãƒˆã‚’èª­ã¿è¾¼ã¿ã€ãƒã‚±ãƒƒãƒˆã®ä¿®æ­£ã¯ã»ã¨ã‚“ã©ãªã„ãŸã‚ã€ãƒ¯ãƒ¼ã‚¯ãƒ­ãƒ¼ãƒ‰ã¯ãƒªãƒ¼ãƒ€ãƒ¼é‡è¦–ã§ã‚ã‚‹ã¨æœŸå¾…ã§ãã‚‹ãŸã‚ã€<code>RwLock&lt;T&gt;</code>ã¯è‰¯ã„é¸æŠã§ã™ã€‚</p>
</blockquote>
<h2 id="exercise-86"><a class="header" href="#exercise-86">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/07_threads/12_rw_lock"><code>07_threads/12_rw_lock</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="design-reviewè¨­è¨ˆãƒ¬ãƒ“ãƒ¥ãƒ¼"><a class="header" href="#design-reviewè¨­è¨ˆãƒ¬ãƒ“ãƒ¥ãƒ¼">Design reviewï¼ˆè¨­è¨ˆãƒ¬ãƒ“ãƒ¥ãƒ¼ï¼‰</a></h1>
<p>Let's take a moment to review the journey we've been through.</p>
<blockquote>
<p>å°‘ã—ã®é–“ã€ã“ã‚Œã¾ã§ã®æ—…ã‚’ãƒ¬ãƒ“ãƒ¥ãƒ¼ã—ã¦ã¿ã¾ã—ã‚‡ã†ã€‚</p>
</blockquote>
<h2 id="lockless-with-channel-serializationãƒãƒ£ãƒãƒ«ã®ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ä½¿ç”¨ã—ãŸãƒ­ãƒƒã‚¯ãƒ¬ã‚¹"><a class="header" href="#lockless-with-channel-serializationãƒãƒ£ãƒãƒ«ã®ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ä½¿ç”¨ã—ãŸãƒ­ãƒƒã‚¯ãƒ¬ã‚¹">Lockless with channel serializationï¼ˆãƒãƒ£ãƒãƒ«ã®ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ä½¿ç”¨ã—ãŸãƒ­ãƒƒã‚¯ãƒ¬ã‚¹ï¼‰</a></h2>
<p>Our first implementation of a multithreaded ticket store used:</p>
<ul>
<li>a single long-lived thread (server), to hold the shared state</li>
<li>multiple clients sending requests to it via channels from their own threads.</li>
</ul>
<blockquote>
<p>ãƒãƒ«ãƒã‚¹ãƒ¬ãƒƒãƒ‰ãªãƒã‚±ãƒƒãƒˆã‚¹ãƒˆã‚¢ã®æœ€åˆã®å®Ÿè£…ã¯ã€æ¬¡ã‚’ä½¿ç”¨ã—ã¾ã—ãŸã€‚</p>
<ul>
<li>å…±æœ‰ã•ã‚ŒãŸçŠ¶æ…‹ã‚’ä¿æŒã™ã‚‹å˜ä¸€ã§é•·ç”Ÿãã™ã‚‹ã‚¹ãƒ¬ãƒƒãƒ‰ï¼ˆã‚µãƒ¼ãƒãƒ¼ï¼‰</li>
<li>ãã‚Œãã‚Œè‡ªèº«ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã‹ã‚‰ãƒãƒ£ãƒãƒ«ã‚’ä»‹ã—ã¦ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’é€ä¿¡ã™ã‚‹è¤‡æ•°ã®ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ</li>
</ul>
</blockquote>
<p>No locking of the state was necessary, since the server was the only one modifying the state. That's because
the "inbox" channel naturally <strong>serialized</strong> incoming requests: the server would process them one by one.<br />
We've already discussed the limitations of this approach when it comes to patching behaviour, but we didn't
discuss the performance implications of the original design: the server could only process one request at a time,
including reads.</p>
<blockquote>
<p>ã‚µãƒ¼ãƒãƒ¼ã¯çŠ¶æ…‹ã‚’å¤‰æ›´ã™ã‚‹å”¯ä¸€ã®ã‚‚ã®ã§ã‚ã£ãŸãŸã‚ã€çŠ¶æ…‹ã®ãƒ­ãƒƒã‚¯ã¯å¿…è¦ã‚ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚
ãã‚Œã¯ã€ã€Œå—ä¿¡ã€ãƒãƒ£ãƒãƒ«ãŒè‡ªç„¶ã«å…¥ã£ã¦ãã‚‹ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’<strong>ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚º</strong>ã—ãŸã‹ã‚‰ã§ã™ã€‚ã‚µãƒ¼ãƒãƒ¼ã¯ãã‚Œã‚‰ã‚’1ã¤ãšã¤å‡¦ç†ã—ã¾ã—ãŸã€‚
ãƒ‘ãƒƒãƒã®æŒ¯ã‚‹èˆã„ã«æ¥ãŸã¨ãã€ã“ã®æŒ¯ã‚‹èˆã„ã®åˆ¶é™ã‚’ã™ã§ã«è­°è«–ã—ã¾ã—ãŸãŒã€ã‚ªãƒªã‚¸ãƒŠãƒ«ã®è¨­è¨ˆã®æ€§èƒ½ã®å½±éŸ¿ã«ã¤ã„ã¦ã¯è­°è«–ã—ã¾ã›ã‚“ã§ã—ãŸã€‚
ã‚µãƒ¼ãƒãƒ¼ã¯ã€èª­ã¿è¾¼ã¿ã‚’å«ã‚ã¦ä¸€åº¦ã«1ã¤ã®ãƒªã‚¯ã‚¨ã‚¹ãƒˆã—ã‹å‡¦ç†ã§ãã¾ã›ã‚“ã€‚</p>
</blockquote>
<h2 id="fine-grained-lockingé©åˆ‡ãªç²’åº¦ã®ãƒ­ãƒƒã‚¯"><a class="header" href="#fine-grained-lockingé©åˆ‡ãªç²’åº¦ã®ãƒ­ãƒƒã‚¯">Fine-grained lockingï¼ˆé©åˆ‡ãªç²’åº¦ã®ãƒ­ãƒƒã‚¯ï¼‰</a></h2>
<p>We then moved to a more sophisticated design, where each ticket was protected by its own lock and
clients could independently decide if they wanted to read or atomically modify a ticket, acquiring the appropriate lock.</p>
<blockquote>
<p>ãã—ã¦ã€ã‚ˆã‚Šæ´—ç·´ã•ã‚ŒãŸè¨­è¨ˆã«ç§»è¡Œã—ã¦ã€ãã‚Œãã‚Œã®ãƒã‚±ãƒƒãƒˆãŒãã‚Œè‡ªèº«ã®ãƒ­ãƒƒã‚¯ã«ã‚ˆã£ã¦ä¿è­·ã•ã‚Œã€ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã¯ç‹¬ç«‹ã§é©åˆ‡ãªãƒ­ãƒƒã‚¯ã‚’ç²å¾—ã—ã¦ã€ãƒã‚±ãƒƒãƒˆã®èª­ã¿è¾¼ã¿ã‹ã‚¢ãƒˆãƒŸãƒƒã‚¯ãªä¿®æ­£ã‹ã‚’æ±ºå®šã§ãã¾ã—ãŸã€‚</p>
</blockquote>
<p>This design allows for better parallelism (i.e. multiple clients can read tickets at the same time), but it is
still fundamentally <strong>serial</strong>: the server processes commands one by one. In particular, it hands out locks to clients
one by one.</p>
<blockquote>
<p>ä¾‹ãˆã°ã€è¤‡æ•°ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆãŒåŒæ™‚ã«ãƒã‚±ãƒƒãƒˆã‚’èª­ã¿è¾¼ã‚ã‚Œã‚‹ã‚ˆã†ã«ã€ã“ã®è¨­è¨ˆã¯è‰¯ã„ä¸¦åˆ—å‡¦ç†ã‚’å¯èƒ½ã«ã—ã¾ã™ãŒã€ãã‚Œã¯ã¾ã åŸºæœ¬çš„ã«<strong>ã‚·ãƒªã‚¢ãƒ«</strong>ã§ã™ã€‚</p>
</blockquote>
<p>Could we remove the channels entirely and allow clients to directly access the <code>TicketStore</code>, relying exclusively on
locks to synchronize access?</p>
<blockquote>
<p>å®Œå…¨ã«ãƒãƒ£ãƒãƒ«ã‚’å‰Šé™¤ã—ã¦ã€ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆãŒç›´æ¥<code>TicketStore</code>ã«ã‚¢ã‚¯ã‚»ã‚¹ã—ã¦ã€åŒæœŸçš„ãªã‚¢ã‚¯ã‚»ã‚¹ã‚’ã™ã‚‹ãŸã‚ã«æ’ä»–çš„ãªãƒ­ãƒƒã‚¯ã«ä¾å­˜ã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã§ã—ã‚‡ã†ã‹ï¼Ÿ</p>
</blockquote>
<h2 id="removing-channelsãƒãƒ£ãƒãƒ«ã®å‰Šé™¤"><a class="header" href="#removing-channelsãƒãƒ£ãƒãƒ«ã®å‰Šé™¤">Removing channelsï¼ˆãƒãƒ£ãƒãƒ«ã®å‰Šé™¤ï¼‰</a></h2>
<p>We have two problems to solve:</p>
<ul>
<li>Sharing <code>TicketStore</code> across threads</li>
<li>Synchronizing access to the store</li>
</ul>
<blockquote>
<p>è§£æ±ºã™ã‚‹ãŸã‚ã«å•é¡ŒãŒ2ã¤ã‚ã‚Šã¾ã™ã€‚</p>
<ul>
<li>ã‚¹ãƒ¬ãƒƒãƒ‰ã‚’ã¾ãŸã„ã§<code>TicketStore</code>ã‚’å…±æœ‰ã™ã‚‹</li>
<li>ã‚¹ãƒˆã‚¢ã¸ã®åŒæœŸã‚¢ã‚¯ã‚»ã‚¹</li>
</ul>
</blockquote>
<h3 id="sharing-ticketstore-across-threadsã‚¹ãƒ¬ãƒƒãƒ‰ã‚’ã¾ãŸã„ã ticketstoreã®å…±æœ‰"><a class="header" href="#sharing-ticketstore-across-threadsã‚¹ãƒ¬ãƒƒãƒ‰ã‚’ã¾ãŸã„ã ticketstoreã®å…±æœ‰">Sharing <code>TicketStore</code> across threadsï¼ˆã‚¹ãƒ¬ãƒƒãƒ‰ã‚’ã¾ãŸã„ã TicketStoreã®å…±æœ‰ï¼‰</a></h3>
<p>We want all threads to refer to the same state, otherwise we don't really have a multithreaded systemâ€”we're just
running multiple single-threaded systems in parallel.<br />
We've already encountered this problem when we tried to share a lock across threads: we can use an <code>Arc</code>.</p>
<blockquote>
<p>ã™ã¹ã¦ã®ã‚¹ãƒ¬ãƒƒãƒ‰ãŒåŒã˜çŠ¶æ…‹ã‚’å‚ç…§ã§ãã‚‹ã‚ˆã†ã«ã—ãŸã„ã§ã™ã€‚ãã†ã§ãªã„ã¨ã€æœ¬ç‰©ã®ãƒãƒ«ãƒã‚¹ãƒ¬ãƒƒãƒ‰ãªã‚·ã‚¹ãƒ†ãƒ ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚
å˜ã«ä¸¦åˆ—ã§è¤‡æ•°ã®å˜ä¸€ã‚¹ãƒ¬ãƒƒãƒ‰ãªã‚·ã‚¹ãƒ†ãƒ ã‚’å®Ÿè¡Œã—ã¦ã„ã‚‹ã ã‘ã§ã™ã€‚
ã‚¹ãƒ¬ãƒƒãƒ‰ã‚’ã¾ãŸã„ã§ãƒ­ãƒƒã‚¯ã‚’å…±æœ‰ã™ã‚‹ã“ã¨ã‚’è©¦ã¿ãŸã¨ãã«ã€ã“ã®å•é¡Œã«é­é‡ã—ã¾ã—ãŸã€‚<code>Arc</code>ã‚’ä½¿ç”¨ã§ãã¾ã™ã€‚</p>
</blockquote>
<h3 id="synchronizing-access-to-the-storeã‚¹ãƒˆã‚¢ã¸ã®åŒæœŸã‚¢ã‚¯ã‚»ã‚¹"><a class="header" href="#synchronizing-access-to-the-storeã‚¹ãƒˆã‚¢ã¸ã®åŒæœŸã‚¢ã‚¯ã‚»ã‚¹">Synchronizing access to the storeï¼ˆã‚¹ãƒˆã‚¢ã¸ã®åŒæœŸã‚¢ã‚¯ã‚»ã‚¹ï¼‰</a></h3>
<p>There is one interaction that's still lockless thanks to the serialization provided by the channels: inserting
(or removing) a ticket from the store.<br />
If we remove the channels, we need to introduce (another) lock to synchronize access to the <code>TicketStore</code> itself.</p>
<blockquote>
<p>ãƒãƒ£ãƒãƒ«ã«ã‚ˆã£ã¦æä¾›ã•ã‚ŒãŸã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³ã®ãŠã‹ã’ã§ã€ã¾ã ãƒ­ãƒƒã‚¯ãƒ¬ã‚¹ãªç›¸äº’ä½œç”¨ãŒ1ã¤ã‚ã‚Šã¾ã™ã€‚
ãã‚Œã¯ã€ã‚¹ãƒˆã‚¢ã«ãƒã‚±ãƒƒãƒˆã‚’æŒ¿å…¥ï¼ˆã¾ãŸã¯å‰Šé™¤ï¼‰ã™ã‚‹ã“ã¨ã§ã™ã€‚
ãƒãƒ£ãƒãƒ«ã‚’å‰Šé™¤ã™ã‚‹å ´åˆã€<code>TicketStore</code>è‡ªèº«ã«åŒæœŸã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ãŸã‚ã«ä»–ã®ãƒ­ãƒƒã‚¯ã‚’å°å…¥ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚</p>
</blockquote>
<p>If we use a <code>Mutex</code>, then it makes no sense to use an additional <code>RwLock</code> for each ticket: the <code>Mutex</code> will
already serialize access to the entire store, so we wouldn't be able to read tickets in parallel anyway.<br />
If we use a <code>RwLock</code>, instead, we can read tickets in parallel. We just need to pause all reads while inserting
or removing a ticket.</p>
<blockquote>
<p><code>Mutex</code>ã‚’ä½¿ç”¨ã™ã‚‹å ´åˆã€ãã‚Œãã‚Œã®ãƒã‚±ãƒƒãƒˆã«å¯¾ã—ã¦è¿½åŠ ã®<code>RwLock</code>ã‚’ä½¿ç”¨ã™ã‚‹æ„å‘³ãŒã‚ã‚Šã¾ã›ã‚“ã€‚
<code>Mutex</code>ã¯ã€ã™ã§ã«ã‚¹ãƒˆã‚¢å…¨ä½“ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ã‚’ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚ºã™ã‚‹ãŸã‚ã€ä¸¦åˆ—ã§ãƒã‚±ãƒƒãƒˆã‚’èª­ã¿è¾¼ã‚€ã“ã¨ãŒã§ããªããªã‚Šã¾ã™ã€‚
ä»£ã‚ã‚Šã«<code>RwLock</code>ã‚’ä½¿ç”¨ã—ãŸå ´åˆã€ä¸¦åˆ—ã§ãƒã‚±ãƒƒãƒˆã‚’èª­ã¿è¾¼ã‚€ã“ã¨ãŒã§ãã¾ã™ã€‚
ãƒã‚±ãƒƒãƒˆã®æŒ¿å…¥ã¾ãŸã¯å‰Šé™¤ã®é–“ã€å˜ã«ã™ã¹ã¦ã®èª­ã¿è¾¼ã¿ã‚’åœæ­¢ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚</p>
</blockquote>
<p>Let's go down this path and see where it leads us.</p>
<blockquote>
<p>ã“ã®é“ã‚’é€²ã‚“ã§ã€ã©ã“ã«å°ã‹ã‚Œã‚‹ã‹ç¢ºèªã—ã¾ã—ã‚‡ã†ã€‚</p>
</blockquote>
<h2 id="exercise-87"><a class="header" href="#exercise-87">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/07_threads/13_without_channels"><code>07_threads/13_without_channels</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sync"><a class="header" href="#sync"><code>Sync</code></a></h1>
<p>Before we wrap up this chapter, let's talk about another key trait in Rust's standard library: <code>Sync</code>.</p>
<blockquote>
<p>ã“ã®ç« ã‚’ä»•ä¸Šã’ã‚‹å‰ã«ã€Rustæ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã«ã‚ã‚‹ä»–ã®ä¸»è¦ãªãƒˆãƒ¬ã‚¤ãƒˆã§ã‚ã‚‹<code>Sync</code>ã«ã¤ã„ã¦è©±ã—ã¾ã—ã‚‡ã†ã€‚</p>
</blockquote>
<p><code>Sync</code> is an auto trait, just like <code>Send</code>.<br />
It is automatically implemented by all types that can be safely <strong>shared</strong> between threads.</p>
<blockquote>
<p><code>Sync</code>ã¯ã€ã¡ã‚‡ã†ã©<code>Send</code>ã¨åŒæ§˜ã«è‡ªå‹•ãƒˆãƒ¬ã‚¤ãƒˆã§ã™ã€‚
ãã‚Œã¯ã€ã‚¹ãƒ¬ãƒƒãƒ‰é–“ã§å®‰å…¨ã«<strong>å…±æœ‰</strong>ã§ãã‚‹ã™ã¹ã¦ã®å‹ã«è‡ªå‹•çš„ã«å®Ÿè£…ã•ã‚Œã¾ã™ã€‚</p>
</blockquote>
<p>In order words: <code>T: Sync</code> means that <code>&amp;T</code> is <code>Send</code>.</p>
<blockquote>
<p>è¨€ã„æ›ãˆã‚Œã°ã€<code>T: Sync</code>ã¯ã€<code>&amp;T</code>ãŒ<code>Send</code>ã§ã‚ã‚‹ã“ã¨ã‚’æ„å‘³ã—ã¾ã™ã€‚</p>
</blockquote>
<h2 id="sync-doesnt-imply-sendsyncã¯sendã‚’æš—ã«æ„å‘³ã—ãªã„"><a class="header" href="#sync-doesnt-imply-sendsyncã¯sendã‚’æš—ã«æ„å‘³ã—ãªã„"><code>Sync</code> doesn't imply <code>Send</code>ï¼ˆSyncã¯Sendã‚’æš—ã«æ„å‘³ã—ãªã„ï¼‰</a></h2>
<p>It's important to note that <code>Sync</code> doesn't imply <code>Send</code>.<br />
For example: <code>MutexGuard</code> is not <code>Send</code>, but it is <code>Sync</code>.</p>
<blockquote>
<p><code>Sync</code>ãŒ<code>Send</code>ã‚’æš—ã«æ„å‘³ã—ãªã„ã“ã¨ã¯é‡è¦ãªæ³¨æ„äº‹é …ã§ã™ã€‚
ä¾‹ãˆã°ã€<code>MutexGuard</code>ã¯<code>Send</code>ã§ã¯ã‚ã‚Šã¾ã›ã‚“ãŒã€<code>Sync</code>ã§ã™ã€‚</p>
</blockquote>
<blockquote>
<p><code>&amp;MutexGuard</code>ã¯<code>Send</code>ã§ã‚ã‚‹ãŒã€<code>MutexGuard</code>ã¯<code>Send</code>ã§ãªã„ã€‚</p>
</blockquote>
<p>It isn't <code>Send</code> because the lock must be released on the same thread that acquired it, therefore we don't
want <code>MutexGuard</code> to be dropped on a different thread.<br />
But it is <code>Sync</code>, because giving a <code>&amp;MutexGuard</code> to another thread has no impact on where the lock is released.</p>
<blockquote>
<p>ãƒ­ãƒƒã‚¯ã¯ã€ãã‚Œã‚’ç²å¾—ã—ãŸåŒã˜ã‚¹ãƒ¬ãƒƒãƒ‰ã§è§£æ”¾ã•ã‚Œãªã‘ã‚Œã°ãªã‚‰ãªã„ãŸã‚ã€<code>MutexGuard</code>ãŒç•°ãªã‚‹ã‚¹ãƒ¬ãƒƒãƒ‰ã§ãƒ‰ãƒ­ãƒƒãƒ—ã•ã‚Œã‚‹ã“ã¨ã‚’æœ›ã‚“ã§ãªã„ãŸã‚ã€<code>MutexGuard</code>ã¯<code>Send</code>ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚
ã—ã‹ã—ã€<code>MutexGuard</code>ã¯<code>Sync</code>ã§ã€ãã‚Œã¯<code>&amp;MutexGuard</code>ã‚’ä»–ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã«ä¸ãˆã‚‹ã“ã¨ã¯ã€ãƒ­ãƒƒã‚¯ãŒè§£æ”¾ã•ã‚Œã‚‹å ´æ‰€ã«å½±éŸ¿ã‚’ä¸ãˆãªã„ã‹ã‚‰ã§ã™ã€‚</p>
</blockquote>
<blockquote>
<p><code>MutexGuard</code>ã®ãƒ­ãƒƒã‚¯ã‚’è§£æ”¾ã™ã‚‹ãŸã‚ã«ã¯ã€æ‰€æœ‰æ¨©ã¾ãŸã¯å¯å¤‰å‚ç…§ãŒå¿…è¦ã«ãªã‚‹ã€‚
ã‚ˆã£ã¦ã€<code>&amp;MutexGuard</code>ã§ã¯ã€ãƒ­ãƒƒã‚¯ã‚’è§£æ”¾ã§ããªã„ã€‚</p>
</blockquote>
<h2 id="send-doesnt-imply-syncsendã¯syncã‚’æš—ã«æ„å‘³ã—ãªã„"><a class="header" href="#send-doesnt-imply-syncsendã¯syncã‚’æš—ã«æ„å‘³ã—ãªã„"><code>Send</code> doesn't imply <code>Sync</code>ï¼ˆSendã¯Syncã‚’æš—ã«æ„å‘³ã—ãªã„ï¼‰</a></h2>
<p>The opposite is also true: <code>Send</code> doesn't imply <code>Sync</code>.<br />
For example: <code>RefCell&lt;T&gt;</code> is <code>Send</code> (if <code>T</code> is <code>Send</code>), but it is not <code>Sync</code>.</p>
<blockquote>
<p>ã¾ãŸåå¯¾ã‚‚æˆç«‹ã—ã¾ã™ã€‚<code>Send</code>ã¯<code>Sync</code>ã‚’æš—ã«æ„å‘³ã—ã¾ã›ã‚“ã€‚</p>
</blockquote>
<p><code>RefCell&lt;T&gt;</code> performs runtime borrow checking, but the counters it uses to track borrows are not thread-safe.
Therefore, having multiple threads holding a <code>&amp;RefCell</code> would lead to a data race, with potentially
multiple threads obtaining mutable references to the same data. Hence <code>RefCell</code> is not <code>Sync</code>.<br />
<code>Send</code> is fine, instead, because when we send a <code>RefCell</code> to another thread we're not
leaving behind any references to the data it contains, hence no risk of concurrent mutable access.</p>
<blockquote>
<p><code>RefCell&lt;T&gt;</code>ã¯ã€ãƒ©ã‚¤ãƒ³ã‚¿ã‚¤ãƒ ã§å€Ÿç”¨ãƒã‚§ãƒƒã‚¯ã‚’è¡Œã„ã¾ã™ãŒã€å€Ÿç”¨ã‚’è¿½è·¡ã™ã‚‹ãŸã‚ã«ãã‚ŒãŒä½¿ç”¨ã™ã‚‹ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼ã¯ã‚¹ãƒ¬ãƒƒãƒ‰ã‚»ãƒ¼ãƒ•ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚
ã‚ˆã£ã¦ã€<code>&amp;RefCell</code>ã‚’ä¿æŒã™ã‚‹è¤‡æ•°ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã‚’æŒã¤ã“ã¨ã¯ã€ãƒ‡ãƒ¼ã‚¿ç«¶åˆã‚’å¼•ãèµ·ã“ã—ã€æ½œåœ¨çš„ã«è¤‡æ•°ã®ã‚¹ãƒ¬ãƒƒãƒ‰ãŒåŒã˜ãƒ‡ãƒ¼ã‚¿ã¸ã®å¯å¤‰å‚ç…§ã‚’å–å¾—ã™ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚
ã‚ˆã£ã¦ã€<code>RefCell</code>ã¯<code>Sync</code>ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚
ä»£ã‚ã‚Šã«<code>Send</code>ã¯å•é¡Œã‚ã‚Šã¾ã›ã‚“ã€‚ãªãœãªã‚‰ã€ä»–ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã«<code>RefCell</code>ã‚’é€ä¿¡ã—ãŸã¨ãã€ãã‚ŒãŒå«ã‚€ãƒ‡ãƒ¼ã‚¿ã¸ã®å‚ç…§ã‚’èƒŒå¾Œã«æ®‹ã™ã“ã¨ã¯ãªã„ãŸã‚ã§ã€ä¸¦è¡Œãªå¯å¤‰ã‚¢ã‚¯ã‚»ã‚¹ã®ãƒªã‚¹ã‚¯ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚</p>
</blockquote>
<h2 id="exercise-88"><a class="header" href="#exercise-88">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/07_threads/14_sync"><code>07_threads/14_sync</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="async-rustéåŒæœŸrust"><a class="header" href="#async-rustéåŒæœŸrust">Async Rustï¼ˆéåŒæœŸRustï¼‰</a></h1>
<p>Threads are not the only way to write concurrent programs in Rust.<br />
In this chapter we'll explore another approach: <strong>asynchronous programming</strong>.</p>
<blockquote>
<p>Rustã«ãŠã„ã¦ã€ã‚¹ãƒ¬ãƒƒãƒ‰ã¯åŒæ™‚ä¸¦è¡Œãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’è¨˜è¿°ã™ã‚‹å”¯ä¸€ã®æ–¹æ³•ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚
ã“ã®ç« ã«ãŠã„ã¦ã€<strong>éåŒæœŸãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°</strong>ã¨ã„ã†ä»–ã®æ‰‹æ³•ã‚’æ¢æ±‚ã—ã¾ã™ã€‚</p>
</blockquote>
<p>In particular, you'll get an introduction to:</p>
<ul>
<li>The <code>async</code>/<code>.await</code> keywords, to write asynchronous code effortlessly</li>
<li>The <code>Future</code> trait, to represent computations that may not be complete yet</li>
<li><code>tokio</code>, the most popular runtime for running asynchronous code</li>
<li>The cooperative nature of Rust asynchronous model, and how this affects your code</li>
</ul>
<blockquote>
<p>ç‰¹ã«ã€ä»¥ä¸‹ã«ã¤ã„ã¦ç´¹ä»‹ã™ã‚‹äºˆå®šã§ã™ã€‚</p>
<ul>
<li>è‹¦åŠ´ã›ãšã«éåŒæœŸã‚³ãƒ¼ãƒ‰ã‚’è¨˜è¿°ã™ã‚‹ãŸã‚ã®<code>async</code>/<code>.await</code>ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰</li>
<li>ã¾ã å®Œäº†ã—ã¦ã„ãªã„ã‹ã‚‚ã—ã‚Œãªã„è¨ˆç®—ã‚’è¡¨ç¾ã™ã‚‹<code>Future</code>ãƒˆãƒ¬ã‚¤ãƒˆ</li>
<li>éåŒæœŸã‚³ãƒ¼ãƒ‰ã‚’å®Ÿè¡Œã™ã‚‹æœ€ã‚‚äººæ°—ã®ã‚ã‚‹ãƒ©ãƒ³ã‚¿ã‚¤ãƒ ã§ã‚ã‚‹<code>tokio</code></li>
<li>Rustã®éåŒæœŸãƒ¢ãƒ‡ãƒ«ã®å”èª¿çš„ãªæ€§è³ªã¨ã€ã“ã‚ŒãŒã©ã®ã‚ˆã†ã«ã‚³ãƒ¼ãƒ‰ã«å½±éŸ¿ã‚’ä¸ãˆã‚‹ã‹</li>
</ul>
</blockquote>
<h2 id="exercise-89"><a class="header" href="#exercise-89">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/08_futures/00_intro"><code>08_futures/00_intro</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="asynchronous-functionséåŒæœŸé–¢æ•°"><a class="header" href="#asynchronous-functionséåŒæœŸé–¢æ•°">Asynchronous functionsï¼ˆéåŒæœŸé–¢æ•°ï¼‰</a></h1>
<p>All the functions and methods you've written so far were eager.<br />
Nothing happened until you invoked them. But once you did, they ran to
completion: they did <strong>all</strong> their work, and then returned their output.</p>
<blockquote>
<p>ã“ã‚Œã¾ã§è¨˜è¿°ã—ã¦ããŸã™ã¹ã¦ã®é–¢æ•°ã¨ãƒ¡ã‚½ãƒƒãƒ‰ã¯ç†±å¿ƒã§ã—ãŸã€‚
ãã‚Œã‚‰ã‚’å‘¼ã³å‡ºã™ã¾ã§ä½•ã‚‚èµ·ã“ã‚Šã¾ã›ã‚“ã€‚ã—ã‹ã—ã€ä¸€æ—¦ã€å‘¼ã³å‡ºã™ã¨ã€ãã‚Œã‚‰ã¯å®Œäº†ã™ã‚‹ã¾ã§å®Ÿè¡Œã—ã¾ã—ãŸã€‚
ãã‚Œã‚‰ã¯ä»•äº‹ã‚’<strong>ã™ã¹ã¦</strong>è¡Œã„ã€å‡ºåŠ›ã‚’è¿”ã—ã¾ã—ãŸã€‚</p>
</blockquote>
<p>Sometimes that's undesirable.<br />
For example, if you're writing an HTTP server, there might be a lot of
<strong>waiting</strong>: waiting for the request body to arrive, waiting for the
database to respond, waiting for a downstream service to reply, etc.</p>
<blockquote>
<p>æ™‚ã€…ã€ãã‚Œã¯æœ›ã¾ã—ãã‚ã‚Šã¾ã›ã‚“ã€‚
ä¾‹ãˆã°ã€HTTPã‚µãƒ¼ãƒãƒ¼ã‚’è¨˜è¿°ã—ã¦ã„ã‚‹å ´åˆã€ãƒªã‚¯ã‚¨ã‚¹ãƒˆæœ¬ä½“ã®åˆ°ç€ã‚’å¾…ã¤ã€ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã®åå¿œã‚’å¾…ã¤ã€ä¸‹æµã‚µãƒ¼ãƒ“ã‚¹ã®å¿œç­”ã‚’å¾…ã¤ãªã©ã€å¤šãã®<strong>å¾…æ©Ÿ</strong>ãŒã‚ã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚</p>
</blockquote>
<p>What if you could do something else while you're waiting?<br />
What if you could choose to give up midway through a computation?<br />
What if you could choose to prioritise another task over the current one?</p>
<blockquote>
<p>å¾…ã£ã¦ã„ã‚‹é–“ã«ä»–ã«ãªã«ã‹ã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã¨ã—ãŸã‚‰ã©ã†ã§ã—ã‚‡ã†ã‹ï¼Ÿ
è¨ˆç®—ã®é€”ä¸­ã§è«¦ã‚ã‚‹ã“ã¨ã‚’é¸æŠã§ãã‚‹ã¨ã—ãŸã‚‰ã©ã†ã§ã—ã‚‡ã†ã‹ï¼Ÿ
ç¾åœ¨ã®ã‚¿ã‚¹ã‚¯ã‚ˆã‚Šã‚‚ä»–ã®ã‚¿ã‚¹ã‚¯ã®å„ªå…ˆã™ã‚‹ã“ã¨ã‚’é¸æŠã§ãã‚‹ã¨ã—ãŸã‚‰ã©ã†ã§ã—ã‚‡ã†ã‹ï¼Ÿ</p>
</blockquote>
<p>That's where <strong>asynchronous functions</strong> come in.</p>
<blockquote>
<p>ãã“ã§<strong>éåŒæœŸé–¢æ•°</strong>ãŒç™»å ´ã—ã¾ã™ã€‚</p>
</blockquote>
<h2 id="async-fn"><a class="header" href="#async-fn"><code>async fn</code></a></h2>
<p>You use the <code>async</code> keyword to define an asynchronous function:</p>
<blockquote>
<p>éåŒæœŸé–¢æ•°ã‚’å®šç¾©ã™ã‚‹ãŸã‚ã«<code>async</code>ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tokio::net::TcpListener;

// This function is asynchronous
// ã“ã®é–¢æ•°ã¯éåŒæœŸã§ã™ã€‚
async fn bind_random() -&gt; TcpListener {
    // [...]
}
<span class="boring">}</span></code></pre></pre>
<p>What happens if you call <code>bind_random</code> as you would a regular function?</p>
<blockquote>
<p>é€šå¸¸ã®é–¢æ•°ã®ã‚ˆã†ã«<code>bind_random</code>ã‚’å‘¼ã³å‡ºã—ãŸå ´åˆã€ä½•ãŒèµ·ã“ã‚‹ã§ã—ã‚‡ã†ã‹ï¼Ÿ</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn run() {
    // Invoke `bind_random`
    // `bind_random`ã‚’å‘¼ã³å‡ºã—ã¾ã™ã€‚
    let listener = bind_random();
    // Now what?
    // ã“ã“ã§ä½•ãŒèµ·ã“ã‚Šã¾ã™ã‹ï¼Ÿ
}
<span class="boring">}</span></code></pre></pre>
<p>Nothing happens!<br />
Rust doesn't start executing <code>bind_random</code> when you call it,
not even as a background task (as you might expect based on your experience
with other languages).
Asynchronous functions in Rust are <strong>lazy</strong>: they don't do any work until you
explicitly ask them to.
Using Rust's terminology, we say that <code>bind_random</code> returns a <strong>future</strong>, a type
that represents a computation that may complete later. They're called futures
because they implement the <code>Future</code> trait, an interface that we'll examine in
detail later on in this chapter.</p>
<blockquote>
<p>ä½•ã‚‚èµ·ã“ã‚Šã¾ã›ã‚“ï¼
Rustã¯ã€<code>bind_random</code>ã‚’å‘¼ã³å‡ºã—ãŸã¨ãã«ã€ãã‚Œã®å®Ÿè¡Œã‚’é–‹å§‹ã›ãšã€ä»–ã®è¨€èªã®çµŒé¨“ã«åŸºã¥ã„ã¦äºˆæƒ³ã—ãŸã‚ˆã†ã«ã€ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã‚¿ã‚¹ã‚¯ã¨ã—ã¦ã‚‚é–‹å§‹ã—ã¾ã›ã‚“ã€‚
Rustã«ãŠã‘ã‚‹éåŒæœŸé–¢æ•°ã¯<strong>æ€ æƒ°</strong>ã§ã™ã€‚
ãã‚Œã‚‰ã¯ã€æ˜ç¤ºçš„ã«ãã‚Œã‚‰ã«å•ã„åˆã‚ã›ã™ã‚‹ã¾ã§ã€ä½•ã®ä½œæ¥­ã‚‚è¡Œã„ã¾ã›ã‚“ã€‚
Rustã®å°‚é–€ç”¨èªã‚’ä½¿ç”¨ã—ã¦ã€<code>bind_random</code>ã¯<strong>ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ãƒ¼</strong>ã‚’è¿”ã™ã¨ã„ã„ã¾ã™ã€‚
ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ãƒ¼ã¯ã€å¾Œã§å®Œäº†ã™ã‚‹ã‹ã‚‚ã—ã‚Œãªã„è¨ˆç®—ã‚’è¡¨ç¾ã™ã‚‹æ–¹ã§ã™ã€‚
ãã‚Œã‚‰ã¯ã€<code>Future</code>ãƒˆãƒ¬ã‚¤ãƒˆã‚’å®Ÿè£…ã—ã¦ã„ã‚‹ãŸã‚ã€ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ãƒ¼ã¨å‘¼ã°ã‚Œã¾ã™ã€‚
<code>Future</code>ãƒˆãƒ¬ã‚¤ãƒˆã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ã‚¤ã‚¹ã¯ã€ã“ã®ç« ã®å¾ŒåŠã§è©³ã—ãèª¿ã¹ã‚‹äºˆå®šã§ã™ã€‚</p>
</blockquote>
<h2 id="await"><a class="header" href="#await"><code>.await</code></a></h2>
<p>The most common way to ask an asynchronous function to do some work is to use
the <code>.await</code> keyword:</p>
<blockquote>
<p>ä½•ã‚‰ã‹ã®ä»•äº‹ã‚’ã™ã‚‹ãŸã‚ã«éåŒæœŸé–¢æ•°ã«å•ã„åˆã‚ã›ã™ã‚‹æœ€ã‚‚ä¸€èˆ¬çš„ãªæ–¹æ³•ã¯ã€<code>.await</code>ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã§ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tokio::net::TcpListener;

async fn bind_random() -&gt; TcpListener {
    // [...]
}

async fn run() {
    // Invoke `bind_random` and wait for it to complete
    // `bind_random`ã‚’å‘¼ã³å‡ºã—ã€ãã‚ŒãŒå®Œäº†ã™ã‚‹ã¾ã§å¾…æ©Ÿã—ã¾ã™ã€‚
    let listener = bind_random().await;
    // Now `listener` is ready
    // ã“ã“ã§ã€`lister`ã¯æº–å‚™ã§ãã¦ã„ã¾ã™ã€‚
}
<span class="boring">}</span></code></pre></pre>
<p><code>.await</code> doesn't return control to the caller until the asynchronous function
has run to completionâ€”e.g. until the <code>TcpListener</code> has been created in the example above.</p>
<blockquote>
<p><code>.await</code>ã¯ã€éåŒæœŸé–¢æ•°ãŒå®Œäº†ã¾ã§å®Ÿè¡Œã•ã‚Œã‚‹ã¾ã§ã€å‘¼ã³å‡ºã—å´ã«åˆ¶å¾¡ã‚’è¿”ã—ã¾ã›ã‚“ã€‚
ã¤ã¾ã‚Šã€ä¸Šè¨˜ä¾‹ã«ãŠã„ã¦ã€<code>TcpListener</code>ãŒä½œæˆã•ã‚Œã‚‹ã¾ã§åˆ¶å¾¡ã‚’è¿”ã—ã¾ã›ã‚“ã€‚</p>
</blockquote>
<h2 id="runtimes"><a class="header" href="#runtimes">Runtimes</a></h2>
<p>If you're puzzled, you're right to be!<br />
We've just said that the perk of asynchronous functions
is that they don't do <strong>all</strong> their work at once. We then introduced <code>.await</code>, which
doesn't return until the asynchronous function has run to completion. Haven't we
just re-introduced the problem we were trying to solve? What's the point?</p>
<blockquote>
<p>ã‚‚ã—æˆ¸æƒ‘ã£ã¦ã„ã‚‹ãªã‚‰ã€ãã‚Œã¯å½“ç„¶ã§ã™ï¼
éåŒæœŸé–¢æ•°ã®åˆ©ç‚¹ã¯ã€ãã‚Œã‚‰ãŒä¸€åº¦ã«<strong>ã™ã¹ã¦</strong>ã®ä»•äº‹ã‚’è¡Œã‚ãªã„ã“ã¨ã ã¨è¨€ã„ã¾ã—ãŸã€‚
<code>.await</code>ã‚’å°å…¥ã—ãŸã¨ãã€ãã‚Œã¯éåŒæœŸé–¢æ•°ãŒå®Œäº†ã¾ã§å®Ÿè¡Œã•ã‚Œã‚‹ã¾ã§æˆ»ã‚Šã¾ã›ã‚“ã€‚
è§£æ±ºã—ã‚ˆã†ã¨ã—ã¦ã„ãŸå•é¡Œã‚’å†åº¦æŒã¡å‡ºã—ãŸã ã‘ã§ã—ã‚‡ã†ã‹ï¼Ÿ
ä½•ãŒãƒã‚¤ãƒ³ãƒˆãªã®ã§ã—ã‚‡ã†ã‹ï¼Ÿ</p>
</blockquote>
<p>Not quite! A lot happens behind the scenes when you call <code>.await</code>!<br />
You're yielding control to an <strong>async runtime</strong>, also known as an <strong>async executor</strong>.
Executors are where the magic happens: they are in charge of managing all your
ongoing asynchronous <strong>tasks</strong>. In particular, they balance two different goals:</p>
<ul>
<li><strong>Progress</strong>: they make sure that tasks make progress whenever they can.</li>
<li><strong>Efficiency</strong>: if a task is waiting for something, they try to make sure that
another task can run in the meantime, fully utilising the available resources.</li>
</ul>
<blockquote>
<p>å…¨ããã†ã§ã¯ã‚ã‚Šã¾ã›ã‚“ï¼<code>.await</code>ã‚’å‘¼ã³å‡ºã—ãŸã¨ãã€å¤šãã®ã“ã¨ãŒèƒŒå¾Œã§ç™ºç”Ÿã—ã¾ã™ï¼
<strong>éåŒæœŸã‚¨ã‚°ã‚¼ã‚­ãƒ¥ãƒ¼ã‚¿ãƒ¼</strong>ã¨ã—ã¦çŸ¥ã‚‰ã‚Œã‚‹ã€<strong>éåŒæœŸãƒ©ãƒ³ã‚¿ã‚¤ãƒ </strong>ã«åˆ¶å¾¡ã‚’ç§»è­²ã—ã¦ã„ã¾ã™ã€‚
ã‚¨ã‚°ã‚¼ã‚­ãƒ¥ãƒ¼ã‚¿ãƒ¼ã¯ã€ãã“ã§é­”æ³•ã‚’èµ·ã“ã—ã¾ã™ã€‚
ã‚¨ã‚°ã‚¼ã‚­ãƒ¥ãƒ¼ã‚¿ãƒ¼ã¯ã€å®Ÿè¡Œä¸­ã®éåŒæœŸã‚¿ã‚¹ã‚¯ã‚’ã™ã¹ã¦ç®¡ç†ã™ã‚‹è²¬ä»»ãŒã‚ã‚Šã¾ã™ã€‚
ç‰¹ã«ã€2ã¤ã®ç•°ãªã‚‹ç›®çš„ã®ãƒãƒ©ãƒ³ã‚¹ã‚’å–ã‚Šã¾ã™ã€‚</p>
<ul>
<li><strong>é€²æ—</strong>: ã‚¨ã‚°ã‚¼ã‚­ãƒ¥ãƒ¼ã‚¿ãƒ¼ã¯ã€ã‚¿ã‚¹ã‚¯ãŒå¯èƒ½ãªã¨ãã¯ã„ã¤ã§ã‚‚ã€ã‚¿ã‚¹ã‚¯ã‚’é€²ã‚ã¾ã™ã€‚</li>
<li><strong>åŠ¹ç‡æ€§</strong>: ã‚¿ã‚¹ã‚¯ãŒä½•ã‹ã‚’å¾…ã£ã¦ã„ã‚‹å ´åˆã€ã‚¨ã‚°ã‚¼ã‚­ãƒ¥ãƒ¼ã‚¿ãƒ¼ã¯ã€ãã®é–“ã«ä»–ã®ã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œã™ã‚‹ã“ã¨ã‚’è©¦ã¿ã¦ã€åˆ©ç”¨å¯èƒ½ãªè³‡æºã‚’ååˆ†ã«æ´»ç”¨ã—ã¾ã™ã€‚</li>
</ul>
</blockquote>
<h3 id="no-default-runtimeãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ©ãƒ³ã‚¿ã‚¤ãƒ ã¯ãªã„"><a class="header" href="#no-default-runtimeãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ©ãƒ³ã‚¿ã‚¤ãƒ ã¯ãªã„">No default runtimeï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ©ãƒ³ã‚¿ã‚¤ãƒ ã¯ãªã„ï¼‰</a></h3>
<p>Rust is fairly unique in its approach to asynchronous programing: there is
no default runtime. The standard library doesn't ship with one. You need to
bring your own!</p>
<blockquote>
<p>Rustã¯ã€éåŒæœŸãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã¸ã®ã‚¢ãƒ—ãƒ­ãƒ¼ãƒãŒã‹ãªã‚Šç‹¬ç‰¹ã§ã™ã€‚
ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ãƒ©ãƒ³ã‚¿ã‚¤ãƒ ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚
æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã¯ã€ãã‚Œã‚’ä¸€ç·’ã«æä¾›ã—ã¦ã„ã¾ã›ã‚“ã€‚
ç‹¬è‡ªã«æŒã£ã¦ãã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ï¼</p>
</blockquote>
<p>In most cases, you'll choose one of the options available in the ecosystem.
Some runtimes are designed to be broadly applicable, a solid option for most applications.
<code>tokio</code> and <code>async-std</code> belong to this category. Other runtimes are optimised for
specific use casesâ€”e.g. <code>embassy</code> for embedded systems.</p>
<blockquote>
<p>ã»ã¨ã‚“ã©ã®å ´åˆã€ã‚¨ã‚³ã‚·ã‚¹ãƒ†ãƒ ã«å­˜åœ¨ã™ã‚‹1ã¤ã‚’é¸æŠã—ã¾ã™ã€‚
ã„ãã¤ã‹ã®ãƒ©ãƒ³ã‚¿ã‚¤ãƒ ã¯ã€åºƒãé©ç”¨ã§ãã‚‹ã‚ˆã†ã«è¨­è¨ˆã•ã‚Œã¦ãŠã‚Šã€ã»ã¨ã‚“ã©ã®ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã«ã¨ã£ã¦å …å®Ÿãªé¸æŠã¨ãªã‚Šã¾ã™ã€‚
<code>tokio</code>ã¨<code>async-std</code>ã¯ã€ã“ã®ã‚«ãƒ†ã‚´ãƒªã«å±ã—ã¦ã„ã¾ã™ã€‚
ä¾‹ãˆã°ã€<code>embassy</code>ã¯çµ„ã¿è¾¼ã¿ã‚·ã‚¹ãƒ†ãƒ ç”¨ã§ã‚ã‚‹ãªã©ã€ä»–ã®ãƒ©ãƒ³ã‚¿ã‚¤ãƒ ã¯ç‰¹å®šã®ãƒ¦ãƒ¼ã‚¹ã‚±ãƒ¼ã‚¹ã®ãŸã‚ã«æœ€é©åŒ–ã•ã‚Œã¦ã„ã¾ã™ã€‚</p>
</blockquote>
<p>Throughout this course we'll rely on <code>tokio</code>, the most popular runtime for general-purpose
asynchronous programming in Rust.</p>
<blockquote>
<p>ã“ã®ã‚³ãƒ¼ã‚¹ã¯ä¸€è²«ã¨ã—ã¦<code>tokio</code>ã«ä¾å­˜ã™ã‚‹äºˆå®šã§ã€Rustã«ãŠã„ã¦ã€ãã‚Œã¯ä¸€èˆ¬çš„ãªç›®çš„ã®éåŒæœŸãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã§ã€æœ€ã‚‚äººæ°—ã®ã‚ã‚‹ãƒ©ãƒ³ã‚¿ã‚¤ãƒ ã§ã™ã€‚</p>
</blockquote>
<h3 id="tokiomain"><a class="header" href="#tokiomain"><code>#[tokio::main]</code></a></h3>
<p>The entrypoint of your executable, the <code>main</code> function, must be a synchronous function.
That's where you're supposed to set up and launch your chosen async runtime.</p>
<blockquote>
<p>å®Ÿè¡Œå½¢å¼ã®ã‚¨ãƒ³ãƒˆãƒªãƒã‚¤ãƒ³ãƒˆã¯ã€<code>main</code>é–¢æ•°ã§ã€ãã‚Œã¯éåŒæœŸé–¢æ•°ã§ãªãã¦ã¯ãªã‚Šã¾ã›ã‚“ã€‚
ãã‚Œã¯ã€é¸æŠã—ãŸéåŒæœŸãƒ©ãƒ³ã‚¿ã‚¤ãƒ ã‚’æº–å‚™ã—ã¦èµ·å‹•ã™ã‚‹ã“ã¨ã‚’æ”¯æ´ã•ã‚Œã‚‹ã¨ã“ã‚ã§ã™ã€‚</p>
</blockquote>
<blockquote>
<p>ã€Œãã‚Œã¯é¸æŠã—ãŸéåŒæœŸãƒ©ãƒ³ã‚¿ã‚¤ãƒ ãŒæº–å‚™ã—ã¦èµ·å‹•ã™ã‚‹ã“ã¨ã‚’æ”¯æ´ã—ã¾ã™ã€‚ã€ã®èª¤ã‚Šï¼Ÿ</p>
</blockquote>
<p>Most runtimes provides a macro to make this easier. For <code>tokio</code>, it's <code>tokio::main</code>:</p>
<blockquote>
<p>ã»ã¨ã‚“ã©ã®ãƒ©ãƒ³ã‚¿ã‚¤ãƒ ã¯ã€ã“ã‚Œã‚’ç°¡å˜ã«ã™ã‚‹ãƒã‚¯ãƒ­ã‚’æä¾›ã—ã¦ã„ã¾ã™ã€‚<code>tokio</code>ã®å ´åˆã€ãã‚Œã¯<code>tokio::main</code>ã§ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">#[tokio::main]
async fn main() {
    // Your async code goes here
    // éåŒæœŸã‚³ãƒ¼ãƒ‰ãŒã“ã“ã«å…¥ã‚Šã¾ã™ã€‚
}</code></pre></pre>
<p>which expands to:</p>
<blockquote>
<p>ãã‚Œã¯æ¬¡ã®ã‚ˆã†ã«å±•é–‹ã•ã‚Œã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let rt = tokio::runtime::Runtime::new().unwrap();
    rt.block_on(
        // Your async function goes here
        // [...]
    );
}</code></pre></pre>
<h3 id="tokiotest"><a class="header" href="#tokiotest"><code>#[tokio::test]</code></a></h3>
<p>The same goes for tests: they must be synchronous functions.<br />
Each test function is run in its own thread, and you're responsible for
setting up and launching an async runtime if you need to run async code
in your tests.<br />
<code>tokio</code> provides a <code>#[tokio::test]</code> macro to make this easier:</p>
<blockquote>
<p>ãƒ†ã‚¹ãƒˆã«ã¤ã„ã¦ã‚‚åŒæ§˜ã§ã™ã€‚ãã‚Œã‚‰ã¯åŒæœŸé–¢æ•°ã§ãªãã¦ã¯ãªã‚Šã¾ã›ã‚“ã€‚
ãã‚Œãã‚Œã®ãƒ†ã‚¹ãƒˆé–¢æ•°ã¯ã€ãã‚Œè‡ªèº«ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã§å®Ÿè¡Œã•ã‚Œã€ãƒ†ã‚¹ãƒˆå†…ã§éåŒæœŸã‚³ãƒ¼ãƒ‰ã‚’å®Ÿè¡Œã™ã‚‹å¿…è¦ãŒã‚ã‚‹å ´åˆã€é–‹ç™ºè€…ãŒéåŒæœŸãƒ©ãƒ³ã‚¿ã‚¤ãƒ ã‚’æº–å‚™ã—ã¦èµ·å‹•ã™ã‚‹è²¬ä»»ãŒã‚ã‚Šã¾ã™ã€‚
<code>tokio</code>ã¯ã“ã‚Œã‚’ç°¡å˜ã«ã™ã‚‹ãŸã‚ã«<code>#[tokio::test]</code>ãƒã‚¯ãƒ­ã‚’æä¾›ã—ã¦ã„ã¾ã™ã€‚</p>
</blockquote>
<blockquote>
<p>ã€Œãã‚Œã‚‰ã¯<strong>é</strong>åŒæœŸé–¢æ•°ã§ãªãã¦ã¯ãªã‚Šã¾ã›ã‚“ã€ã®èª¤ã‚Šï¼Ÿ</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn my_test() {
    // Your async test code goes here
}
<span class="boring">}</span></code></pre></pre>
<h2 id="exercise-90"><a class="header" href="#exercise-90">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/08_futures/01_async_fn"><code>08_futures/01_async_fn</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="spawning-tasksã‚¿ã‚¹ã‚¯ã‚’ç”Ÿã¿å‡ºã™"><a class="header" href="#spawning-tasksã‚¿ã‚¹ã‚¯ã‚’ç”Ÿã¿å‡ºã™">Spawning tasksï¼ˆã‚¿ã‚¹ã‚¯ã‚’ç”Ÿã¿å‡ºã™ï¼‰</a></h1>
<p>Your solution to the previous exercise should look something like this:</p>
<blockquote>
<p>å‰ã®æ¼”ç¿’ã®è§£ç­”ã¯æ¬¡ã®ã‚ˆã†ã«ãªã‚‹ã¯ãšã§ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub async fn echo(listener: TcpListener) -&gt; Result&lt;(), anyhow::Error&gt; {
    loop {
        let (mut socket, _) = listener.accept().await?;
        let (mut reader, mut writer) = socket.split();
        tokio::io::copy(&amp;mut reader, &amp;mut writer).await?;
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This is not bad!<br />
If a long time passes between two incoming connections, the <code>echo</code> function will be idle
(since <code>TcpListener::accept</code> is an asynchronous function), thus allowing the executor
to run other tasks in the meantime.</p>
<blockquote>
<p>ãã‚Œã¯æ‚ªãã‚ã‚Šã¾ã›ã‚“ï¼
2ã¤ã®ç€ä¿¡æ¥ç¶šã®é–“ã§é•·ã„æ™‚é–“ãŒçµŒéã™ã‚‹ã¨ã€<code>TcpListener::accept</code>ãŒéåŒæœŸé–¢æ•°ã§ã‚ã‚‹ãŸã‚ã€<code>echo</code>é–¢æ•°ã¯ã‚¢ã‚¤ãƒ‰ãƒ«çŠ¶æ…‹ã«ãªã‚Šã€ãã®é–“ã€ã‚¨ã‚°ã‚¼ã‚­ãƒ¥ãƒ¼ã‚¿ãƒ¼ã«ä»–ã®ã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œã•ã›ã¾ã™ã€‚</p>
</blockquote>
<p>But how can we actually have multiple tasks running concurrently?<br />
If we always run our asynchronous functions until completion (by using <code>.await</code>), we'll never
have more than one task running at a time.</p>
<blockquote>
<p>ã—ã‹ã—ã€å®Ÿéš›ã€ã©ã®ã‚ˆã†ã«è¤‡æ•°ã®ã‚¿ã‚¹ã‚¯ã‚’åŒæ™‚ä¸¦è¡Œã§å®Ÿè¡Œã™ã‚‹ã®ã§ã—ã‚‡ã†ã‹ï¼Ÿ
<code>.await</code>ã‚’ä½¿ç”¨ã—ã¦ã€å¸¸ã«å®Œäº†ã™ã‚‹ã¾ã§éåŒæœŸé–¢æ•°ã‚’å®Ÿè¡Œã—ãŸå ´åˆã€ä¸€åº¦ã«1ã¤ã®ã‚¿ã‚¹ã‚¯ã—ã‹å®Ÿè¡Œã§ãã¾ã›ã‚“ã€‚</p>
</blockquote>
<p>This is where the <code>tokio::spawn</code> function comes in.</p>
<blockquote>
<p>ã“ã‚ŒãŒã€<code>tokio::spawn</code>é–¢æ•°ãŒç™»å ´ã—ã¾ã™ã€‚</p>
</blockquote>
<h2 id="tokiospawn"><a class="header" href="#tokiospawn"><code>tokio::spawn</code></a></h2>
<p><code>tokio::spawn</code> allows you to hand off a task to the executor, <strong>without waiting for it to complete</strong>.<br />
Whenever you invoke <code>tokio::spawn</code>, you're telling <code>tokio</code> to continue running
the spawned task, in the background, <strong>concurrently</strong> with the task that spawned it.</p>
<blockquote>
<p><code>tokio::spawn</code>ã¯ã€<strong>ã‚¿ã‚¹ã‚¯ãŒå®Œäº†ã™ã‚‹ã“ã¨ã‚’å¾…ãŸãšã«</strong>ã‚¿ã‚¹ã‚¯ã‚’ã‚¨ã‚°ã‚¼ã‚­ãƒ¥ãƒ¼ã‚¿ãƒ¼ã«æ¸¡ã—ã¾ã™ã€‚
<code>tokio::spawn</code>ã‚’å‘¼ã³å‡ºã™ã¨ãã¯ã„ã¤ã§ã‚‚ã€ç”Ÿæˆã•ã‚ŒãŸã‚¿ã‚¹ã‚¯ã¨ãã®ã‚¿ã‚¹ã‚¯ã‚’ç”Ÿæˆã—ãŸã‚¿ã‚¹ã‚¯ã‚’ã€<strong>åŒæ™‚ä¸¦è¡Œ</strong>ã§ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã§å®Ÿè¡Œã‚’ç¶™ç¶šã™ã‚‹ã‚ˆã†ã«<code>tokio</code>ã«ä¼ãˆã¾ã™ã€‚</p>
</blockquote>
<p>Here's how you can use it to process multiple connections concurrently:</p>
<blockquote>
<p>è¤‡æ•°ã®æ¥ç¶šã‚’åŒæ™‚ä¸¦è¡Œã§å‡¦ç†ã™ã‚‹ãŸã‚ã«ã€ãã‚Œï¼ˆ<code>tokio::spawn</code>ï¼‰ã‚’ä½¿ç”¨ã™ã‚‹æ–¹æ³•ã‚’æ¬¡ã«ç¤ºã—ã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tokio::net::TcpListener;

pub async fn echo(listener: TcpListener) -&gt; Result&lt;(), anyhow::Error&gt; {
    loop {
        // `listener.accept().await?`ã«ã‚ˆã‚Šã€`echo`é–¢æ•°ã¯æ–°ã—ã„æ¥ç¶šã‚’å—ã‘ä»˜ã‘ã‚‹ã¾ã§ã€ã“ã“ã§å¾…æ©Ÿã™ã‚‹ã€‚
        // ã‚ˆã£ã¦ã€ã“ã®`loop`ã¯ã€æ–°ã—ã„æ¥ç¶šãŒåˆ°ç€ã™ã‚‹ãŸã³ã«å†é–‹ã•ã‚Œã‚‹ã€‚
        // ãƒªã‚¹ãƒŠãƒ¼ã®æ¥ç¶šãŒåˆ‡ã‚ŒãŸå ´åˆã€`listener.accept().await?`ã¯ã‚¨ãƒ©ãƒ¼ã‚’è¿”ã™ãŸã‚ã€`echo`é–¢æ•°ã¯çµ‚äº†ã™ã‚‹ã€‚
        let (mut socket, _) = listener.accept().await?;
        // Spawn a background task to handle the connection
        // thus allowing the main task to immediately start
        // accepting new connections
        // ãƒ¡ã‚¤ãƒ³ã‚¿ã‚¹ã‚¯ã«ã™ãã«æ–°ã—ã„æ¥ç¶šã®å—ä»˜ã‚’é–‹å§‹ã•ã›ã‚‹ãŸã‚ã«ã€æ¥ç¶šã‚’å‡¦ç†ã™ã‚‹ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã‚¿ã‚¹ã‚¯ã‚’ç”Ÿã¿å‡ºã—ã¾ã™ã€‚
        tokio::spawn(async move {
            let (mut reader, mut writer) = socket.split();
            tokio::io::copy(&amp;mut reader, &amp;mut writer).await?;
        });
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="asynchronous-blockséåŒæœŸãƒ–ãƒ­ãƒƒã‚¯"><a class="header" href="#asynchronous-blockséåŒæœŸãƒ–ãƒ­ãƒƒã‚¯">Asynchronous blocksï¼ˆéåŒæœŸãƒ–ãƒ­ãƒƒã‚¯ï¼‰</a></h3>
<p>In this example, we've passed an <strong>asynchronous block</strong> to <code>tokio::spawn</code>: <code>async move { /* */ }</code>
Asynchronous blocks are a quick way to mark a region of code as asynchronous without having
to define a separate async function.</p>
<blockquote>
<p>ã“ã®ä¾‹ã«ãŠã„ã¦ã€<code>tokio::spawn</code>ã«<code>async move { /* */ }</code>ã®<strong>éåŒæœŸãƒ–ãƒ­ãƒƒã‚¯</strong>ã‚’æ¸¡ã—ã¾ã—ãŸã€‚
éåŒæœŸãƒ–ãƒ­ãƒƒã‚¯ã¯ã€åˆ†é›¢ã—ãŸéåŒæœŸé–¢æ•°ã‚’å®šç¾©ã™ã‚‹å¿…è¦ãªãã€éåŒæœŸã¨ã—ã¦ã‚³ãƒ¼ãƒ‰é ˜åŸŸã‚’ãƒãƒ¼ã‚¯ã™ã‚‹ç°¡å˜ãªæ–¹æ³•ã§ã™ã€‚</p>
</blockquote>
<h3 id="joinhandle"><a class="header" href="#joinhandle"><code>JoinHandle</code></a></h3>
<p><code>tokio::spawn</code> returns a <code>JoinHandle</code>.<br />
You can use <code>JoinHandle</code> to <code>.await</code> the background task, in the same way
we used <code>join</code> for spawned threads.</p>
<blockquote>
<p><code>tokio::spawn</code>ã¯<code>JoinHandle</code>ã‚’è¿”ã—ã¾ã™ã€‚
ç”Ÿã¿å‡ºã—ãŸã‚¹ãƒ¬ãƒƒãƒ‰ã«å¯¾ã—ã¦<code>join</code>ã‚’ä½¿ç”¨ã—ãŸåŒã˜æ–¹æ³•ã§ã€ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã‚¿ã‚¹ã‚¯ã‚’<code>.await</code>ã™ã‚‹ãŸã‚ã«<code>JoinHandle</code>ã‚’ä½¿ç”¨ã§ãã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// æ¸¬å®šãƒ‡ãƒ¼ã‚¿ã‚’ãƒªãƒ¢ãƒ¼ãƒˆã‚µãƒ¼ãƒãƒ¼ã«é‹æ¬ã—ã¦ã€ãã®é–“ã«ã€è‡ªåˆ†ã®ä»–ã®ä»•äº‹ã‚’ã™ã‚‹ã€‚
// è‡ªåˆ†ã®ä»–ã®ä»•äº‹ãŒå®Œäº†ã—ãŸã‚‰ã€ãƒªãƒ¢ãƒ¼ãƒˆã‚µãƒ¼ãƒãƒ¼ã«æ¸¬å®šãƒ‡ãƒ¼ã‚¿ãŒé‹æ¬ã•ã‚Œã‚‹ã¾ã§å¾…æ©Ÿã™ã‚‹ã€‚
pub async fn run() {
    // Spawn a background task to ship telemetry data
    // to a remote server
    // æ¸¬å®šãƒ‡ãƒ¼ã‚¿ã‚’ãƒªãƒ¢ãƒ¼ãƒˆã‚µãƒ¼ãƒãƒ¼ã«é‹æ¬ã™ã‚‹ãŸã‚ã«ã€ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã‚¿ã‚¹ã‚¯ã‚’ç”Ÿã¿å‡ºã—ã¾ã™ã€‚
    let handle = tokio::spawn(emit_telemetry());
    // In the meantime, do some other useful work
    // ãã®é–“ã€ä»»æ„ã®ä»–ã®æœ‰ç›Šãªä»•äº‹ã‚’ã—ã¾ã™ã€‚
    do_work().await;
    // But don't return to the caller until
    // the telemetry data has been successfully delivered
    // ã—ã‹ã—ã€æ¸¬å®šãƒ‡ãƒ¼ã‚¿ãŒæˆåŠŸè£ã«é…é€ã•ã‚Œã‚‹ã¾ã§ã€å‘¼ã³å‡ºã—å´ã«æˆ»ã‚‰ãªã„ã§ãã ã•ã„ã€‚
    handle.await;
}

pub async fn emit_telemetry() {
    // [...]
}

pub async fn do_work() {
    // [...]
}
<span class="boring">}</span></code></pre></pre>
<h3 id="panic-boundaryãƒ‘ãƒ‹ãƒƒã‚¯å¢ƒç•Œ"><a class="header" href="#panic-boundaryãƒ‘ãƒ‹ãƒƒã‚¯å¢ƒç•Œ">Panic boundaryï¼ˆãƒ‘ãƒ‹ãƒƒã‚¯å¢ƒç•Œï¼‰</a></h3>
<p>If a task spawned with <code>tokio::spawn</code> panics, the panic will be caught by the executor.<br />
If you don't <code>.await</code> the corresponding <code>JoinHandle</code>, the panic won't be propagated to the spawner.
Even if you do <code>.await</code> the <code>JoinHandle</code>, the panic won't be propagated automatically.
Awaiting a <code>JoinHandle</code> returns a <code>Result</code>, with <a href="https://docs.rs/tokio/latest/tokio/task/struct.JoinError.html"><code>JoinError</code></a>
as its error type. You can then check if the task panicked by calling <code>JoinError::is_panic</code> and
choose what to do with the panicâ€”either log it, ignore it, or propagate it.</p>
<blockquote>
<p><code>tokio::spawn</code>ã§ç”Ÿã¿å‡ºã•ã‚ŒãŸã‚¿ã‚¹ã‚¯ãŒãƒ‘ãƒ‹ãƒƒã‚¯ã—ãŸå ´åˆã€ãã®ãƒ‘ãƒ‹ãƒƒã‚¯ã¯ã‚¨ã‚°ã‚¼ã‚­ãƒ¥ãƒ¼ã‚¿ãƒ¼ã«ã‚ˆã£ã¦å—ã‘å–ã‚‰ã‚Œã¾ã™ã€‚
å¯¾å¿œã™ã‚‹<code>JoinHandle</code>ã‚’<code>.await</code>ã—ãªã„å ´åˆã€ãã®ãƒ‘ãƒ‹ãƒƒã‚¯ã¯ï¼ˆã‚¿ã‚¹ã‚¯ã®ï¼‰ç”Ÿã¿å‡ºã—å…ƒã«ã¯ä¼æ’­ã—ã¾ã›ã‚“ã€‚
<code>JoinHandle</code>ã‚’<code>.await</code>ã—ãŸã¨ã—ã¦ã‚‚ã€ãã®ãƒ‘ãƒ‹ãƒƒã‚¯ã¯è‡ªå‹•çš„ã«ä¼æ’­ã—ã¾ã›ã‚“ã€‚
<code>JoinHandle</code>ã‚’<code>.await</code>ã™ã‚‹ã¨ã€ãã®ã‚¨ãƒ©ãƒ¼å‹ã¨ã—ã¦<code>JoinError</code>ã‚’æŒã¤<code>Result</code>ãŒè¿”ã•ã‚Œã¾ã™ã€‚
ãã—ã¦ã€<code>JoinError::is_panic</code>ã‚’å‘¼ã³å‡ºã™ã“ã¨ã§ã€ã‚¿ã‚¹ã‚¯ãŒãƒ‘ãƒ‹ãƒƒã‚¯ã—ãŸã‹ç¢ºèªã—ã¦ã€ãã‚Œã‚’ãƒ­ã‚°ã«è¨˜éŒ²ã™ã‚‹ã‹ã€ã¾ãŸã¯ãã‚Œã‚’ä¼æ’­ã™ã‚‹ã‹ã€ãƒ‘ãƒ‹ãƒƒã‚¯ã«å¯¾ã—ã¦è¡Œã†ã“ã¨ã‚’é¸æŠã§ãã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tokio::task::JoinError;

pub async fn run() {
    let handle = tokio::spawn(work());
    if let Err(e) = handle.await {
        if let Ok(reason) = e.try_into_panic() {
            // The task has panicked
            // We resume unwinding the panic,
            // thus propagating it to the current task
            // ã‚¿ã‚¹ã‚¯ãŒãƒ‘ãƒ‹ãƒƒã‚¯ã—ã¾ã—ãŸã€‚
            // ãƒ‘ãƒ‹ãƒƒã‚¯ã®å·»ãæˆ»ã—ã‚’å†é–‹ã—ã¦ã€ç¾åœ¨ã®ã‚¿ã‚¹ã‚¯ã«ãƒ‘ãƒ‹ãƒƒã‚¯ã‚’ä¼æ’­ã—ã¦ã„ã¾ã™ã€‚
            panic::resume_unwind(reason);
        }
    }
}

pub async fn work() {
    // [...]
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p><code>panic</code>ã‚’<code>unwind</code>ã™ã‚‹ã¨ã¯ã€<code>panic</code>ãŒç™ºç”Ÿã—ãŸã‚¹ãƒ¬ãƒƒãƒ‰ã®ã‚¹ã‚¿ãƒƒã‚¯ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’å·»ãæˆ»ã—ã¦ã€ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ã‚³ãƒ¼ãƒ‰ã‚’å®Ÿè¡Œã—ã¦ã€ãƒªã‚½ãƒ¼ã‚¹ã‚’é©åˆ‡ã«è§£æ”¾ã™ã‚‹å‡¦ç†ã‚’ç¤ºã™ã€‚</p>
</blockquote>
<h3 id="stdthreadspawn-vs-tokiospawnstdthreadspawnã¨tokiospawn"><a class="header" href="#stdthreadspawn-vs-tokiospawnstdthreadspawnã¨tokiospawn"><code>std::thread::spawn</code> vs <code>tokio::spawn</code>ï¼ˆstd::thread::spawnã¨tokio::spawnï¼‰</a></h3>
<p>You can think of <code>tokio::spawn</code> as the asynchronous sibling of <code>std::thread::spawn</code>.</p>
<blockquote>
<p><code>tokio::spawn</code>ã‚’<code>std::thread::spawn</code>ã®éåŒæœŸã®å…„å¼Ÿã¨è€ƒãˆã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚</p>
</blockquote>
<p>Notice a key difference: with <code>std::thread::spawn</code>, you're delegating control to the OS scheduler.
You're not in control of how threads are scheduled.</p>
<blockquote>
<p>é‡è¦ãªé•ã„ã«æ³¨æ„ã—ã¦ãã ã•ã„: <code>std::thread::spawn</code>ã‚’ä½¿ç”¨ã™ã‚‹ã¨ã€OSã®ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ©ãƒ¼ã«åˆ¶å¾¡ã‚’ç§»è­²ã—ã¾ã™ã€‚
ã‚¹ãƒ¬ãƒƒãƒ‰ãŒã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã•ã‚Œã‚‹æ–¹æ³•ã‚’åˆ¶å¾¡ã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚</p>
</blockquote>
<p>With <code>tokio::spawn</code>, you're delegating to an async executor that runs entirely in
user space. The underlying OS scheduler is not involved in the decision of which task
to run next. We're in charge of that decision now, via the executor we chose to use.</p>
<blockquote>
<p><code>tokio::spawn</code>ã‚’ä½¿ç”¨ã™ã‚‹ã¨ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ç©ºé–“ã§å…¨ä½“ã‚’å®Ÿè¡Œã™ã‚‹éåŒæœŸã‚¨ã‚°ã‚¼ã‚­ãƒ¥ãƒ¼ã‚¿ãƒ¼ã«ï¼ˆåˆ¶å¾¡ã‚’ï¼‰ç§»è­²ã—ã¾ã™ã€‚
åŸºç›¤ã¨ãªã‚‹OSã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ©ãƒ¼ã¯ã€æ¬¡ã«å®Ÿè¡Œã™ã‚‹ã‚¿ã‚¹ã‚¯ã®æ±ºå®šã«é–¢ä¸ã—ã¾ã›ã‚“ã€‚
ç¾åœ¨ã€ãã®æ±ºå®šã®è²¬ä»»ã¯ã€ä½¿ç”¨ã™ã‚‹ã“ã¨ã‚’é¸æŠã—ãŸã‚¨ã‚°ã‚¼ã‚­ãƒ¥ãƒ¼ã‚¿ãƒ¼ã‚’ä»‹ã—ã¦ã€é–‹ç™ºè€…ã«ã‚ã‚Šã¾ã™ã€‚</p>
</blockquote>
<h2 id="exercise-91"><a class="header" href="#exercise-91">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/08_futures/02_spawn"><code>08_futures/02_spawn</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="runtime-architectureãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ãƒ¼"><a class="header" href="#runtime-architectureãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ãƒ¼">Runtime architectureï¼ˆãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ãƒ¼ï¼‰</a></h1>
<p>So far we've been talking about async runtimes as an abstract concept.
Let's dig a bit deeper into the way they are implementedâ€”as you'll see soon enough,
it has an impact on our code.</p>
<blockquote>
<p>ã“ã‚Œã¾ã§ã€éåŒæœŸãƒ©ãƒ³ã‚¿ã‚¤ãƒ ã«ã¤ã„ã¦æŠ½è±¡åŒ–æ¦‚å¿µã¨ã—ã¦è©±ã—ã¦ãã¾ã—ãŸã€‚
ãã‚Œã‚‰ãŒå®Ÿè£…ã•ã‚ŒãŸæ–¹æ³•ã‚’å°‘ã—æ·±å €ã‚Šã—ã¾ã—ã‚‡ã†ã€‚ã™ãã«ååˆ†ç†è§£ã§ãã‚‹ã‚ˆã†ã«ã€ãã‚Œã¯ã‚³ãƒ¼ãƒ‰ã«å½±éŸ¿ã‚’ä¸ãˆã¾ã™ã€‚</p>
</blockquote>
<h2 id="flavorsé¢¨å‘³ã¥ã‘"><a class="header" href="#flavorsé¢¨å‘³ã¥ã‘">Flavorsï¼ˆé¢¨å‘³ã¥ã‘ï¼‰</a></h2>
<p><code>tokio</code> ships two different runtime <em>flavors</em>.</p>
<blockquote>
<p><code>tokio</code>ã¯2ã¤ã®ç•°ãªã‚‹ãƒ©ãƒ³ã‚¿ã‚¤ãƒ  <em>ãƒ•ãƒ¬ãƒ¼ãƒãƒ¼</em> ã‚’æä¾›ã—ã¦ã„ã¾ã™ã€‚</p>
</blockquote>
<p>You can configure your runtime via <code>tokio::runtime::Builder</code>:</p>
<ul>
<li><code>Builder::new_multi_thread</code> gives you a <strong>multithreaded <code>tokio</code> runtime</strong></li>
<li><code>Builder::new_current_thread</code> will instead rely on the <strong>current thread</strong> for execution.</li>
</ul>
<blockquote>
<p><code>tokio::runtime::Builder</code>ã‚’ä»‹ã—ã¦ãƒ©ãƒ³ã‚¿ã‚¤ãƒ ã‚’æ§‹æˆã§ãã¾ã™ã€‚</p>
<ul>
<li><code>Builder::new_multi_thread</code>ã¯ã€<strong>ãƒãƒ«ãƒã‚¹ãƒ¬ãƒƒãƒ‰ãª<code>tokio</code>ãƒ©ãƒ³ã‚¿ã‚¤ãƒ </strong>ã‚’æä¾›ã—ã¾ã™ã€‚</li>
<li><code>Builder::new_current_thread</code>ã¯ã€ä»£ã‚ã‚Šã«<strong>ç¾åœ¨ã®ã‚¹ãƒ¬ãƒƒãƒ‰</strong>ã«ä¾å­˜ã—ã¦å®Ÿè¡Œã•ã‚Œã¾ã™ã€‚</li>
</ul>
</blockquote>
<p><code>#[tokio::main]</code> returns a multithreaded runtime by default, while
<code>#[tokio::test]</code> uses a current thread runtime out of the box.</p>
<blockquote>
<p><code>#[tokio::main]</code>ã¯ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ãƒãƒ«ãƒã‚¹ãƒ¬ãƒƒãƒ‰ãªãƒ©ãƒ³ã‚¿ã‚¤ãƒ ã‚’è¿”ã™ä¸€æ–¹ã§ã€<code>#[tokio::test]</code>ã¯ç¾åœ¨ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚</p>
</blockquote>
<h3 id="current-thread-runtimeã‚«ãƒ¬ãƒ³ãƒˆã‚¹ãƒ¬ãƒƒãƒ‰ãƒ©ãƒ³ã‚¿ã‚¤ãƒ "><a class="header" href="#current-thread-runtimeã‚«ãƒ¬ãƒ³ãƒˆã‚¹ãƒ¬ãƒƒãƒ‰ãƒ©ãƒ³ã‚¿ã‚¤ãƒ ">Current thread runtimeï¼ˆã‚«ãƒ¬ãƒ³ãƒˆã‚¹ãƒ¬ãƒƒãƒ‰ãƒ©ãƒ³ã‚¿ã‚¤ãƒ ï¼‰</a></h3>
<p>The current-thread runtime, as the name implies, relies exclusively on the OS thread
it was launched on to schedule and execute tasks.<br />
When using the current-thread runtime, you have <strong>concurrency</strong> but no <strong>parallelism</strong>:
asynchronous tasks will be interleaved, but there will always be at most one task running
at any given time.</p>
<blockquote>
<p>åå‰ãŒæš—ã«æ„å‘³ã™ã‚‹é€šã‚Šã€ã‚«ãƒ¬ãƒ³ãƒˆã‚¹ãƒ¬ãƒƒãƒ‰ãƒ©ãƒ³ã‚¿ã‚¤ãƒ ã¯ã€ã‚¿ã‚¹ã‚¯ã‚’ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã—ã¦å®Ÿè¡Œã™ã‚‹ãŸã‚ã«èµ·å‹•ã•ã‚Œã‚‹OSã‚¹ãƒ¬ãƒƒãƒ‰ã®ã¿ã«ä¾å­˜ã—ã¾ã™ã€‚
ã‚«ãƒ¬ãƒ³ãƒˆã‚¹ãƒ¬ãƒƒãƒ‰ãƒ©ãƒ³ã‚¿ã‚¤ãƒ ã‚’ä½¿ç”¨ã—ãŸã¨ãã€<strong>åŒæ™‚ä¸¦è¡Œæ€§</strong>ã‚’å¾—ã‚‰ã‚Œã¾ã™ãŒã€<strong>ä¸¦åˆ—æ€§</strong>ã¯å¾—ã‚‰ã‚Œã¾ã›ã‚“ã€‚
éåŒæœŸã‚¿ã‚¹ã‚¯ã¯ã€é–“ã‚’ãŠã„ã¦äº¤äº’ã«å®Ÿè¡Œã•ã‚Œã¾ã™ãŒã€å¸¸ã«ç‰¹å®šã®æ™‚é–“ã«æœ€å¤§1ã¤ã®ã‚¿ã‚¹ã‚¯ã—ãŒå®Ÿè¡Œã—ã¦ã„ã¾ã›ã‚“ã€‚</p>
</blockquote>
<h3 id="multithreaded-runtimeãƒãƒ«ãƒã‚¹ãƒ¬ãƒƒãƒ‰ãƒ©ãƒ³ã‚¿ã‚¤ãƒ "><a class="header" href="#multithreaded-runtimeãƒãƒ«ãƒã‚¹ãƒ¬ãƒƒãƒ‰ãƒ©ãƒ³ã‚¿ã‚¤ãƒ ">Multithreaded runtimeï¼ˆãƒãƒ«ãƒã‚¹ãƒ¬ãƒƒãƒ‰ãƒ©ãƒ³ã‚¿ã‚¤ãƒ ï¼‰</a></h3>
<p>When using the multithreaded runtime, instead, there can up to <code>N</code> tasks running
<em>in parallel</em> at any given time, where <code>N</code> is the number of threads used by the
runtime. By default, <code>N</code> matches the number of available CPU cores.</p>
<blockquote>
<p>ãƒãƒ«ãƒã‚¹ãƒ¬ãƒƒãƒ‰ãƒ©ãƒ³ã‚¿ã‚¤ãƒ ã‚’ä½¿ç”¨ã—ãŸã¨ãã€ç‰¹å®šã®æ™‚é–“ã« <em>ä¸¦åˆ—ã§</em> æœ€å¤§<code>N</code>å€‹ã¾ã§ã®ã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œã§ãã€<code>N</code>ã¯ãƒ©ãƒ³ã‚¿ã‚¤ãƒ ã§ä½¿ç”¨ã•ã‚Œã‚‹ã‚¹ãƒ¬ãƒƒãƒ‰ã®æ•°ã§ã™ã€‚
ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã€<code>N</code>ã¯åˆ©ç”¨å¯èƒ½ãªCPUã‚³ã‚¢ã®æ•°ã«ä¸€è‡´ã—ã¾ã™ã€‚</p>
</blockquote>
<p>There's more: <code>tokio</code> performs <strong>work-stealing</strong>.<br />
If a thread is idle, it won't wait around: it'll try to find a new task that's ready for
execution, either from a global queue or by stealing it from the local queue of another
thread.<br />
Work-stealing can have significant performance benefits, especially on tail latencies,
whenever your application is dealing with workloads that are not perfectly balanced
across threads.</p>
<blockquote>
<p>ã¾ã ã‚ã‚Šã¾ã™ã€‚<code>tokio</code>ã¯<strong>ãƒ¯ãƒ¼ã‚¯ã‚¹ãƒãƒ¼ãƒªãƒ³ã‚°</strong>ã‚’è¡Œã„ã¾ã™ã€‚
ã‚¹ãƒ¬ãƒƒãƒ‰ãŒã‚¢ã‚¤ãƒ‰ãƒ«çŠ¶æ…‹ã«ãªã£ãŸå ´åˆã€ãã‚Œï¼ˆ<code>tokio</code>ï¼‰ã¯å¾…æ©Ÿã—ã¾ã›ã‚“ã€‚
ãã‚Œï¼ˆ<code>tokio</code>ï¼‰ã¯ã€ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚­ãƒ¥ãƒ¼ã¾ãŸã¯ä»–ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã®ãƒ­ãƒ¼ã‚«ãƒ«ã‚­ãƒ¥ãƒ¼ã‹ã‚‰ç›—ã‚€ã“ã¨ã§ã€å®Ÿè¡Œã®æº–å‚™ãŒã§ãã¦ã„ã‚‹æ–°ã—ã„ã‚¿ã‚¹ã‚¯ã‚’è¦‹ã¤ã‘ã‚‹ã“ã¨ã‚’è©¦ã¿ã¾ã™ã€‚
ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãŒã€ã‚¹ãƒ¬ãƒƒãƒ‰é–“ã§å®Œå…¨ã«ãƒãƒ©ãƒ³ã‚¹ãŒå–ã‚Œã¦ã„ãªã„ãƒ¯ãƒ¼ã‚¯ãƒ­ãƒ¼ãƒ‰ã‚’å‡¦ç†ã—ã¦ã„ã‚‹ã¨ãã¯ã„ã¤ã§ã‚‚ã€ãƒ¯ãƒ¼ã‚¯ã‚¹ãƒãƒ¼ãƒªãƒ³ã‚°ã¯ã€ç‰¹ã«ãƒ†ãƒ¼ãƒ«ãƒ¬ã‚¤ãƒ†ãƒ³ã‚·ãƒ¼ã«å¯¾ã—ã¦ã€å¤§ããªæ€§èƒ½ã®åˆ©ç‚¹ã‚’ã‚‚ãŸã‚‰ã™å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚</p>
</blockquote>
<blockquote>
<p>ãƒ†ãƒ¼ãƒ«ãƒ¬ã‚¤ãƒ†ãƒ³ã‚·ãƒ¼ï¼ˆ<code>tail latency</code>ï¼‰ã¨ã¯ã€ã‚·ã‚¹ãƒ†ãƒ ã«ãŠã„ã¦æœ€ã‚‚é…ã„ãƒªã‚¯ã‚¨ã‚¹ãƒˆã®å¿œç­”æ™‚é–“ã‚’æŒ‡ã™ã€‚
å…·ä½“çš„ã«ã¯ã€å¿œç­”æ™‚é–“ã®åˆ†å¸ƒã«ãŠã‘ã‚‹ä¸Šä½ã®ãƒ‘ãƒ¼ã‚»ãƒ³ã‚¿ã‚¤ãƒ«ã€ä¾‹ãˆã°95ãƒ‘ãƒ¼ã‚»ãƒ³ã‚¿ã‚¤ãƒ«ã‚„99ãƒ‘ãƒ¼ã‚»ãƒ³ã‚¿ã‚¤ãƒ«ã®å¿œç­”æ™‚é–“ã‚’ç¤ºã™ã€‚
å¿œç­”æ™‚é–“ã®é•·ã„ã‚¿ã‚¹ã‚¯ãŒã‚ã‚‹å ´åˆã€ãã®é•·ã„ã‚¿ã‚¹ã‚¯ãŒã‚¢ã‚¤ãƒ‰ãƒ«çŠ¶æ…‹ã«ãªã£ãŸã¨ãã«ã€ä»–ã®ã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œã™ã‚‹ã“ã¨ã§ã€å…¨ä½“ã®å¿œç­”æ™‚é–“ã‚’çŸ­ãã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚</p>
</blockquote>
<h2 id="implicationsé–¢é€£äº‹é …"><a class="header" href="#implicationsé–¢é€£äº‹é …">Implicationsï¼ˆé–¢é€£äº‹é …ï¼‰</a></h2>
<p><code>tokio::spawn</code> is flavor-agnostic: it'll work no matter if you're running on the multithreaded
or current-thread runtime. The downside is that the signature assume the worst case
(i.e. multithreaded) and is constrained accordingly:</p>
<blockquote>
<p><code>tokio::spawn</code>ã¯ãƒ•ãƒ¬ãƒ¼ãƒãƒ¼ã«ä¾å­˜ã—ã¾ã›ã‚“ã€‚
ãã‚Œã¯ã€ãƒãƒ«ãƒã‚¹ãƒ¬ãƒƒãƒ‰ã¾ãŸã¯ã‚«ãƒ¬ãƒ³ãƒˆã‚¹ãƒ¬ãƒƒãƒ‰ãƒ©ãƒ³ã‚¿ã‚¤ãƒ ã§å®Ÿè¡Œã•ã‚Œã¦ã„ã‚‹ã‹ã©ã†ã‹ã«é–¢ã‚ã‚‰ãšæ©Ÿèƒ½ã—ã¾ã™ã€‚
ãã®æ¬ ç‚¹ã¯ã€ã‚·ã‚°ãƒãƒãƒ£ãƒ¼ãŒæœ€æ‚ªã®ã‚±ãƒ¼ã‚¹ï¼ˆã¤ã¾ã‚Šãƒãƒ«ãƒã‚¹ãƒ¬ãƒƒãƒ‰ï¼‰ã‚’ä»®å®šã—ã¦ã€ãã‚Œã«å¿œã˜ã¦åˆ¶ç´„ã•ã‚Œã‚‹ã“ã¨ã§ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn spawn&lt;F&gt;(future: F) -&gt; JoinHandle&lt;F::Output&gt;
where
    F: Future + Send + 'static,
    F::Output: Send + 'static,
{ /* */ }
<span class="boring">}</span></code></pre></pre>
<p>Let's ignore the <code>Future</code> trait for now to focus on the rest.<br />
<code>spawn</code> is asking all its inputs to be <code>Send</code> and have a <code>'static</code> lifetime.</p>
<blockquote>
<p>ç¾æ™‚ç‚¹ã§ã¯ã€<code>Future</code>ãƒˆãƒ¬ã‚¤ãƒˆã‚’ç„¡è¦–ã—ã¦ã€æ®‹ã‚Šã«ç„¦ç‚¹ã‚’å½“ã¦ã¾ã—ã‚‡ã†ã€‚
<code>spawn</code>ã¯ã€ãã®å…¥åŠ›ã«å¯¾ã—ã¦ã€<code>Send</code>ã§ã‚ã‚Šã€<code>'static</code>ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ã‚’æŒã¤ã“ã¨ã‚’è¦æ±‚ã—ã¦ã„ã¾ã™ã€‚</p>
</blockquote>
<p>The <code>'static</code> constraint follows the same rationale of the <code>'static</code> constraint
on <code>std::thread::spawn</code>: the spawned task may outlive the context it was spawned
from, therefore it shouldn't depend on any local data that may be de-allocated
after the spawning context is destroyed.</p>
<blockquote>
<p><code>'static</code>åˆ¶ç´„ã¯ã€<code>std::thread::spawn</code>ã®<code>'static</code>åˆ¶ç´„ã¨åŒã˜è«–ç†çš„æ ¹æ‹ ã«å¾“ã£ã¦ã„ã¾ã™ã€‚
ç”Ÿã¿å‡ºã•ã‚ŒãŸã‚¿ã‚¹ã‚¯ã¯ã€ãã‚ŒãŒç”Ÿã¿å‡ºã•ã‚ŒãŸã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚ˆã‚Šã‚‚é•·ç”Ÿãã™ã‚‹ã‹ã‚‚ã—ã‚Œãšã€ãã®ãŸã‚ã€ãã‚Œã¯ç”Ÿã¿å‡ºã—ãŸã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãŒç ´å£Šã•ã‚ŒãŸå¾Œã§ã€è§£æ”¾ã•ã‚Œã¦ã—ã¾ã†ã‹ã‚‚ã—ã‚Œãªã„ä»»æ„ã®ãƒ­ãƒ¼ã‚«ãƒ«ãƒ‡ãƒ¼ã‚¿ã«ä¾å­˜ã™ã‚‹ã¹ãã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn spawner() {
    let v = vec![1, 2, 3];
    // This won't work, since `&amp;v` doesn't
    // live long enough.
    // `&amp;v`ã¯ååˆ†ã«é•·ç”Ÿãã—ãªã„ãŸã‚ã€ã“ã‚Œã¯æ©Ÿèƒ½ã—ã¾ã›ã‚“ã€‚
    tokio::spawn(async {
        for x in &amp;v {
            println!("{x}")
        }
    })
    // `spawn`ã—ãŸã‚¿ã‚¹ã‚¯ãŒçµ‚äº†ã™ã‚‹å‰ã«ã€`spawner`é–¢æ•°ãŒçµ‚äº†ã—ã¦ã€
    // `v`ãŒè§£æ”¾ã•ã‚Œã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹ãŸã‚ã€Rustã¯ã“ã®ã‚³ãƒ¼ãƒ‰ã‚’ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã›ãªã„ã€‚
}
<span class="boring">}</span></code></pre></pre>
<p><code>Send</code>, on the other hand, is a direct consequence of <code>tokio</code>'s work-stealing strategy:
a task that was spawned on thread <code>A</code> may end up being moved to thread <code>B</code> if that's idle,
thus requiring a <code>Send</code> bound since we're crossing thread boundaries.</p>
<blockquote>
<p>ä¸€æ–¹ã€<code>Send</code>ã¯<code>tokio</code>ã®ãƒ¯ãƒ¼ã‚¯ã‚¹ãƒãƒ¼ãƒ«æˆ¦ç•¥ã®ç›´æ¥ãªçµæœã§ã™ã€‚
ã‚¹ãƒ¬ãƒƒãƒ‰<code>A</code>ã§ç”Ÿã¿å‡ºã•ã‚ŒãŸã‚¿ã‚¹ã‚¯ã¯ã€ãã‚ŒãŒã‚¢ã‚¤ãƒ‰ãƒ«çŠ¶æ…‹ã«ãªã£ãŸå ´åˆã€æœ€çµ‚çš„ã«ã‚¹ãƒ¬ãƒƒãƒ‰<code>B</code>ã«ãƒ ãƒ¼ãƒ–ã•ã‚Œã‚‹ã‹ã‚‚ã—ã‚Œãšã€ãã®ãŸã‚ã‚¹ãƒ¬ãƒƒãƒ‰å¢ƒç•Œã‚’è¶…ãˆã‚‹ãŸã‚ã«<code>Send</code>å¢ƒç•ŒãŒè¦æ±‚ã•ã‚Œã¾ã™ã€‚</p>
</blockquote>
<blockquote>
<p>ã‚¹ãƒ¬ãƒƒãƒ‰<code>A</code>ãŒç”Ÿã¿å‡ºã•ã‚ŒãŸã‚¿ã‚¹ã‚¯ãŒã€IOå¾…ã¡ãªã©ã§ãƒ–ãƒ­ãƒƒã‚¯ã•ã‚ŒãŸå ´åˆã€ãã®ã‚¿ã‚¹ã‚¯ã¯ã‚­ãƒ¥ãƒ¼ã«é…ç½®ã•ã‚Œã‚‹ã€‚
ã‚¹ãƒ¬ãƒƒãƒ‰<code>A</code>ãŒä»–ã®ã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œã—ã¦ã„ã‚‹é–“ã€ã‚­ãƒ¥ãƒ¼ã«å…¥ã£ãŸã‚¿ã‚¹ã‚¯ãŒè¦æ±‚ã—ãŸIOå‡¦ç†ãŒå®Œäº†ã—ã¦ã€ã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œã§ãã‚‹çŠ¶æ…‹ã«ãªã‚‹ã€‚
ã“ã®ã¨ãã€ã‚¹ãƒ¬ãƒƒãƒ‰<code>A</code>ãŒã¾ã ä»–ã®ã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œã—ã¦ã„ã¦ã€ã‚¹ãƒ¬ãƒƒãƒ‰<code>B</code>ãŒå®Ÿè¡Œã—ã¦ã„ãŸã‚¿ã‚¹ã‚¯ãŒãƒ–ãƒ­ãƒƒã‚¯ã¾ãŸã¯çµ‚äº†ã—ãŸå ´åˆã€
ã‚¹ãƒ¬ãƒƒãƒ‰<code>B</code>ã¯ã€ã‚¹ãƒ¬ãƒƒãƒ‰<code>A</code>ã®ã‚­ãƒ¥ãƒ¼ã«å…¥ã£ãŸã‚¿ã‚¹ã‚¯ã‚’<strong>ç›—ã‚“ã§</strong>å®Ÿè¡Œã™ã‚‹ã€‚
ãŸã ã—ã€ã“ã‚Œã¯ã‚¹ãƒ¬ãƒƒãƒ‰è‡ªèº«ãŒè¡Œã†ã®ã§ã¯ãªãã€ãƒ©ãƒ³ã‚¿ã‚¤ãƒ ã®ã‚¨ã‚°ã‚¼ã‚­ãƒ¥ãƒ¼ã‚¿ãƒ¼ãŒã‚¿ã‚¹ã‚¯ã®å‰²ã‚Šå½“ã¦ã‚’è¡Œã†ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn spawner(input: Rc&lt;u64&gt;) {
    // This won't work either, because
    // `Rc` isn't `Send`.
    // `Rc`ã¯`Send`ã§ãªã„ãŸã‚ã€ã“ã‚Œã‚‚æ©Ÿèƒ½ã—ã¾ã›ã‚“ã€‚
    tokio::spawn(async move {
        println!("{}", input);
    })
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p><code>Rc</code>ã¯ãã®ã‚¹ãƒ¬ãƒƒãƒ‰é–“ã§å…±æœ‰ã§ããªã„ã€‚
<code>Rc</code>ãŒæŒã¤å‚ç…§ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼ã¯<code>usize</code>å‹ã§ã‚¢ãƒˆãƒŸãƒƒã‚¯ã«å‚ç…§ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼ã‚’å¢—æ¸›ã§ããªã„ã€‚</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(C)]
struct RcBox&lt;T: ?Sized&gt; {
    strong: Cell&lt;usize&gt;,
    weak: Cell&lt;usize&gt;,
    value: T,
}
<span class="boring">}</span></code></pre></pre>
<p>ã‚‚ã—ã€<code>Rc</code>ãŒ<code>Send</code>ãªå ´åˆã€ã‚¯ãƒ­ãƒ¼ãƒ³ã—ã¦åˆ¥ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã«æ¸¡ã™ã“ã¨ãŒã§ãã€ã“ã®ã¨ããã‚Œãã‚Œã®ã‚¹ãƒ¬ãƒƒãƒ‰ã§å‚ç…§ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼ã‚’å¢—æ¸›ã™ã‚‹ã“ã¨ã«ãªã‚‹ã€‚
ãã®å ´åˆã€å‚ç…§ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼ã¯ã‚¢ãƒˆãƒŸãƒƒã‚¯ãªæ“ä½œãŒã§ããªã„ãŸã‚ã€å‚ç…§ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼ã¯æ­£ã—ã„å€¤ã‚’ä¿æŒã§ããªã„ã€‚
ã‚ˆã£ã¦ã€<code>Rc</code>ã¯<code>Send</code>ã§ãªã„ã€‚</p>
</blockquote>
<h2 id="exercise-92"><a class="header" href="#exercise-92">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/08_futures/03_runtime"><code>08_futures/03_runtime</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-future-traitfutureãƒˆãƒ¬ã‚¤ãƒˆ"><a class="header" href="#the-future-traitfutureãƒˆãƒ¬ã‚¤ãƒˆ">The <code>Future</code> traitï¼ˆFutureãƒˆãƒ¬ã‚¤ãƒˆï¼‰</a></h1>
<h2 id="the-local-rc-problem-ãƒ­ãƒ¼ã‚«ãƒ«rcå•é¡Œ"><a class="header" href="#the-local-rc-problem-ãƒ­ãƒ¼ã‚«ãƒ«rcå•é¡Œ">The local <code>Rc</code> problem ï¼ˆãƒ­ãƒ¼ã‚«ãƒ«Rcå•é¡Œï¼‰</a></h2>
<p>Let's go back to <code>tokio::spawn</code>'s signature:</p>
<blockquote>
<p><code>tokio::spawn</code>ã®ã‚·ã‚°ãƒãƒãƒ£ãƒ¼ã«æˆ»ã‚Šã¾ã—ã‚‡ã†ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn spawn&lt;F&gt;(future: F) -&gt; JoinHandle&lt;F::Output&gt;
    where
        F: Future + Send + 'static,
        F::Output: Send + 'static,
{ /* */ }
<span class="boring">}</span></code></pre></pre>
<p>What does it <em>actually</em> mean for <code>F</code> to be <code>Send</code>?<br />
It implies, as we saw in the previous section, that whatever value it captures from the
spawning environment has to be <code>Send</code>. But it goes further than that.</p>
<blockquote>
<p><code>F</code>ãŒ<code>Send</code>ã§ã‚ã‚‹ã¨ã¯ <em>å®Ÿéš›ã«</em> ä½•ã‚’æ„å‘³ã—ã¦ã„ã‚‹ã®ã§ã—ã‚‡ã†ã‹ï¼Ÿ
ãã‚Œã¯ã€å‰ã®ç¯€ã§ç¢ºèªã—ãŸé€šã‚Šã€ç”Ÿã¿å‡ºã—ãŸç’°å¢ƒã‹ã‚‰ã‚­ãƒ£ãƒ—ãƒãƒ£ãƒ¼ã•ã‚ŒãŸå€¤ãŒ<code>Send</code>ã§ãªã‘ã‚Œã°ãªã‚‰ãªã„ã“ã¨ã‚’æš—ç¤ºã—ã¦ã„ã¾ã™ã€‚
ã—ã‹ã—ã€ãã‚Œã¯ãã‚Œä»¥ä¸Šã®ã“ã¨ã‚’æ„å‘³ã—ã¦ã„ã¾ã™ã€‚</p>
</blockquote>
<p>Any value that's <em>held across a .await point</em> has to be <code>Send</code>.<br />
Let's look at an example:</p>
<blockquote>
<p><em><code>.await</code>ãƒã‚¤ãƒ³ãƒˆã‚’ã¾ãŸãŒã£ã¦ä¿æŒã•ã‚Œã‚‹</em> ä»»æ„ã®å€¤ã¯ã€<code>Send</code>ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚
ä¾‹ã‚’ç¢ºèªã—ã¾ã—ã‚‡ã†ã€‚</p>
</blockquote>
<blockquote>
<p>å€¤ã¯ã‚¹ãƒ¬ãƒƒãƒ‰2ã‚’ç”Ÿã¿å‡ºã™ã‚¹ãƒ¬ãƒƒãƒ‰1ã§ä½œæˆã•ã‚Œã€ãã®å¾Œãã®å€¤ãŒã‚¹ãƒ¬ãƒƒãƒ‰2ã§ä½œæˆã•ã‚Œã€ç”Ÿã¿å‡ºã™ã‚¹ãƒ¬ãƒƒãƒ‰1ã§ç”Ÿã¿å‡ºã—ãŸã‚¹ãƒ¬ãƒƒãƒ‰2ã‚’<code>.await</code>ã—ãŸå¾Œã«ã€ãã®å€¤ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã¯ã€ã‚¹ãƒ¬ãƒƒãƒ‰é–“ã‚’ã¾ãŸãŒã£ã¦ã„ã‚‹ãŸã‚ã€å½“ç„¶<code>Send</code>ã§ãªã‘ã‚Œã°ãªã‚‰ãªã„ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::rc::Rc;
use tokio::task::yield_now;

fn spawner() {
    tokio::spawn(example());
}

async fn example() {
    // A value that's not `Send`,
    // created _inside_ the async function
    // éåŒæœŸé–¢æ•°å†…ã§ä½œæˆã•ã‚ŒãŸãã®å€¤ã¯`Send`ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚
    let non_send = Rc::new(1);

    // A `.await` point that does nothing
    // ä½•ã‚‚ã—ãªã„`.await`ãƒã‚¤ãƒ³ãƒˆã§ã™ã€‚
    yield_now().await;

    // The local non-`Send` value is still needed
    // after the `.await`
    // `.await`ã®å¾Œã‚‚ã€ãƒ­ãƒ¼ã‚«ãƒ«ãªé`Send`ã®å€¤ãŒå¿…è¦ã§ã™ã€‚
    println!("{}", non_send);
}
<span class="boring">}</span></code></pre></pre>
<p>The compiler will reject this code:</p>
<blockquote>
<p>ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ¼ã¯ã“ã®ã‚³ãƒ¼ãƒ‰ã‚’æ‹’å¦ã—ã¾ã™ã€‚</p>
</blockquote>
<pre><code class="language-text">error: future cannot be sent between threads safely
    |
5   |     tokio::spawn(example());
    |                  ^^^^^^^^^ future returned by `example` is not `Send`
    |
note: future is not `Send` as this value is used across an await
    |
11  |     let non_send = Rc::new(1);
    |         -------- has type `Rc&lt;i32&gt;` which is not `Send`
12  |     // A `.await` point
13  |     yield_now().await;
    |                 ^^^^^ await occurs here, with `non_send` maybe used later
note: required by a bound in `tokio::spawn`
    |
164 |     pub fn spawn&lt;F&gt;(future: F) -&gt; JoinHandle&lt;F::Output&gt;
    |            ----- required by a bound in this function
165 |     where
166 |         F: Future + Send + 'static,
    |                     ^^^^ required by this bound in `spawn`
</code></pre>
<p>To understand why that's the case, we need to refine our understanding of
Rust's asynchronous model.</p>
<blockquote>
<p>ãªãœæ‹’å¦ã•ã‚Œã‚‹ã‹ã‚’ç†è§£ã™ã‚‹ãŸã‚ã«ã€Rustã®éåŒæœŸãƒ¢ãƒ‡ãƒ«ã®ç†è§£ã‚’æ´—ç·´ã•ã›ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚</p>
</blockquote>
<h2 id="the-future-traitfutureãƒˆãƒ¬ã‚¤ãƒˆ-1"><a class="header" href="#the-future-traitfutureãƒˆãƒ¬ã‚¤ãƒˆ-1">The <code>Future</code> traitï¼ˆFutureãƒˆãƒ¬ã‚¤ãƒˆï¼‰</a></h2>
<p>We stated early on that <code>async</code> functions return <strong>futures</strong>, types that implement
the <code>Future</code> trait. You can think of a future as a <strong>state machine</strong>.
It's in one of two states:</p>
<ul>
<li><strong>pending</strong>: the computation has not finished yet.</li>
<li><strong>ready</strong>: the computation has finished, here's the output.</li>
</ul>
<blockquote>
<p><code>async</code>é–¢æ•°ãŒã€<code>Future</code>ãƒˆãƒ¬ã‚¤ãƒˆã‚’å®Ÿè£…ã—ãŸå‹ã§ã‚ã‚‹<strong>ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ãƒ¼</strong>ã‚’è¿”ã™ã¨å‰ã«è¿°ã¹ã¾ã—ãŸã€‚
ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ãƒ¼ã‚’<strong>çŠ¶æ…‹ãƒã‚·ãƒ³</strong>ã¨è€ƒãˆã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚
ãã‚Œã¯ï¼’ã¤ã®çŠ¶æ…‹ã‚’æŒã¡ã¾ã™ã€‚</p>
<ul>
<li><strong>ä¿ç•™ä¸­</strong>: è¨ˆç®—ã¯ã¾ã çµ‚äº†ã—ã¦ã„ã¾ã›ã‚“ã€‚</li>
<li><strong>æº–å‚™å®Œäº†</strong>: è¨ˆç®—ãŒçµ‚äº†ã—ã¦ã€ã“ã“ã«å‡ºåŠ›ãŒã‚ã‚Šã¾ã™ã€‚</li>
</ul>
</blockquote>
<p>This is encoded in the trait definition:</p>
<blockquote>
<p>ã“ã‚Œã¯ã€ãƒˆãƒ¬ã‚¤ãƒˆå®šç¾©å†…ã«ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã•ã‚Œã¦ã„ã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Future {
    type Output;

    // Ignore `Pin` and `Context` for now
    // ç¾æ™‚ç‚¹ã§ã¯`Pin`ã¨`Context`ã‚’ç„¡è¦–ã—ã¦ãã ã•ã„ã€‚
    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt;;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="poll"><a class="header" href="#poll"><code>poll</code></a></h3>
<p>The <code>poll</code> method is the heart of the <code>Future</code> trait.<br />
A future on its own doesn't do anything. It needs to be <strong>polled</strong> to make progress.<br />
When you call <code>poll</code>, you're asking the future to do some work.
<code>poll</code> tries to make progress, and then returns one of the following:</p>
<ul>
<li><code>Poll::Pending</code>: the future is not ready yet. You need to call <code>poll</code> again later.</li>
<li><code>Poll::Ready(value)</code>: the future has finished. <code>value</code> is the result of the computation,
of type <code>Self::Output</code>.</li>
</ul>
<blockquote>
<p><code>poll</code>ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€<code>Future</code>ãƒˆãƒ¬ã‚¤ãƒˆã®å¿ƒè‡“ã§ã™ã€‚
ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ãƒ¼ãã‚Œè‡ªèº«ã¯ã€ä½•ã‚‚ã—ã¾ã›ã‚“ã€‚ãã‚Œã¯é€²æ—ã™ã‚‹ãŸã‚ã«<strong>ãƒãƒ¼ãƒªãƒ³ã‚°</strong>ã•ã‚Œã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚
<code>poll</code>ã‚’å‘¼ã³å‡ºã—ãŸã¨ãã€ä½•ã‹ä½œæ¥­ã‚’è¡Œã†ã“ã¨ã‚’ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ãƒ¼ã«è¦æ±‚ã—ã¾ã™ã€‚
<code>poll</code>ã¯ã€é€²ã‚ã‚ˆã†ã¨è©¦ã¿ã€ãã—ã¦ã€æ¬¡ã®1ã¤ã‚’è¿”ã—ã¾ã™ã€‚</p>
<ul>
<li><code>Poll::Pending</code>: ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ãƒ¼ã¯ã¾ã æº–å‚™ã§ãã¦ã„ã¾ã›ã‚“ã€‚å¾Œã§å†åº¦<code>poll</code>ã‚’å‘¼ã³å‡ºã™å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚</li>
<li><code>Poll::Ready(value)</code>: ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ãƒ¼ã¯å®Œäº†ã—ã¾ã—ãŸã€‚<code>value</code>ã¯è¨ˆç®—ã®çµæœã§ã€å‹ã¯<code>Self::Output</code>ã§ã™ã€‚</li>
</ul>
</blockquote>
<p>Once <code>Future::poll</code> returns <code>Poll::Ready</code>, it should not be polled again: the future has
completed, there's nothing left to do.</p>
<blockquote>
<p>ä¸€æ—¦ã€<code>Future::poll</code>ãŒ<code>Poll::Ready</code>ã‚’è¿”ã™ã¨ã€ãã‚Œã¯å†åº¦ãƒãƒ¼ãƒªãƒ³ã‚°ã•ã‚Œã‚‹ã¹ãã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ãã®ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ãƒ¼ã¯å®Œäº†ã—ã¦ãŠã‚Šã€è¡Œã†ã“ã¨ã¯ä½•ã‚‚æ®‹ã£ã¦ã„ã¾ã›ã‚“ã€‚</p>
</blockquote>
<h3 id="the-role-of-the-runtimeãƒ©ãƒ³ã‚¿ã‚¤ãƒ ã®å½¹ç›®"><a class="header" href="#the-role-of-the-runtimeãƒ©ãƒ³ã‚¿ã‚¤ãƒ ã®å½¹ç›®">The role of the runtimeï¼ˆãƒ©ãƒ³ã‚¿ã‚¤ãƒ ã®å½¹ç›®ï¼‰</a></h3>
<p>You'll rarely, if ever, be calling poll directly.<br />
That's the job of your async runtime: it has all the required information (the <code>Context</code>
in <code>poll</code>'s signature) to ensure that your futures are making progress whenever they can.</p>
<blockquote>
<p>ã»ã¨ã‚“ã©ã€ã¾ãŸã¯æ±ºã—ã¦ã€ç›´æ¥ãƒãƒ¼ãƒªãƒ³ã‚°ã™ã‚‹ã“ã¨ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚
ãã‚Œã¯ã€éåŒæœŸãƒ©ãƒ³ã‚¿ã‚¤ãƒ ã®ä»•äº‹ã§ã™ã€‚ãã‚Œã¯ã€ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ãƒ¼ã¯å¯èƒ½ãªã¨ãã¯ã„ã¤ã§ã‚‚ã€ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ãƒ¼ã‚’é€²ã‚ã‚‹ã“ã¨ã‚’ç¢ºå®Ÿã«ã™ã‚‹ãŸã‚ã«ã€<code>poll</code>ã®ã‚·ã‚°ãƒãƒãƒ£ãƒ¼å†…ã®<code>Context</code>ã¨ã—ã¦ã€å¿…è¦ãªæƒ…å ±ã‚’ã™ã¹ã¦æŒã£ã¦ã„ã¾ã™ã€‚</p>
</blockquote>
<h2 id="async-fn-and-futuresasync-fnã¨ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ãƒ¼"><a class="header" href="#async-fn-and-futuresasync-fnã¨ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ãƒ¼"><code>async fn</code> and futuresï¼ˆasync fnã¨ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ãƒ¼ï¼‰</a></h2>
<p>We've worked with the high-level interface, asynchronous functions.<br />
We've now looked at the low-level primitive, the <code>Future trait</code>.</p>
<blockquote>
<p>éåŒæœŸé–¢æ•°ã®é«˜æ°´æº–ãªã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ã‚¤ã‚¹ã§ä½œæ¥­ã‚’ã—ã¦ãã¾ã—ãŸã€‚
ã“ã“ã§ã¯ã€<code>Future</code>ãƒˆãƒ¬ã‚¤ãƒˆã®ä½æ°´æº–ãªæ§‹æˆè¦ç´ ã‚’ç¢ºèªã—ã¾ã—ãŸã€‚</p>
</blockquote>
<p>How are they related?</p>
<blockquote>
<p>ãã‚Œã‚‰ã¯ã©ã®ã‚ˆã†ã«é–¢é€£ã—ã¦ã„ã‚‹ã®ã§ã—ã‚‡ã†ã‹ï¼Ÿ</p>
</blockquote>
<p>Every time you mark a function as asynchronous, that function will return a future.
The compiler will transform the body of your asynchronous function into a <strong>state machine</strong>:
one state for each <code>.await</code> point.</p>
<blockquote>
<p>éåŒæœŸé–¢æ•°ã‚’ä½œæˆã™ã‚‹ãŸã³ã«ã€ãã®é–¢æ•°ã¯ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ãƒ¼ã‚’è¿”ã—ã¾ã™ã€‚
ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ¼ã¯ã€ãã‚Œãã‚Œã®<code>.await</code>ãƒã‚¤ãƒ³ãƒˆã«1ã¤ã®çŠ¶æ…‹ãŒã‚ã‚‹ã‚ˆã†ãª<strong>çŠ¶æ…‹ãƒã‚·ãƒ³</strong>ã«ã€éåŒæœŸé–¢æ•°ã®æœ¬ä½“ã‚’å¤‰æ›ã—ã¾ã™ã€‚</p>
</blockquote>
<p>Going back to our <code>Rc</code> example:</p>
<blockquote>
<p><code>Rc</code>ã®ä¾‹ã«æˆ»ã‚Šã¾ã—ã‚‡ã†ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::rc::Rc;
use tokio::task::yield_now;

async fn example() {
    let non_send = Rc::new(1);
    yield_now().await;
    println!("{}", non_send);
}
<span class="boring">}</span></code></pre></pre>
<p>The compiler would transform it into an enum that looks somewhat like this:</p>
<blockquote>
<p>ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ¼ã¯ã€ãã‚Œã‚’æ¬¡ã®ã‚ˆã†ã«è¦‹ãˆã‚‹åˆ—æŒ™å‹ã«å¤‰æ›ã—ã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum ExampleFuture {
    NotStarted,
    YieldNow(Rc&lt;i32&gt;), // Rcã‚’ä¿æŒã—ã¦ã„ã‚‹ã€‚Rcã¯Sendã§ãªã„ã€‚ã‚ˆã£ã¦exampleã¯Sendã§ãªã„ã€‚
    Terminated,
}
<span class="boring">}</span></code></pre></pre>
<p>When <code>example</code> is called, it returns <code>ExampleFuture::NotStarted</code>. The future has never
been polled yet, so nothing has happened.<br />
When the runtime polls it the first time, <code>ExampleFuture</code> will advance until the next
<code>.await</code> point: it'll stop at the <code>ExampleFuture::YieldNow(Rc&lt;i32&gt;)</code> stage of the state
machine, returning <code>Poll::Pending</code>.<br />
When it's polled again, it'll execute the remaining code (<code>println!</code>) and
return <code>Poll::Ready(())</code>.</p>
<blockquote>
<p><code>example</code>ãŒå‘¼ã³å‡ºã•ã‚ŒãŸã¨ãã€ãã‚Œã¯<code>ExampleFuture::NotStarted</code>ã‚’è¿”ã—ã¾ã™ã€‚
ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ãƒ¼ã¯ã€ã¾ã æ±ºã—ã¦ãƒãƒ¼ãƒªãƒ³ã‚°ã•ã‚Œã¦ã„ãªã„ãŸã‚ã€ä½•ã‚‚ç™ºç”Ÿã—ã¦ã„ã¾ã›ã‚“ã€‚
ãƒ©ãƒ³ã‚¿ã‚¤ãƒ ãŒæœ€åˆã«ãã‚Œã‚’ãƒãƒ¼ãƒªãƒ³ã‚°ã—ãŸã¨ãã€<code>ExampleFuture</code>ã¯æ¬¡ã®<code>.await</code>ãƒã‚¤ãƒ³ãƒˆã¾ã§é€²ã‚ã¾ã™ã€‚
ãã‚Œã¯ã€çŠ¶æ…‹ãƒã‚·ãƒ³ã®<code>ExampleFuture::YieldNow(Rc&lt;i32&gt;)</code>ã‚¹ãƒ†ãƒ¼ã‚¸ã§åœæ­¢ã—ã¦ã€<code>Poll::Pending</code>ã‚’è¿”ã—ã¾ã™ã€‚
å†åº¦ãƒãƒ¼ãƒªãƒ³ã‚°ã•ã‚ŒãŸã¨ãã€ãã‚Œã¯æ®‹ã‚Šã®ã‚³ãƒ¼ãƒ‰ã®<code>println!</code>ã‚’å®Ÿè¡Œã—ã¦ã€<code>Poll::Ready(())</code>ã‚’è¿”ã—ã¾ã™ã€‚</p>
</blockquote>
<p>When you look at its state machine representation, <code>ExampleFuture</code>,
it is now clear why <code>example</code> is not <code>Send</code>: it holds an <code>Rc</code>, therefore
it cannot be <code>Send</code>.</p>
<blockquote>
<p>ãã®çŠ¶æ…‹ãƒã‚·ãƒ³ã‚’è¡¨ç¾ã™ã‚‹<code>ExampleFuture</code>ã‚’ç¢ºèªã—ãŸã¨ãã€<code>example</code>ãŒ<code>Send</code>ã§ãªã„ç†ç”±ã‚’æ˜ç¢ºã«ã—ã¦ã„ã¾ã™ã€‚
ãã‚Œã¯<code>Rc</code>ã‚’ä¿æŒã—ã¦ã„ã‚‹ãŸã‚ã€ãã‚Œã¯<code>Send</code>ã«ãªã‚Šã¾ã›ã‚“ã€‚</p>
</blockquote>
<h2 id="yield-pointsç§»è­²ãƒã‚¤ãƒ³ãƒˆ"><a class="header" href="#yield-pointsç§»è­²ãƒã‚¤ãƒ³ãƒˆ">Yield pointsï¼ˆç§»è­²ãƒã‚¤ãƒ³ãƒˆï¼‰</a></h2>
<p>As you've just seen with <code>example</code>, every <code>.await</code> point creates a new intermediate
state in the lifecycle of a future.<br />
That's why <code>.await</code> points are also known as <strong>yield points</strong>: your future <em>yields control</em>
back to the runtime that was polling it, allowing the runtime to pause it and (if necessary)
schedule another task for execution, thus making progress on multiple fronts concurrently.</p>
<blockquote>
<p><code>example</code>ã§ç¢ºèªã—ãŸé€šã‚Šã€ã™ã¹ã¦ã®<code>.await</code>ãƒã‚¤ãƒ³ãƒˆã¯ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ãƒ¼ã®ãƒ©ã‚¤ãƒ•ã‚µã‚¤ã‚¯ãƒ«å†…ã«ã€æ–°ã—ã„ä¸­é–“çŠ¶æ…‹ã‚’ä½œæˆã—ã¾ã™ã€‚
ãã‚ŒãŒ<code>.await</code>ãƒã‚¤ãƒ³ãƒˆãŒ<strong>ç§»è­²ãƒã‚¤ãƒ³ãƒˆ</strong>ã¨ã—ã¦çŸ¥ã‚‰ã‚Œã‚‹ç†ç”±ã§ã™ã€‚
ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ãƒ¼ã¯ã€ãã‚Œï¼ˆãƒ•ãƒ¥ãƒ¼ãƒãƒ£ãƒ¼ï¼‰ã‚’ãƒãƒ¼ãƒªãƒ³ã‚°ã—ã¦ã„ãŸãƒ©ãƒ³ã‚¿ã‚¤ãƒ ã«<strong>åˆ¶å¾¡ã‚’ç§»è­²ã—ã¦</strong>ã€ãƒ©ãƒ³ã‚¿ã‚¤ãƒ ãŒãã‚Œï¼ˆãƒ•ãƒ¥ãƒ¼ãƒãƒ£ãƒ¼ï¼‰ã‚’åœæ­¢ã—ã¦ã€ã•ã‚‰ã«å¿…è¦ãŒã‚ã‚Œã°ä»–ã®ã‚¿ã‚¹ã‚¯ã®å®Ÿè¡Œã‚’ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ãã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚
ã“ã‚Œã«ã‚ˆã‚Šã€è¤‡æ•°ã‚’åŒæ™‚ä¸¦è¡Œã§é€²ã‚ã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚</p>
</blockquote>
<p>We'll come back to the importance of yielding in a later section.</p>
<blockquote>
<p>å¾ŒåŠã®ç¯€ã§ã€ç§»è­²ã™ã‚‹é‡è¦æ€§ã«æˆ»ã‚Šã¾ã™ã€‚</p>
</blockquote>
<h2 id="exercise-93"><a class="header" href="#exercise-93">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/08_futures/04_future"><code>08_futures/04_future</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dont-block-the-runtimeãƒ©ãƒ³ã‚¿ã‚¤ãƒ ã‚’ãƒ–ãƒ­ãƒƒã‚¯ã—ã¦ã¯ãªã‚‰ãªã„"><a class="header" href="#dont-block-the-runtimeãƒ©ãƒ³ã‚¿ã‚¤ãƒ ã‚’ãƒ–ãƒ­ãƒƒã‚¯ã—ã¦ã¯ãªã‚‰ãªã„">Don't block the runtimeï¼ˆãƒ©ãƒ³ã‚¿ã‚¤ãƒ ã‚’ãƒ–ãƒ­ãƒƒã‚¯ã—ã¦ã¯ãªã‚‰ãªã„ï¼‰</a></h1>
<p>Let's circle back to yield points.<br />
Unlike threads, <strong>Rust tasks cannot be preempted</strong>.</p>
<blockquote>
<p><code>ç§»è­²</code>ãƒã‚¤ãƒ³ãƒˆã«ãã‚‹ã£ã¨æˆ»ã‚Šã¾ã—ã‚‡ã†ã€‚
ã‚¹ãƒ¬ãƒƒãƒ‰ã¨ç•°ãªã‚Šã€<strong>Rustã®ã‚¿ã‚¹ã‚¯ã¯ã€ãƒ—ãƒªã‚¨ãƒ³ãƒ—ãƒˆã§ãã¾ã›ã‚“</strong>ã€‚</p>
</blockquote>
<blockquote>
<p>ãƒ—ãƒªã‚¨ãƒ³ãƒ—ãƒˆ: ã‚·ã‚¹ãƒ†ãƒ ã®ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒªãƒ³ã‚°ã«ãŠã„ã¦ã€ã‚·ã‚¹ãƒ†ãƒ ã®å¿œç­”æ€§ã‚„åŠ¹ç‡æ€§ã‚’é«˜ã‚ã‚‹ãŸã‚ã«ã€ã‚ã‚‹ãƒ—ãƒ­ã‚»ã‚¹ã‚„ã‚¿ã‚¹ã‚¯ãŒCPUã®åˆ¶å¾¡ã‚’å¼·åˆ¶çš„ã«ä¸­æ–­ã•ã‚Œã€ä»–ã®ãƒ—ãƒ­ã‚»ã‚¹ã‚„ã‚¿ã‚¹ã‚¯ã«åˆ¶å¾¡ãŒç§»ã•ã‚Œã‚‹ã“ã¨ã€‚</p>
</blockquote>
<p><code>tokio</code> cannot, on its own, decide to pause a task and run another one in its place.
The control goes back to the executor <strong>exclusively</strong> when the task yieldsâ€”i.e.
when <code>Future::poll</code> returns <code>Poll::Pending</code> or, in the case of <code>async fn</code>, when
you <code>.await</code> a future.</p>
<blockquote>
<p><code>tokio</code>è‡ªèº«ã¯ã€ã‚¿ã‚¹ã‚¯ã‚’åœæ­¢ã—ã¦ã€ãã®å ´æ‰€ã§ä»–ã®ã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œã™ã‚‹ã“ã¨ã‚’æ±ºå®šã§ãã¾ã›ã‚“ã€‚
ãã®åˆ¶å¾¡ã¯ã€ã‚¿ã‚¹ã‚¯ãŒç§»è­²ã™ã‚‹ã¨ãã€<strong>æ’ä»–çš„ã«</strong>ã‚¨ã‚°ã‚¼ã‚­ãƒ¥ãƒ¼ã‚¿ãƒ¼ã«æˆ»ã‚Šã¾ã™ã€‚
ä¾‹ãˆã°ã€<code>Future::poll</code>ãŒ<code>Poll::Pending</code>ã‚’è¿”ã—ãŸã¨ãã€ã¾ãŸã¯<code>async fn</code>ã®å ´åˆã¯ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ãƒ¼ã‚’<code>.await</code>ã—ãŸã¨ãã§ã™ã€‚</p>
</blockquote>
<p>This exposes the runtime to a risk: if a task never yields, the runtime will never
be able to run another task. This is called <strong>blocking the runtime</strong>.</p>
<blockquote>
<p>ã“ã‚Œã¯ã€ãƒ©ãƒ³ã‚¿ã‚¤ãƒ ãŒãƒªã‚¹ã‚¯ã‚’ã•ã‚‰ã‘å‡ºã™ã“ã¨ã«ãªã‚Šã¾ã™ã€‚
ã‚¿ã‚¹ã‚¯ãŒæ±ºã—ã¦ç§»è­²ã•ã‚Œãªã„å ´åˆã€ãƒ©ãƒ³ã‚¿ã‚¤ãƒ ã¯æ±ºã—ã¦ä»–ã®ã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œã§ãã¾ã›ã‚“ã€‚
ã“ã‚Œã¯<strong>ãƒ©ãƒ³ã‚¿ã‚¤ãƒ ã®ãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°</strong>ã¨å‘¼ã°ã‚Œã¾ã™ã€‚</p>
</blockquote>
<h2 id="what-is-blockingãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ã¨ã¯ä½•ã‹"><a class="header" href="#what-is-blockingãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ã¨ã¯ä½•ã‹">What is blocking?ï¼ˆãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ã¨ã¯ä½•ã‹ï¼Ÿï¼‰</a></h2>
<p>How long is too long? How much time can a task spend without yielding before it
becomes a problem?</p>
<blockquote>
<p>ã©ã‚Œãã‚‰ã„ãŒé•·ã„ã®ã§ã—ã‚‡ã†ã‹ï¼Ÿ
å•é¡Œã«ãªã‚‹ã¾ã§ã€ç§»è­²ã—ãªã„ã‚¿ã‚¹ã‚¯ã¯ã©ã‚Œãã‚‰ã„ã®æ™‚é–“ã‚’è²»ã‚„ã™ã“ã¨ãŒã§ãã‚‹ã§ã—ã‚‡ã†ã‹ï¼Ÿ</p>
</blockquote>
<p>It depends on the runtime, the application, the number of in-flight tasks, and
many other factors. But, as a general rule of thumb, try to spend less than 100
microseconds between yield points.</p>
<blockquote>
<p>ãã‚Œã¯ãƒ©ãƒ³ã‚¿ã‚¤ãƒ ã€ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã€å®Ÿè¡Œä¸­ã®ã‚¿ã‚¹ã‚¯ã®æ•°ã€ãã—ã¦å¤šãã®ä»–ã®è¦å› ã«ä¾å­˜ã—ã¾ã™ã€‚
ã—ã‹ã—ã€ä¸€èˆ¬çš„ãªçµŒé¨“å‰‡ã¨ã—ã¦ã€ç§»è­²ãƒã‚¤ãƒ³ãƒˆé–“ã§100ãƒã‚¤ã‚¯ãƒ­ç§’ã‚ˆã‚Šå°‘ãªã„æ™‚é–“ã‚’è²»ã‚„ã™ã‚ˆã†ã«ã—ã¦ãã ã•ã„ã€‚</p>
</blockquote>
<h2 id="consequencesçµæœ"><a class="header" href="#consequencesçµæœ">Consequencesï¼ˆçµæœï¼‰</a></h2>
<p>Blocking the runtime can lead to:</p>
<ul>
<li><strong>Deadlocks</strong>: if the task that's not yielding is waiting for another task to
complete, and that task is waiting for the first one to yield, you have a deadlock.
No progress can be made, unless the runtime is able to schedule the other task on
a different thread.</li>
<li><strong>Starvation</strong>: other tasks might not be able to run, or might run after a long
delay, which can lead to poor performances (e.g. high tail latencies).</li>
</ul>
<blockquote>
<p>ãƒ©ãƒ³ã‚¿ã‚¤ãƒ ã®ãƒ–ãƒ­ãƒƒã‚¯ã¯æ¬¡ã‚’å¼•ãèµ·ã“ã™å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚</p>
<ul>
<li><strong>ãƒ‡ãƒƒãƒ‰ãƒ­ãƒƒã‚¯</strong>: ç§»è­²ã—ã¦ã„ãªã„ã‚¿ã‚¹ã‚¯ãŒä»–ã®ã‚¿ã‚¹ã‚¯ãŒå®Œäº†ã™ã‚‹ã“ã¨ã‚’å¾…ã£ã¦ã„ã¦ã€ã¾ãŸãã®ã‚¿ã‚¹ã‚¯ï¼ˆä»–ã®ã‚¿ã‚¹ã‚¯ï¼‰ãŒæœ€åˆã®ã‚¿ã‚¹ã‚¯ï¼ˆç§»è­²ã—ã¦ã„ãªã„ã‚¿ã‚¹ã‚¯ï¼‰ãŒç§»è­²ã™ã‚‹ã®ã‚’å¾…ã£ã¦ã„ã‚‹å ´åˆã€ãƒ‡ãƒƒãƒ‰ãƒ­ãƒƒã‚¯ã«ãªã‚Šã¾ã™ã€‚
ãƒ©ãƒ³ã‚¿ã‚¤ãƒ ã¯ç•°ãªã‚‹ã‚¹ãƒ¬ãƒƒãƒ‰ã«ä»–ã®ã‚¿ã‚¹ã‚¯ã‚’ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ãã‚‹ã«ã‚‚é–¢ã‚ã‚‰ãšã€ä½•ã‚‚é€²ã¿ã¾ã›ã‚“ã€‚</li>
<li><strong>é£¢é¤“</strong>: ä»–ã®ã‚¿ã‚¹ã‚¯ã¯å®Ÿè¡Œã§ããªã„ã‹ã€é•·ã„é…å»¶ã®å¾Œã«å®Ÿè¡Œã•ã‚Œã‚‹ã‹ã‚‚ã—ã‚Œãªã„å ´åˆã€ãã‚Œã¯æ€§èƒ½ã®æ‚ªåŒ–ã‚’å¼•ãèµ·ã“ã™å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚ä¾‹ãˆã°ãƒ†ãƒ¼ãƒ«ãƒ¬ã‚¤ãƒ†ãƒ³ã‚·ãƒ¼ã§ã™ã€‚</li>
</ul>
</blockquote>
<h2 id="blocking-is-not-always-obviousãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ã¯å¸¸ã«æ˜ã‚‰ã‹ã§ãªã„"><a class="header" href="#blocking-is-not-always-obviousãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ã¯å¸¸ã«æ˜ã‚‰ã‹ã§ãªã„">Blocking is not always obviousï¼ˆãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ã¯å¸¸ã«æ˜ã‚‰ã‹ã§ãªã„ï¼‰</a></h2>
<p>Some types of operations should generally be avoided in async code, like:</p>
<ul>
<li>Synchronous I/O. You can't predict how long it will take, and it's likely to be
longer than 100 microseconds.</li>
<li>Expensive CPU-bound computations.</li>
</ul>
<blockquote>
<p>ã„ãã¤ã‹ã®ç¨®é¡ã®æ“ä½œã¯ã€ä¸€èˆ¬çš„ã«éåŒæœŸã‚³ãƒ¼ãƒ‰ã§ã¯é¿ã‘ã‚‰ã‚Œã‚‹ã¹ãã§ã™ã€‚æ¬¡ã®ã‚ˆã†ã«ãƒ»ãƒ»ãƒ»</p>
<ul>
<li>åŒæœŸI/Oã€‚ãã‚Œã«ã‹ã‹ã‚‹æ™‚é–“ã‚’äºˆæ¸¬ã§ããšã€ãã‚Œã¯100ãƒã‚¤ã‚¯ãƒ­ç§’ã‚ˆã‚Šã‚‚é•·ããªã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚</li>
<li>é«˜ã„CPUãƒã‚¦ãƒ³ãƒ‰ã®è¨ˆç®—ã€‚</li>
</ul>
</blockquote>
<p>The latter category is not always obvious though. For example, sorting a vector with
a few elements is not a problem; that evaluation changes if the vector has billions
of entries.</p>
<blockquote>
<p>ãŸã ã—ã€å¾Œè€…ã®ã‚«ãƒ†ã‚´ãƒªãƒ¼ã¯å¸¸ã«æ˜ã‚‰ã‹ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚
ä¾‹ãˆã°ã€ã„ãã¤ã‹ã®è¦ç´ ã‚’æŒã¤ãƒ™ã‚¯ã‚¿ãƒ¼ã‚’ã‚½ãƒ¼ãƒˆã™ã‚‹ã“ã¨ã¯å•é¡Œã«ãªã‚Šã¾ã›ã‚“ã€‚
ãƒ™ã‚¯ã‚¿ãƒ¼ãŒæ•°åå„„ã®ã‚¨ãƒ³ãƒˆãƒªã‚’æŒã¤å ´åˆã€è©•ä¾¡ã¯å¤‰ã‚ã‚Šã¾ã™ã€‚</p>
</blockquote>
<h2 id="how-to-avoid-blockingãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ã‚’é¿ã‘ã‚‹æ–¹æ³•"><a class="header" href="#how-to-avoid-blockingãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ã‚’é¿ã‘ã‚‹æ–¹æ³•">How to avoid blockingï¼ˆãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ã‚’é¿ã‘ã‚‹æ–¹æ³•ï¼‰</a></h2>
<p>OK, so how do you avoid blocking the runtime assuming you <em>must</em> perform an operation
that qualifies or risks qualifying as blocking?<br />
You need to move the work to a different thread. You don't want to use the so-called
runtime threads, the ones used by <code>tokio</code> to run tasks.</p>
<blockquote>
<p>ã§ã¯ã€ãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ã¨ã—ã¦èªè­˜ã•ã‚Œã‚‹ã€ã¾ãŸã¯èªè­˜ã•ã‚Œã‚‹ãƒªã‚¹ã‚¯ãŒã‚ã‚‹æ“ä½œã‚’å®Ÿè¡Œ <em>ã—ãªã‘ã‚Œã°ãªã‚‰ãªã„</em> å ´åˆã€ã©ã®ã‚ˆã†ã«ãƒ©ãƒ³ã‚¿ã‚¤ãƒ ã®ãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ã‚’é¿ã‘ãŸã‚‰ã‚ˆã„ã§ã—ã‚‡ã†ã‹ï¼Ÿ
ç•°ãªã‚‹ã‚¹ãƒ¬ãƒƒãƒ‰ã«ãã®ä½œæ¥­ã‚’ç§»å‹•ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚
ãƒ©ãƒ³ã‚¿ã‚¤ãƒ ã‚¹ãƒ¬ãƒƒãƒ‰ã¨å‘¼ã°ã‚Œã‚‹ã‚¹ãƒ¬ãƒƒãƒ‰ã‚’ä½¿ç”¨ã—ãªã„ã§ãã ã•ã„ã€‚ãã‚Œã¯<code>tokio</code>ãŒã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚</p>
</blockquote>
<p><code>tokio</code> provides a dedicated threadpool for this purpose, called the <strong>blocking pool</strong>.
You can spawn a synchronous operation on the blocking pool using the
<code>tokio::task::spawn_blocking</code> function. <code>spawn_blocking</code> returns a future that resolves
to the result of the operation when it completes.</p>
<blockquote>
<p><code>tokio</code>ã¯ã€ã“ã®ç›®çš„ã®ãŸã‚ã«<strong>ãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ãƒ—ãƒ¼ãƒ«</strong>ã¨å‘¼ã°ã‚Œã‚‹å°‚ç”¨ã®ã‚¹ãƒ¬ãƒƒãƒ‰ãƒ—ãƒ¼ãƒ«ã‚’æä¾›ã—ã¦ã„ã¾ã™ã€‚
<code>tokio::task::spawn_blocking</code>é–¢æ•°ã‚’ä½¿ç”¨ã—ã¦ã€ãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ãƒ—ãƒ¼ãƒ«ä¸Šã§åŒæœŸæ“ä½œã‚’ç”Ÿã¿å‡ºã™ã“ã¨ãŒã§ãã¾ã™ã€‚
<code>spawn_blocking</code>ã¯ã€ãã‚ŒãŒå®Œäº†ã—ãŸã¨ãã€æ“ä½œã®çµæœã‚’è§£æ±ºã™ã‚‹ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ãƒ¼ã‚’è¿”ã—ã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tokio::task;

fn expensive_computation() -&gt; u64 {
    // [...]
}

async fn run() {
    let handle = task::spawn_blocking(expensive_computation);

    // Do other stuff in the meantime
    // ã“ã®é–“ï¼ˆä¸Šè¨˜ã®é«˜ã‚³ã‚¹ãƒˆãªé–¢æ•°ã‚’å®Ÿè¡Œã—ã¦ã„ã‚‹é–“ï¼‰ã«ä»–ã®ã“ã¨ã‚’ã—ã¾ã™ã€‚

    // `spawn_blocking`ã¯ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ãƒ¼ã‚’è¿”ã™ãŸã‚ã€`await`ã—ã¦é«˜ã‚³ã‚¹ãƒˆãªé–¢æ•°ã®çµæœãŒå¾—ã‚‰ã‚Œã‚‹ã¾ã§`.await`ã—ã¾ã™ã€‚
    let result = handle.await.unwrap();
}
<span class="boring">}</span></code></pre></pre>
<p>The blocking pool is long-lived. <code>spawn_blocking</code> should be faster
than creating a new thread directly via <code>std::thread::spawn</code>
because the cost of thread initialization is amortized over multiple calls.</p>
<blockquote>
<p>ãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ãƒ—ãƒ¼ãƒ«ã¯é•·ç”Ÿãã§ã™ã€‚
<code>spawn_blocking</code>ã¯ã€<code>std::thread::spawn</code>ã‚’ä»‹ã—ã¦ç›´æ¥æ–°ã—ã„ã‚¹ãƒ¬ãƒƒãƒ‰ã‚’ä½œæˆã™ã‚‹ã‚ˆã‚Šã‚‚æ—©ã„ã¯ãšã§ã™ã€‚
ãã‚Œã¯ã€ã‚¹ãƒ¬ãƒƒãƒ‰ã®åˆæœŸåŒ–ã®ã‚³ã‚¹ãƒˆãŒã€è¤‡æ•°ã®å‘¼ã³å‡ºã—ã«ã‚ãŸã£ã¦åˆ†å‰²ã•ã‚Œã‚‹ã‹ã‚‰ã§ã™ã€‚</p>
</blockquote>
<h2 id="further-readingå‚è€ƒè³‡æ–™-12"><a class="header" href="#further-readingå‚è€ƒè³‡æ–™-12">Further readingï¼ˆå‚è€ƒè³‡æ–™ï¼‰</a></h2>
<ul>
<li>Check out <a href="https://ryhl.io/blog/async-what-is-blocking/">Alice Ryhl's blog post</a>
on the topic.</li>
</ul>
<h2 id="exercise-94"><a class="header" href="#exercise-94">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/08_futures/05_blocking"><code>08_futures/05_blocking</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="async-aware-primitiveséåŒæœŸã‚’çŸ¥ã£ã¦ã„ã‚‹æ§‹æˆè¦ç´ "><a class="header" href="#async-aware-primitiveséåŒæœŸã‚’çŸ¥ã£ã¦ã„ã‚‹æ§‹æˆè¦ç´ ">Async-aware primitivesï¼ˆéåŒæœŸã‚’çŸ¥ã£ã¦ã„ã‚‹æ§‹æˆè¦ç´ ï¼‰</a></h1>
<p>If you browse <code>tokio</code>'s documentation, you'll notice that it provides a lot of types
that "mirror" the ones in the standard library, but with an asynchronous twist:
locks, channels, timers, and more.</p>
<blockquote>
<p><code>tokio</code>ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’å‚ç…§ã—ãŸå ´åˆã€ãƒ­ãƒƒã‚¯ã€ãƒãƒ£ãƒãƒ«ã€ã‚¿ã‚¤ãƒãƒ¼ã€ãã®ä»–ãªã©ã€å¤šãã®æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®å‹ã‚’ã€Œåæ˜ ã—ãŸã€å‹ãŒæä¾›ã•ã‚Œã¦ã„ã‚‹ã“ã¨ã«æ°—ä»˜ãã§ã—ã‚‡ã†ãŒã€éåŒæœŸã«ãªã£ã¦ã„ã¾ã™ã€‚</p>
</blockquote>
<p>When working in an asynchronous context, you should prefer these asynchronous alternatives
to their synchronous counterparts.</p>
<blockquote>
<p>éåŒæœŸã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã§ä½œæ¥­ã™ã‚‹ã¨ãã€ãã‚Œã‚‰ã®åŒæœŸçš„ãªåŒç­‰ç‰©ã§ã¯ãªãã€ã“ã‚Œã‚‰éåŒæœŸã®ä»£æ›¿ç‰©ã‚’å„ªå…ˆã™ã‚‹ã¹ãã§ã™ã€‚</p>
</blockquote>
<p>To understand why, let's take a look at <code>Mutex</code>, the mutually exclusive lock we explored
in the previous chapter.</p>
<blockquote>
<p>ç†ç”±ã‚’ç†è§£ã™ã‚‹ãŸã‚ã«ã€å‰ã®ç« ã§æ¢æ±‚ã—ãŸå¯å¤‰æ’ä»–ãƒ­ãƒƒã‚¯ã§ã‚ã‚‹<code>Mutex</code>ã‚’ç¢ºèªã—ã¾ã—ã‚‡ã†ã€‚</p>
</blockquote>
<h2 id="case-study-mutexäº‹ä¾‹ç ”ç©¶-mutex"><a class="header" href="#case-study-mutexäº‹ä¾‹ç ”ç©¶-mutex">Case study: <code>Mutex</code>ï¼ˆäº‹ä¾‹ç ”ç©¶: Mutexï¼‰</a></h2>
<p>Let's look at a simple example:</p>
<blockquote>
<p>å˜ç´”ãªä¾‹ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::{Arc, Mutex};

async fn run(m: Arc&lt;Mutex&lt;Vec&lt;u64&gt;&gt;&gt;) {
    let guard = m.lock().unwrap();
    http_call(&amp;guard).await;
    println!("Sent {:?} to the server", &amp;guard);
    // `guard` is dropped here
    // `guard`ã¯ã“ã“ã§ãƒ‰ãƒ­ãƒƒãƒ—ã•ã‚Œã¾ã™ã€‚
}

/// Use `v` as the body of an HTTP call.
/// HTTPå‘¼ã³å‡ºã—ã®æœ¬ä½“ã¨ã—ã¦`v`ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚
async fn http_call(v: &amp;[u64]) {
  // [...]
}
<span class="boring">}</span></code></pre></pre>
<h3 id="stdsyncmutexguard-and-yield-pointsstdsyncmutexguardã¨yieldãƒã‚¤ãƒ³ãƒˆ"><a class="header" href="#stdsyncmutexguard-and-yield-pointsstdsyncmutexguardã¨yieldãƒã‚¤ãƒ³ãƒˆ"><code>std::sync::MutexGuard</code> and yield pointsï¼ˆstd::sync::MutexGuardã¨yieldãƒã‚¤ãƒ³ãƒˆï¼‰</a></h3>
<p>This code will compile, but it's dangerous.</p>
<blockquote>
<p>ã“ã®ã‚³ãƒ¼ãƒ‰ã¯ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã‚Œã¾ã™ãŒã€å±é™ºã§ã™ã€‚</p>
</blockquote>
<p>We try to acquire a lock over a <code>Mutex</code> from <code>std</code> in an asynchronous context.
We then hold on to the resulting <code>MutexGuard</code> across a yield point (the <code>.await</code> on
<code>http_call</code>).</p>
<blockquote>
<p><code>std</code>ã®éåŒæœŸã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®<code>Mutex</code>ã‚’ä»‹ã—ã¦ãƒ­ãƒƒã‚¯ã‚’å–å¾—ã™ã‚‹ã“ã¨ã‚’è©¦ã¿ã¾ã™ã€‚
ãã—ã¦ã€<code>http_call</code>ã‚’<code>.await</code>ã—ã¦ã„ã‚‹ç§»è­²ãƒã‚¤ãƒ³ãƒˆã‚’ã¾ãŸã„ã§<code>MutexGuard</code>ã‚’ä¿æŒã—ã¾ã™ã€‚</p>
</blockquote>
<p>Let's imagine that there are two tasks executing <code>run</code>, concurrently, on a single-threaded
runtime. We observe the following sequence of scheduling events:</p>
<blockquote>
<p>å˜ä¸€ã‚¹ãƒ¬ãƒƒãƒ‰ãªãƒ©ãƒ³ã‚¿ã‚¤ãƒ ã§ã€åŒæ™‚ä¸¦è¡Œã§<code>run</code>ã‚’å®Ÿè¡Œã™ã‚‹2ã¤ã®ã‚¿ã‚¹ã‚¯ãŒã‚ã‚‹å ´åˆã‚’æƒ³åƒã—ã¦ãã ã•ã„ã€‚
ã‚¤ãƒ™ãƒ³ãƒˆã®ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒªãƒ³ã‚°ã®æ¬¡ã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚’è¦³å¯Ÿã—ã¾ã™ã€‚</p>
</blockquote>
<pre><code class="language-text">     Task A          Task B
        |
  Acquire lock
Yields to runtime
        |
        +--------------+
                       |
             Tries to acquire lock
</code></pre>
<p>We have a deadlock. Task B we'll never manage to acquire the lock, because the lock
is currently held by task A, which has yielded to the runtime before releasing the
lock and won't be scheduled again because the runtime cannot preempt task B.</p>
<blockquote>
<p>ãƒ‡ãƒƒãƒ‰ãƒ­ãƒƒã‚¯ãŒç™ºç”Ÿã—ã¾ã™ã€‚
ã‚¿ã‚¹ã‚¯Bã¯æ±ºã—ã¦ãƒ­ãƒƒã‚¯ã‚’å–å¾—ã§ãã¾ã›ã‚“ã€‚
ç¾åœ¨ã€ãƒ­ãƒƒã‚¯ã¯ã‚¿ã‚¹ã‚¯Aã«ã‚ˆã£ã¦ä¿æŒã•ã‚Œã¦ãŠã‚Šã€ã‚¿ã‚¹ã‚¯Aã¯ãƒ­ãƒƒã‚¯ã‚’è§£æ”¾ã™ã‚‹å‰ã«ãƒ©ãƒ³ã‚¿ã‚¤ãƒ ã«ç§»è­²ã—ã¾ã™ãŒã€ãƒ©ãƒ³ã‚¿ã‚¤ãƒ ã¯ã‚¿ã‚¹ã‚¯Bã‚’å®Ÿè¡Œã§ããªã„ãŸã‚ã€å†åº¦ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã•ã‚Œã‚‹ã“ã¨ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚</p>
</blockquote>
<blockquote>
<p>ã‚¿ã‚¹ã‚¯BãŒãƒ­ãƒƒã‚¯ã‚’å–å¾—ã—ã‚ˆã†ã¨ã—ã¦ã‚‚ã€ã‚¿ã‚¹ã‚¯AãŒãƒ­ãƒƒã‚¯ã‚’å–å¾—ã—ã¦ã„ã‚‹ãŸã‚ã€ã‚¿ã‚¹ã‚¯Bã¯<code>let guard = m.lock().unwrap();</code>ã§ãƒ–ãƒ­ãƒƒã‚¯ã•ã‚Œã‚‹ã€‚</p>
</blockquote>
<h3 id="tokiosyncmutex"><a class="header" href="#tokiosyncmutex"><code>tokio::sync::Mutex</code></a></h3>
<p>You can solve the issue by switching to <code>tokio::sync::Mutex</code>:</p>
<blockquote>
<p><code>tokio::sync::Mutex</code>ã«åˆ‡ã‚Šæ›¿ãˆã‚‹ã“ã¨ã§ã€ãã®å•é¡Œã‚’è§£æ±ºã§ãã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::Arc;
use tokio::sync::Mutex;

async fn run(m: Arc&lt;Mutex&lt;Vec&lt;u64&gt;&gt;&gt;) {
    let guard = m.lock().await;
    http_call(&amp;guard).await;
    println!("Sent {:?} to the server", &amp;guard);
    // `guard` is dropped here
}
<span class="boring">}</span></code></pre></pre>
<p>Acquiring the lock is now an asynchronous operation, which yields back to the runtime
if it can't make progress.<br />
Going back to the previous scenario, the following would happen:</p>
<blockquote>
<p>ç¾åœ¨ã€ãƒ­ãƒƒã‚¯ã®å–å¾—ã¯éåŒæœŸæ“ä½œã§ã€ãã‚ŒãŒé€²ã‚ã‚‹ã“ã¨ãŒã§ããªã„å ´åˆã€ï¼ˆåˆ¶å¾¡ã‚’ï¼‰ãƒ©ãƒ³ã‚¿ã‚¤ãƒ ã«ç§»è­²ã—ã¾ã™ã€‚
å‰ã®ã‚·ãƒŠãƒªã‚ªã«æˆ»ã‚‹ã¨ã€æ¬¡ãŒç™ºç”Ÿã—ã¾ã™ã€‚</p>
</blockquote>
<pre><code class="language-text">       Task A          Task B
          |
  Acquires the lock
  Starts `http_call`
  Yields to runtime
          |
          +--------------+
                         |
             Tries to acquire the lock
              Cannot acquire the lock
                 Yields to runtime
                         |
          +--------------+
          |
`http_call` completes
  Releases the lock
   Yield to runtime
          |
          +--------------+
                         |
                 Acquires the lock
                       [...]
</code></pre>
<p>All good!</p>
<blockquote>
<p>ã™ã¹ã¦ãŒã†ã¾ãã„ãã¾ã™ï¼</p>
</blockquote>
<h3 id="multithreaded-wont-save-youãƒãƒ«ãƒã‚¹ãƒ¬ãƒƒãƒ‰ã¯æ•‘ã„ã¾ã›ã‚“"><a class="header" href="#multithreaded-wont-save-youãƒãƒ«ãƒã‚¹ãƒ¬ãƒƒãƒ‰ã¯æ•‘ã„ã¾ã›ã‚“">Multithreaded won't save youï¼ˆãƒãƒ«ãƒã‚¹ãƒ¬ãƒƒãƒ‰ã¯æ•‘ã„ã¾ã›ã‚“ï¼‰</a></h3>
<p>We've used a single-threaded runtime as the execution context in our
previous example, but the same risk persists even when using a multithreaded
runtime.<br />
The only difference is in the number of concurrent tasks required to create the deadlock:
in a single-threaded runtime, 2 are enough; in a multithreaded runtime, we
would need <code>N+1</code> tasks, where <code>N</code> is the number of runtime threads.</p>
<blockquote>
<p>å‰ã®ä¾‹ã§ã¯å®Ÿè¡Œã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã¨ã—ã¦å˜ä¸€ã‚¹ãƒ¬ãƒƒãƒ‰ãƒ©ãƒ³ã‚¿ã‚¤ãƒ ã‚’ä½¿ç”¨ã—ã¾ã—ãŸãŒã€åŒã˜ãƒªã‚¹ã‚¯ã¯ãƒãƒ«ãƒã‚¹ãƒ¬ãƒƒãƒ‰ãƒ©ãƒ³ã‚¿ã‚¤ãƒ ã‚’ä½¿ç”¨ã—ãŸã¨ãã‚‚æ®‹ã‚Šã¾ã™ã€‚
å”¯ä¸€ã®é•ã„ã¯ã€ãƒ‡ãƒƒãƒ‰ãƒ­ãƒƒã‚¯ã‚’ä½œæˆã™ã‚‹ãŸã‚ã«å¿…è¦ãªåŒæ™‚ä¸¦è¡Œã‚¿ã‚¹ã‚¯ã®æ•°ã§ã™ã€‚
å˜ä¸€ã‚¹ãƒ¬ãƒƒãƒ‰ãƒ©ãƒ³ã‚¿ã‚¤ãƒ ã§ã¯2ã¤ã§ååˆ†ã§ã—ãŸã€‚
ãƒãƒ«ãƒã‚¹ãƒ¬ãƒƒãƒ‰ãƒ©ãƒ³ã‚¿ã‚¤ãƒ ã§ã¯ã€<code>N+1</code>ã®ã‚¿ã‚¹ã‚¯ãŒå¿…è¦ã§ã€<code>N</code>ã¯ãƒ©ãƒ³ã‚¿ã‚¤ãƒ ã‚¹ãƒ¬ãƒƒãƒ‰ã®æ•°ã§ã™ã€‚</p>
</blockquote>
<h3 id="downsidesæ¬ ç‚¹-1"><a class="header" href="#downsidesæ¬ ç‚¹-1">Downsidesï¼ˆæ¬ ç‚¹ï¼‰</a></h3>
<p>Having an async-aware <code>Mutex</code> comes with a performance penalty.<br />
If you're confident that the lock isn't under significant contention
<em>and</em> you're careful to never hold it across a yield point, you can
still use <code>std::sync::Mutex</code> in an asynchronous context.</p>
<blockquote>
<p>éåŒæœŸã‚’ç†è§£ã—ã¦ã„ã‚‹<code>Mutex</code>ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã¯ã€ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã®ä¸åˆ©ç›Šã‚’ä¼´ã„ã¾ã™ã€‚
ãƒ­ãƒƒã‚¯ãŒç«¶åˆçŠ¶æ…‹ã§ãªã„ã“ã¨ã«è‡ªä¿¡ãŒã‚ã‚Šã€ç§»è­²ãƒã‚¤ãƒ³ãƒˆã‚’ã¾ãŸã„ã§ãƒ­ãƒƒã‚¯ã‚’æ±ºã—ã¦ä¿æŒã—ãªã„ã‚ˆã†ã«æ³¨æ„ã—ã¦ã„ã‚‹å ´åˆã€ã¾ã éåŒæœŸã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã§<code>std::sync::Mutex</code>ã‚’ä½¿ç”¨ã§ãã¾ã™ã€‚</p>
</blockquote>
<p>But weigh the performance benefit against the liveness risk you
will incur.</p>
<blockquote>
<p>ãŸã ã—ã€ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ä¸Šã®åˆ©ç‚¹ã¨ã€ç™ºç”Ÿã™ã‚‹éç”Ÿå­˜ãƒªã‚¹ã‚¯ã‚’æ¯”è¼ƒæ¤œè¨ã—ã¦ãã ã•ã„ã€‚</p>
</blockquote>
<h2 id="other-primitivesã»ã‹ã®æ§‹æˆè¦ç´ "><a class="header" href="#other-primitivesã»ã‹ã®æ§‹æˆè¦ç´ ">Other primitivesï¼ˆã»ã‹ã®æ§‹æˆè¦ç´ ï¼‰</a></h2>
<p>We used <code>Mutex</code> as an example, but the same applies to <code>RwLock</code>, semaphores, etc.<br />
Prefer async-aware versions when working in an asynchronous context to minimise
the risk of issues.</p>
<blockquote>
<p>ä¾‹ã¨ã—ã¦<code>Mutex</code>ã‚’ä½¿ç”¨ã—ã¾ã—ãŸãŒã€<code>RwLock</code>ã€ã‚»ãƒãƒ•ã‚©ãªã©ã«ã‚‚åŒã˜ã“ã¨ãŒé©ç”¨ã•ã‚Œã¾ã™ã€‚
å•é¡Œã®ãƒªã‚¹ã‚¯ã‚’æœ€å°åŒ–ã™ã‚‹ãŸã‚ã«éåŒæœŸã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã§ä½œæ¥­ã™ã‚‹ã¨ãã¯ã€éåŒæœŸã‚’ç†è§£ã—ã¦ã„ã‚‹ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’å„ªå…ˆã—ã¦ãã ã•ã„ã€‚</p>
</blockquote>
<h2 id="exercise-95"><a class="header" href="#exercise-95">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/08_futures/06_async_aware_primitives"><code>08_futures/06_async_aware_primitives</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cancellationã‚­ãƒ£ãƒ³ã‚»ãƒ«"><a class="header" href="#cancellationã‚­ãƒ£ãƒ³ã‚»ãƒ«">Cancellationï¼ˆã‚­ãƒ£ãƒ³ã‚»ãƒ«ï¼‰</a></h1>
<p>What happens when a pending future is dropped?<br />
The runtime will no longer poll it, therefore it won't make any further progress.
In other words, its execution has been <strong>cancelled</strong>.</p>
<blockquote>
<p>ä¿ç•™ä¸­ã®ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ãƒ¼ãŒãƒ‰ãƒ­ãƒƒãƒ—ã•ã‚ŒãŸã¨ãä½•ãŒèµ·ã“ã‚‹ã§ã—ã‚‡ã†ã‹ï¼Ÿ
ãƒ©ãƒ³ã‚¿ã‚¤ãƒ ã‚’ã‚‚ã¯ã‚„ãã‚Œã‚’ãƒãƒ¼ãƒªãƒ³ã‚°ã—ãªã„ãŸã‚ã€ãã‚Œä»¥ä¸Šé€²ã¿ã¾ã›ã‚“ã€‚
è¨€ã„æ›ãˆã‚Œã°ã€ãã®å®Ÿè¡Œã¯<strong>ã‚­ãƒ£ãƒ³ã‚»ãƒ«</strong>ã•ã‚Œã¾ã™ã€‚</p>
</blockquote>
<p>In the wild, this often happens when working with timeouts.
For example:</p>
<blockquote>
<p>å®Ÿéš›ã«ã€ã“ã‚Œã¯ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã‚’ä½¿ç”¨ã—ãŸã¨ãã«ã‚ˆãç™ºç”Ÿã—ã¾ã™ã€‚
ä¾‹ãˆã°ãƒ»ãƒ»ãƒ»</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tokio::time::timeout;
use tokio::sync::oneshot;
use std::time::Duration;

async fn http_call() {
    // [...]
}

async fn run() {
    // Wrap the future with a `Timeout` set to expire in 10 milliseconds.
    // æœŸé™ã‚’10ãƒŸãƒªç§’ã«è¨­å®šã—ãŸ`Timeout`ã§ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ãƒ¼ã‚’ãƒ©ãƒƒãƒ—ã—ã¾ã™ã€‚
    let duration = Duration::from_millis(10);
    if let Err(_) = timeout(duration, http_call()).await {
        println!("Didn't receive a value within 10 ms");
    }
}
<span class="boring">}</span></code></pre></pre>
<p>When the timeout expires, the future returned by <code>http_call</code> will be cancelled.
Let's imagine that this is <code>http_call</code>'s body:</p>
<blockquote>
<p>æ™‚é–“åˆ‡ã‚Œã«ãªã£ãŸã¨ãã€<code>http_call</code>ã«ã‚ˆã£ã¦è¿”ã•ã‚ŒãŸãƒ•ãƒ¥ãƒ¼ãƒãƒ£ãƒ¼ã¯ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã‚Œã¾ã™ã€‚
æ¬¡ãŒ<code>http_call</code>ã®æœ¬ä½“ã§ã‚ã‚‹ã¨æƒ³åƒã—ã¾ã—ã‚‡ã†ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::net::TcpStream;

async fn http_call() {
    let (stream, _) = TcpStream::connect(/* */).await.unwrap();
    let request: Vec&lt;u8&gt; = /* */;
    stream.write_all(&amp;request).await.unwrap();
}
<span class="boring">}</span></code></pre></pre>
<p>Each yield point becomes a <strong>cancellation point</strong>.<br />
<code>http_call</code> can't be preempted by the runtime, so it can only be discarded after
it has yielded control back to the executor via <code>.await</code>.
This applies recursivelyâ€”e.g. <code>stream.write_all(&amp;request)</code> is likely to have multiple
yield points in its implementation. It is perfectly possible to see <code>http_call</code> pushing
a <em>partial</em> request before being cancelled, thus dropping the connection and never
finishing transmitting the body.</p>
<blockquote>
<p>ãã‚Œãã‚Œã®ç§»è­²ãƒã‚¤ãƒ³ãƒˆã¯ã€<strong>ã‚­ãƒ£ãƒ³ã‚»ãƒ«ãƒã‚¤ãƒ³ãƒˆ</strong>ã«ãªã‚Šã¾ã™ã€‚
<code>http_call</code>ã¯ãƒ©ãƒ³ã‚¿ã‚¤ãƒ ã«ã‚ˆã£ã¦ãƒ—ãƒªã‚¨ãƒ³ãƒ—ãƒˆã•ã‚Œã‚‹ã“ã¨ã¯ãªã„ãŸã‚ã€ãã‚Œã¯<code>.await</code>ã‚’ä»‹ã—ã¦ã‚¨ã‚°ã‚¼ã‚­ãƒ¥ãƒ¼ã‚¿ãƒ¼ã«åˆ¶å¾¡ã‚’ç§»è­²ã—ãŸå¾Œã«ã®ã¿ã€ç ´æ£„ã•ã‚Œã‚‹ã¾ã™ã€‚
ã“ã‚Œã¯ã€å†å¸°çš„ã«é©ç”¨ã•ã‚Œã¾ã™ã€‚
ä¾‹ãˆã°ã€<code>stream.write_all(&amp;request)</code>ã¯ã€ãã®å®Ÿè£…å†…ã«è¤‡æ•°ã®ç§»è­²ãƒã‚¤ãƒ³ãƒˆã‚’æŒã¤å¯èƒ½æ€§ãŒé«˜ã„ã§ã™ã€‚
<code>http_call</code>ãŒã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã‚Œã‚‹å‰ã« <em>éƒ¨åˆ†çš„ãª</em> ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’æŠ¼å…¥ã‚Œã€æ¥ç¶šãŒåˆ‡æ–­ã•ã‚Œã¦ã€æœ¬ä½“ã®é€ä¿¡ãŒçµ‚äº†ã—ãªã„å¯èƒ½æ€§ãŒååˆ†ã«ã‚ã‚Šã¾ã™ã€‚</p>
</blockquote>
<blockquote>
<p><strong>ãƒ—ãƒªã‚¨ãƒ³ãƒ—ãƒˆ</strong>: ãƒ—ãƒ­ã‚»ã‚¹ã«ä¸ãˆã‚‰ã‚ŒãŸCPUæ™‚é–“ã‚’æ¶ˆè²»ã—ãŸã¨ãã«ã€ãã®ãƒ—ãƒ­ã‚»ã‚¹ã®å®Ÿè¡Œã‚’ä¸­æ–­ã—ã¦ã€ä»–ã®ãƒ—ãƒ­ã‚»ã‚¹ã«CPUã‚’å‰²ã‚Šå½“ã¦ã‚‹ã“ã¨ã€‚</p>
</blockquote>
<h2 id="clean-upã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—"><a class="header" href="#clean-upã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—">Clean upï¼ˆã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ï¼‰</a></h2>
<p>Rust's cancellation mechanism is quite powerfulâ€”it allows the caller to cancel an ongoing task
without needing any form of cooperation from the task itself.<br />
At the same time, this can be quite dangerous. It may be desirable to perform a
<strong>graceful cancellation</strong>, to ensure that some clean-up tasks are performed
before aborting the operation.</p>
<blockquote>
<p>Rustã®ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã®ãƒ¡ã‚«ãƒ‹ã‚ºãƒ ã¯ã¨ã¦ã‚‚å¼·åŠ›ã§ã™ã€‚
ãã‚Œã¯ã€ã‚¿ã‚¹ã‚¯è‡ªèº«ã‹ã‚‰ã®ã„ã‹ãªã‚‹å½¢å¼ã®å”åŠ›ã‚’å¿…è¦ã¨ã—ãªã„ã§ã€å‘¼ã³å‡ºã—å´ã«å®Ÿè¡Œä¸­ã®ã‚¿ã‚¹ã‚¯ã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã§ãã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚
ãã‚Œã¨åŒæ™‚ã«ã€ã“ã‚Œã¯ã¨ã¦ã‚‚å±é™ºã«ãªã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚
ãã‚Œã¯ã€æ“ä½œã‚’ä¸­æ­¢ã™ã‚‹å‰ã«ã€ã„ãã¤ã‹ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œã™ã‚‹ã“ã¨ã‚’ç¢ºå®Ÿã«ã™ã‚‹ãŸã‚ã«ã€<strong>å„ªé›…ãªã‚­ãƒ£ãƒ³ã‚»ãƒ«</strong>ã‚’å®Ÿè¡Œã™ã‚‹ã“ã¨ãŒæœ›ã¾ã—ã„ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚</p>
</blockquote>
<p>For example, consider this fictional API for a SQL transaction:</p>
<blockquote>
<p>ä¾‹ãˆã°ã€SQLãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã®ãŸã‚ã«ã€æ¬¡ã®æ¶ç©ºã®APIã‚’è€ƒãˆã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn transfer_money(
    connection: SqlConnection,
    payer_id: u64,
    payee_id: u64,
    amount: u64
) -&gt; Result&lt;(), anyhow::Error&gt; {
    let transaction = connection.begin_transaction().await?;
    update_balance(payer_id, amount, &amp;transaction).await?;
    decrease_balance(payee_id, amount, &amp;transaction).await?;
    transaction.commit().await?;
}
<span class="boring">}</span></code></pre></pre>
<p>On cancellation, it'd be ideal to explicitly abort the pending transaction rather
than leaving it hanging.
Rust, unfortunately, doesn't provide a bullet-proof mechanism for this kind of
<strong>asynchronous</strong> clean up operations.</p>
<blockquote>
<p>ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã™ã‚‹å ´åˆã€ä¿ç•™ä¸­ã®ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã‚’æ˜ç¤ºçš„ã«ä¸­æ­¢ã™ã‚‹ã“ã¨ãŒã€ãã®å¿œç­”ãŒãªã„ã¾ã¾æ®‹ã—ã¦ãŠãã‚ˆã‚Šã‚‚ç†æƒ³çš„ã§ã™ã€‚
ä¸é‹ã«ã‚‚ã€Rustã¯ã“ã®ç¨®ã®<strong>éåŒæœŸ</strong>ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—æ“ä½œã‚’è¡Œã†ãŸã‚ã®å¼·å›ºãªãƒ¡ã‚«ãƒ‹ã‚ºãƒ ã‚’æä¾›ã—ã¦ã„ã¾ã›ã‚“ã€‚</p>
</blockquote>
<p>The most common strategy is to rely on the <code>Drop</code> trait to schedule the required
clean-up work. This can be by:</p>
<ul>
<li>Spawning a new task on the runtime</li>
<li>Enqueueing a message on a channel</li>
<li>Spawning a background thread</li>
</ul>
<blockquote>
<p>æœ€ã‚‚ä¸€èˆ¬çš„ãªæˆ¦ç•¥ã¯ã€è¦æ±‚ã•ã‚Œã‚‹ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ä½œæ¥­ã‚’ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã™ã‚‹ãŸã‚ã«<code>Drop</code>ãƒˆãƒ¬ã‚¤ãƒˆã«ä¾å­˜ã™ã‚‹ã“ã¨ã§ã™ã€‚
ã“ã‚Œã¯ã€æ¬¡ã«ã‚ˆã£ã¦è¡Œãˆã¾ã™ã€‚</p>
<ul>
<li>ãƒ©ãƒ³ã‚¿ã‚¤ãƒ ä¸Šã§æ–°ã—ã„ã‚¿ã‚¹ã‚¯ã‚’ç”Ÿã¿å‡ºã—ã¾ã™ã€‚</li>
<li>ãƒãƒ£ãƒãƒ«ä¸Šã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ã‚­ãƒ¥ãƒ¼ã«å…¥ã‚Œã¾ã™ã€‚</li>
<li>ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã‚¹ãƒ¬ãƒƒãƒ‰ã‚’ç”Ÿã¿å‡ºã—ã¾ã™ã€‚</li>
</ul>
</blockquote>
<p>The optimal choice is contextual.</p>
<blockquote>
<p>æœ€é©ãªé¸æŠè‚¢ã¯ã€çŠ¶æ³ã«ã‚ˆã£ã¦ç•°ãªã‚Šã¾ã™ã€‚</p>
</blockquote>
<h2 id="cancelling-spawned-tasksç”Ÿã¿å‡ºã—ãŸã‚¿ã‚¹ã‚¯ã®ã‚­ãƒ£ãƒ³ã‚»ãƒ«"><a class="header" href="#cancelling-spawned-tasksç”Ÿã¿å‡ºã—ãŸã‚¿ã‚¹ã‚¯ã®ã‚­ãƒ£ãƒ³ã‚»ãƒ«">Cancelling spawned tasksï¼ˆç”Ÿã¿å‡ºã—ãŸã‚¿ã‚¹ã‚¯ã®ã‚­ãƒ£ãƒ³ã‚»ãƒ«ï¼‰</a></h2>
<p>When you spawn a task using <code>tokio::spawn</code>, you can no longer drop it;
it belongs to the runtime.<br />
Nonetheless, you can use its <code>JoinHandle</code> to cancel it if needed:</p>
<blockquote>
<p><code>tokio::spawn</code>ã‚’ä½¿ç”¨ã—ã¦ã‚¿ã‚¹ã‚¯ã‚’ç”Ÿã¿å‡ºã—ãŸã¨ãã€ã‚‚ã¯ã‚„ãã‚Œã‚’ãƒ‰ãƒ­ãƒƒãƒ—ã§ãã¾ã›ã‚“ã€‚
ãã‚Œã¯ãƒ©ãƒ³ã‚¿ã‚¤ãƒ ã«å±ã—ã¦ã„ã¾ã™ã€‚
ãã‚Œã«ã‚‚é–¢ã‚ã‚‰ãšã€å¿…è¦ã«å¿œã˜ã¦ã€ãã‚Œã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã™ã‚‹ãŸã‚ã«ã€ãã®<code>JoinHandle</code>ã‚’ä½¿ç”¨ã§ãã¾ã™ã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn run() {
    let handle = tokio::spawn(/* some async taskï¼ˆä½•ã‚‰ã‹ã®éåŒæœŸã‚¿ã‚¹ã‚¯ï¼‰ */);
    // Cancel the spawned task
    // ç”Ÿã¿å‡ºã—ãŸã‚¿ã‚¹ã‚¯ã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã—ã¾ã™ã€‚
    handle.abort();
}
<span class="boring">}</span></code></pre></pre>
<h2 id="further-readingå‚è€ƒè³‡æ–™-13"><a class="header" href="#further-readingå‚è€ƒè³‡æ–™-13">Further readingï¼ˆå‚è€ƒè³‡æ–™ï¼‰</a></h2>
<ul>
<li>Be extremely careful when using <code>tokio</code>'s <code>select!</code> macro to "race" two different futures.
Retrying the same task in a loop is dangerous unless you can ensure <strong>cancellation safety</strong>.
Check out <a href="https://tokio.rs/tokio/tutorial/select"><code>select!</code>'s documentation</a> for more details.<br />
If you need to interleave two asynchronous streams of data (e.g. a socket and a channel), prefer using
<a href="https://docs.rs/tokio-stream/latest/tokio_stream/trait.StreamExt.html#method.merge"><code>StreamExt::merge</code></a> instead.</li>
<li>Rather than "abrupt" cancellation, it can be preferable to rely
on <a href="https://docs.rs/tokio-util/latest/tokio_util/sync/struct.CancellationToken.html"><code>CancellationToken</code></a>.</li>
</ul>
<blockquote>
<ul>
<li><code>tokio</code>ã®<code>select!</code>ãƒã‚¯ãƒ­ã‚’ä½¿ç”¨ã—ã¦2ã¤ã®ç•°ãªã‚‹ãƒ•ãƒ¥ãƒ¼ãƒãƒ£ãƒ¼ã‚’ã€Œç«¶åˆã€ã•ã›ã‚‹å ´åˆã¯ã€ç´°å¿ƒã®æ³¨æ„ã‚’æ‰•ã£ã¦ãã ã•ã„ã€‚
<strong>ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã®å®‰å…¨æ€§</strong>ã‚’ç¢ºä¿ã§ããªã„é™ã‚Šã€ãƒ«ãƒ¼ãƒ—å†…ã§åŒã˜ã‚¿ã‚¹ã‚¯ã‚’å†è©¦è¡Œã™ã‚‹ã“ã¨ã¯å±é™ºã§ã™ã€‚
è©³ç´°ã¯<code>select!</code>ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚
ä¾‹ãˆã°ã‚½ã‚±ãƒƒãƒˆã¨ãƒãƒ£ãƒãƒ«ãªã©ã€2ã¤ã®éåŒæœŸã‚¹ãƒˆãƒªãƒ¼ãƒ ã®ãƒ‡ãƒ¼ã‚¿ã‚’äº¤äº’ã«å‡¦ç†ã™ã‚‹å¿…è¦ãŒã‚ã‚‹å ´åˆã€ä»£ã‚ã‚Šã«<code>StreamExt::merge</code>ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã‚’å„ªå…ˆã—ã¦ãã ã•ã„ã€‚</li>
<li>ã€Œçªç„¶ã®ã€ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã‚ˆã‚Šã‚‚ã€<code>CancellationToken</code>ã«ä¾å­˜ã™ã‚‹ã“ã¨ãŒå¥½ã¾ã—ã„å ´åˆãŒã‚ã‚Šã¾ã™ã€‚</li>
</ul>
</blockquote>
<h2 id="exercise-96"><a class="header" href="#exercise-96">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/08_futures/07_cancellation"><code>08_futures/07_cancellation</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="outro"><a class="header" href="#outro">Outro</a></h1>
<p>Rust's asynchronous model is quite powerful, but it does introduce additional
complexity. Take time to know your tools: dive deep into <code>tokio</code>'s documentation
and get familiar with its primitives to make the most out of it.</p>
<blockquote>
<p>Rustã®éåŒæœŸãƒ¢ãƒ‡ãƒ«ã¯ã¨ã¦ã‚‚å¼·åŠ›ã§ã™ãŒã€è¿½åŠ ã®è¤‡é›‘ã•ã‚’å°å…¥ã—ã¾ã™ã€‚
ãƒ„ãƒ¼ãƒ«ã‚’ç†è§£ã™ã‚‹æ™‚é–“ã‚’å–ã£ã¦ãã ã•ã„ã€‚
<code>tokio</code>ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã«æ·±å…¥ã‚Šã—ã¦ã€æœ€å¤§é™ã«åˆ©ç”¨ã™ã‚‹ãŸã‚ã«ãã®æ§‹æˆè¦ç´ ã«æ…£ã‚Œã¦ãã ã•ã„ã€‚</p>
</blockquote>
<p>Keep in mind, as well, that there is ongoing work at the language and <code>std</code> level
to streamline and "complete" Rust's asynchronous story. You may experience some
rough edges in your day-to-day work due to some of these missing pieces.</p>
<blockquote>
<p>åŒæ§˜ã«ã€Rustã®éåŒæœŸã‚¹ãƒˆãƒ¼ãƒªãƒ¼ã‚’åˆç†åŒ–ã—ã¦ã€Œå®Œäº†ã€ã™ã‚‹ãŸã‚ã®ä½œæ¥­ãŒã€è¨€èªã¨<code>std</code>ãƒ¬ãƒ™ãƒ«ã§ä½œæ¥­ä¸­ã§ã‚ã‚‹ã“ã¨ã«ç•™æ„ã—ã¦ãã ã•ã„ã€‚
ã“ã‚Œã‚‰ã®æ¬ è½ã—ã¦ã„ã‚‹éƒ¨åˆ†ã®ãŸã‚ã«ã€æ—¥ã€…ã®ä½œæ¥­ã§ã„ãã¤ã‹ã®ä¸éƒ½åˆã‚’çµŒé¨“ã™ã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚</p>
</blockquote>
<p>A few recommendations for a mostly-pain-free async experience:</p>
<ul>
<li><strong>Pick a runtime and stick to it.</strong><br />
Some primitives (e.g. timers, I/O) are not portable across runtimes. Trying to
mix runtimes is likely to cause you pain. Trying to write code that's runtime
agnostic can significantly increase the complexity of your codebase. Avoid it
if you can.</li>
<li><strong>There is no stable <code>Stream</code>/<code>AsyncIterator</code> interface yet.</strong><br />
An <code>AsyncIterator</code> is, conceptually, an iterator that yields new items
asynchronously. There is ongoing design work, but no consensus (yet).
If you're using <code>tokio</code>, refer to <a href="https://docs.rs/tokio-stream/latest/tokio_stream/"><code>tokio_stream</code></a>
as your go-to interface.</li>
<li><strong>Be careful with buffering.</strong><br />
It is often the cause of subtle bugs. Check out
<a href="https://rust-lang.github.io/wg-async/vision/submitted_stories/status_quo/barbara_battles_buffered_streams.html">"Barbara battles buffered streams"</a>
for more details.</li>
<li><strong>There is no equivalent of scoped threads for asynchronous tasks</strong>.<br />
Check out <a href="https://without.boats/blog/the-scoped-task-trilemma/">"The scoped task trilemma"</a>
for more details.</li>
</ul>
<blockquote>
<p>éåŒæœŸä½“é¨“ã‚’ã»ã¨ã‚“ã©ç—›ã¿ãªãã™ã‚‹ãŸã‚ã®ã„ãã¤ã‹ã®æ¨å¥¨äº‹é …ãŒã‚ã‚Šã¾ã™ã€‚</p>
<ul>
<li><strong>ãƒ©ãƒ³ã‚¿ã‚¤ãƒ ã‚’é¸æŠã—ã¦ã€ãã‚Œã«å›ºåŸ·ã—ã¦ãã ã•ã„</strong>
ã‚¿ã‚¤ãƒãƒ¼ã‚„I/Oãªã©ã®ã„ãã¤ã‹ã®æ§‹æˆè¦ç´ ã¯ã€ãƒ©ãƒ³ã‚¿ã‚¤ãƒ ã‚’ã¾ãŸã„ã§æŒã¡é‹ã³ã§ãã¾ã›ã‚“ã€‚
ãƒ©ãƒ³ã‚¿ã‚¤ãƒ ã‚’æ··ãœã‚‹ã“ã¨ã¯ã€ç—›ã¿ã‚’å¼•ãèµ·ã“ã™å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚
ãƒ©ãƒ³ã‚¿ã‚¤ãƒ ã‚’ç†è§£ã—ãªã„ã‚³ãƒ¼ãƒ‰ã‚’è¨˜è¿°ã™ã‚‹ã“ã¨ã¯ã€ã‚³ãƒ¼ãƒ‰ãƒ™ãƒ¼ã‚¹ã®è¤‡é›‘ã•ã‚’å¤§å¹…ã«å¢—åŠ ã•ã›ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚
å¯èƒ½ã§ã‚ã‚Œã°ã€ãã‚Œã‚’é¿ã‘ã¦ãã ã•ã„ã€‚</li>
<li><strong>ã¾ã å®‰å®šã—ãŸ<code>Stream</code>/<code>AsyncIterator</code>ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ã‚¤ã‚¹ã¯ã‚ã‚Šã¾ã›ã‚“</strong>
æ¦‚å¿µçš„ã«<code>AsyncIterator</code>ã¯ã€éåŒæœŸã§æ–°ã—ã„ã‚¢ã‚¤ãƒ†ãƒ ã‚’ç”Ÿã¿å‡ºã™ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ãƒ¼ã§ã™ã€‚
è¨­è¨ˆä½œæ¥­ä¸­ã§ã™ãŒã€ã„ã¾ã åˆæ„ãŒå¾—ã‚‰ã‚Œã¦ã„ã¾ã›ã‚“ã€‚
<code>tokio</code>ã‚’ä½¿ç”¨ã—ã¦ã„ã‚‹å ´åˆã€ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã¨ã—ã¦<code>tokio_stream</code>ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚</li>
<li><strong>ãƒãƒƒãƒ•ã‚¡ãƒªãƒ³ã‚°ã«æ³¨æ„ã—ã¦ãã ã•ã„</strong>
ãã‚Œã¯ã—ã°ã—ã°å¾®å¦™ãªãƒã‚°ã®åŸå› ã«ãªã‚Šã¾ã™ã€‚è©³ç´°ã¯ã€ŒBarbara battles buffered streamsã€ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚</li>
<li><strong>éåŒæœŸã‚¿ã‚¹ã‚¯ã«ã‚¹ã‚³ãƒ¼ãƒ—ãŒåˆ¶é™ã•ã‚ŒãŸã‚¹ãƒ¬ãƒƒãƒ‰ã¨åŒç­‰ãªã‚‚ã®ã¯ã‚ã‚Šã¾ã›ã‚“</strong>
è©³ç´°ã¯ã€ŒThe scoped task trilemmaã€ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚</li>
</ul>
</blockquote>
<p>Don't let these caveats scare you: asynchronous Rust is being used effectively
at <em>massive</em> scale (e.g. AWS, Meta) to power foundational services.<br />
You will have to master it if you're planning building networked applications
in Rust.</p>
<blockquote>
<p>ã“ã‚Œã‚‰ã®æ³¨æ„ç‚¹ã«æ€¯ãˆãªã„ã§ãã ã•ã„ã€‚
éåŒæœŸRustã¯ã€åŸºç›¤ã¨ãªã‚‹ã‚µãƒ¼ãƒ“ã‚¹ã‚’å¼·åŒ–ã™ã‚‹ãŸã‚ã«ã€ä¾‹ãˆã°AWSã€Metaãªã©ã® <em>å·¨å¤§ãª</em> ã‚¹ã‚±ãƒ¼ãƒ«ã§åŠ¹æœçš„ã«ä½¿ç”¨ã•ã‚Œã¦ã„ã¾ã™ã€‚
Rustã§ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®æ§‹ç¯‰ã‚’è¨ˆç”»ã—ã¦ã„ã‚‹å ´åˆã€ãã‚Œã‚’ãƒã‚¹ã‚¿ãƒ¼ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚</p>
</blockquote>
<h2 id="exercise-97"><a class="header" href="#exercise-97">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/08_futures/08_outro"><code>08_futures/08_outro</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="epilogue"><a class="header" href="#epilogue">Epilogue</a></h1>
<p>Our tour of Rust ends here.<br />
It has been quite extensive, but by no means exhaustive: Rust is a language with
a large surface area, and an even larger ecosystem!<br />
Don't let this scare you, though: there's <strong>no need to learn everything</strong>.
You'll pick up whatever is necessary to be effective in the domain
(backend, embedded, CLIs, GUIs, etc.) <strong>while working on your projects</strong>.</p>
<p>In the end, there are no shortcuts: if you want to get good at something,
you need to do it, over and over again. Throughout this course you wrote a fair
amount of Rust, enough to get the language and its syntax flowing under your
fingers. It'll take many more lines of code to feel it "yours", but that moment
will come without a doubt if you keep practicing.</p>
<h2 id="going-further"><a class="header" href="#going-further">Going further</a></h2>
<p>Let's close with some pointers to additional resources that you might find
useful as you move forward in your journey with Rust.</p>
<h3 id="exercises"><a class="header" href="#exercises">Exercises</a></h3>
<p>You can find more exercises to practice Rust in the <a href="https://github.com/rust-lang/rustlings"><code>rustlings</code></a>
project and on <a href="https://exercism.io">exercism.io</a>'s Rust track.</p>
<h3 id="introductory-material"><a class="header" href="#introductory-material">Introductory material</a></h3>
<p>Check out <a href="https://doc.rust-lang.org/book/title-page.html">the Rust book</a> and
<a href="https://www.oreilly.com/library/view/programming-rust-2nd/9781492052586/">"Programming Rust"</a>
if you're looking for a different perspective on the same concepts we covered throughout this course.
You'll certainly learn something new since they don't cover exactly the same topics; Rust has a lot of surface area!</p>
<h3 id="advanced-material"><a class="header" href="#advanced-material">Advanced material</a></h3>
<p>If you want to dive deeper into the language, refer to the <a href="https://doc.rust-lang.org/nomicon/">Rustonomicon</a>
and <a href="https://nostarch.com/rust-rustaceans">"Rust for Rustaceans"</a>.<br />
The <a href="https://www.youtube.com/playlist?list=PLqbS7AVVErFirH9armw8yXlE6dacF-A6z">"Decrusted" series</a> is another excellent
resource to learn more about the internals of many of the most popular Rust libraries.</p>
<h3 id="domain-specific-material"><a class="header" href="#domain-specific-material">Domain-specific material</a></h3>
<p>If you want to use Rust for backend development,
check out <a href="https://zero2prod.com">"Zero to Production in Rust"</a>.<br />
If you want to use Rust for embedded development,
check out the <a href="https://docs.rust-embedded.org/book/">Embedded Rust book</a>.</p>
<h3 id="masterclasses"><a class="header" href="#masterclasses">Masterclasses</a></h3>
<p>You can then find resources on key topics that cut across domains.<br />
For testing, check out
<a href="https://github.com/mainmatter/rust-advanced-testing-workshop">"Advanced testing, going beyond the basics"</a>.<br />
For telemetry, check out <a href="https://github.com/mainmatter/rust-telemetry-workshop">"You can't fix what you can't see"</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
