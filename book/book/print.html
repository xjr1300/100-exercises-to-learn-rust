<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>100 Exercises To Learn Rust</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="01_intro/00_welcome.html"><strong aria-hidden="true">1.</strong> Welcome</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="01_intro/01_syntax.html"><strong aria-hidden="true">1.1.</strong> Syntax</a></li></ol></li><li class="chapter-item expanded "><a href="02_basic_calculator/00_intro.html"><strong aria-hidden="true">2.</strong> A Basic Calculator</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="02_basic_calculator/01_integers.html"><strong aria-hidden="true">2.1.</strong> Integers</a></li><li class="chapter-item expanded "><a href="02_basic_calculator/02_variables.html"><strong aria-hidden="true">2.2.</strong> Variables</a></li><li class="chapter-item expanded "><a href="02_basic_calculator/03_if_else.html"><strong aria-hidden="true">2.3.</strong> Branching: if/else</a></li><li class="chapter-item expanded "><a href="02_basic_calculator/04_panics.html"><strong aria-hidden="true">2.4.</strong> Panics</a></li><li class="chapter-item expanded "><a href="02_basic_calculator/05_factorial.html"><strong aria-hidden="true">2.5.</strong> Factorial</a></li><li class="chapter-item expanded "><a href="02_basic_calculator/06_while.html"><strong aria-hidden="true">2.6.</strong> Loops: while</a></li><li class="chapter-item expanded "><a href="02_basic_calculator/07_for.html"><strong aria-hidden="true">2.7.</strong> Loops: for</a></li><li class="chapter-item expanded "><a href="02_basic_calculator/08_overflow.html"><strong aria-hidden="true">2.8.</strong> Overflow and underflow</a></li><li class="chapter-item expanded "><a href="02_basic_calculator/09_saturating.html"><strong aria-hidden="true">2.9.</strong> Saturating arithmetic</a></li><li class="chapter-item expanded "><a href="02_basic_calculator/10_as_casting.html"><strong aria-hidden="true">2.10.</strong> Conversions: as casting</a></li></ol></li><li class="chapter-item expanded "><a href="03_ticket_v1/00_intro.html"><strong aria-hidden="true">3.</strong> Ticket v1</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="03_ticket_v1/01_struct.html"><strong aria-hidden="true">3.1.</strong> Structs</a></li><li class="chapter-item expanded "><a href="03_ticket_v1/02_validation.html"><strong aria-hidden="true">3.2.</strong> Validation</a></li><li class="chapter-item expanded "><a href="03_ticket_v1/03_modules.html"><strong aria-hidden="true">3.3.</strong> Modules</a></li><li class="chapter-item expanded "><a href="03_ticket_v1/04_visibility.html"><strong aria-hidden="true">3.4.</strong> Visibility</a></li><li class="chapter-item expanded "><a href="03_ticket_v1/05_encapsulation.html"><strong aria-hidden="true">3.5.</strong> Encapsulation</a></li><li class="chapter-item expanded "><a href="03_ticket_v1/06_ownership.html"><strong aria-hidden="true">3.6.</strong> Ownership</a></li><li class="chapter-item expanded "><a href="03_ticket_v1/07_setters.html"><strong aria-hidden="true">3.7.</strong> Setters</a></li><li class="chapter-item expanded "><a href="03_ticket_v1/08_stack.html"><strong aria-hidden="true">3.8.</strong> Stack</a></li><li class="chapter-item expanded "><a href="03_ticket_v1/09_heap.html"><strong aria-hidden="true">3.9.</strong> Heap</a></li><li class="chapter-item expanded "><a href="03_ticket_v1/10_references_in_memory.html"><strong aria-hidden="true">3.10.</strong> References in memory</a></li><li class="chapter-item expanded "><a href="03_ticket_v1/11_destructor.html"><strong aria-hidden="true">3.11.</strong> Destructors</a></li><li class="chapter-item expanded "><a href="03_ticket_v1/12_outro.html"><strong aria-hidden="true">3.12.</strong> Outro</a></li></ol></li><li class="chapter-item expanded "><a href="04_traits/00_intro.html"><strong aria-hidden="true">4.</strong> Traits</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="04_traits/01_trait.html"><strong aria-hidden="true">4.1.</strong> Trait</a></li><li class="chapter-item expanded "><a href="04_traits/02_orphan_rule.html"><strong aria-hidden="true">4.2.</strong> Orphan rule</a></li><li class="chapter-item expanded "><a href="04_traits/03_operator_overloading.html"><strong aria-hidden="true">4.3.</strong> Operator overloading</a></li><li class="chapter-item expanded "><a href="04_traits/04_derive.html"><strong aria-hidden="true">4.4.</strong> Derive macros</a></li><li class="chapter-item expanded "><a href="04_traits/05_trait_bounds.html"><strong aria-hidden="true">4.5.</strong> Trait bounds</a></li><li class="chapter-item expanded "><a href="04_traits/06_str_slice.html"><strong aria-hidden="true">4.6.</strong> String slices</a></li><li class="chapter-item expanded "><a href="04_traits/07_deref.html"><strong aria-hidden="true">4.7.</strong> Deref trait</a></li><li class="chapter-item expanded "><a href="04_traits/08_sized.html"><strong aria-hidden="true">4.8.</strong> Sized trait</a></li><li class="chapter-item expanded "><a href="04_traits/09_from.html"><strong aria-hidden="true">4.9.</strong> From trait</a></li><li class="chapter-item expanded "><a href="04_traits/10_assoc_vs_generic.html"><strong aria-hidden="true">4.10.</strong> Associated vs generic types</a></li><li class="chapter-item expanded "><a href="04_traits/11_clone.html"><strong aria-hidden="true">4.11.</strong> Clone trait</a></li><li class="chapter-item expanded "><a href="04_traits/12_copy.html"><strong aria-hidden="true">4.12.</strong> Copy trait</a></li><li class="chapter-item expanded "><a href="04_traits/13_drop.html"><strong aria-hidden="true">4.13.</strong> Drop trait</a></li><li class="chapter-item expanded "><a href="04_traits/14_outro.html"><strong aria-hidden="true">4.14.</strong> Outro</a></li></ol></li><li class="chapter-item expanded "><a href="05_ticket_v2/00_intro.html"><strong aria-hidden="true">5.</strong> Ticket v2</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="05_ticket_v2/01_enum.html"><strong aria-hidden="true">5.1.</strong> Enums</a></li><li class="chapter-item expanded "><a href="05_ticket_v2/02_match.html"><strong aria-hidden="true">5.2.</strong> Branching: match</a></li><li class="chapter-item expanded "><a href="05_ticket_v2/03_variants_with_data.html"><strong aria-hidden="true">5.3.</strong> Variants with data</a></li><li class="chapter-item expanded "><a href="05_ticket_v2/04_if_let.html"><strong aria-hidden="true">5.4.</strong> Branching: if let and let/else</a></li><li class="chapter-item expanded "><a href="05_ticket_v2/05_nullability.html"><strong aria-hidden="true">5.5.</strong> Nullability</a></li><li class="chapter-item expanded "><a href="05_ticket_v2/06_fallibility.html"><strong aria-hidden="true">5.6.</strong> Fallibility</a></li><li class="chapter-item expanded "><a href="05_ticket_v2/07_unwrap.html"><strong aria-hidden="true">5.7.</strong> Unwrap</a></li><li class="chapter-item expanded "><a href="05_ticket_v2/08_error_enums.html"><strong aria-hidden="true">5.8.</strong> Error enums</a></li><li class="chapter-item expanded "><a href="05_ticket_v2/09_error_trait.html"><strong aria-hidden="true">5.9.</strong> Error trait</a></li><li class="chapter-item expanded "><a href="05_ticket_v2/10_packages.html"><strong aria-hidden="true">5.10.</strong> Packages</a></li><li class="chapter-item expanded "><a href="05_ticket_v2/11_dependencies.html"><strong aria-hidden="true">5.11.</strong> Dependencies</a></li><li class="chapter-item expanded "><a href="05_ticket_v2/12_thiserror.html"><strong aria-hidden="true">5.12.</strong> thiserror</a></li><li class="chapter-item expanded "><a href="05_ticket_v2/13_try_from.html"><strong aria-hidden="true">5.13.</strong> TryFrom trait</a></li><li class="chapter-item expanded "><a href="05_ticket_v2/14_source.html"><strong aria-hidden="true">5.14.</strong> Error::source</a></li><li class="chapter-item expanded "><a href="05_ticket_v2/15_outro.html"><strong aria-hidden="true">5.15.</strong> Outro</a></li></ol></li><li class="chapter-item expanded "><a href="06_ticket_management/00_intro.html"><strong aria-hidden="true">6.</strong> Ticket Management</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="06_ticket_management/01_arrays.html"><strong aria-hidden="true">6.1.</strong> Arrays</a></li><li class="chapter-item expanded "><a href="06_ticket_management/02_vec.html"><strong aria-hidden="true">6.2.</strong> Vectors</a></li><li class="chapter-item expanded "><a href="06_ticket_management/03_resizing.html"><strong aria-hidden="true">6.3.</strong> Resizing</a></li><li class="chapter-item expanded "><a href="06_ticket_management/04_iterators.html"><strong aria-hidden="true">6.4.</strong> Iterators</a></li><li class="chapter-item expanded "><a href="06_ticket_management/05_iter.html"><strong aria-hidden="true">6.5.</strong> Iter</a></li><li class="chapter-item expanded "><a href="06_ticket_management/06_lifetimes.html"><strong aria-hidden="true">6.6.</strong> Lifetimes</a></li><li class="chapter-item expanded "><a href="06_ticket_management/07_combinators.html"><strong aria-hidden="true">6.7.</strong> Combinators</a></li><li class="chapter-item expanded "><a href="06_ticket_management/08_impl_trait.html"><strong aria-hidden="true">6.8.</strong> impl Trait</a></li><li class="chapter-item expanded "><a href="06_ticket_management/09_impl_trait_2.html"><strong aria-hidden="true">6.9.</strong> impl Trait, pt.2</a></li><li class="chapter-item expanded "><a href="06_ticket_management/10_slices.html"><strong aria-hidden="true">6.10.</strong> Slices</a></li><li class="chapter-item expanded "><a href="06_ticket_management/11_mutable_slices.html"><strong aria-hidden="true">6.11.</strong> Mutable slices</a></li><li class="chapter-item expanded "><a href="06_ticket_management/12_two_states.html"><strong aria-hidden="true">6.12.</strong> Two states</a></li><li class="chapter-item expanded "><a href="06_ticket_management/13_index.html"><strong aria-hidden="true">6.13.</strong> Index trait</a></li><li class="chapter-item expanded "><a href="06_ticket_management/14_index_mut.html"><strong aria-hidden="true">6.14.</strong> IndexMut trait</a></li><li class="chapter-item expanded "><a href="06_ticket_management/15_hashmap.html"><strong aria-hidden="true">6.15.</strong> HashMap</a></li><li class="chapter-item expanded "><a href="06_ticket_management/16_btreemap.html"><strong aria-hidden="true">6.16.</strong> BTreeMap</a></li></ol></li><li class="chapter-item expanded "><a href="07_threads/00_intro.html"><strong aria-hidden="true">7.</strong> Threads</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="07_threads/01_threads.html"><strong aria-hidden="true">7.1.</strong> Threads</a></li><li class="chapter-item expanded "><a href="07_threads/02_static.html"><strong aria-hidden="true">7.2.</strong> 'static lifetime</a></li><li class="chapter-item expanded "><a href="07_threads/03_leak.html"><strong aria-hidden="true">7.3.</strong> Leaking memory</a></li><li class="chapter-item expanded "><a href="07_threads/04_scoped_threads.html"><strong aria-hidden="true">7.4.</strong> Scoped threads</a></li><li class="chapter-item expanded "><a href="07_threads/05_channels.html"><strong aria-hidden="true">7.5.</strong> Channels</a></li><li class="chapter-item expanded "><a href="07_threads/06_interior_mutability.html"><strong aria-hidden="true">7.6.</strong> Interior mutability</a></li><li class="chapter-item expanded "><a href="07_threads/07_ack.html"><strong aria-hidden="true">7.7.</strong> Ack pattern</a></li><li class="chapter-item expanded "><a href="07_threads/08_client.html"><strong aria-hidden="true">7.8.</strong> Client</a></li><li class="chapter-item expanded "><a href="07_threads/09_bounded.html"><strong aria-hidden="true">7.9.</strong> Bounded channels</a></li><li class="chapter-item expanded "><a href="07_threads/10_patch.html"><strong aria-hidden="true">7.10.</strong> Patching</a></li><li class="chapter-item expanded "><a href="07_threads/11_locks.html"><strong aria-hidden="true">7.11.</strong> Mutex, Send and Arc</a></li><li class="chapter-item expanded "><a href="07_threads/12_rw_lock.html"><strong aria-hidden="true">7.12.</strong> RwLock</a></li><li class="chapter-item expanded "><a href="07_threads/13_without_channels.html"><strong aria-hidden="true">7.13.</strong> Without channels</a></li><li class="chapter-item expanded "><a href="07_threads/14_sync.html"><strong aria-hidden="true">7.14.</strong> Sync trait</a></li></ol></li><li class="chapter-item expanded "><a href="08_futures/00_intro.html"><strong aria-hidden="true">8.</strong> Futures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="08_futures/01_async_fn.html"><strong aria-hidden="true">8.1.</strong> Asynchronous functions</a></li><li class="chapter-item expanded "><a href="08_futures/02_spawn.html"><strong aria-hidden="true">8.2.</strong> Spawning tasks</a></li><li class="chapter-item expanded "><a href="08_futures/03_runtime.html"><strong aria-hidden="true">8.3.</strong> Runtime</a></li><li class="chapter-item expanded "><a href="08_futures/04_future.html"><strong aria-hidden="true">8.4.</strong> Future trait</a></li><li class="chapter-item expanded "><a href="08_futures/05_blocking.html"><strong aria-hidden="true">8.5.</strong> Blocking the runtime</a></li><li class="chapter-item expanded "><a href="08_futures/06_async_aware_primitives.html"><strong aria-hidden="true">8.6.</strong> Async-aware primitives</a></li><li class="chapter-item expanded "><a href="08_futures/07_cancellation.html"><strong aria-hidden="true">8.7.</strong> Cancellation</a></li><li class="chapter-item expanded "><a href="08_futures/08_outro.html"><strong aria-hidden="true">8.8.</strong> Outro</a></li></ol></li><li class="chapter-item expanded "><a href="going_further.html"><strong aria-hidden="true">9.</strong> Going further</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">100 Exercises To Learn Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/mainmatter/100-exercises-to-learn-rust" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="welcomeようこそ"><a class="header" href="#welcomeようこそ">Welcome（ようこそ）</a></h1>
<p>Welcome to <strong>"100 Exercises To Learn Rust"</strong>!</p>
<blockquote>
<p>ようこそ、<strong>"Rustを学ぶための100個の演習</strong>へ!</p>
</blockquote>
<p>This course will teach you Rust's core concepts, one exercise at a time.<br />
You'll learn about Rust's syntax, its type system, its standard library, and its ecosystem.</p>
<blockquote>
<p>このコースは、1回で1つの演習によって、Rustの核となる概念を教えます。
Rustの構文、その型システム、その標準ライブラリ、そしてそのエコシステムについて学びます。</p>
</blockquote>
<p>We don't assume any prior knowledge of Rust, but we assume you know at least
another programming language.
We also don't assume any prior knowledge of systems programming or memory management. Those
topics will be covered in the course.</p>
<blockquote>
<p>Rustの事前知識を前提としていませんが、少なくとも他のプログラミング言語についての知識があることを想定しています。
また、システムプログラミングまたはメモリ管理の前提知識を想定していません。
これらのトピックは、コース内でカバーします。</p>
</blockquote>
<p>In other words, we'll be starting from scratch!<br />
You'll build up your Rust knowledge in small, manageable steps.
By the end of the course, you will have solved ~100 exercises, enough to
feel comfortable working on small to medium-sized Rust projects.</p>
<blockquote>
<p>つまり、スクラッチから始めます！
小さく、そして管理可能なステップを踏んで、Rustの知識を構築します。
コースの最後では、小規模から中規模のRustプロジェクトで気持ちよく作業するために十分な、100個までの演習を解決するでしょう。</p>
</blockquote>
<h2 id="methodology方法論"><a class="header" href="#methodology方法論">Methodology（方法論）</a></h2>
<p>This course is based on the "learn by doing" principle.<br />
It has been designed to be interactive and hands-on.</p>
<blockquote>
<p>このコースは、「実践で学ぶ」という原則に基づいています。
それは、対話的で実践的になるように設計されています。</p>
</blockquote>
<p><a href="https://mainmatter.com/rust-consulting/">Mainmatter</a> developed this course
to be delivered in a classroom setting, over 4 days: each attendee advances
through the lessons at their own pace, with an experienced instructor providing
guidance, answering questions and diving deeper into the topics as needed.<br />
If you're interested in attending one of our training sessions, or if you'd like to
bring this course to your company, please <a href="https://mainmatter.com/contact/">get in touch</a>.</p>
<blockquote>
<p>Mainmatterは、クラスルームで4日間にわたって提供されるようにこのコースを設計しました。
それぞれの参加者は、自分のペースでレッスンを進め、必要に応じて経験豊富なインストラクターがガイダンスを提供して、質問に回答して、トピックに深入りします。
トレーニングセッションに参加する興味がある場合、またはこのコースを会社に持ち込みたい場合は、連絡を取ってください。</p>
</blockquote>
<p>You can also follow the course on your own, but we recommend you find a friend or
a mentor to help you along the way should you get stuck. You can
also find solutions to all exercises in the
<a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/solutions"><code>solutions</code> branch of the GitHub repository</a>.</p>
<blockquote>
<p>また、独自でコースをフォローすることもできますが、行き詰まった場合に助けてくれる友人やメンターを探すことをお勧めします。
また、GitHubリポジトリの<code>solutions</code>ブランチに、すべての演習の解答を見つけることもできます。</p>
</blockquote>
<h2 id="structure構造"><a class="header" href="#structure構造">Structure（構造）</a></h2>
<p>On the left side of the screen, you can see that the course is divided into sections.
Each section introduces a new concept or feature of the Rust language.<br />
To verify your understanding, each section is paired with an exercise that you need to solve.</p>
<blockquote>
<p>画面の左側で、コースが節に分割されていることを確認できます。
それぞれの節は、Rust言語の新しい概念または機能を導入します。
理解を確認するために、それぞれの節は、解決しなくてはならない演習とペアになっています。</p>
</blockquote>
<p>You can find the exercises in the
<a href="https://github.com/mainmatter/100-exercises-to-learn-rust">companion GitHub repository</a>.<br />
Before starting the course, make sure to clone the repository to your local machine:</p>
<blockquote>
<p>GitHubリポジトリの手引書の中に演習を見つけることができます。
コースを開始する前に、ローカルマシンにリポジトリをクローンしてください。</p>
</blockquote>
<pre><code class="language-bash"># If you have an SSH key set up with GitHub
git clone git@github.com:mainmatter/100-exercises-to-learn-rust.git
# Otherwise, use the HTTPS URL:
#
#   git clone https://github.com/mainmatter/100-exercises-to-learn-rust.git
</code></pre>
<p>We also recommend you work on a branch, so you can easily track your progress and pull
in updates from the main repository, if needed:</p>
<blockquote>
<p>また、必要に応じて、<code>main</code>リポジトリから容易に更新を追跡できるように、ブランチで作業することをおすすめします。</p>
</blockquote>
<pre><code class="language-bash">cd 100-exercises-to-learn-rust
git checkout -b my-solutions
</code></pre>
<p>All exercises are located in the <code>exercises</code> folder.
Each exercise is structured as a Rust package.
The package contains the exercise itself, instructions on what to do (in <code>src/lib.rs</code>), and a test suite to
automatically verify your solution.</p>
<blockquote>
<p>すべての演習は、<code>exercises</code>フォルダに配置されています。
それぞれの演習は、Rustパッケージとして構成されています。
そのパッケージは、演習自体、何をするべきかの指示（<code>src/lib.rs</code>内）と、解答を自動確認するテストスイートを含んでいます。</p>
</blockquote>
<h3 id="wr-the-workshop-runnerwrワークショップランナー"><a class="header" href="#wr-the-workshop-runnerwrワークショップランナー"><code>wr</code>, the workshop runner（<code>wr</code>、ワークショップランナー）</a></h3>
<p>To verify your solutions, we've provided a tool that will guide you through the course.
It is the <code>wr</code> CLI (short for "workshop runner").
Install it with:</p>
<blockquote>
<p>解答を確認するために、コースをガイドするツールを提供しています。
それは、<code>wr</code>CLI（「workshop runner」の略）です。
それを次の通りインストールしてください。</p>
</blockquote>
<pre><code class="language-bash">cargo install --locked workshop-runner
</code></pre>
<p>In a new terminal, navigate back to the top-level folder of the repository.
Run the <code>wr</code> command to start the course:</p>
<blockquote>
<p>新しいターミナルで、リポジトリの最上位フォルダーに移動してください。
そして、コースを開始するために<code>wr</code>コマンドを実行してください。</p>
</blockquote>
<pre><code class="language-bash">wr
</code></pre>
<p><code>wr</code> will verify the solution to the current exercise.<br />
Don't move on to the next section until you've solved the exercise for the current one.</p>
<blockquote>
<p><code>wr</code>は現在の演習の解答を検証します。
現在の演習を解決するまで、次の節に進まないでください。</p>
</blockquote>
<blockquote>
<p>We recommend committing your solutions to Git as you progress through the course,
so you can easily track your progress and "restart" from a known point if needed.</p>
</blockquote>
<blockquote>
<p>必要に応じて、容易に進捗を追跡したり、理解している場所から「再開」できるように、コースを進めるにつれて、解答をコミットすることをおすすめします。</p>
</blockquote>
<p>Enjoy the course!</p>
<blockquote>
<p>コースを楽しんでください！</p>
</blockquote>
<h2 id="author著者"><a class="header" href="#author著者">Author（著者）</a></h2>
<p>This course was written by <a href="https://www.lpalmieri.com/">Luca Palmieri</a>, Principal Engineering
Consultant at <a href="https://mainmatter.com/rust-consulting/">Mainmatter</a>.<br />
Luca has been working with Rust since 2018, initially at TrueLayer and then at AWS.<br />
Luca is the author of <a href="https://zero2prod.com">"Zero to Production in Rust"</a>,
the go-to resource for learning how to build backend applications in Rust.<br />
He is also the author and maintainer of a variety of open-source Rust projects, including
<a href="https://github.com/LukeMathWalker/cargo-chef"><code>cargo-chef</code></a>,
<a href="https://pavex.dev">Pavex</a> and <a href="https://github.com/LukeMathWalker/wiremock-rs"><code>wiremock</code></a>.</p>
<blockquote>
<p>このコースは、<code>Mainmatter</code>の主任エンジニアコンサルタントの<code>Luca Palmieri</code>によって記述されました。
Lucaは2018年からRustで作業しており、最初はTrueLayerで、その後はAWSで働いています。
Lucaは、Rustでバックエンドアプリケーションを構築する方法を学ぶためのリソースである<code>Zero to Production in Rust</code>の著者です。
また、彼は、<code>cargo-chef</code>、<code>Pavex</code>、<code>wiremock</code>などのさまざまなオープンソースのRustプロジェクトの著者およびメンテナーでもあります。</p>
</blockquote>
<h2 id="exercise"><a class="header" href="#exercise">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/01_intro/00_welcome"><code>01_intro/00_welcome</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="syntax構文"><a class="header" href="#syntax構文">Syntax（構文）</a></h1>
<div class="warning">
<p>Don't jump ahead!<br />
Complete the exercise for the previous section before you start this one.<br />
It's located in <code>exercises/01_intro/00_welcome</code>, in the <a href="https://github.com/mainmatter/100-exercises-to-learn-rust">course GitHub's repository</a>.<br />
Use <a href="01_intro/00_welcome.html#wr-the-workshop-runner"><code>wr</code></a> to start the course and verify your solutions.</p>
<blockquote>
<p>進みすぎないでください！
これを始める前に、前の節の演習を完成してください。
それは、GitHubリポジトリのコース内の<code>exercises/01_intro/00_welcome</code>にあります。
コースを開始して解答を確認するために<code>wr</code>を使用してください。</p>
</blockquote>
</div>
<p>The previous task doesn't even qualify as an exercise, but it already exposed you to quite a bit of Rust <strong>syntax</strong>.
We won't cover every single detail of Rust's syntax used in the previous exercise.
Instead, we'll cover <em>just enough</em> to keep going without getting stuck in the details.<br />
One step at a time!</p>
<blockquote>
<p>前のタスクは演習としての資格すらありませんが、すでにそれはRust<strong>構文</strong>のかなりの部分を公開しています。
前の演習で使用されたRustの構文のすべての詳細をカバーしません。
代わりに、詳細に行き詰まることなしに進み続けるために_ちょうど十分な_説明をする予定です。
1度に1つずつ！</p>
</blockquote>
<h2 id="commentsコメント"><a class="header" href="#commentsコメント">Comments（コメント）</a></h2>
<p>You can use <code>//</code> for single-line comments:</p>
<blockquote>
<p>1行コメントには<code>//</code>を使用できます。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// This is a single-line comment
// Followed by another single-line comment
<span class="boring">}</span></code></pre></pre>
<h2 id="functions関数"><a class="header" href="#functions関数">Functions（関数）</a></h2>
<p>Functions in Rust are defined using the <code>fn</code> keyword, followed by the function's name, its input parameters, and its
return type.
The function's body is enclosed in curly braces <code>{}</code>.</p>
<blockquote>
<p>Rustにおける関数は、<code>fn</code>キーワードを使用して定義され、関数の名前、その入力パラメーター、そして戻り値の型が続きます。
関数の本体は、波括弧<code>{}</code>で囲まれています。</p>
</blockquote>
<p>In previous exercise, you saw the <code>greeting</code> function:</p>
<blockquote>
<p>前の演習において、<code>greeting</code>関数を確認しました。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// `fn` &lt;function_name&gt; ( &lt;input parameters&gt; ) -&gt; &lt;return_type&gt; { &lt;body&gt; }
fn greeting() -&gt; &amp;'static str {
    // TODO: fix me 👇
    "I'm ready to __!"
}
<span class="boring">}</span></code></pre></pre>
<p><code>greeting</code> has no input parameters and returns a reference to a string slice (<code>&amp;'static str</code>).</p>
<blockquote>
<p><code>greeting</code>は入力パラメーターを持たず、文字列スライスへの参照（<code>&amp;'static str</code>）を返します。</p>
</blockquote>
<h3 id="return-type戻り値の型"><a class="header" href="#return-type戻り値の型">Return type（戻り値の型）</a></h3>
<p>The return type can be omitted from the signature if the function doesn't return anything (i.e. if it returns <code>()</code>,
Rust's unit type).
That's what happened with the <code>test_welcome</code> function:</p>
<blockquote>
<p>戻り値の型は、例えば、Rustのユニット型である<code>()</code>を返す場合など、関数が何も返さないとき、そのシグネチャーから省略できます。
それが、<code>test_welcome</code>関数で発生したことです。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn test_welcome() {
    assert_eq!(greeting(), "I'm ready to learn Rust!");
}
<span class="boring">}</span></code></pre></pre>
<p>The above is equivalent to:</p>
<blockquote>
<p>上記は、次と同等です。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Spelling out the unit return type explicitly
//                   👇
fn test_welcome() -&gt; () {
    assert_eq!(greeting(), "I'm ready to learn Rust!");
}
<span class="boring">}</span></code></pre></pre>
<h3 id="returning-values戻り値"><a class="header" href="#returning-values戻り値">Returning values（戻り値）</a></h3>
<p>The last expression in a function is implicitly returned:</p>
<blockquote>
<p>関数の最後の式は暗黙的に返されます。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn greeting() -&gt; &amp;'static str {
    // This is the last expression in the function
    // Therefore its value is returned by `greeting`
    "I'm ready to learn Rust!"
}
<span class="boring">}</span></code></pre></pre>
<p>You can also use the <code>return</code> keyword to return a value early:</p>
<blockquote>
<p>また、早期に値を返すために<code>return</code>キーワードを使用できます。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn greeting() -&gt; &amp;'static str {
    // Notice the semicolon at the end of the line!
    return "I'm ready to learn Rust!";
}
<span class="boring">}</span></code></pre></pre>
<p>It is considered idiomatic to omit the <code>return</code> keyword when possible.</p>
<blockquote>
<p>可能なとき<code>return</code>キーワードを省略することは、慣用的である考えられています。</p>
</blockquote>
<h3 id="input-parameters入力パラメーター"><a class="header" href="#input-parameters入力パラメーター">Input parameters（入力パラメーター）</a></h3>
<p>Input parameters are declared inside the parentheses <code>()</code> that follow the function's name.<br />
Each parameter is declared with its name, followed by a colon <code>:</code>, followed by its type.</p>
<blockquote>
<p>入力パラメーターは、関数名の後に続く括弧<code>()</code>内で宣言されます。
それぞれのパラメーターは、その名前、コロン<code>:</code>、その型を続けて宣言されます。</p>
</blockquote>
<p>For example, the <code>greet</code> function below takes a <code>name</code> parameter of type <code>&amp;str</code> (a "string slice"):</p>
<blockquote>
<p>例えば、下の<code>greet</code>関数は、<code>&amp;str</code>型（「文字列スライス」）の<code>name</code>パラメーターを受け取ります。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// An input parameter
//        👇
fn greet(name: &amp;str) -&gt; String {
    format!("Hello, {}!", name)
}
<span class="boring">}</span></code></pre></pre>
<p>If there are multiple input parameters, they must be separated with commas.</p>
<blockquote>
<p>複数の入力パラメーターがある場合、それらはカンマで区切られなければなりません。</p>
</blockquote>
<h3 id="type-annotations型注釈"><a class="header" href="#type-annotations型注釈">Type annotations（型注釈）</a></h3>
<p>Since we've been mentioned "types" a few times, let's state it clearly: Rust is a <strong>statically typed language</strong>.<br />
Every single value in Rust has a type and that type must be known to the compiler at compile-time.</p>
<blockquote>
<p>数回「型」について言及したため、それを明確に述べましょう。
Rustは<strong>静的型付け言語</strong>です。
Rustにおけるすべての単独の値は型を持ち、その型はコンパイル時にコンパイラーによって理解されなければなりません。</p>
</blockquote>
<p>Types are a form of <strong>static analysis</strong>.<br />
You can think of a type as a <strong>tag</strong> that the compiler attaches to every value in your program. Depending on the
tag, the compiler can enforce different rules—e.g. you can't add a string to a number, but you can add two numbers
together.
If leveraged correctly, types can prevent whole classes of runtime bugs.</p>
<blockquote>
<p>型は<strong>静的解析</strong>の1つの形態です。
型を、コンパイラーがプログラム内のすべての値に添付する<strong>タグ</strong>と考えることができます。
タグに依存して、コンパイラは異なるルールを強制することができます。
例えば、文字列と数値を足すことはできませんが、2つの数値同士であれば足せれます。
正確に利用されれば、型はランタイムで発生するバグの種類の全体を避けれます。</p>
</blockquote>
<h2 id="exercise-1"><a class="header" href="#exercise-1">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/01_intro/01_syntax"><code>01_intro/01_syntax</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a-basic-calculator基本的な計算機"><a class="header" href="#a-basic-calculator基本的な計算機">A Basic Calculator（基本的な計算機）</a></h1>
<p>In this chapter we'll learn how to use Rust as a <strong>calculator</strong>.<br />
It might not sound like much, but it'll give us a chance to cover a lot of Rust's basics, such as:</p>
<blockquote>
<p>この章では、<strong>計算機</strong>としてRustを使用する方法を学びます。
それは大げさに聞こえるかもしれませんが、次のようなRustの基本の多くを説明する機会を与えてくれます。</p>
</blockquote>
<ul>
<li>How to define and call functions</li>
<li>How to declare and use variables</li>
<li>Primitive types (integers and booleans)</li>
<li>Arithmetic operators (including overflow and underflow behavior)</li>
<li>Comparison operators</li>
<li>Control flow</li>
<li>Panics</li>
</ul>
<blockquote>
<ul>
<li>関数を定義そして呼び出す方法</li>
<li>変数を宣言して使用する方法</li>
<li>プリミティブ型（整数とブール値）</li>
<li>算術演算子（オーバーフローとアンダーフローの挙動を含む）</li>
<li>比較演算子</li>
<li>制御フロー</li>
<li>パニック</li>
</ul>
</blockquote>
<p>Nailing the basics with a few exercises will get the language flowing under your fingers.
When we move on to more complex topics, such as traits and ownership, you'll be able to focus on the new concepts
without getting bogged down by the syntax or other trivial details.</p>
<blockquote>
<p>いくつかの演習で基本を確実に物にすることで、言語が指先で流れるようになります。
トレイトや所有権のような、より複雑なトピックに進むとき、構文または他の些細な詳細の沼に陥ることなく、新しい概念に焦点を当てれます。</p>
</blockquote>
<h2 id="exercise-2"><a class="header" href="#exercise-2">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/02_basic_calculator/00_intro"><code>02_basic_calculator/00_intro</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="types-part-1型その1"><a class="header" href="#types-part-1型その1">Types, part 1（型、その1）</a></h1>
<p>In the <a href="02_basic_calculator/../01_intro/01_syntax.html">"Syntax" section</a> <code>compute</code>'s input parameters were of type <code>u32</code>.<br />
Let's unpack what that <em>means</em>.</p>
<blockquote>
<p>「構文」節において、<code>compute</code>の入力パラメーターは<code>u32</code>型でした。
それが何を意味するか解説しましょう。</p>
</blockquote>
<h2 id="primitive-typesプリミティブ型"><a class="header" href="#primitive-typesプリミティブ型">Primitive types（プリミティブ型）</a></h2>
<p><code>u32</code> is one of Rust's <strong>primitive types</strong>. Primitive types are the most basic building blocks of a language.
They're built into the language itself—i.e. they are not defined in terms of other types.</p>
<blockquote>
<p><code>u32</code>はRustの<strong>プリミティブ型</strong>の1つです。
プリミティブ型は言語の最も基本的な構成要素です。
それらは、言語自体に組み込まれており、つまり他の型に基づいて定義されていません。</p>
</blockquote>
<p>You can combine these primitive types to create more complex types. We'll see how soon enough.</p>
<blockquote>
<p>より複雑な型を作成するために、これらのプリミティブ型を組み合わせれます。
すぐにその方法を確認します。</p>
</blockquote>
<h2 id="integers整数"><a class="header" href="#integers整数">Integers（整数）</a></h2>
<p><code>u32</code>, in particular, is an <strong>unsigned 32-bit integer</strong>.</p>
<blockquote>
<p>特に<code>u32</code>は<strong>符号なし32ビット整数</strong>です。</p>
</blockquote>
<p>An integer is a number that can be written without a fractional component. E.g. <code>1</code> is an integer, while <code>1.2</code> is not.</p>
<blockquote>
<p>整数は、小数部分なしで記述できる数値です。
例えば、<code>1</code>は整数ですが、<code>1.2</code>は整数ではありません。</p>
</blockquote>
<h3 id="signed-vs-unsigned符号付きと符号なし"><a class="header" href="#signed-vs-unsigned符号付きと符号なし">Signed vs. unsigned（符号付きと符号なし）</a></h3>
<p>An integer can be <strong>signed</strong> or <strong>unsigned</strong>.<br />
An unsigned integer can only represent non-negative numbers (i.e. <code>0</code> or greater).
A signed integer can represent both positive and negative numbers (e.g. <code>-1</code>, <code>12</code>, etc.).</p>
<blockquote>
<p>整数は<strong>符号付き</strong>または<strong>符号なし</strong>になります。
符号なし整数は、例えば0またはそれより大きい非負数のみを表現できます。
符号付き整数は、正と負の数の両方を表現できます。</p>
</blockquote>
<p>The <code>u</code> in <code>u32</code> stands for <strong>unsigned</strong>.<br />
The equivalent type for signed integer is <code>i32</code>, where the <code>i</code> stands for integer (i.e. any integer, positive or
negative).</p>
<blockquote>
<p><code>u32</code>の<code>u</code>は<strong>符号なし</strong>に由来します。
符号付き整数と同等の型は<code>i32</code>で、<code>i</code>は整数（例えば、正または負の任意の整数）に由来します。</p>
</blockquote>
<h3 id="bit-widthビット幅"><a class="header" href="#bit-widthビット幅">Bit width（ビット幅）</a></h3>
<p>The <code>32</code> in <code>u32</code> refers to the <strong>number of bits<sup class="footnote-reference"><a href="#bit">1</a></sup></strong> used to represent the number in memory.<br />
The more bits, the larger the range of numbers that can be represented.</p>
<blockquote>
<p><code>u32</code>の<code>32</code>は、メモリ内でその数を表現するために使用される<strong>ビット数</strong>を指します。
ビット数が多いほど、表現できる数値の範囲が広がります。</p>
</blockquote>
<p>Rust supports multiple bit widths for integers: <code>8</code>, <code>16</code>, <code>32</code>, <code>64</code>, <code>128</code>.</p>
<blockquote>
<p>Rustは、整数に対して<code>8</code>、<code>16</code>、<code>32</code>、<code>64</code>、<code>128</code>の複数のビット幅をサポートしています。</p>
</blockquote>
<p>With 32 bits, <code>u32</code> can represent numbers from <code>0</code> to <code>2^32 - 1</code> (a.k.a. <a href="https://doc.rust-lang.org/std/primitive.u32.html#associatedconstant.MAX"><code>u32::MAX</code></a>).<br />
With the same number of bits, a signed integer (<code>i32</code>) can represent numbers from <code>-2^31</code> to <code>2^31 - 1</code>
(i.e. from <a href="https://doc.rust-lang.org/std/primitive.i32.html#associatedconstant.MIN"><code>i32::MIN</code></a>
to <a href="https://doc.rust-lang.org/std/primitive.i32.html#associatedconstant.MAX"><code>i32::MAX</code></a>).<br />
The maximum value for <code>i32</code> is smaller than the maximum value for <code>u32</code> because one bit is used to represent
the sign of the number. Check out the <a href="https://en.wikipedia.org/wiki/Two%27s_complement">two's complement</a>
representation for more details on how signed integers are represented in memory.</p>
<blockquote>
<p>32ビット幅の場合、<code>u32</code>は<code>0</code>から<code>2^32 - 1</code>（<code>u32::MAX</code>として知られる）までの数値を表現できます。
同じビット数の場合、符号付き整数（<code>i32</code>）は<code>-2^31</code>から<code>2^31 - 1</code>（<code>i32::MIN</code>から<code>i32::MAX</code>）までの数値を表現できます。
<code>i32</code>の最大値は<code>u32</code>の最大値よりも小さいです。なぜなら、1ビットが数値の符号を表現するために使用されるからです。
メモリ内で符号付き整数を表現する方法の詳細は、<code>2の補数</code>表現を参照してください。</p>
</blockquote>
<h3 id="summaryまとめ"><a class="header" href="#summaryまとめ">Summary（まとめ）</a></h3>
<p>Combining the two variables (signed/unsigned and bit width), we get the following integer types:</p>
<blockquote>
<p>符号付き／符号なしとビット幅の2つの変数の組み合わせで、次の整数型が得られます。</p>
</blockquote>
<div class="table-wrapper"><table><thead><tr><th>Bit width</th><th>Signed</th><th>Unsigned</th></tr></thead><tbody>
<tr><td>8-bit</td><td><code>i8</code></td><td><code>u8</code></td></tr>
<tr><td>16-bit</td><td><code>i16</code></td><td><code>u16</code></td></tr>
<tr><td>32-bit</td><td><code>i32</code></td><td><code>u32</code></td></tr>
<tr><td>64-bit</td><td><code>i64</code></td><td><code>u64</code></td></tr>
<tr><td>128-bit</td><td><code>i128</code></td><td><code>u128</code></td></tr>
</tbody></table>
</div>
<h2 id="literalsリテラル"><a class="header" href="#literalsリテラル">Literals（リテラル）</a></h2>
<p>A <strong>literal</strong> is a notation for representing a fixed value in source code.<br />
For example, <code>42</code> is a Rust literal for the number forty-two.</p>
<blockquote>
<p><strong>リテラル</strong>は、ソースコード内で固定された値を表現するための表記法です。
例えば、<code>42</code>は数値42のRustのリテラルです。</p>
</blockquote>
<h3 id="type-annotations-for-literalsリテラルの型注釈"><a class="header" href="#type-annotations-for-literalsリテラルの型注釈">Type annotations for literals（リテラルの型注釈）</a></h3>
<p>But all values in Rust have a type, so... what's the type of <code>42</code>?</p>
<blockquote>
<p>しかし、Rustにおけるすべての値は型を持つため、<code>42</code>の型は何でしょうか？</p>
</blockquote>
<p>The Rust compiler will try to infer the type of a literal based on how it's used.<br />
If you don't provide any context, the compiler will default to <code>i32</code> for integer literals.<br />
If you want to use a different type, you can add the desired integer type as a suffix—e.g. <code>2u64</code> is a 2 that's
explicitly typed as a <code>u64</code>.</p>
<blockquote>
<p>Rustのコンパイラーは、それが使用される方法に基づいてリテラルの型を推論することを試みます。
何らかの文脈を提供しない場合、コンパイラーは整数リテラルに対してデフォルトで<code>i32</code>を与えます。
異なる型を使用したい場合、接尾辞として望ましい整数型を追加できます。
例えば、<code>2u64</code>は、<code>u64</code>として明示的に型付けられた2です。</p>
</blockquote>
<h3 id="underscores-in-literalsリテラル内のアンダースコア"><a class="header" href="#underscores-in-literalsリテラル内のアンダースコア">Underscores in literals（リテラル内のアンダースコア）</a></h3>
<p>You can use underscores <code>_</code> to improve the readability of large numbers.<br />
For example, <code>1_000_000</code> is the same as <code>1000000</code>.</p>
<blockquote>
<p>大きな数の可読性を改善するために、アンダースコア<code>_</code>を使用できます。
例えば、<code>1_000_000</code>は<code>1000000</code>と同じです。</p>
</blockquote>
<h2 id="arithmetic-operators算術演算子"><a class="header" href="#arithmetic-operators算術演算子">Arithmetic operators（算術演算子）</a></h2>
<p>Rust supports the following arithmetic operators<sup class="footnote-reference"><a href="#traits">2</a></sup> for integers:</p>
<ul>
<li><code>+</code> for addition</li>
<li><code>-</code> for subtraction</li>
<li><code>*</code> for multiplication</li>
<li><code>/</code> for division</li>
<li><code>%</code> for remainder</li>
</ul>
<blockquote>
<p>Rustは整数のために次の算術演算子をサポートしています。</p>
<ul>
<li><code>+</code>: 加算</li>
<li><code>-</code>: 減算</li>
<li><code>*</code>: 乗算</li>
<li><code>/</code>: 除算</li>
<li><code>%</code>: 剰余</li>
</ul>
</blockquote>
<p>Precedence and associativity rules for these operators are the same as in mathematics.<br />
You can use parentheses to override the default precedence. E.g. <code>2 * (3 + 4)</code>.</p>
<blockquote>
<p>これらの演算子の優先順位と結合性のルールは、数学と同じです。
デフォルトの優先順位を上書きするためにカッコを使用できます。
例えば、<code>2 * (3 + 4)</code>。</p>
</blockquote>
<blockquote>
<p>⚠️ <strong>Warning</strong></p>
<p>The division operator <code>/</code> performs integer division when used with integer types.
I.e. the result is truncated towards zero. For example, <code>5 / 2</code> is <code>2</code>, not <code>2.5</code>.</p>
</blockquote>
<blockquote>
<p>⚠️ <strong>警告</strong>
除算演算子<code>/</code>は、整数型と使用すると整数除算を行います。
つまり、結果はゼロに向かって切り捨てられます。
例えば、<code>5 / 2</code>は<code>2</code>であり、<code>2.5</code>ではありません。</p>
</blockquote>
<h2 id="no-automatic-type-coercion自動型強制なし"><a class="header" href="#no-automatic-type-coercion自動型強制なし">No automatic type coercion（自動型強制なし）</a></h2>
<p>As we discussed in the previous exercise, Rust is a statically typed language.<br />
In particular, Rust is quite strict about type coercion. It won't automatically convert a value from one type to
another<sup class="footnote-reference"><a href="#coercion">3</a></sup>,
even if the conversion is lossless. You have to do it explicitly.</p>
<blockquote>
<p>前の演習で議論したように、Rustは静的型付け言語です。
特に、Rustは、型強制についてかなり厳格です。
それは、変換が損失なしでも、値をある型から他の型に自動で変換しません。
明示的にそれを行わなければなりません。</p>
</blockquote>
<p>For example, you can't assign a <code>u8</code> value to a variable with type <code>u32</code>, even though all <code>u8</code> values are valid <code>u32</code>
values:</p>
<blockquote>
<p>例えば、すべての<code>u8</code>値は有効な<code>u32</code>値にも関わらず、<code>u32</code>型である変数に<code>u8</code>値を割り当てることはできません。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let b: u8 = 100;
let a: u32 = b;
<span class="boring">}</span></code></pre></pre>
<p>It'll throw a compilation error:</p>
<blockquote>
<p>それはコンパイルエラーを投げます。</p>
</blockquote>
<pre><code class="language-text">error[E0308]: mismatched types
  |
3 |     let a: u32 = b;
  |            ---   ^ expected `u32`, found `u8`
  |            |
  |            expected due to this
  |
</code></pre>
<p>We'll see how to convert between types <a href="02_basic_calculator/../04_traits/09_from.html">later in this course</a>.</p>
<blockquote>
<p>型の変換方法はこのコースの後半で確認します。</p>
</blockquote>
<h2 id="further-reading参考文献"><a class="header" href="#further-reading参考文献">Further reading（参考文献）</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch03-02-data-types.html#integer-types">The integer types section</a> in the official Rust book</li>
</ul>
<blockquote>
<ul>
<li>整数型節: 公式Rustブック</li>
</ul>
</blockquote>
<div class="footnote-definition" id="bit"><sup class="footnote-definition-label">1</sup>
<p>A bit is the smallest unit of data in a computer. It can only have two values: <code>0</code> or <code>1</code>.コンピューター内の最も小さなデータ単位です。それは<code>0</code>または<code>1</code>の2つの値しか持つことができません。</p>
</div>
<div class="footnote-definition" id="traits"><sup class="footnote-definition-label">2</sup>
<p>Rust doesn't let you define custom operators, but it puts you in control of how the built-in operators
behave.
We'll talk about operator overloading <a href="02_basic_calculator/../04_traits/03_operator_overloading.html">later in the course</a>, after we've covered traits.
Rustは独自の演算子を定義することを許可しませんが、組み込み演算子の振る舞いを制御する事ができます。
コースの後半でトレイトを説明した後、演算子のオーバーロードについて話します。</p>
</div>
<div class="footnote-definition" id="coercion"><sup class="footnote-definition-label">3</sup>
<p>There are some exceptions to this rule, mostly related to references, smart pointers and ergonomics. We'll
cover those <a href="02_basic_calculator/../04_traits/07_deref.html">later on</a>.
A mental model of "all conversions are explicit" will serve you well in the meantime.
このルールにはいくつかの例外があり、多くは参照、スマートポインターそして人間工学に関連します。それらは後で説明します。
「すべての変換は明示的である」というメンタルモデルは、それまでの間に役立ちます。</p>
</div>
<h2 id="exercise-3"><a class="header" href="#exercise-3">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/02_basic_calculator/01_integers"><code>02_basic_calculator/01_integers</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="variables変数"><a class="header" href="#variables変数">Variables（変数）</a></h1>
<p>In Rust, you can use the <code>let</code> keyword to declare <strong>variables</strong>.<br />
For example:</p>
<blockquote>
<p>Rustにおいて、<strong>変数</strong>を宣言するために<code>let</code>キーワードを使用できます。
例えば・・・</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 42;
<span class="boring">}</span></code></pre></pre>
<p>Above we defined a variable <code>x</code> and assigned it the value <code>42</code>.</p>
<blockquote>
<p>上記で変数<code>x</code>を定義して、その値に<code>42</code>を割り当てました。</p>
</blockquote>
<h2 id="type型"><a class="header" href="#type型">Type（型）</a></h2>
<p>Every variable in Rust must have a type. It can either be inferred by the compiler or explicitly specified by the
developer.</p>
<blockquote>
<p>Rustにおいて、すべての変数は型を持たなくてはなりません。
型はコンパイラーによって推論されるか、開発者によって明示的に指定されるかのどちらかです。</p>
</blockquote>
<h3 id="explicit-type-annotation明示的な型注釈"><a class="header" href="#explicit-type-annotation明示的な型注釈">Explicit type annotation（明示的な型注釈）</a></h3>
<p>You can specify the variable type by adding a colon <code>:</code> followed by the type after the variable name. For example:</p>
<blockquote>
<p>変数名の後に、コロン<code>:</code>と型を追加することで、変数の型を指定できます。
例えば・・・</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// let &lt;variable_name&gt;: &lt;type&gt; = &lt;expression&gt;;
let x: u32 = 42;
<span class="boring">}</span></code></pre></pre>
<p>In the example above, we explicitly constrained the type of <code>x</code> to be <code>u32</code>.</p>
<blockquote>
<p>上記の例で、<code>u32</code>で<code>x</code>の型を明示的に制約しました。</p>
</blockquote>
<h3 id="type-inference型推論"><a class="header" href="#type-inference型推論">Type inference（型推論）</a></h3>
<p>If we don't specify the type of a variable, the compiler will try to infer it based on the context in which the variable
is used.</p>
<blockquote>
<p>変数の型を指定しない場合、コンパイラーは変数が使用される文脈に基づいて推論を試みます。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 42;
let y: u32 = x;
<span class="boring">}</span></code></pre></pre>
<p>In the example above, we didn't specify the type of <code>x</code>.<br />
<code>x</code> is later assigned to <code>y</code>, which is explicitly typed as <code>u32</code>. Since Rust doesn't perform automatic type coercion,
the compiler infers the type of <code>x</code> to be <code>u32</code>—the same as <code>y</code> and the only type that will allow the program to compile
without errors.</p>
<blockquote>
<p>上記の例で、<code>x</code>の型を指定していません。
<code>x</code>は、後で<code>y</code>に割り当てれれ、それは明示的に<code>u32</code>型として型付けられています。
Rustは自動的に型強制をしないため、コンパイラーは<code>x</code>の型に<code>u32</code>を推論します。
<code>u32</code>は、<code>y</code>とエラーなしでプログラムをコンパイルできる唯一の型です。</p>
</blockquote>
<h3 id="inference-limitations推論の制限"><a class="header" href="#inference-limitations推論の制限">Inference limitations（推論の制限）</a></h3>
<p>The compiler sometimes needs a little help to infer the correct variable type based on its usage.<br />
In those cases you'll get a compilation error and the compiler will ask you to provide an explicit type hint to
disambiguate the situation.</p>
<blockquote>
<p>時々、コンパイラーは、変数の使用に基づいて正確に変数の型を推論するために少し助けが必要です。
そのような場面では、コンパイルエラーが発生して、状況の曖昧さをなくすためにコンパイラーは明示的なヒントを提供するように要求します。</p>
</blockquote>
<h2 id="function-arguments-are-variables関数の引数と変数"><a class="header" href="#function-arguments-are-variables関数の引数と変数">Function arguments are variables（関数の引数と変数）</a></h2>
<p>Not all heroes wear capes, not all variables are declared with <code>let</code>.<br />
Function arguments are variables too!</p>
<blockquote>
<p>すべてのヒーローがマントを付けているわけでななく、すべての変数は<code>let</code>で宣言されるわけではありません。
関数引数も変数です！</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn add_one(x: u32) -&gt; u32 {
    x + 1
}
<span class="boring">}</span></code></pre></pre>
<p>In the example above, <code>x</code> is a variable of type <code>u32</code>.<br />
The only difference between <code>x</code> and a variable declared with <code>let</code> is that functions arguments <strong>must</strong> have their type
explicitly declared. The compiler won't infer it for you.<br />
This constraint allows the Rust compiler (and us humans!) to understand the function's signature without having to look
at its implementation. That's a big boost for compilation speed<sup class="footnote-reference"><a href="#speed">1</a></sup>!</p>
<blockquote>
<p>上記例で、<code>x</code>は<code>u32</code>型の変数です。
<code>x</code>と<code>let</code>で宣言された変数の唯一の違いは、関数の引数はそれらの型を明示的に宣言されなければならないことです。
コンパイラーはそれを推論しません。
この制約は、Rustコンパイラー（そして私たち人間！）が実装を確認しなくても関数のシグネチャを理解できるようにします。
それは、コンパイル速度を大きく向上させます。</p>
</blockquote>
<h2 id="initialization初期化"><a class="header" href="#initialization初期化">Initialization（初期化）</a></h2>
<p>You don't have to initialize a variable when you declare it.<br />
For example</p>
<blockquote>
<p>変数を宣言したとき、変数を初期化する必要はありません。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: u32;
<span class="boring">}</span></code></pre></pre>
<p>is a valid variable declaration.<br />
However, you must initialize the variable before using it. The compiler will throw an error if you don't:</p>
<blockquote>
<p>上記は、妥当な変数宣言です。
しかし、それを使用する前に変数を初期化しなくてはなりません。
それをしない場合、コンパイラーはエラーを投げます。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: u32;
let y = x + 1;
<span class="boring">}</span></code></pre></pre>
<p>will throw a compilation error:</p>
<blockquote>
<p>上記はコンパイルエラーを投げます。</p>
</blockquote>
<pre><code class="language-text">error[E0381]: used binding `x` isn't initialized
 --&gt; src/main.rs:3:9
  |
2 | let x: u32;
  |     - binding declared here but left uninitialized
3 | let y = x + 1;
  |         ^ `x` used here but it isn't initialized
  |
help: consider assigning a value
  |
2 | let x: u32 = 0;
  |            +++
</code></pre>
<div class="footnote-definition" id="speed"><sup class="footnote-definition-label">1</sup>
<p>The Rust compiler needs all the help it can get when it comes to compilation speed.
Rustコンパイラーは、コンパイル速度に関して、可能な限りの助けを必要としています。</p>
</div>
<h2 id="exercise-4"><a class="header" href="#exercise-4">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/02_basic_calculator/02_variables"><code>02_basic_calculator/02_variables</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="control-flow-part-1制御フローその1"><a class="header" href="#control-flow-part-1制御フローその1">Control flow, part 1（制御フロー、その1）</a></h1>
<p>All our programs so far have been pretty straightforward.<br />
A sequence of instructions is executed from top to bottom, and that's it.</p>
<blockquote>
<p>これまで、すべてのプログラムは、とても単純でした。
命令のシーケンスは、上から下に実行され、それだけです。</p>
</blockquote>
<p>It's time to introduce some <strong>branching</strong>.</p>
<blockquote>
<p><strong>分岐</strong>を導入する時です。</p>
</blockquote>
<h2 id="if-clausesif節"><a class="header" href="#if-clausesif節"><code>if</code> clauses（if節）</a></h2>
<p>The <code>if</code> keyword is used to execute a block of code only if a condition is true.
Here's a simple example:</p>
<blockquote>
<p><code>if</code>キーワードは、<code>if</code>条件がtrueの場合のみ、コードブロックを実行するために使用されます。
ここに単純な例を示します。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let number = 3;
if number &lt; 5 {
    println!("`number` is smaller than 5");
}
<span class="boring">}</span></code></pre></pre>
<p>This program will print <code>number is smaller than 5</code> because the condition <code>number &lt; 5</code> is true.</p>
<blockquote>
<p>このプログラムは、条件<code>number &lt; 5</code>はtrueであるため、<code>number is smaller than 5</code>を表示します。</p>
</blockquote>
<h3 id="else-clauseselse節"><a class="header" href="#else-clauseselse節"><code>else</code> clauses（else節）</a></h3>
<p>Like most programming languages, Rust supports an optional <code>else</code> branch to execute a block of code when the condition in an
<code>if</code> expression is false.<br />
For example:</p>
<blockquote>
<p>ほとんどのプログラミング言語と同様に、Rustは<code>if</code>式内の条件がfalseのときにコードブロックを実行するオプションの<code>else</code>分岐をサポートしています。
例えば・・・</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let number = 3;

if number &lt; 5 {
    println!("`number` is smaller than 5");
} else {
    println!("`number` is greater than or equal to 5");
}
<span class="boring">}</span></code></pre></pre>
<h2 id="booleansブーリアン"><a class="header" href="#booleansブーリアン">Booleans（ブーリアン）</a></h2>
<p>The condition in an <code>if</code> expression must be of type <code>bool</code>, a <strong>boolean</strong>.<br />
Booleans, just like integers, are a primitive type in Rust.</p>
<blockquote>
<p><code>if</code>式内の条件は<strong>ブーリアン</strong>である<code>bool</code>型にならなくてはなりません。
ちょうど整数のように、ブーリアンはRustにおけるプリミティブ型です。</p>
</blockquote>
<p>A boolean can have one of two values: <code>true</code> or <code>false</code>.</p>
<blockquote>
<p>ブーリアンは、<code>true</code>または<code>false</code>の2つの値のうちの1つになります。</p>
</blockquote>
<h3 id="no-truthy-or-falsy-values真のようなまた偽のような値がない"><a class="header" href="#no-truthy-or-falsy-values真のようなまた偽のような値がない">No truthy or falsy values（真のような、また偽のような値がない）</a></h3>
<p>If the condition in an <code>if</code> expression is not a boolean, you'll get a compilation error.
For example, the following code will not compile:</p>
<blockquote>
<p><code>if</code>式内の条件がブーリアンでない場合、コンパイルエラーが発生します。
例えば、次のコードはコンパイルされません。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let number = 3;
if number {
    println!("`number` is not zero");
}
<span class="boring">}</span></code></pre></pre>
<p>You'll get the following compilation error:</p>
<blockquote>
<p>次のコンパイルエラーが発生します。</p>
</blockquote>
<pre><code class="language-text">error[E0308]: mismatched types
 --&gt; src/main.rs:3:8
  |
3 |     if number {
  |        ^^^^^^ expected `bool`, found integer
</code></pre>
<p>This follows from Rust's philosophy around type coercion: there's no automatic conversion from non-boolean types to booleans.
Rust doesn't have the concept of <strong>truthy</strong> or <strong>falsy</strong> values, like JavaScript or Python.<br />
You have to be explicit about the condition you want to check.</p>
<blockquote>
<p>これは、Rustの型強制まわりの哲学に従っています。
非ブーリアン型からブーリアンへの自動変換はありません。
JavaScriptまたはPythonのように、Rustは<strong>真のような</strong>または<strong>偽のような</strong>値の概念がありません。
確認したい条件について明示的でなければなりません。</p>
</blockquote>
<h3 id="comparison-operators比較演算子"><a class="header" href="#comparison-operators比較演算子">Comparison operators（比較演算子）</a></h3>
<p>It's quite common to use comparison operators to build conditions for <code>if</code> expressions.<br />
Here are the comparison operators available in Rust when working with integers:</p>
<ul>
<li><code>==</code>: equal to</li>
<li><code>!=</code>: not equal to</li>
<li><code>&lt;</code>: less than</li>
<li><code>&gt;</code>: greater than</li>
<li><code>&lt;=</code>: less than or equal to</li>
<li><code>&gt;=</code>: greater than or equal to</li>
</ul>
<blockquote>
<p><code>if</code>式の条件を構築するために比較演算子を使用することは、とても一般的です。
ここに、整数と一緒に機能する、Rustで利用できる比較演算子を示します。</p>
<ul>
<li><code>==</code>: 等しい</li>
<li><code>!=</code>: 等しくない</li>
<li><code>&lt;</code>: より小さい</li>
<li><code>&gt;</code>: より大きい</li>
<li><code>&lt;=</code>: 以下</li>
<li><code>&gt;=</code>: 以上</li>
</ul>
</blockquote>
<h2 id="ifelse-is-an-expressionifelseは式"><a class="header" href="#ifelse-is-an-expressionifelseは式"><code>if/else</code> is an expression（if/elseは式）</a></h2>
<p>In Rust, <code>if</code> expressions are <strong>expressions</strong>, not statements: they return a value.<br />
That value can be assigned to a variable or used in other expressions. For example:</p>
<blockquote>
<p>Rustで、<code>if</code>式は<strong>式</strong>で、文ではありません。それらは値を返します。
その値は変数に割り当てる、または他の式の中で使用できます。
例えば・・・</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let number = 3;
let message = if number &lt; 5 {
    "smaller than 5"
} else {
    "greater than or equal to 5"
};
<span class="boring">}</span></code></pre></pre>
<p>In the example above, each branch of the <code>if</code> evaluates to a string literal,
which is then assigned to the <code>message</code> variable.<br />
The only requirement is that both <code>if</code> branches return the same type.</p>
<blockquote>
<p>上記例で、<code>if</code>のそれぞれのブランチは、文字列リテラルに評価され、それは<code>message</code>変数に割り当てられます。
唯一の要求事項は、両方の<code>if</code>ブランチが同じ型を返すことです。</p>
</blockquote>
<h2 id="exercise-5"><a class="header" href="#exercise-5">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/02_basic_calculator/03_if_else"><code>02_basic_calculator/03_if_else</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="panicsパニック"><a class="header" href="#panicsパニック">Panics（パニック）</a></h1>
<p>Let's go back to the <code>speed</code> function you wrote for the <a href="02_basic_calculator/02_variables.html">"Variables" section</a>.
It probably looked something like this:</p>
<blockquote>
<p>「変数」節で記述した<code>speed</code>関数に戻りましょう。
それはおそらく次のように見えたでしょう。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn speed(start: u32, end: u32, time_elapsed: u32) -&gt; u32 {
    let distance = end - start;
    distance / time_elapsed
}
<span class="boring">}</span></code></pre></pre>
<p>If you have a keen eye, you might have spotted one issue<sup class="footnote-reference"><a href="#one">1</a></sup>: what happens if <code>time_elapsed</code> is zero?</p>
<blockquote>
<p>もし注意深い目を持っている場合、1つの問題点があることに気づいたかもしれません。<code>time_elapses</code>がゼロの場合、何が起こるでしょうか？</p>
</blockquote>
<p>You can try it
out <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=36e5ddbe3b3f741dfa9f74c956622bac">on the Rust playground</a>!<br />
The program will exit with the following error message:</p>
<blockquote>
<p><code>Rust playground</code>で試すことができます！
プログラムは、次のエラーメッセージで終了します。</p>
</blockquote>
<pre><code class="language-text">thread 'main' panicked at src/main.rs:3:5:
attempt to divide by zero
</code></pre>
<blockquote>
<pre><code class="language-text">`main`スレッドは、src/main.rs:3:5でパニックしました：
ゼロで割ろうと試みています
</code></pre>
</blockquote>
<p>This is known as a <strong>panic</strong>.<br />
A panic is Rust's way to signal that something went so wrong that
the program can't continue executing, it's an <strong>unrecoverable error</strong><sup class="footnote-reference"><a href="#catching">2</a></sup>. Division by zero classifies as such an
error.</p>
<blockquote>
<p>これは<strong>パニック</strong>として知られています。
パニックは、プログラムが実行を継続できない何か悪い状態になったことを示すRustの方法です。
それは<strong>回復不能なエラー</strong>です。
ゼロ割りはそのようなエラーに分類されます。</p>
</blockquote>
<h2 id="the-panic-macropanicマクロ"><a class="header" href="#the-panic-macropanicマクロ">The panic! macro（panic!マクロ）</a></h2>
<p>You can intentionally trigger a panic by calling the <code>panic!</code> macro<sup class="footnote-reference"><a href="#macro">3</a></sup>:</p>
<blockquote>
<p><code>panic!</code>マクロを呼び出すことで、意図的にパニックを起こせます。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">fn main() {
    panic!("This is a panic!");
    // The line below will never be executed
    // 下の行は決して実行されません
    let x = 1 + 2;
}</code></pre></pre>
<p>There are other mechanisms to work with recoverable errors in Rust, which <a href="02_basic_calculator/../05_ticket_v2/06_fallibility.html">we'll cover later</a>.
For the time being we'll stick with panics as a brutal but simple stopgap solution.</p>
<blockquote>
<p>Rustには回復可能なエラーと一緒に機能する他のメカニズムがあり、それは後で説明します。
当分は、野蛮ですが単純な一時しのぎの解決策としてパニックに固執します。</p>
</blockquote>
<h2 id="further-reading参考資料"><a class="header" href="#further-reading参考資料">Further reading（参考資料）</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/std/macro.panic.html">The panic! macro documentation</a></li>
</ul>
<div class="footnote-definition" id="one"><sup class="footnote-definition-label">1</sup>
<p>There's another issue with <code>speed</code> that we'll address soon enough. Can you spot it?
<code>speed</code>には十分すぐに対処できる別の問題があります。それを見つけることはできますか？</p>
</div>
<div class="footnote-definition" id="catching"><sup class="footnote-definition-label">2</sup>
<p>You can try to catch a panic, but it should be a last resort attempt reserved for very specific
circumstances.
パニックをキャッチすることを試みることができますが、それはとても特定な状況に予約された最後の手段であるべきです。</p>
</div>
<div class="footnote-definition" id="macro"><sup class="footnote-definition-label">3</sup>
<p>If it's followed by a <code>!</code>, it's a macro invocation. Think of macros as spicy functions for now. We'll
cover them in more detail later in the course.
それに<code>!</code>が続く場合、それはマクロ呼び出しです。
現段階では、スパイシーな関数としてマクロを考えてください。
コースの後半で詳細にそれらを説明します。</p>
</div>
<h2 id="exercise-6"><a class="header" href="#exercise-6">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/02_basic_calculator/04_panics"><code>02_basic_calculator/04_panics</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="factorial階乗"><a class="header" href="#factorial階乗">Factorial（階乗）</a></h1>
<p>So far you've learned:</p>
<ul>
<li>How to define a function</li>
<li>How to call a function</li>
<li>Which integer types are available in Rust</li>
<li>Which arithmetic operators are available for integers</li>
<li>How to execute conditional logic via comparisons and <code>if</code>/<code>else</code> expressions</li>
</ul>
<p>It looks like you're ready to tackle factorials!</p>
<blockquote>
<p>これまで、次を学びました。</p>
<ul>
<li>関数を定義する方法</li>
<li>関数を呼び出す方法</li>
<li>Rustで利用可能な整数型</li>
<li>整数のために利用できる算術演算子</li>
<li>比較と<code>if</code>/<code>else</code>式を介して条件的なロジックを実行する方法</li>
</ul>
<p>階乗に取り組む準備ができたようです！</p>
</blockquote>
<h2 id="exercise-7"><a class="header" href="#exercise-7">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/02_basic_calculator/05_factorial"><code>02_basic_calculator/05_factorial</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="loops-part-1-whileループその1-while"><a class="header" href="#loops-part-1-whileループその1-while">Loops, part 1: <code>while</code>（ループ、その1: while）</a></h1>
<p>Your implementation of <code>factorial</code> has been forced to use recursion.<br />
This may feel natural to you, especially if you're coming from a functional programming background.
Or it may feel strange, if you're used to more imperative languages like C or Python.</p>
<blockquote>
<p><code>factorial</code>の実装は、再帰を使用するように強制されました。
特に関数プログラミングをバックグラウンドに持っている場合、これは自然に感じるかもしれません。
また、CやPythonのような命令的な言語を使用してきた場合、奇妙に感じたかもしれません。</p>
</blockquote>
<p>Let's see how you can implement the same functionality using a <strong>loop</strong> instead.</p>
<blockquote>
<p>代わりに<strong>ループ</strong>を使用して同じ機能を実装する方法を確認しましょう。</p>
</blockquote>
<h2 id="the-while-loopwhileループ"><a class="header" href="#the-while-loopwhileループ">The <code>while</code> loop（whileループ）</a></h2>
<p>A <code>while</code> loop is a way to execute a block of code as long as a <strong>condition</strong> is true.<br />
Here's the general syntax:</p>
<blockquote>
<p><code>while</code>ループは、<strong>条件</strong>がtrueである限りコードブロックを実行する方法です。
ここに一般的な構文を示します。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>while &lt;condition&gt; {
    // code to execute
}
<span class="boring">}</span></code></pre></pre>
<p>For example, we might want to sum the numbers from 1 to 5:</p>
<blockquote>
<p>例えば、1から5までの数を合計したいとします。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let sum = 0;
let i = 1;
// "while i is less than or equal to 5"
// iが5より小さいか等しい間
while i &lt;= 5 {
    // `+=` is a shorthand for `sum = sum + i`
    // `+=`は`sum = sum + i`の省略形です
    sum += i;
    i += 1;
}
<span class="boring">}</span></code></pre></pre>
<p>This will keep adding 1 to <code>i</code> and <code>i</code> to <code>sum</code> until <code>i</code> is no longer less than or equal to 5.</p>
<blockquote>
<p>これは、<code>i</code>が5以下でなくなるまで、1を<code>i</code>に、<code>i</code>を<code>sum</code>に追加し続けます。</p>
</blockquote>
<h2 id="the-mut-keywordmutキーワード"><a class="header" href="#the-mut-keywordmutキーワード">The <code>mut</code> keyword（mutキーワード）</a></h2>
<p>The example above won't compile as is. You'll get an error like:</p>
<blockquote>
<p>上記例はコンパイルされません。次のようなエラーが発生します。</p>
</blockquote>
<pre><code class="language-text">error[E0384]: cannot assign twice to immutable variable `sum`
 --&gt; src/main.rs:7:9
  |
2 |     let sum = 0;
  |         ---
  |         |
  |         first assignment to `sum`
  |         help: consider making this binding mutable: `mut sum`
...
7 |         sum += i;
  |         ^^^^^^^^ cannot assign twice to immutable variable

error[E0384]: cannot assign twice to immutable variable `i`
 --&gt; src/main.rs:8:9
  |
3 |     let i = 1;
  |         -
  |         |
  |         first assignment to `i`
  |         help: consider making this binding mutable: `mut i`
...
8 |         i += 1;
  |         ^^^^^^ cannot assign twice to immutable variable
</code></pre>
<p>This is because variables in Rust are <strong>immutable</strong> by default.<br />
You can't change their value once it has been assigned.</p>
<blockquote>
<p>これは、デフォルトでRustの変数が<strong>不変</strong>であるためです。
一度、変数が値を割り当てられると、それらの値を変更できません。</p>
</blockquote>
<p>If you want to allow modifications, you have to declare the variable as <strong>mutable</strong> using the <code>mut</code> keyword:</p>
<blockquote>
<p>変更を許可したい場合、<code>mut</code>キーワードを使用して、<strong>可変</strong>として変数を宣言しなくてはなりません。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// `sum` and `i` are mutable now!
// 現在、`sum`と`i`は可変です！
let mut sum = 0;
let mut i = 1;

while i &lt;= 5 {
    sum += i;
    i += 1;
}
<span class="boring">}</span></code></pre></pre>
<p>This will compile and run without errors.</p>
<blockquote>
<p>これはコンパイルされ、エラーなしで実行されます。</p>
</blockquote>
<h2 id="further-reading参考資料-1"><a class="header" href="#further-reading参考資料-1">Further reading（参考資料）</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/std/keyword.while.html"><code>while</code> loop documentation</a></li>
</ul>
<h2 id="exercise-8"><a class="header" href="#exercise-8">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/02_basic_calculator/06_while"><code>02_basic_calculator/06_while</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="loops-part-2-forループその2-for"><a class="header" href="#loops-part-2-forループその2-for">Loops, part 2: <code>for</code>（ループ、その2: for）</a></h1>
<p>Having to manually increment a counter variable is somewhat tedious. The pattern is also extremely common!<br />
To make this easier, Rust provides a more concise way to iterate over a range of values: the <code>for</code> loop.</p>
<blockquote>
<p>手動でカウンター変数をインクリメントしなければならないことは、なにかと面倒です。
また、このパターンはとても一般的です！
これを簡単にするために、Rustは値の範囲を反復処理する、より簡潔な方法を提供しています。それは<code>for</code>ループです。</p>
</blockquote>
<h2 id="the-for-loopforループ"><a class="header" href="#the-for-loopforループ">The <code>for</code> loop（forループ）</a></h2>
<p>A <code>for</code> loop is a way to execute a block of code for each element in an iterator<sup class="footnote-reference"><a href="#iterator">1</a></sup>.
Here's the general syntax:</p>
<blockquote>
<p><code>for</code>ループは、イテレーター内のそれぞれの要素でコードブロックを実行する方法です。
ここに一般的な構文を示します。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for &lt;element&gt; in &lt;iterator&gt; {
    // code to execute
}
<span class="boring">}</span></code></pre></pre>
<h2 id="rangesレンジ範囲"><a class="header" href="#rangesレンジ範囲">Ranges（レンジ、範囲）</a></h2>
<p>Rust's standard library provides <strong>range</strong> type that can be used to iterate over a sequence of numbers<sup class="footnote-reference"><a href="#weird-ranges">2</a></sup>.
For example, if we want to sum the numbers from 1 to 5:</p>
<blockquote>
<p>Rust標準ライブラリは、数のシーケンスを反復処理するために使用できる<strong>レンジ</strong>型を提供しています。
例えば、1から5までの数を合計したいとします。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut sum = 0;
for i in 1..=5 {
    sum += i;
}
<span class="boring">}</span></code></pre></pre>
<p>Every time the loop runs, <code>i</code> will be assigned the next value in the range before executing the block of code.
There are five kinds of ranges in Rust:</p>
<ul>
<li><code>1..5</code>: A (half-open) range. It includes all numbers from 1 to 4. It doesn't include the last value, 5.</li>
<li><code>1..=5</code>: An inclusive range. It includes all numbers from 1 to 5. It includes the last value, 5.</li>
<li><code>1..</code>: An open-ended range. It includes all numbers from 1 to infinity (well, until the maximum value of the integer type).</li>
<li><code>..5</code>: A range that starts at the minimum value for the integer type and ends at 4. It doesn't include the last value, 5.</li>
<li><code>..=5</code>: A range that starts at the minimum value for the integer type and ends at 5. It includes the last value, 5.</li>
</ul>
<blockquote>
<p>ループが実行されるたびに、<code>i</code>はコードブロックを実行する前に、レンジ内の次の値が割り当てられます。
Rustには次の5種類のレンジがあります。</p>
<ul>
<li><code>1..5</code>: 左閉右開レンジです。それは1から4までのすべての値を含みます。それは最後の値である5を含みません。</li>
<li><code>1..=5</code>: 包括的（左閉右閉）なレンジです。それは1から5までのすべての値を含みます。それは最後の値である5を含みます。</li>
<li><code>1..</code>: 最後が開かれたレンジです。それは1から無限までのすべての値を含みます（といっても、その整数型の最大値までです）。</li>
<li><code>..5</code>: その整数型の最小値から開始して4で終わるレンジです。それは最後の値である5を含みません。</li>
<li><code>..=5</code>: その整数型の最小値から開始して5で終わるレンジです。それは最後の値である5を含みます。</li>
</ul>
</blockquote>
<p>You can use a <code>for</code> loop with the first three kinds of ranges, where the starting point
is explicitly specified. The last two range types are used in other contexts, that we'll cover later.
The extreme values of a range don't have to be integer literals—they can be variables or expressions too!
For example:</p>
<blockquote>
<p>レンジの最初の3種類を<code>for</code>ループで使用でき、開始値は明示的に指定されています。
最後の2つのレンジタイプは、他の文脈で使用されますが、それは後で説明します。
レンジの極端な値は、整数リテラルである必要はなく、それらは変数や式でも可能です！</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let end = 5;
let mut sum = 0;

for i in 1..(end + 1) {
    sum += i;
}
<span class="boring">}</span></code></pre></pre>
<h2 id="further-reading参考資料-2"><a class="header" href="#further-reading参考資料-2">Further reading（参考資料）</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/std/keyword.for.html"><code>for</code> loop documentation</a></li>
</ul>
<div class="footnote-definition" id="iterator"><sup class="footnote-definition-label">1</sup>
<p>Later in the course we'll give a precise definition of what counts as an "iterator".
For now, think of it as a sequence of values that you can loop over.
コースの後半で、「イテレーター」とは何を示すか、正確な定義を与えます。
現時点では、それをループ可能な値のシーケンスと考えてください。</p>
</div>
<div class="footnote-definition" id="weird-ranges"><sup class="footnote-definition-label">2</sup>
<p>You can use ranges with other types too (e.g. characters and IP addresses),
but integers are definitely the most common case in day-to-day Rust programming.
例えば文字やIPアドレスなど、他の型でレンジを使用できますが、整数が絶対的に日常のRustプログラミングで最も一般的なケースです。</p>
</div>
<h2 id="exercise-9"><a class="header" href="#exercise-9">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/02_basic_calculator/07_for"><code>02_basic_calculator/07_for</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overflowオーバーフロー"><a class="header" href="#overflowオーバーフロー">Overflow（オーバーフロー）</a></h1>
<p>The factorial of a number grows quite fast.<br />
For example, the factorial of 20 is 2,432,902,008,176,640,000. That's already bigger than the maximum value for a
32-bit integer, 2,147,483,647.</p>
<blockquote>
<p>階乗の数はとても早く増加します。
例えば、20の階乗は2,432,902,008,176,640,000です。これはすでに32ビット整数の最大値である2,147,483,647よりも大きいです。</p>
</blockquote>
<p>When the result of an arithmetic operation is bigger than the maximum value for a given integer type,
we are talking about <strong>an integer overflow</strong>.</p>
<blockquote>
<p>算術操作の結果が特定の整数型の最大値よりも大きくなるとき、それは<strong>整数オーバーフロー</strong>と呼ばれます。</p>
</blockquote>
<p>Integer overflows are an issue because they violate the contract for arithmetic operations.<br />
The result of an arithmetic operation between two integers of a given type should be another integer of the same type.
But the <em>mathematically correct result</em> doesn't fit into that integer type!</p>
<blockquote>
<p>整数オーバーフローは、それらが算術操作の契約に違反するため問題です。
特定の型の2つの整数の算術演算の結果は、同じ型の別な値になるべきです。
しかし、_数学的に正確な結果_は、その整数型に収まりません！</p>
</blockquote>
<blockquote>
<p>If the result is smaller than the minimum value for a given integer type, we refer to the event as <strong>an integer
underflow</strong>.<br />
For brevity, we'll only talk about integer overflows for the rest of this section, but keep in mind that
everything we say applies to integer underflows as well.</p>
<p>The <code>speed</code> function you wrote in the <a href="02_basic_calculator/02_variables.html">"Variables" section</a> underflowed for some input
combinations.
E.g. if <code>end</code> is smaller than <code>start</code>, <code>end - start</code> will underflow the <code>u32</code> type since the result is supposed
to be negative but <code>u32</code> can't represent negative numbers.</p>
</blockquote>
<blockquote>
<p>結果が特定の整数型の最小値よりも小さい場合、そのイベントを<strong>整数アンダーフロー</strong>と呼びます。
簡潔にするために、この節の残りは整数オーバーフローについて話しますが、ここで話すすべてのことは整数アンダーフローにも適用することを心に留めておいてください。</p>
<p>「変数」節で記述した<code>speed</code>関数は、任意の入力の組み合わせでアンダーフローします。
例えば、<code>end</code>が<code>start</code>よりも小さい場合、<code>end - start</code>は、その結果は負が想定されますが、<code>u32</code>は負数を表現できないため、<code>u32</code>型でアンダーフローします。</p>
</blockquote>
<h2 id="no-automatic-promotion自動昇格はありません"><a class="header" href="#no-automatic-promotion自動昇格はありません">No automatic promotion（自動昇格はありません）</a></h2>
<p>One possible approach would be automatically promote the result to a bigger integer type.
E.g. if you're summing two <code>u8</code> integers and the result is 256 (<code>u8::MAX + 1</code>), Rust could choose to interpret the
result as <code>u16</code>, the next integer type that's big enough to hold 256.</p>
<p>But, as we've discussed before, Rust is quite picky about type conversions. Automatic integer promotion
is not Rust's solution to the integer overflow problem.</p>
<blockquote>
<p>1つの可能なアプローチは、結果をより大きな整数型に自動的に昇格させることです。
例えば、2つの<code>u8</code>整数を合計して、結果が256（<code>u8::MAX + 1</code>）になる場合、Rustは<code>u16</code>として結果を解釈することを選択するかもしれません。
次の整数型は、256を保持するほど十分大きいです。</p>
<p>しかし、前に議論したように、Rustは型変換についてとてもうるさいです。
自動整数昇格は、整数オーバーフロー問題に対するRustの解決策ではありません。</p>
</blockquote>
<h2 id="alternatives代替手段"><a class="header" href="#alternatives代替手段">Alternatives（代替手段）</a></h2>
<p>Since we ruled out automatic promotion, what can we do when an integer overflow occurs?<br />
It boils down to two different approaches:</p>
<ul>
<li>Reject the operation</li>
<li>Come up with a "sensible" result that fits into the expected integer type</li>
</ul>
<blockquote>
<p>自動昇格を除外したため、整数オーバーフローが発生したとき何ができるでしょうか？
2つの異なるアプローチにまとめられます。</p>
<ul>
<li>操作を拒否する</li>
<li>期待される整数型にフィットする「良識ある」結果を考える</li>
</ul>
</blockquote>
<h3 id="reject-the-operation操作を拒否する"><a class="header" href="#reject-the-operation操作を拒否する">Reject the operation（操作を拒否する）</a></h3>
<p>This is the most conservative approach: we stop the program when an integer overflow occurs.<br />
That's done via a panic, the mechanism we've already seen in the <a href="02_basic_calculator/04_panics.html">"Panics" section</a>.</p>
<blockquote>
<p>これは最も保守的なアプローチです。
整数オーバーフローが発生したときプログラムを停止します。
これはパニックを介して行われ、そのメカニズムは、「パニック」節ですでに確認しました。</p>
</blockquote>
<h3 id="come-up-with-a-sensible-result良識ある結果を考える"><a class="header" href="#come-up-with-a-sensible-result良識ある結果を考える">Come up with a "sensible" result（【良識ある」結果を考える）</a></h3>
<p>When the result of an arithmetic operation is bigger than the maximum value for a given integer type, you can
choose to <strong>wrap around</strong>.<br />
If you think of all the possible values for a given integer type as a circle, wrapping around means that when you
reach the maximum value, you start again from the minimum value.</p>
<blockquote>
<p>算術操作の結果が特定の整数型の最大値よりも大きくなったとき、<strong>包み込む</strong>ことを選択できます。
円として与えられた整数型ですべての可能性のある値を考えると、包み込みは最大値に到達したとき、最小値から再び開始することを意味します。</p>
</blockquote>
<p>For example, if you do a <strong>wrapping addition</strong> between 1 and 255 (=<code>u8::MAX</code>), the result is 0 (=<code>u8::MIN</code>).
If you're working with signed integers, the same principle applies. E.g. adding 1 to 127 (=<code>i8::MAX</code>) with wrapping
will give you -128 (=<code>i8::MIN</code>).</p>
<blockquote>
<p>例えば、1と255 (=<code>u8::MAX</code>)の<strong>包み込み加算</strong>をすると、結果は0（=<code>u8::MIN</code>）になります。
符号付き整数で作業している場合、同じ原則が適用されます。
例えば、包み込みを使用した1と127（=<code>i8::MAX</code>）の加算は、-128（=<code>i8::MIN</code>）を与えます。</p>
</blockquote>
<h2 id="overflow-checksオーバーフロー検査"><a class="header" href="#overflow-checksオーバーフロー検査"><code>overflow-checks</code>（オーバーフロー検査）</a></h2>
<p>Rust lets you, the developer, choose which approach to use when an integer overflow occurs.
The behaviour is controlled by the <code>overflow-checks</code> profile setting.</p>
<blockquote>
<p>Rustは、整数オーバーフローが発生したときに使用するアプローチを開発者に選択できるようにします。
その振る舞いは、<code>overflow-checks</code>プロファイル設定によって制御されます。</p>
</blockquote>
<p>If <code>overflow-checks</code> is set to <code>true</code>, Rust will <strong>panic at runtime</strong> when an integer operation overflows.
If <code>overflow-checks</code> is set to <code>false</code>, Rust will <strong>wrap around</strong> when an integer operation overflows.</p>
<blockquote>
<p><code>overflow-checks</code>が<code>true</code>に設定されている場合、Rustは整数オーバーフローが発生したとき<strong>ランタイムでパニック</strong>します。
<code>overflow-checks</code>が<code>false</code>に設定されている場合、Rustは整数オーバーフローが発生したとき<strong>包み込み</strong>します。</p>
</blockquote>
<p>You may be wondering—what is a profile setting? Let's get into that!</p>
<blockquote>
<p>困惑しているかもしれません。プロファイル設定とは何でしょうか？
それについて説明しましょう！</p>
</blockquote>
<h2 id="profilesプロファイル"><a class="header" href="#profilesプロファイル">Profiles（プロファイル）</a></h2>
<p>A <a href="https://doc.rust-lang.org/cargo/reference/profiles.html"><strong>profile</strong></a> is a set of configuration options that can be
used to customize the way Rust code is compiled.</p>
<blockquote>
<p><strong>プロファイル</strong>は、Rustコードがコンパイルされる方法をカスタマイズするために使用できる構成オプションのセットです。</p>
</blockquote>
<p>Cargo provides two built-in profiles: <code>dev</code> and <code>release</code>.<br />
The <code>dev</code> profile is used every time you run <code>cargo build</code>, <code>cargo run</code> or <code>cargo test</code>. It's aimed at local
development,
therefore it sacrifices runtime performance in favor of faster compilation times and a better debugging experience.<br />
The <code>release</code> profile, instead, is optimized for runtime performance but incurs longer compilation times. You need
to explicitly request via the <code>--release</code> flag—e.g. <code>cargo build --release</code> or <code>cargo run --release</code>.</p>
<blockquote>
<p>Cargoは、<code>dev</code>と<code>release</code>の2つの組み込みプロファイルを提供します。
<code>dev</code>プロファイルは、<code>cargo build</code>、<code>cargo run</code>または<code>cargo test</code>を実行するたびに使用されます。
それはローカル開発を目的としているため、それは短いコンパイル時間とより良いデバッグ体験を得るために、ランタイムの性能を犠牲にしています。
代わりに、<code>release</code>プロファイルはランタイム性能のために最適化されますが、より長いコンパイル時間が必要です。
明示的に<code>--release</code>フラグを要求する必要があります。
例えば、<code>cargo build --release</code>または<code>cargo run --release</code>です。</p>
</blockquote>
<blockquote>
<p>"Have you built your project in release mode?" is almost a meme in the Rust community.<br />
It refers to developers who are not familiar with Rust and complain about its performance on
social media (e.g. Reddit, Twitter, etc.) before realizing they haven't built their project in
release mode.</p>
</blockquote>
<blockquote>
<p>「リリースモードでプロジェクトをビルドしましたか？」は、Rustコミュニティでほぼミーム（文化の中で人から人に広がっていく行動やアイデアのこと）です。
それは、Rustに慣れていない開発者が、リリースモードでプロジェクトをビルドしていないことに気づく前に、Redditやツイッターなどのソーシャルメディアでその性能について不満を言うことを示します。</p>
</blockquote>
<p>You can also define custom profiles or customize the built-in ones.</p>
<blockquote>
<p>また、カスタムプロファイルを定義したり、組み込みのプロファイルをカスタマイズすることもできます。</p>
</blockquote>
<h3 id="overflow-checkオーバーフロー確認"><a class="header" href="#overflow-checkオーバーフロー確認"><code>overflow-check</code>（オーバーフロー確認）</a></h3>
<p>By default, <code>overflow-checks</code> is set to:</p>
<ul>
<li><code>true</code> for the <code>dev</code> profile</li>
<li><code>false</code> for the <code>release</code> profile</li>
</ul>
<blockquote>
<p>デフォルトで、<code>overflow-checks</code>は次の通り設定されています。</p>
<p><code>true</code>は<code>dev</code>プロファイルに対して
<code>false</code>は<code>release</code>プロファイルに対して</p>
</blockquote>
<p>This is in line with the goals of the two profiles.<br />
<code>dev</code> is aimed at local development, so it panics in order to highlight potential issues as early as possible.<br />
<code>release</code>, instead, is tuned for runtime performance: checking for overflows would slow down the program, so it
prefers to wrap around.</p>
<blockquote>
<p>これは、2つのプロファイルの目標と一致しています。
<code>dev</code>はローカル開発を目的としているため、それは可能な限り早期に問題の可能性を強調するためにパニックします。
代わりに、<code>release</code>は、ランタイム性能を向上させるために調整されており、オーバーフローの確認はプログラムを遅くするため、それは包み込むことを選択しています。</p>
</blockquote>
<p>At the same time, having different behaviours for the two profiles can lead to subtle bugs.<br />
Our recommendation is to enable <code>overflow-checks</code> for both profiles: it's better to crash than to silently produce
incorrect results. The runtime performance hit is negligible in most cases; if you're working on a performance-critical
application, you can run benchmarks to decide if it's something you can afford.</p>
<blockquote>
<p>同時に、2つのプロファイルで異なる振る舞いを持つことで、些細なバグを招く可能性があります。
推奨は、両方のプロファイルで<code>overflow-checks</code>を有効にすることです。
それは、静かに誤った結果を生産するよりも、クラッシュしたほうが良いからです。
ランタイム性能の影響は、ほとんどの場合で無視できます。
パフォーマンスが重要なアプリケーションで作業している場合、ベンチマークを実行して、それが許容できるか決定できます。</p>
</blockquote>
<h2 id="further-reading参考資料-3"><a class="header" href="#further-reading参考資料-3">Further reading（参考資料）</a></h2>
<ul>
<li>Check out <a href="https://huonw.github.io/blog/2016/04/myths-and-legends-about-integer-overflow-in-rust/">"Myths and legends about integer overflow in Rust"</a>
for an in-depth discussion about integer overflow in Rust.</li>
</ul>
<h2 id="exercise-10"><a class="header" href="#exercise-10">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/02_basic_calculator/08_overflow"><code>02_basic_calculator/08_overflow</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="case-by-case-behavior状況に応じた振る舞い"><a class="header" href="#case-by-case-behavior状況に応じた振る舞い">Case-by-case behavior（状況に応じた振る舞い）</a></h1>
<p><code>overflow-checks</code> is a blunt tool: it's a global setting that affects the whole program.<br />
It often happens that you want to handle integer overflows differently depending on the context: sometimes
wrapping is the right choice, other times panicking is preferable.</p>
<blockquote>
<p><code>overflow-checks</code>は遠慮のないツールです。
それは、プログラム全体に影響を与えるグローバルな設定です。
文脈によって異なる整数オーバーフローを処理したいことがよくあります。
時々、包み込みは正しい選択で、他のときはパニックが好ましいです。</p>
</blockquote>
<h2 id="wrapping_-methodswrapping_メソッド"><a class="header" href="#wrapping_-methodswrapping_メソッド"><code>wrapping_</code> methods（wrapping_メソッド）</a></h2>
<p>You can opt into wrapping arithmetic on a per-operation basis by using the <code>wrapping_</code> methods<sup class="footnote-reference"><a href="#method">1</a></sup>.<br />
For example, you can use <code>wrapping_add</code> to add two integers with wrapping:</p>
<blockquote>
<p><code>wrapping_</code>メソッドを使用して、操作ごとに包み込み算術を選択することができます。
例えば、包み込みを使用して2つの整数を加算するために、<code>wrapping_add</code>を使用できます。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 255u8;
let y = 1u8;
let sum = x.wrapping_add(y);
assert_eq!(sum, 0);
<span class="boring">}</span></code></pre></pre>
<h2 id="saturating_-methodssaturating_メソッド"><a class="header" href="#saturating_-methodssaturating_メソッド"><code>saturating_</code> methods（saturating_メソッド）</a></h2>
<p>Alternatively, you can opt into <strong>saturating arithmetic</strong> by using the <code>saturating_</code> methods.<br />
Instead of wrapping around, saturating arithmetic will return the maximum or minimum value for the integer type.
For example:</p>
<blockquote>
<p>代わりに、<code>saturating_</code>メソッドを使用して<strong>飽和算術</strong>を選択することができます。
包み込みの代わりに、飽和算術は整数型の最大値または最小値を返します。
例えば・・・</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 255u8;
let y = 1u8;
let sum = x.saturating_add(y);
assert_eq!(sum, 255);
<span class="boring">}</span></code></pre></pre>
<p>Since <code>255 + 1</code> is <code>256</code>, which is bigger than <code>u8::MAX</code>, the result is <code>u8::MAX</code> (255).<br />
The opposite happens for underflows: <code>0 - 1</code> is <code>-1</code>, which is smaller than <code>u8::MIN</code>, so the result is <code>u8::MIN</code> (0).</p>
<blockquote>
<p><code>255 + 1</code>は<code>256</code>であり、<code>u8::MAX</code>より大きいため、結果は<code>u8::MAX</code>（255）です。
アンダーフローの場合は逆です。<code>0 - 1</code>は<code>-1</code>であり、<code>u8::MIN</code>より小さいため、結果は<code>u8::MIN</code>（0）です。</p>
</blockquote>
<p>You can't get saturating arithmetic via the <code>overflow-checks</code> profile setting—you have to explicitly opt into it
when performing the arithmetic operation.</p>
<blockquote>
<p>飽和算術は<code>overflow-checks</code>プロファイル設定を介して取得できません。
算術操作を実行するときに明示的に選択する必要があります。</p>
</blockquote>
<div class="footnote-definition" id="method"><sup class="footnote-definition-label">1</sup>
<p>You can think of methods as functions that are "attached" to a specific type.
We'll cover methods (and how to define them) in the next chapter.
特定の型に「付属した」関数としてメソッドを考えることができます。
次の章でメソッド（およびそれらを定義する方法）について説明します。</p>
</div>
<h2 id="exercise-11"><a class="header" href="#exercise-11">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/02_basic_calculator/09_saturating"><code>02_basic_calculator/09_saturating</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="conversions-pt-1変換その1"><a class="header" href="#conversions-pt-1変換その1">Conversions, pt. 1（変換、その1）</a></h1>
<p>We've repeated over and over again that Rust won't perform
implicit type conversions for integers.<br />
How do you perform <em>explicit</em> conversions then?</p>
<blockquote>
<p>Rustは整数の暗黙的な型変換を行わないことを何度も繰り返し説明しました。
では、どの用に_明示的に_変換を行うのでしょうか？</p>
</blockquote>
<h2 id="as"><a class="header" href="#as"><code>as</code></a></h2>
<p>You can use the <code>as</code> operator to convert between integer types.<br />
<code>as</code> conversions are <strong>infallible</strong>.
For example:</p>
<blockquote>
<p>整数型間を変換するために<code>as</code>演算子を使用できます。
<code>as</code>変換は<strong>失敗しません</strong>。
例えば・・・</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a: u32 = 10;

// Cast `a` into the `u64` type
// `a`を`u64`型にキャストします。
let b = a as u64;

// You can use `_` as the target type
// if it can be correctly inferred
// by the compiler. For example:
// コンパイラによって正確に推論される場合、目的の型として`_`を使用できます。
// 例えば・・・
let c: u64 = a as _;
<span class="boring">}</span></code></pre></pre>
<p>The semantics of this conversion are what you expect: all <code>u32</code> values are valid <code>u64</code>
values.</p>
<blockquote>
<p>この変換の意味は、何を期待するかを示します。
すべての<code>u32</code>値は有効な<code>u64</code>値です。</p>
</blockquote>
<h3 id="truncation切り捨て"><a class="header" href="#truncation切り捨て">Truncation（切り捨て）</a></h3>
<p>Things get more interesting if we go in the opposite direction:</p>
<blockquote>
<p>反対方向に行った場合、より興味深いことが起こります。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// A number that's too big
// to fit into a `u8`
// `u8`に収まらないほど大きな数です。
let a: u16 = 255 + 1;
let b = a as u8;
<span class="boring">}</span></code></pre></pre>
<p>This program will run without issues, because <code>as</code> conversions are infallible.
But what is the value of <code>b</code>?
When going from a larger integer type to a smaller, the Rust compiler will perform
a <strong>truncation</strong>.</p>
<blockquote>
<p><code>as</code>変換は失敗しないため、このプログラムは問題なく実行されます。
では、<code>b</code>の値は何でしょうか？
大きな整数型を小さな整数型に変換したとき、Rustコンパイラーは<strong>切り捨て</strong>を行います。</p>
</blockquote>
<p>To understand what happens, let's start by looking at how <code>256u16</code> is
represented in memory, as a sequence of bits:</p>
<blockquote>
<p>何が起こるかを理解するために、<code>256u16</code>がビットシーケンスとしてメモリ内で表現される方法を確認することから始めましょう。</p>
</blockquote>
<pre><code class="language-text"> 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0
|               |               |
+---------------+---------------+
  First 8 bits    Last 8 bits
</code></pre>
<p>When converting to a <code>u8</code>, the Rust compiler will keep the last 8 bits of a <code>u16</code>
memory representation:</p>
<blockquote>
<p><code>u8</code>に変換するとき、Rustコンパイラーは<code>u16</code>のメモリ表現の最後の8ビットを維持します。</p>
</blockquote>
<pre><code class="language-text"> 0 0 0 0 0 0 0 0
|               |
+---------------+
  Last 8 bits
</code></pre>
<p>Hence <code>256 as u8</code> is equal to <code>0</code>. That's... not ideal, in most scenarios.<br />
In fact, the Rust compiler will actively try to stop you if it sees you trying
to cast a literal value which will result in a truncation:</p>
<blockquote>
<p>よって、<code>256 as u8</code>は<code>0</code>と等しいです。ほとんどのシナリオで、それは・・・理想的ではありません。
実際に、Rustコンパイラーは、切り捨ての結果になるリテラル値をキャストする試みを確認すると、積極的に停止しようとします。</p>
</blockquote>
<pre><code class="language-text">error: literal out of range for `i8`
  |
4 |     let a = 255 as i8;
  |             ^^^
  |
  = note: the literal `255` does not fit into the type `i8` whose range is `-128..=127`
  = help: consider using the type `u8` instead
  = note: `#[deny(overflowing_literals)]` on by default
</code></pre>
<h3 id="recommendation推奨事項"><a class="header" href="#recommendation推奨事項">Recommendation（推奨事項）</a></h3>
<p>As a rule of thumb, be quite careful with <code>as</code> casting.<br />
Use it <em>exclusively</em> for going from a smaller type to a larger type.
To convert from a larger to smaller integer type, rely on the
<a href="02_basic_calculator/../05_ticket_v2/13_try_from.html"><em>fallible</em> conversion machinery</a> that we'll
explore later in the course.</p>
<blockquote>
<p>経験則として、<code>as</code>キャストの使用はとても注意して行ってください。
それは、小さな型から大きな型に変換するために_排他的に_使用してください。
_失敗しない変換機械_についてコースの後半で探求します。</p>
</blockquote>
<h3 id="limitations制限事項"><a class="header" href="#limitations制限事項">Limitations（制限事項）</a></h3>
<p>Surprising behaviour is not the only downside of <code>as</code> casting.
It is also fairly limited: you can only rely on <code>as</code> casting
for primitive types and a few other special cases.<br />
When working with composite types, you'll have to rely on
different conversion mechanisms (<a href="02_basic_calculator/../05_ticket_v2/13_try_from.html">fallible</a>
and <a href="02_basic_calculator/../04_traits/09_from.html">infallible</a>), which we'll explore later on.</p>
<blockquote>
<p>驚くべき振る舞いは、<code>as</code>キャストの唯一の欠点ではありません。
また、それはかなり制限されています。
<code>as</code>キャストは、プリミティブな型といくつかの他の特別な場面にのみ依存しています。
複合型で作業しているとき、後で探求する_失敗する_と_失敗しない_の異なる変換メカニズムに依存しなければなりません。</p>
</blockquote>
<h2 id="further-reading参考資料-4"><a class="header" href="#further-reading参考資料-4">Further reading（参考資料）</a></h2>
<ul>
<li>Check out <a href="https://doc.rust-lang.org/reference/expressions/operator-expr.html#numeric-cast">Rust's official reference</a>
to learn the precise behaviour of <code>as</code> casting for each source/target combination,
as well as the exhaustive list of allowed conversions.
変換を許可する網羅的なリストと同様に、それそれのソース/ターゲットの組み合わせに対する<code>as</code>キャストの正確な動作を学ぶために、_Rustの公式リファレンス_を参照してください。</li>
</ul>
<h2 id="exercise-12"><a class="header" href="#exercise-12">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/02_basic_calculator/10_as_casting"><code>02_basic_calculator/10_as_casting</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="modelling-a-ticketチケットのモデリング"><a class="header" href="#modelling-a-ticketチケットのモデリング">Modelling A Ticket（チケットのモデリング）</a></h1>
<p>The first chapter should have given you a good grasp over some of Rust's primitive types, operators and
basic control flow constructs.<br />
In this chapter we'll go one step further and cover what makes Rust truly unique: <strong>ownership</strong>.<br />
Ownership is what enables Rust to be both memory-safe and performant, with no garbage collector.</p>
<blockquote>
<p>最初の章は、Rustのプリミティブ型、演算子そして基本的な制御フローの構築について良い理解を与えるはずです。
この章は、先にステップを進めて、Rustを本当にユニークにする<strong>所有権</strong>について説明します。
所有権は、メモリセーフと高性能の両方を有効にするもので、ガベージコレクターはありません。</p>
</blockquote>
<p>As our running example, we'll use a (JIRA-like) ticket, the kind you'd use to track bugs, features, or tasks in
a software project.<br />
We'll take a stab at modeling it in Rust. It'll be the first iteration—it won't be perfect nor very idiomatic
by the end of the chapter. It'll be enough of a challenge though!<br />
To move forward you'll have to pick up several new Rust concepts, such as:</p>
<ul>
<li><code>struct</code>s, one of Rust's ways to define custom types</li>
<li>Ownership, references and borrowing</li>
<li>Memory management: stack, heap, pointers, data layout, destructors</li>
<li>Modules and visibility</li>
<li>Strings</li>
</ul>
<blockquote>
<p>実行例として、ソフトウェアプロジェクトのバグ、機能またはタスクを追跡するために使用する、JIRAのようなチケットを使用します。
Rustでモデリングする予定です。それは最初のイテレーションで、章の最後でもそれは完全で理想的ではありません。
しかし、それは挑戦するには十分です！
先に進むために、次のようなRustの新しい概念を取り上げなければなりません。</p>
<ul>
<li><code>struct</code>は、カスタム型を定義するRustの1つの方法です。</li>
<li>所有権、参照そして借用</li>
<li>メモリ管理: スタック、ヒープ、ポインター、データレイアウト、デストラクター</li>
<li>モジュールと可視性</li>
<li>文字列</li>
</ul>
</blockquote>
<h2 id="exercise-13"><a class="header" href="#exercise-13">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/03_ticket_v1/00_intro"><code>03_ticket_v1/00_intro</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="structs構造体"><a class="header" href="#structs構造体">Structs（構造体）</a></h1>
<p>We need to keep track of three pieces of information for each ticket:</p>
<ul>
<li>A title</li>
<li>A description</li>
<li>A status</li>
</ul>
<blockquote>
<p>それぞれのチケットの3つの情報を追跡する必要があります。</p>
<ul>
<li>タイトル</li>
<li>説明</li>
<li>状態</li>
</ul>
</blockquote>
<p>We can start by using a <a href="https://doc.rust-lang.org/std/string/struct.String.html"><code>String</code></a>
to represent them. <code>String</code> is the type defined in Rust's standard library to represent
<a href="https://en.wikipedia.org/wiki/UTF-8">UTF-8 encoded</a> text.</p>
<blockquote>
<p>それらを表現するために<code>String</code>を使用することから始めます。
<code>String</code>は、<code>UTF-8エンコード</code>テキストを表現するために、Rustの標準ライブラリに定義された型です。</p>
</blockquote>
<p>But how do we <strong>combine</strong> these three pieces of information into a single entity?</p>
<blockquote>
<p>しかし、どのようにこれら3つの情報の断片を、単一のエントリに<strong>組み合わせ</strong>するのでしょうか？</p>
</blockquote>
<h2 id="defining-a-structstructの定義"><a class="header" href="#defining-a-structstructの定義">Defining a <code>struct</code>（structの定義）</a></h2>
<p>A <code>struct</code> defines a <strong>new Rust type</strong>.</p>
<blockquote>
<p><code>struct</code>は、<strong>新しいRustの型</strong>を定義します。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Ticket {
    title: String,
    description: String,
    status: String
}
<span class="boring">}</span></code></pre></pre>
<p>A struct is quite similar to what you would call a class or an object in other programming languages.</p>
<blockquote>
<p>構造体は、他のプログラミング言語でクラスまたはオブジェクトと呼んでいるものに、とても似ています。</p>
</blockquote>
<h2 id="defining-fieldsフィールドの定義"><a class="header" href="#defining-fieldsフィールドの定義">Defining fields（フィールドの定義）</a></h2>
<p>The new type is built by combining other types as <strong>fields</strong>.<br />
Each field must have a name and a type, separated by a colon, <code>:</code>. If there are multiple fields, they are separated by a comma, <code>,</code>.</p>
<blockquote>
<p>新しい型は、<strong>フィールド</strong>として他の型を組み合わせることによって構築されます。
それぞれのフィールドは、コロン<code>:</code>で区切られた名前と型を持たなければなりません。
複数のフィールドがある場合、それらはカンマ<code>,</code>で区切られます。</p>
</blockquote>
<p>Fields don't have to be of the same type, as you can see in the <code>Configuration</code> struct below:</p>
<blockquote>
<p>下の<code>Configuration</code>構造体で確認できるように、フィールドは同じ型である必要はありません。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Configuration {
   version: u32,
   active: bool
}
<span class="boring">}</span></code></pre></pre>
<h2 id="instantiationインスタンス化"><a class="header" href="#instantiationインスタンス化">Instantiation（インスタンス化）</a></h2>
<p>You can create an instance of a struct by specifying the values for each field:</p>
<blockquote>
<p>それぞれのフィールドの値を指定することで、構造体のインスタンスを作成できます。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Syntax: &lt;StructName&gt; { &lt;field_name&gt;: &lt;value&gt;, ... }
let ticket = Ticket {
    title: "Build a ticket system".into(),
    description: "Create a system that can manage tickets across a Kanban board".into(),
    status: "Open".into()
};
<span class="boring">}</span></code></pre></pre>
<h2 id="accessing-fieldsフィールドアクセス"><a class="header" href="#accessing-fieldsフィールドアクセス">Accessing fields（フィールドアクセス）</a></h2>
<p>You can access the fields of a struct using the <code>.</code> operator:</p>
<blockquote>
<p><code>.</code>演算子を使用して、構造体のフィールドにアクセスできます。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Field access
let x = ticket.description;
<span class="boring">}</span></code></pre></pre>
<h2 id="methodsメソッド"><a class="header" href="#methodsメソッド">Methods（メソッド）</a></h2>
<p>We can attach behaviour to our structs by defining <strong>methods</strong>.<br />
Using the <code>Ticket</code> struct as an example:</p>
<blockquote>
<p><strong>メソッド</strong>を定義することで、構造体の振る舞いを取り付けできます。
例として、<code>Ticket</code>構造体を使用します。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Ticket {
    fn is_open(self) -&gt; bool {
        self.status == "Open"
    }
}

// Syntax:
// impl &lt;StructName&gt; {
//    fn &lt;method_name&gt;(&lt;parameters&gt;) -&gt; &lt;return_type&gt; {
//        // Method body
//    }
// }
<span class="boring">}</span></code></pre></pre>
<p>Methods are pretty similar to functions, with two key differences:</p>
<ol>
<li>methods must be defined inside an <strong><code>impl</code> block</strong></li>
<li>methods may use <code>self</code> as their first parameter.
<code>self</code> is a keyword and represents the instance of the struct the method is being called on.</li>
</ol>
<blockquote>
<p>メソッドは、2つの主要な違いを持ちますが、関数にとても似ています。</p>
<ol>
<li>メソッドは、<strong><code>impl</code>ブロック</strong>内に定義されなければなりません。</li>
<li>メソッドは、それらの最初の引数として<code>self</code>を使用することができます。
<code>self</code>はキーワードであり、メソッドが呼ばれたインスタンスを表現します。</li>
</ol>
</blockquote>
<h3 id="self"><a class="header" href="#self"><code>self</code></a></h3>
<p>If a method takes <code>self</code> as its first parameter, it can be called using the <strong>method call syntax</strong>:</p>
<blockquote>
<p>メソッドが最初の引数で<code>self</code>を受け取る場合、それは<strong>メソッド呼び出し構文</strong>を使用して呼び出すことができます。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Method call syntax: &lt;instance&gt;.&lt;method_name&gt;(&lt;parameters&gt;)
let is_open = ticket.is_open();
<span class="boring">}</span></code></pre></pre>
<p>This is the same calling syntax you used to perform saturating arithmetic operations on <code>u32</code> values
in <a href="03_ticket_v1/../02_basic_calculator/09_saturating.html">the previous chapter</a>.</p>
<blockquote>
<p>これは、前の章で<code>u32</code>値に対して飽和算術演算するために使用した呼び出し構文と同じです。</p>
</blockquote>
<h3 id="static-methods静的メソッド"><a class="header" href="#static-methods静的メソッド">Static methods（静的メソッド）</a></h3>
<p>If a method doesn't take <code>self</code> as its first parameter, it's a <strong>static method</strong>.</p>
<blockquote>
<p>メソッドが最初の引数で<code>self</code>を受け取らない場合、それは<strong>静的メソッド</strong>です。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Configuration {
    version: u32,
    active: bool
}

impl Configuration {
    // `default` is a static method on `Configuration`
    // `default`は`Configuration`の静的メソッドです。
    fn default() -&gt; Configuration {
        Configuration { version: 0, active: false }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The only way to call a static method is by using the <strong>function call syntax</strong>:</p>
<blockquote>
<p>静的メソッドを呼び出す唯一の方法は、<strong>関数呼び出し構文</strong>を使用することです。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Function call syntax: &lt;StructName&gt;::&lt;method_name&gt;(&lt;parameters&gt;)
let default_config = Configuration::default();
<span class="boring">}</span></code></pre></pre>
<h3 id="equivalence等価"><a class="header" href="#equivalence等価">Equivalence（等価）</a></h3>
<p>You can use the function call syntax even for methods that take <code>self</code> as their first parameter:</p>
<blockquote>
<p>最初の引数で<code>self</code>を受け取るメソッドに対しても、関数呼び出し構文を使用できます。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Function call syntax: &lt;StructName&gt;::&lt;method_name&gt;(&lt;instance&gt;, &lt;parameters&gt;)
let is_open = Ticket::is_open(ticket);
<span class="boring">}</span></code></pre></pre>
<p>The function call syntax makes it quite clear that <code>ticket</code> is being used as <code>self</code>, the first parameter of the method,
but it's definitely more verbose. Prefer the method call syntax when possible.</p>
<blockquote>
<p>関数呼び出し構文は、<code>ticket</code>が、メソッドの最初の引数の<code>self</code>として使用されることをとても明確にしますが、間違いなくより冗長です。
可能であれば、メソッド呼び出し構文を使用してください。</p>
</blockquote>
<h2 id="exercise-14"><a class="header" href="#exercise-14">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/03_ticket_v1/01_struct"><code>03_ticket_v1/01_struct</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="validation検証"><a class="header" href="#validation検証">Validation（検証）</a></h1>
<p>Let's go back to our ticket definition:</p>
<blockquote>
<p>チケットの定義に戻りましょう。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Ticket {
    title: String,
    description: String,
    status: String,
}
<span class="boring">}</span></code></pre></pre>
<p>We are using "raw" types for the fields of our <code>Ticket</code> struct.
This means that users can create a ticket with an empty title, a suuuuuuuper long description or
a nonsensical status (e.g. "Funny").<br />
We can do better than that!</p>
<blockquote>
<p><code>Ticket</code>構造体のフィールドに「生」の型を使用しています。
これは、空のタイトル、とても長い説明、または意味のない状態（例えば、「面白い」）でチケットを作成できることを意味します。
もっと良い方法があります！</p>
</blockquote>
<h2 id="further-reading参考資料-5"><a class="header" href="#further-reading参考資料-5">Further reading（参考資料）</a></h2>
<ul>
<li>Check out <a href="https://doc.rust-lang.org/std/string/struct.String.html"><code>String</code>'s documentation</a>
for a thorough overview of the methods it provides. You'll need it for the exercise!</li>
</ul>
<blockquote>
<ul>
<li><code>String</code>が提供するメソッドの概要を確認するために、<code>String</code>のドキュメントを参照してください。
この演習にはそれが必要です。</li>
</ul>
</blockquote>
<h2 id="exercise-15"><a class="header" href="#exercise-15">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/03_ticket_v1/02_validation"><code>03_ticket_v1/02_validation</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="modulesモジュール"><a class="header" href="#modulesモジュール">Modules（モジュール）</a></h1>
<p>The <code>new</code> method you've just defined is trying to enforce some <strong>constraints</strong> on the field values for <code>Ticket</code>.
But are those invariants really enforced? What prevents a developer from creating a <code>Ticket</code>
without going through <code>Ticket::new</code>?</p>
<blockquote>
<p>ちょうど定義した<code>new</code>メソッドは、<code>Ticket</code>のフィールドの値に何らかの<strong>制約</strong>を強制することを試みます。
しかし、それらの不変性は本当に強制されるのでしょうか？
<code>Ticket::new</code>を介することなく、開発者が<code>Ticket</code>を作成することを防ぐのは何でしょうか？</p>
</blockquote>
<p>To get proper <strong>encapsulation</strong> you need to become familiar with two new concepts: <strong>visibility</strong> and <strong>modules</strong>.
Let's start with modules.</p>
<blockquote>
<p>適切な<strong>カプセル化</strong>を得るために、<strong>可視性</strong>と<strong>モジュール</strong>という2つの新しい概念に慣れる必要があります。
モジュールから始めましょう。</p>
</blockquote>
<h2 id="what-is-a-moduleモジュールとは"><a class="header" href="#what-is-a-moduleモジュールとは">What is a module?（モジュールとは？）</a></h2>
<p>In Rust a <strong>module</strong> is a way to group related code together, under a common namespace (i.e. the module's name).<br />
You've already seen modules in action: the unit tests that verify the correctness of your code are defined in a
different module, named <code>tests</code>.</p>
<blockquote>
<p>Rustにおいて、<strong>モジュール</strong>は、例えばモジュールの名前など、一般的な名前空間の下で、関連したコード同士でグループを作成する方法です。
実際にすでにモジュールを確認しています。コードの正確性を検証するユニットテストは、<code>tests</code>と名付けられた異なるモジュールに定義されています。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    // [...]
}
<span class="boring">}</span></code></pre></pre>
<h2 id="inline-modulesインラインモジュール"><a class="header" href="#inline-modulesインラインモジュール">Inline modules（インラインモジュール）</a></h2>
<p>The <code>tests</code> module above is an example of an <strong>inline module</strong>: the module declaration (<code>mod tests</code>) and the module
contents (the stuff inside <code>{ ... }</code>) are next to each other.</p>
<blockquote>
<p>上記<code>tests</code>モジュールは、<strong>インラインモジュール</strong>の例で、そのモジュールの定義（<code>mod tests</code>）とそのモジュールのコンテンツ（<code>{ ... }</code>の内部のもの）は隣り合っています。</p>
</blockquote>
<h2 id="module-treeモジュールツリー"><a class="header" href="#module-treeモジュールツリー">Module tree（モジュールツリー）</a></h2>
<p>Modules can be nested, forming a <strong>tree</strong> structure.<br />
The root of the tree is the <strong>crate</strong> itself, which is the top-level module that contains all the other modules.
For a library crate, the root module is usually <code>src/lib.rs</code> (unless its location has been customized).
The root module is also known as the <strong>crate root</strong>.</p>
<blockquote>
<p>モジュールはネストでき、<strong>木</strong>構造を形成します。
木のルートは<strong>クレート</strong>それ自身で、それはすべての他のモジュールを含む最上位モジュールです。
ライブラリクレートの場合、場所がカスタマイズされていない限り、ルートモジュールは通常<code>src/lib.rs</code>です。
また、ルートモジュールは、<strong>クレートルート</strong>としても知られています。</p>
</blockquote>
<p>The crate root can have submodules, which in turn can have their own submodules, and so on.</p>
<blockquote>
<p>クレートルートはサブモジュールを持て、サブモジュールは自身のサブモジュールを持つことができ、それが続きます。</p>
</blockquote>
<h2 id="external-modules-and-the-filesystem外部モジュールとファイルシステム"><a class="header" href="#external-modules-and-the-filesystem外部モジュールとファイルシステム">External modules and the filesystem（外部モジュールとファイルシステム）</a></h2>
<p>Inline modules are useful for small pieces of code, but as your project grows you'll want to split your code into
multiple files. In the parent module, you declare the existence of a submodule using the <code>mod</code> keyword.</p>
<blockquote>
<p>インラインモジュールは少量のコードで便利ですが、プロジェクトが成長するにつれて、コードを複数のファイルに分割したいと考えるでしょう。
親モジュールで、<code>mod</code>キーワードを使用して、サブモジュールの存在を宣言します。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod dog;
<span class="boring">}</span></code></pre></pre>
<p><code>cargo</code>, Rust's build tool, is then in charge of finding the file that contains
the module implementation.<br />
If your module is declared in the root of your crate (e.g. <code>src/lib.rs</code> or <code>src/main.rs</code>),
<code>cargo</code> expects the file to be named either:</p>
<ul>
<li><code>src/&lt;module_name&gt;.rs</code></li>
<li><code>src/&lt;module_name&gt;/mod.rs</code></li>
</ul>
<blockquote>
<p>Rustのビルドツールである<code>cargo</code>は、モジュール実装を含むファイルを検索する責任があります。
<code>src/lib.rs</code>または<code>src/main.rs</code>など、モジュールがクレートのルートに宣言されている場合、<code>cargo</code>はファイルの名前が次のいずれかであることを期待します。</p>
<ul>
<li><code>src/&lt;module_name&gt;.rs</code></li>
<li><code>src/&lt;module_name&gt;/mod.rs</code></li>
</ul>
</blockquote>
<p>If your module is a submodule of another module, the file should be named:</p>
<ul>
<li><code>[..]/&lt;parent_module&gt;/&lt;module_name&gt;.rs</code></li>
<li><code>[..]/&lt;parent_module&gt;/&lt;module_name&gt;/mod.rs</code></li>
</ul>
<blockquote>
<p>モジュールが他のモジュールのサブモジュールの場合、ファイルは次の通り名付けられるべきです。</p>
<ul>
<li><code>[..]/&lt;parent_module&gt;/&lt;module_name&gt;.rs</code></li>
<li><code>[..]/&lt;parent_module&gt;/&lt;module_name&gt;/mod.rs</code></li>
</ul>
</blockquote>
<p>E.g. <code>src/animals/dog.rs</code> or <code>src/animals/dog/mod.rs</code> if <code>dog</code> is a submodule of <code>animals</code>.</p>
<blockquote>
<p>例えば、<code>dog</code>が<code>animals</code>のサブモジュールの場合、<code>src/animals/dog.rs</code>または<code>src/animals/dog/mod.rs</code>です。</p>
</blockquote>
<p>Your IDE might help you create these files automatically when you declare a new module using the <code>mod</code> keyword.</p>
<blockquote>
<p>IDEは、<code>mod</code>キーワードを使用して新しいモジュールを宣言したとき、自動的にこれらのファイルを作成することを支援するかもしれません。</p>
</blockquote>
<h2 id="item-paths-and-use-statementsアイテムパスとuse文"><a class="header" href="#item-paths-and-use-statementsアイテムパスとuse文">Item paths and <code>use</code> statements（アイテムパスとuse文）</a></h2>
<p>You can access items defined in the same module without any special syntax. You just use their name.</p>
<blockquote>
<p>特別な構文なしで、同じモジュール内に定義されたアイテムにアクセスできます。
単にそれらの名前を使用するだけです。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Ticket {
    // [...]
}

// No need to qualify `Ticket` in any way here
// because we're in the same module
// 同じモジュール内にいるため、ここではなにも`Ticket`を修飾する必要はありません。
fn mark_ticket_as_done(ticket: Ticket) {
    // [...]
}
<span class="boring">}</span></code></pre></pre>
<p>That's not the case if you want to access an entity from a different module.<br />
You have to use a <strong>path</strong> pointing to the entity you want to access.</p>
<blockquote>
<p>異なるモジュールのエンティティにアクセスしたい場合は別です。
アクセスしたいエンティティを示す<strong>パス</strong>を使用しなければなりません。</p>
</blockquote>
<p>You can compose the path in various ways:</p>
<ul>
<li>starting from the root of the current crate, e.g. <code>crate::module_1::module_2::MyStruct</code></li>
<li>starting from the parent module, e.g. <code>super::my_function</code></li>
<li>starting from the current module, e.g. <code>sub_module_1::MyStruct</code></li>
</ul>
<blockquote>
<p>さまざまな方法でパスを構成できます。</p>
<ul>
<li>例えば、<code>crate::module_1::module_2::MyStruct</code>のように、現在のクレートのルートから開始</li>
<li>例えば、<code>super::my_function</code>のうように、親モジュールから開始</li>
<li>例えば、<code>sub_module_1::MyStruct</code>のように、現在のモジュールから開始</li>
</ul>
</blockquote>
<p>Having to write the full path every time you want to refer to a type can be cumbersome.
To make your life easier, you can introduce a <code>use</code> statement to bring the entity into scope.</p>
<blockquote>
<p>型を参照したい場合はいつでも、完全なパスを記述しなければならないことは、面倒になる可能性があります。
人生を楽にするために、スコープ内にエンティティを持ち込む<code>use</code>文を導入できます。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Bring `MyStruct` into scope
use crate::module_1::module_2::MyStruct;

// Now you can refer to `MyStruct` directly
fn a_function(s: MyStruct) {
     // [...]
}
<span class="boring">}</span></code></pre></pre>
<h3 id="star-importsスターインポート"><a class="header" href="#star-importsスターインポート">Star imports（スターインポート）</a></h3>
<p>You can also import all the items from a module with a single <code>use</code> statement.</p>
<blockquote>
<p>また、単一の<code>use</code>文を使用して、モジュールからすべてのアイテムをインポートできます。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::module_1::module_2::*;
<span class="boring">}</span></code></pre></pre>
<p>This is known as a <strong>star import</strong>.<br />
It is generally discouraged because it can pollute the current namespace, making it hard to understand
where each name comes from and potentially introducing name conflicts.<br />
Nonetheless, it can be useful in some cases, like when writing unit tests. You might have noticed
that most of our test modules start with a <code>use super::*;</code> statement to bring all the items from the parent module
(the one being tested) into scope.</p>
<blockquote>
<p>これは<strong>スターインポート</strong>として知られています。
それは、それぞれの名前がどこから来たのか理解することを難しくして、名前の衝突を招く可能性があり、現在の名前空間を汚染する可能性があるため、一般的には推奨されません。
それにも関わらず、ユニットテストを記述しているときなど、スターインポートはいくつかの場面で便利です。
ほとんどのテストモジュールが、親モジュールからテストされるすべてのアイテムをスコープ内に持ち込むために、<code>user super::*;</code>文で開始していることに気付いたかもしれません。</p>
</blockquote>
<h2 id="exercise-16"><a class="header" href="#exercise-16">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/03_ticket_v1/03_modules"><code>03_ticket_v1/03_modules</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="visibility可視性"><a class="header" href="#visibility可視性">Visibility（可視性）</a></h1>
<p>When you start breaking down your code into multiple modules, you need to start thinking about <strong>visibility</strong>.
Visibility determines which regions of your code (or other people's code) can access a given entity,
be it a struct, a function, a field, etc.</p>
<blockquote>
<p>コードを複数のモジュールに分割し始めたとき、<strong>可視性</strong>について考え始めなければなりません。
可視性は、コードまたは他の人のコードのどの領域が、構造体、関数、フィールドなど、特定のエンティティにアクセスできるかを決定します。</p>
</blockquote>
<h2 id="private-by-defaultデフォルトでプライベート"><a class="header" href="#private-by-defaultデフォルトでプライベート">Private by default（デフォルトでプライベート）</a></h2>
<p>By default, everything in Rust is <strong>private</strong>.<br />
A private entity can only be accessed:</p>
<ol>
<li>within the same module where it's defined, or</li>
<li>by one of its submodules</li>
</ol>
<blockquote>
<p>デフォルトで、Rustのすべては<strong>プライベート</strong>です。
プライベートなエンティティは、次のいずれかでのみアクセスできます。</p>
<ol>
<li>それが定義された同じモジュール内で、または・・・</li>
<li>そのサブモジュールのいずれかによって</li>
</ol>
</blockquote>
<p>We've used this extensively in the previous exercises:</p>
<ul>
<li><code>create_todo_ticket</code> worked (once you added a <code>use</code> statement) because <code>helpers</code> is a submodule of the crate root,
where <code>Ticket</code> is defined. Therefore, <code>create_todo_ticket</code> can access <code>Ticket</code> without any issues even
though <code>Ticket</code> is private.</li>
<li>All our unit tests are defined in a submodule of the code they're testing, so they can access everything without
restrictions.</li>
</ul>
<blockquote>
<p>前の演習でこれを広範囲に使用しました。</p>
<ul>
<li><code>create_todo_ticket</code>は、<code>helpers</code>が<code>Ticket</code>が定義されたクレートルートのサブモジュールのため、一旦<code>use</code>文を追加すると機能しました。
よって、<code>create_todo_ticket</code>は、<code>Ticket</code>がプライベートであるにも関わらず、問題なく<code>Ticket</code>にアクセスできます。</li>
<li>すべてのユニットテストは、ユニットテストがテストしているコード（<code>Ticket</code>）のサブモジュールに定義されたため、ユニットテストは制限無しですべてにアクセスできます。</li>
</ul>
</blockquote>
<h2 id="visibility-modifiers可視性修飾子"><a class="header" href="#visibility-modifiers可視性修飾子">Visibility modifiers（可視性修飾子）</a></h2>
<p>You can modify the default visibility of an entity using a <strong>visibility modifier</strong>.<br />
Some common visibility modifiers are:</p>
<ul>
<li><code>pub</code>: makes the entity <strong>public</strong>, i.e. accessible from outside the module where it's defined, potentially from
other crates.</li>
<li><code>pub(crate)</code>: makes the entity public within the same <strong>crate</strong>, but not outside of it.</li>
<li><code>pub(super)</code>: makes the entity public within the parent module.</li>
<li><code>pub(in path::to::module)</code>: makes the entity public within the specified module.</li>
</ul>
<blockquote>
<p><strong>可視性修飾子</strong>を使用して、エンティティのデフォルトの可視性を変更できます。
いくつか一般的な可視性修飾子を次に示します。</p>
<ul>
<li><code>pub</code>: エンティティを<strong>パブリック</strong>にします。例えば、それが定義されたモジュールの外からアクセス可能で、他のクレートからも可能です。</li>
<li><code>pub(crate)</code>: 同じ<strong>クレート</strong>内でエンティティをパブリックにしますが、そのクレートの外部からアクセスできません。</li>
<li><code>pub(super)</code>: 親モジュール内でエンティティをパブリックにします。</li>
<li><code>pub(in path::to::module)</code>: 指定されたモジュール内でエンティティをパブリックにします。</li>
</ul>
</blockquote>
<p>You can use these modifiers on modules, structs, functions, fields, etc.
For example:</p>
<blockquote>
<p>これらの修飾子を構造体、関数、フィールドなどに使用できます。
例えば・・・</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Configuration {
    pub(crate) version: u32,
    active: bool,
}
<span class="boring">}</span></code></pre></pre>
<p><code>Configuration</code> is public, but you can only access the <code>version</code> field from within the same crate.
The <code>active</code> field, instead, is private and can only be accessed from within the same module or one of its submodules.</p>
<blockquote>
<p><code>Configuration</code>はパブリックですが、同じクレート内でのみ<code>version</code>フィールドにアクセスできます。
代わりに<code>active</code>フィールドはプライベートで、同じモジュールかそのサブモジュール内でのみアクセスできます。</p>
</blockquote>
<h2 id="exercise-17"><a class="header" href="#exercise-17">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/03_ticket_v1/04_visibility"><code>03_ticket_v1/04_visibility</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="encapsulationカプセル化"><a class="header" href="#encapsulationカプセル化">Encapsulation（カプセル化）</a></h1>
<p>Now that we have a basic understanding of modules and visibility, let's circle back to <strong>encapsulation</strong>.<br />
Encapsulation is the practice of hiding the internal representation of an object. It is most commonly
used to enforce some <strong>invariants</strong> on the object's state.</p>
<blockquote>
<p>現在、モジュールと可視性の基本的な理解があるため、<strong>カプセル化</strong>について再度考えてみましょう。
カプセル化は、オブジェクトの内部表現を隠す実践です。
それは、オブジェクトの状態に、何らかの<strong>不変</strong>に強制するために、最も一般的に使用されます。</p>
</blockquote>
<p>Going back to our <code>Ticket</code> struct:</p>
<blockquote>
<p><code>Ticket</code>構造体に戻りましょう。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Ticket {
    title: String,
    description: String,
    status: String,
}
<span class="boring">}</span></code></pre></pre>
<p>If all fields are made public, there is no encapsulation.<br />
You must assume that the fields can be modified at any time, set to any value that's allowed by
their type. You can't rule out that a ticket might have an empty title or a status
that doesn't make sense.</p>
<blockquote>
<p>すべてのフィールドをパブリックにする場合、カプセル化はありません。
いつでもフィールドが変更され、それらの型に従って任意な値を設定されることを想定しなければなりません。
チケットが、意味のない空のタイトルや状態を持つかもしれず、それを除外できません。</p>
</blockquote>
<p>To enforce stricter rules, we must keep the fields private<sup class="footnote-reference"><a href="#newtype">1</a></sup>.
We can then provide public methods to interact with a <code>Ticket</code> instance.
Those public methods will have the responsibility of upholding our invariants (e.g. a title must not be empty).</p>
<blockquote>
<p>厳密なルールを強制するために、フィールドをプライベートに維持しなければなりません。
そして、<code>Ticket</code>インスタンスと相互作用するパブリックなメソッドを提供できます。
それらパブリックメソッドは、例えばタイトルは空であってはならないなどの、不変を維持する責任をもちます。</p>
</blockquote>
<p>If all fields are private, it is no longer possible to create a <code>Ticket</code> instance directly using the struct
instantiation syntax:</p>
<blockquote>
<p>すべてのフィールドがプライベートの場合、構造体インスタンス化構文を使用して、直接<code>Ticket</code>インスタンスを作成できなくなります。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// This won't work!
// （`Ticket`構造体のすべてのフィールドがプライベートであるため）次は機能しません！
let ticket = Ticket {
    title: "Build a ticket system".into(),
    description: "Create a system that can manage tickets across a Kanban board".into(),
    status: "Open".into()
};
<span class="boring">}</span></code></pre></pre>
<p>You've seen this in action in the previous exercise on visibility.<br />
We now need to provide one or more public <strong>constructors</strong>—i.e. static methods or functions that can be used
from outside the module to create a new instance of the struct.<br />
Luckily enough we already have one: <code>Ticket::new</code>, as implemented in <a href="03_ticket_v1/02_validation.html">a previous exercise</a>.</p>
<blockquote>
<p>可視性の前の演習内で実際にこれを確認しました。
現在、例えば構造体の新しいインスタンスを作成するために、モジュールの外側から使用される静的メソッドまたは関数など、1つ以上のパブリックな<strong>コンストラクター</strong>を提供する必要があります。
とても幸いなことに、前の演習で実装した<code>Ticket::new</code>がすでにあります。</p>
</blockquote>
<h2 id="accessor-methodsアクセッサーメソッド"><a class="header" href="#accessor-methodsアクセッサーメソッド">Accessor methods（アクセッサーメソッド）</a></h2>
<p>In summary:</p>
<ul>
<li>All <code>Ticket</code> fields are private</li>
<li>We provide a public constructor, <code>Ticket::new</code>, that enforces our validation rules on creation</li>
</ul>
<blockquote>
<p>要約すると:</p>
<ul>
<li>すべての<code>Ticket</code>フィールドはプライベートです。</li>
<li>作成時の検証ルールを強制するパブリックコンストラクターである<code>Ticket::new</code>を提供します。</li>
</ul>
</blockquote>
<p>That's a good start, but it's not enough: apart from creating a <code>Ticket</code>, we also need to interact with it.
But how can we access the fields if they're private?</p>
<blockquote>
<p>これは良いスタートですが、十分ではありません。<code>Ticket</code>の作成とは別に、チケットと相互作用する必要があります。
しかし、フィールドがプライベートな場合、どのようにアクセスできるのでしょうか？</p>
</blockquote>
<p>We need to provide <strong>accessor methods</strong>.<br />
Accessor methods are public methods that allow you to read the value of a private field (or fields) of a struct.</p>
<blockquote>
<p><strong>アクセッサーメソッド</strong>を提供する必要があります。
アクセッサーメソッドは、構造体のプライベートなフィールドまたは複数のフィールドの値を読み取れるパブリックメソッドです。</p>
</blockquote>
<p>Rust doesn't have a built-in way to generate accessor methods for you, like some other languages do.
You have to write them yourself—they're just regular methods.</p>
<blockquote>
<p>Rustは、他の言語のように、アクセッサーメソッドを生成する組み込みの仕組みがありません。
アクセッサーメソッドを自身で記述しなくてはなりません。アクセッサーメソッドは単なる普通のメソッドです。</p>
</blockquote>
<div class="footnote-definition" id="newtype"><sup class="footnote-definition-label">1</sup>
<p>Or refine their type, a technique we'll explore <a href="03_ticket_v1/../05_ticket_v2/15_outro.html">later on</a>.
または、型を洗練する後で探求するテクニックです。</p>
</div>
<h2 id="exercise-18"><a class="header" href="#exercise-18">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/03_ticket_v1/05_encapsulation"><code>03_ticket_v1/05_encapsulation</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ownership所有権"><a class="header" href="#ownership所有権">Ownership（所有権）</a></h1>
<p>If you solved the previous exercise using what this course has taught you so far,
your accessor methods probably look like this:</p>
<blockquote>
<p>このコースがこれまでに教えた方法を使用して、前の演習を解いた場合、アクセッサーメソッドはおそらく次のようになります。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Ticket {
    pub fn title(self) -&gt; String {
        self.title
    }

    pub fn description(self) -&gt; String {
        self.description
    }

    pub fn status(self) -&gt; String {
        self.status
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Those methods compile and are enough to get tests to pass, but in a real-world scenario they won't get you very far.
Consider this snippet:</p>
<blockquote>
<p>それらのメソッドはコンパイルされ、テストにパスするのに十分ですが、それらは実際のシナリオで役に立ちません。
次のスニペットを考えてください。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if ticket.status() == "To-Do" {
    // We haven't covered the `println!` macro yet,
    // but for now it's enough to know that it prints
    // a (templated) message to the console
    // まだ`println!`マクロを説明していませんが、現時点では、コンソールに
    // テンプレート化したメッセージを出力することを理解するだけで十分です。
    println!("Your next task is: {}", ticket.title());
}
<span class="boring">}</span></code></pre></pre>
<p>If you try to compile it, you'll get an error:</p>
<blockquote>
<p>そのコンパイルを試みると、エラーが発生します。</p>
</blockquote>
<pre><code class="language-text">error[E0382]: use of moved value: `ticket`
  --&gt; src/main.rs:30:43
   |
25 |     let ticket = Ticket::new(/* */);
   |         ------ move occurs because `ticket` has type `Ticket`,
   |                which does not implement the `Copy` trait
26 |     if ticket.status() == "To-Do" {
   |               -------- `ticket` moved due to this method call
...
30 |         println!("Your next task is: {}", ticket.title());
   |                                           ^^^^^^ value used here after move
   |
note: `Ticket::status` takes ownership of the receiver `self`, which moves `ticket`
  --&gt; src/main.rs:12:23
   |
12 |         pub fn status(self) -&gt; String {
   |                       ^^^^
</code></pre>
<p>Congrats, this is your first borrow-checker error!</p>
<blockquote>
<p>おめでとうございます。これは最初の借用チェッカーのエラーです！</p>
</blockquote>
<h2 id="the-perks-of-rusts-ownership-systemrustの所有権システムの特典"><a class="header" href="#the-perks-of-rusts-ownership-systemrustの所有権システムの特典">The perks of Rust's ownership system（Rustの所有権システムの特典）</a></h2>
<p>Rust's ownership system is designed to ensure that:</p>
<ul>
<li>Data is never mutated while it's being read</li>
<li>Data is never read while it's being mutated</li>
<li>Data is never accessed after it has been destroyed</li>
</ul>
<blockquote>
<p>Rustの所有権システムは、次を確実にするために設計されています。</p>
<ul>
<li>データが読み込まれている間に変更されない。</li>
<li>データが変更されている間に読み込まれない。</li>
<li>データが破壊された後でアクセスされない。</li>
</ul>
</blockquote>
<p>These constraints are enforced by the <strong>borrow checker</strong>, a subsystem of the Rust compiler,
often the subject of jokes and memes in the Rust community.</p>
<blockquote>
<p>これらの制約は、Rustコンパイラーのサブシステムである<strong>借用チェッカー</strong>によって強制され、Rustコミュニティー内でよくジョークやミームの対象となっています。</p>
</blockquote>
<p>Ownership is a key concept in Rust, and it's what makes the language unique.
Ownership enables Rust to provide <strong>memory safety without compromising performance</strong>.
All these things are true at the same time for Rust:</p>
<ol>
<li>There is no runtime garbage collector</li>
<li>As a developer, you rarely have to manage memory directly</li>
<li>You can't cause dangling pointers, double frees, and other memory-related bugs</li>
</ol>
<blockquote>
<p>Rustにおいて、所有権は重要な概念であり、言語をユニークにします。
所有権は、Rustに<strong>性能の妥協なしにメモリ安全</strong>を提供します。
次のすべては、Rustにおいて同時に成立します。</p>
<ol>
<li>ランタイムなガベージコレクターはありません。</li>
<li>開発者として、まれに直接メモリを管理しなければならないとことがあります。</li>
<li>ダングリングポインター、二重解放、そして他のメモリに関連するバグを引き起こせません。</li>
</ol>
</blockquote>
<p>Languages like Python, JavaScript, and Java give you 2. and 3., but not 1.<br />
Language like C or C++ give you 1., but neither 2. nor 3.</p>
<blockquote>
<p>Python、JavaScript、そしてJavaのような言語は、２と3は成立しますが、1は成立しません。
CやC++のような言語は、1は成立しますが、2と3は成立しません。</p>
</blockquote>
<p>Depending on your background, 3. might sound a bit arcane: what is a "dangling pointer"?
What is a "double free"? Why are they dangerous?<br />
Don't worry: we'll cover these concepts in more details during the rest of the course.</p>
<blockquote>
<p>バックグラウンドに依存して、3は少し難解に聞こえるかもしれません。
「ダングリングポインター」とは何でしょうか？
「二重解放」とは何でしょうか？
なぜそれらは危険なのでしょうか？
心配しないでください。コースの残りで、これらの概念をより詳細に説明します。</p>
</blockquote>
<p>For now, though, let's focus on learning how to work within Rust's ownership system.</p>
<blockquote>
<p>しかし、現時点では、Rustの所有権システム内で作業する方法を学ぶことに焦点を当てましょう。</p>
</blockquote>
<h2 id="the-owner所有者"><a class="header" href="#the-owner所有者">The owner（所有者）</a></h2>
<p>In Rust, each value has an <strong>owner</strong>, statically determined at compile-time.
There is only one owner for each value at any given time.</p>
<blockquote>
<p>Rustにおいて、それぞれの値は、コンパイル時に静的に決定される<strong>所有者</strong>を持ちます。
任意の時点でそれぞれの値には、たった1つの所有者がいます。</p>
</blockquote>
<h2 id="move-semanticsムーブセマンティックムーブの意味論"><a class="header" href="#move-semanticsムーブセマンティックムーブの意味論">Move semantics（ムーブセマンティック、ムーブの意味論）</a></h2>
<p>Ownership can be transferred.</p>
<blockquote>
<p>所有権は移動されます。</p>
</blockquote>
<p>If you own a value, for example, you can transfer ownership to another variable:</p>
<blockquote>
<p>例えば、値を所有している場合、他の変数に所有権を移動できます。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = "hello, world".to_string(); // &lt;--- `a` is the owner of the String
                                    // &lt;--- `a`は文字列の所有者です。
let b = a;  // &lt;--- `b` is now the owner of the String
            // &lt;--- 現在、`b`は文字列の所有者です。
<span class="boring">}</span></code></pre></pre>
<p>Rust's ownership system is baked into the type system: each function has to declare in its signature
<em>how</em> it wants to interact with its arguments.</p>
<blockquote>
<p>Rustの所有権システムは、型システム内に組み込まれています。
それぞれの関数は、その引数と相互作用する方法を、そのシグネチャーで宣言しなければなりません。</p>
</blockquote>
<p>So far, all our methods and functions have <strong>consumed</strong> their arguments: they've taken ownership of them.
For example:</p>
<blockquote>
<p>これまで、すべてのメソッドと関数は、それらの引数を<strong>消費</strong>しました。
それらは、実引数の所有権を取りました。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Ticket {
    pub fn description(self) -&gt; String {
        self.description
    }
}
<span class="boring">}</span></code></pre></pre>
<p><code>Ticket::description</code> takes ownership of the <code>Ticket</code> instance it's called on.<br />
This is known as <strong>move semantics</strong>: ownership of the value (<code>self</code>) is <strong>moved</strong> from the caller to
the callee, and the caller can't use it anymore.</p>
<blockquote>
<p><code>Ticket::description</code>は、それを呼び出した<code>Ticket</code>インスタンスの所有権を取ります。
これは、<strong>ムーブセマンティック</strong>として知られています。
値（<code>self</code>）の所有権は、呼び出し元から呼び出し先に<strong>移動</strong>して、呼び出し元はそれを使用できません。</p>
</blockquote>
<p>That's exactly the language used by the compiler in the error message we saw earlier:</p>
<blockquote>
<p>それは、前に見たエラーメッセージでコンパイラーによって使用された正確な言語です。</p>
</blockquote>
<pre><code class="language-text">error[E0382]: use of moved value: `ticket`
  --&gt; src/main.rs:30:43
   |
25 |     let ticket = Ticket::new(/* */);
   |         ------ move occurs because `ticket` has type `Ticket`,
   |                which does not implement the `Copy` trait
26 |     if ticket.status() == "To-Do" {
   |               -------- `ticket` moved due to this method call
...
30 |         println!("Your next task is: {}", ticket.title());
   |                                           ^^^^^^ value used here after move
   |
note: `Ticket::status` takes ownership of the receiver `self`, which moves `ticket`
  --&gt; src/main.rs:12:23
   |
12 |         pub fn status(self) -&gt; String {
   |                       ^^^^
</code></pre>
<p>In particular, this is the sequence of events that unfold when we call <code>ticket.status()</code>:</p>
<ul>
<li><code>Ticket::status</code> takes ownership of the <code>Ticket</code> instance</li>
<li><code>Ticket::status</code> extracts <code>status</code> from <code>self</code> and transfers ownership of <code>status</code> back to the caller</li>
<li>The rest of the <code>Ticket</code> instance is discarded (<code>title</code> and <code>description</code>)</li>
</ul>
<blockquote>
<p>特に、次は、<code>ticket.status()</code>を呼び出したときに、展開されたイベントのシーケンスです。</p>
<ul>
<li><code>Ticket::status</code>は、<code>Ticket</code>インスタンスの所有権を取ります。</li>
<li><code>Ticket::status</code>は、<code>self</code>から<code>status</code>を抽出して、呼び出し元に<code>status</code>の所有権を移動します。</li>
<li><code>Ticket</code>インスタンスの残りは、破棄されます（<code>title</code>と<code>description</code>）。</li>
</ul>
</blockquote>
<p>When we try to use <code>ticket</code> again via <code>ticket.title()</code>, the compiler complains: the <code>ticket</code> value is gone now,
we no longer own it, therefore we can't use it anymore.</p>
<blockquote>
<p><code>ticket.title()</code>で再度<code>ticket</code>を使用することを試みると、コンパイラーは不満を言います。
現在<code>ticket</code>の値はなくなったため、もはやそれを所有しておらず、これ以上それを使用できません。</p>
</blockquote>
<p>To build <em>useful</em> accessor methods we need to start working with <strong>references</strong>.</p>
<blockquote>
<p>_有用な_アクセッサーメソッドを構築するために、<strong>参照</strong>を使用した作業を始める必要があります。</p>
</blockquote>
<h2 id="borrowing借用"><a class="header" href="#borrowing借用">Borrowing（借用）</a></h2>
<p>It is desirable to have methods that can read the value of a variable without taking ownership of it.<br />
Programming would be quite limited otherwise. In Rust, that's done via <strong>borrowing</strong>.</p>
<blockquote>
<p>値の所有権を取らずに、変数の値を読み込むことができるメソッドを持つことが望ましいです。
そうでなければ、プログラミングは、かなり制限されます。
Rustでは、それを<strong>借用</strong>を介して行います。</p>
</blockquote>
<p>Whenever you borrow a value, you get a <strong>reference</strong> to it.<br />
References are tagged with their privileges<sup class="footnote-reference"><a href="#refine">1</a></sup>:</p>
<ul>
<li>Immutable references (<code>&amp;</code>) allow you to read the value, but not to mutate it</li>
<li>Mutable references (<code>&amp;mut</code>) allow you to read and mutate the value</li>
</ul>
<blockquote>
<p>値を借用するときはいつでも、その<strong>参照</strong>を取得します。
参照は、それらの権限でタグ付けされます。</p>
<ul>
<li>不変参照（<code>&amp;</code>）は、値を読み込めるようにしますが、それを変更できません。</li>
<li>可変参照（<code>&amp;mut</code>）は、値を読み込み、変更できるようにします。</li>
</ul>
</blockquote>
<p>Going back to the goals of Rust's ownership system:</p>
<ul>
<li>Data is never mutated while it's being read</li>
<li>Data is never read while it's being mutated</li>
</ul>
<blockquote>
<p>Rustの所有権システムの目的に戻ります。</p>
<ul>
<li>データは、それが読み込まれている間、変更できません。</li>
<li>データは、それが変更されている間、読み込みできません。</li>
</ul>
</blockquote>
<p>To ensure these two properties, Rust has to introduce some restrictions on references:</p>
<ul>
<li>You can't have a mutable reference and an immutable reference to the same value at the same time</li>
<li>You can't have more than one mutable reference to the same value at the same time</li>
<li>The owner can't mutate the value while it's being borrowed</li>
<li>You can have as many immutable references as you want, as long as there are no mutable references</li>
</ul>
<blockquote>
<p>これら2つの属性を確実にするために、Rustは参照にいくつかの制約を導入しなければなりません。</p>
<ul>
<li>同時に同じ値への可変参照と不変参照を持つことはできません。</li>
<li>同時に同じ値への可変参照を複数持つことはできません（1つしか持てない）。</li>
<li>所有者は、値が借用されている間、値を変更できません。</li>
<li>可変参照がない限り、希望に応じて多くの不変参照を持てます。</li>
</ul>
</blockquote>
<p>In a way, you can think of an immutable reference as a "read-only" lock on the value,
while a mutable reference is like a "read-write" lock.</p>
<blockquote>
<p>ある意味で、値の「読み込み専用」ロックとして不変参照を考えることができる一方で、可変参照は「読み書き」ロックのようです。</p>
</blockquote>
<p>All these restrictions are enforced at compile-time by the borrow checker.</p>
<blockquote>
<p>これらすべての制約は、借用チェッカーによってコンパイル時に強制されます。</p>
</blockquote>
<h3 id="syntax構文-1"><a class="header" href="#syntax構文-1">Syntax（構文）</a></h3>
<p>How do you borrow a value, in practice?<br />
By adding <code>&amp;</code> or <code>&amp;mut</code> <strong>in front a variable</strong>, you're borrowing its value.
Careful though! The same symbols (<code>&amp;</code> and <code>&amp;mut</code>) in <strong>front of a type</strong> have a different meaning:
they denote a different type, a reference to the original type.</p>
<p>For example:</p>
<blockquote>
<p>実際に、どのように値を借用すればよいのでしょうか？
<strong>変数の前</strong>に<code>&amp;</code>または<code>&amp;mut</code>を追加することで、その値を借用できます。
ただし、注意してください！
<strong>型の前</strong>の同じシンボル（<code>&amp;</code>と<code>&amp;mut</code>）は、異なる意味を持ちます。
それらは、オリジナルの型への参照を示す異なる型です。</p>
<p>例えば・・・</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">struct Configuration {
    version: u32,
    active: bool,
}

fn main() {
    let config = Configuration {
        version: 1,
        active: true,
    };
    // `b` is a reference to the `version` field of `config`.
    // The type of `b` is `&amp;u32`, since it contains a reference to a `u32` value.
    // We create a reference by borrowing `config.version`, using the `&amp;` operator.
    // Same symbol (`&amp;`), different meaning depending on the context!
    // `b`は、`config`の`version`フィールドへの参照です。
    // `b`は`u32`値への参照を含むため、`b`の型は`&amp;u32`です。
    // `&amp;`演算子を使用して`config.version`を借用することで、参照を作成しました。
    // 同じシンボル（`&amp;`）ですが、文脈に依存して異なる意味を持ちます！
    let b: &amp;u32 = &amp;config.version;
    //     ^ The type annotation is not necessary,
    //       it's just there to clarify what's going on
    //       型注釈は必要ありませんが、それは何が起こっているかを明確にするためだけにあります。
}</code></pre></pre>
<p>The same concept applies to function arguments and return types:</p>
<blockquote>
<p>同じ概念は、関数の引数と戻り値の型に適用されます。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// `f` takes a mutable reference to a `u32` as an argument,
// bound to the name `number`
// `f`は、引数として`u32`への可変参照を取り、名前`number`に拘束されます。
fn f(number: &amp;mut u32) -&gt; &amp;u32 {
    // [...]
}
<span class="boring">}</span></code></pre></pre>
<h2 id="breathe-in-breathe-out息を吸って息を吐く"><a class="header" href="#breathe-in-breathe-out息を吸って息を吐く">Breathe in, breathe out（息を吸って、息を吐く）</a></h2>
<p>Rust's ownership system can be a bit overwhelming at first.<br />
But don't worry: it'll become second nature with practice.<br />
And you're going to get a lot of practice over the rest of this chapter, as well as the rest of the course!
We'll revisit each concept multiple times to make sure you get familiar with them
and truly understand how they work.</p>
<blockquote>
<p>Rustの所有権システムは、最初は少し打ちのめさせられるかもしれません。
しかし、心配しないでください。それは実践により自然になります。
そして、コースの残りと同様に、この章の残りで多くの実践を行います。
それらに慣れることを確実にするために、何回もそれぞれの概念を再訪して、それらがどのように機能するかを本当に理解します。</p>
</blockquote>
<p>Towards the end of this chapter we'll explain <em>why</em> Rust's ownership system is designed the way it is.
For the time being, focus on understanding the <em>how</em>. Take each compiler error as a learning opportunity!</p>
<blockquote>
<p>この章の最後に、Rustの所有権システムが、そのように設計された理由を説明します。
現時点では、_どのように_理解するかに焦点を当ててください。
学ぶ機会として、それぞれのコンパイルエラーを受け入れてください！</p>
</blockquote>
<div class="footnote-definition" id="refine"><sup class="footnote-definition-label">1</sup>
<p>This is a great mental model to start out, but it doesn't capture the <em>full</em> picture.
We'll refine our understanding of references <a href="03_ticket_v1/../07_threads/06_interior_mutability.html">later in the course</a>.
これは始めるための素晴らしいメンタルモデルですが、_完全な_姿を捉えていません。
コースの後半で、参照の理解を洗練させます。</p>
</div>
<h2 id="exercise-19"><a class="header" href="#exercise-19">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/03_ticket_v1/06_ownership"><code>03_ticket_v1/06_ownership</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mutable-references可変参照"><a class="header" href="#mutable-references可変参照">Mutable references（可変参照）</a></h1>
<p>Your accessor methods should look like this now:</p>
<blockquote>
<p>現在、アクセッサーメソッドは、次のようになります。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Ticket {
    pub fn title(&amp;self) -&gt; &amp;String {
        &amp;self.title
    }

    pub fn description(&amp;self) -&gt; &amp;String {
        &amp;self.description
    }

    pub fn status(&amp;self) -&gt; &amp;String {
        &amp;self.status
    }
}
<span class="boring">}</span></code></pre></pre>
<p>A sprinkle of <code>&amp;</code> here and there did the trick!<br />
We now have a way to access the fields of a <code>Ticket</code> instance without consuming it in the process.
Let's see how we can enhance our <code>Ticket</code> struct with <strong>setter methods</strong> next.</p>
<blockquote>
<p>ここに<code>&amp;</code>を振りかけることで、それらはうまくいきました！
現在、処理で<code>Ticket</code>インスタンスを消費しないで、<code>Ticket</code>インスタンスのフィールドにアクセスする方法を持つようになりました。
次に、<strong>セッターメソッド</strong>で<code>Ticket</code>構造体を強化する方法を確認しましょう。</p>
</blockquote>
<h2 id="settersセッター"><a class="header" href="#settersセッター">Setters（セッター）</a></h2>
<p>Setter methods allow users to change the values of <code>Ticket</code>'s private fields while making sure that its invariants
are respected (i.e. you can't set a <code>Ticket</code>'s title to an empty string).</p>
<blockquote>
<p>セッターメソッドは、例えば、<code>Ticket</code>のタイトルに空の文字列を設定できないなど、<code>Ticket</code>の不変性を尊重することを確実にする一方で、<code>Ticket</code>のプライベートフィールドの値を変更できるようにします。</p>
</blockquote>
<p>There are two common ways to implement setters in Rust:</p>
<ul>
<li>Taking <code>self</code> as input.</li>
<li>Taking <code>&amp;mut self</code> as input.</li>
</ul>
<blockquote>
<p>Rustにおいてセッターを実装する2つの一般的な方法があります。</p>
<ul>
<li>入力として<code>self</code>を受け取る。</li>
<li>入力として<code>&amp;mut self</code>を受け取る。</li>
</ul>
</blockquote>
<h3 id="taking-self-as-input入力としてselfを受け取る"><a class="header" href="#taking-self-as-input入力としてselfを受け取る">Taking <code>self</code> as input（入力としてselfを受け取る）</a></h3>
<p>The first approach looks like this:</p>
<blockquote>
<p>最初の方法は次のようになります。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Ticket {
    pub fn set_title(mut self, new_title: String) -&gt; Self {
        // Validate the new title [...]
        // 新しいタイトルを検証します。
        self.title = new_title;
        self
    }
}
<span class="boring">}</span></code></pre></pre>
<p>It takes ownership of <code>self</code>, changes the title, and returns the modified <code>Ticket</code> instance.<br />
This is how you'd use it:</p>
<blockquote>
<p>それは、<code>self</code>の所有権を取得して、タイトルを変更した後、変更された<code>Ticket</code>インスタンスを返します。
次はそれを使用する方法です。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let ticket = Ticket::new("Title".into(), "Description".into(), "To-Do".into());
let ticket = ticket.set_title("New title".into());
<span class="boring">}</span></code></pre></pre>
<p>Since <code>set_title</code> takes ownership of <code>self</code> (i.e. it <strong>consumes it</strong>), we need to reassign the result to a variable.
In the example above we take advantage of <strong>variable shadowing</strong> to reuse the same variable name: when
you declare a new variable with the same name as an existing one, the new variable <strong>shadows</strong> the old one. This
is a common pattern in Rust code.</p>
<blockquote>
<p><code>set_title</code>が<code>self</code>の所有権を取得して、<strong>それを消費する</strong>ため、変数に結果を再割り当てする必要があります。
上記例において、変数の名前を再利用する_変数のシャドーイング_を利用しています。
存在する同じ名前で新しい変数を宣言したとき、新しい変数は古いものを<strong>隠します</strong>。
Rustのコードで、これは一般的なパターンです。</p>
</blockquote>
<p><code>self</code>-setters work quite nicely when you need to change multiple fields at once: you can chain multiple calls together!</p>
<blockquote>
<p>一度に複数のフィールドを変更する必要があるときも、<code>self</code>セッターはとても良く機能します。
複数の呼び出しを一緒に繋げれます。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let ticket = ticket
    .set_title("New title".into())
    .set_description("New description".into())
    .set_status("In Progress".into());
<span class="boring">}</span></code></pre></pre>
<h3 id="taking-mut-self-as-input入力としてmut-selfを受け取る"><a class="header" href="#taking-mut-self-as-input入力としてmut-selfを受け取る">Taking <code>&amp;mut self</code> as input（入力として&amp;mut selfを受け取る）</a></h3>
<p>The second approach to setters, using <code>&amp;mut self</code>, looks like this instead:</p>
<blockquote>
<p><code>&amp;mut self</code>を使用するセッターの2つ目の方法は、次のようになります。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Ticket {
    pub fn set_title(&amp;mut self, new_title: String) {
        // Validate the new title [...]
        // 新しいタイトルを検証します。

        self.title = new_title;
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This time the method takes a mutable reference to <code>self</code> as input, changes the title, and that's it.
Nothing is returned.</p>
<blockquote>
<p>今回、メソッドは入力として<code>self</code>への可変参照を受け取り、タイトルを変更して、それだけです。
何も返されません。</p>
</blockquote>
<p>You'd use it like this:</p>
<blockquote>
<p>次のようにそれを使用します。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut ticket = Ticket::new("Title".into(), "Description".into(), "To-Do".into());
ticket.set_title("New title".into());

// Use the modified ticket
// 変更されたチケットを使用します。
<span class="boring">}</span></code></pre></pre>
<p>Ownership stays with the caller, so the original <code>ticket</code> variable is still valid. We don't need to reassign the result.
We need to mark <code>ticket</code> as mutable though, because we're taking a mutable reference to it.</p>
<blockquote>
<p>所有権は呼び出し元に留まるため、オリジナルの<code>ticket</code>変数はまだ有効です。
結果を再割り当てする必要はありません。
しかし、その可変参照を得ているため、可変として<code>ticket</code>をマークする必要があります。</p>
</blockquote>
<p><code>&amp;mut</code>-setters have a downside: you can't chain multiple calls together.
Since they don't return the modified <code>Ticket</code> instance, you can't call another setter on the result of the first one.
You have to call each setter separately:</p>
<blockquote>
<p><code>&amp;mut</code>セッターは欠点があります。複数の呼び出しを一緒に繋げれません。
変更された<code>ticket</code>インスタンスを返さないため、最初の結果で他のセッターを呼び出しできません。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>ticket.set_title("New title".into());
ticket.set_description("New description".into());
ticket.set_status("In Progress".into());
<span class="boring">}</span></code></pre></pre>
<h2 id="exercise-20"><a class="header" href="#exercise-20">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/03_ticket_v1/07_setters"><code>03_ticket_v1/07_setters</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="memory-layoutメモリレイアウト"><a class="header" href="#memory-layoutメモリレイアウト">Memory layout（メモリレイアウト）</a></h1>
<p>We've looked at ownership and references from an operational point of view—what you can and can't do with them.
Now it's a good time to take a look under the hood: let's talk about <strong>memory</strong>.</p>
<blockquote>
<p>操作の観点から、所有権と参照を使用して何ができて、何ができないかを確認しました。
現在、内部を確認する良い時です。</p>
</blockquote>
<h2 id="stack-and-heapスタックとヒープ"><a class="header" href="#stack-and-heapスタックとヒープ">Stack and heap（スタックとヒープ）</a></h2>
<p>When discussing memory, you'll often hear people talk about the <strong>stack</strong> and the <strong>heap</strong>.<br />
These are two different memory regions used by programs to store data.</p>
<blockquote>
<p>メモリを議論するとき、人が<strong>スタック</strong>と<strong>ヒープ</strong>について話していることを、よく聞くでしょう。
これらは、データを保存するためにプログラムによって使用される2つの異なるメモリ領域です。</p>
</blockquote>
<p>Let's start with the stack.</p>
<blockquote>
<p>スタックから始めましょう。</p>
</blockquote>
<h2 id="stackスタック"><a class="header" href="#stackスタック">Stack（スタック）</a></h2>
<p>The <strong>stack</strong> is a <strong>LIFO</strong> (Last In, First Out) data structure.<br />
When you call a function, a new <strong>stack frame</strong> is added on top of the stack. That stack frame stores
the function's arguments, local variables and a few "bookkeeping" values.<br />
When the function returns, the stack frame is popped off the stack<sup class="footnote-reference"><a href="#stack-overflow">1</a></sup>.</p>
<blockquote>
<p><strong>スタック</strong>は<strong>LIFO</strong>（Last In, First Out: 最後に入ったら、最初に出る）データ構造です。
関数を呼び出したとき、新しい<strong>スタックフレーム</strong>がスタックの最上部に追加されます。
スタックフレームは関数の引数、ローカル変数、そして少しの「簿記するため」の値を保存します。
関数が戻ったとき、スタックフレームはスタックから取り出されます。</p>
</blockquote>
<blockquote>
<p><code>bookkeeping</code>: 簿記、帳簿管理、経理の意味だが、この場合、スタックを管理することを示していると考えられる。
スタックを利用するためには、スタックの先頭を指すポインタが必要で、そのポインタの位置を管理することが必要になる。</p>
</blockquote>
<pre><code class="language-text">                                 +-----------------+
                       func2     | frame for func2 |   func2
+-----------------+  is called   +-----------------+  returns   +-----------------+
| frame for func1 | -----------&gt; | frame for func1 | ---------&gt; | frame for func1 |
+-----------------+              +-----------------+            +-----------------+
</code></pre>
<p>From an operational point of view, stack allocation/de-allocation is <strong>very fast</strong>.<br />
We are always pushing and popping data from the top of the stack, so we don't need to search for free memory.
We also don't have to worry about fragmentation: the stack is a single contiguous block of memory.</p>
<blockquote>
<p>操作の観点から、スタックの割り当て／解放は<strong>とても早い</strong>です。
常にスタックの最上部にデータを入れて、最上部からデータを取り出すため、空きメモリを探す必要はありません。
また、フラグメントについて心配する必要もありません。
スタックは、1つの連続したメモリブロックです。</p>
</blockquote>
<h3 id="rust"><a class="header" href="#rust">Rust</a></h3>
<p>Rust will often allocate data on the stack.<br />
You have a <code>u32</code> input argument in a function? Those 32 bits will be on the stack.<br />
You define a local variable of type <code>i64</code>? Those 64 bits will be on the stack.<br />
It all works quite nicely because the size of those integers is known at compile time, therefore
the compiled program knows how much space it needs to reserve on the stack for them.</p>
<blockquote>
<p>Rustは、よくスタックにデータを割り当てます。
関数に<code>u32</code>の入力引数がありますか？その32ビットはスタックにあります。
<code>i64</code>型のローカル変数を定義してますか？その64ビットはスタックにあります。
それら整数のサイズは、コンパイル時にわかるため、そのすべてはとても素晴らしく機能します。
よって、コンパイルされたプログラムは、それらのためにスタックに予約する必要がある領域の量を理解しています。</p>
</blockquote>
<h3 id="stdmemsize_of"><a class="header" href="#stdmemsize_of"><code>std::mem::size_of</code></a></h3>
<p>You can verify how much space a type would take on the stack
using the <a href="https://doc.rust-lang.org/std/mem/fn.size_of.html"><code>std::mem::size_of</code></a> function.</p>
<blockquote>
<p>型がスタックにどれだけ多くの領域を取得するか、<code>std::mem::size_of</code>関数を使用することで検証できます。</p>
</blockquote>
<p>For a <code>u8</code>, for example:</p>
<blockquote>
<p>例えば<code>u8</code>では・・・</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// We'll explain this funny-looking syntax (`::&lt;u8&gt;`) later on.
// Ignore it for now.
// 後で、この面白く見える構文（`::&lt;u8&gt;`）を説明します。
// 現時点では無視してください。
assert_eq!(std::mem::size_of::&lt;u8&gt;(), 1);
<span class="boring">}</span></code></pre></pre>
<p>1 makes sense, because a <code>u8</code> is 8 bits long, or 1 byte.</p>
<blockquote>
<p><code>u8</code>は8ビット長または1バイトであるため、1は理にかなっています。</p>
</blockquote>
<div class="footnote-definition" id="stack-overflow"><sup class="footnote-definition-label">1</sup>
<p>If you have nested function calls, each function pushes its data onto the stack when it's called but
it doesn't pop it off until the innermost function returns.
If you have too many nested function calls, you can run out of stack space—the stack is not infinite!
That's called a <a href="https://en.wikipedia.org/wiki/Stack_overflow"><strong>stack overflow</strong></a>.
ネストされた関数呼び出しがある場合、関数が呼び出されたとき、それぞれの関数はスタックに関数のデータをプッシュしますが、最も内側にある関数が戻るまで、そのデータは取り出されません。
非常に多くネストした関数呼び出しがある場合、スタック領域を使い果たすかもしれません。スタックは無限でありません。
これは<strong>スタック・オーバーフロー</strong>と呼ばれます。</p>
</div>
<h2 id="exercise-21"><a class="header" href="#exercise-21">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/03_ticket_v1/08_stack"><code>03_ticket_v1/08_stack</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="heapヒープ"><a class="header" href="#heapヒープ">Heap（ヒープ）</a></h1>
<p>The stack is great, but it can't solve all our problems. What about data whose size is not known at compile time?
Collections, strings, and other dynamically-sized data cannot be (entirely) stack-allocated.
That's where the <strong>heap</strong> comes in.</p>
<blockquote>
<p>スタックは偉大ですが、スタックはすべてのプログラムを解決することができません。
コンパイル時にデータのサイズがわからない場合、何が発生しますか？
コレクション、文字列、そして他の動的なサイズを持つデータは、まったくスタックに割り当てられません。
ここで、<strong>ヒープ</strong>が登場します。</p>
</blockquote>
<h2 id="heap-allocationsヒープ割り当て"><a class="header" href="#heap-allocationsヒープ割り当て">Heap allocations（ヒープ割り当て）</a></h2>
<p>You can visualize the heap as a big chunk of memory—a huge array, if you will.<br />
Whenever you need to store data on the heap, you ask a special program, the <strong>allocator</strong>, to reserve for you
a subset of the heap. We call this interaction (and the memory you reserved) a <strong>heap allocation</strong>.
If the allocation succeeds, the allocator will give you a <strong>pointer</strong> to the start of the reserved block.</p>
<blockquote>
<p>大きなメモリの塊、巨大な配列としてヒープを可視化できます。
ヒープにデータを保存する必要があるときはいつでも、ヒープの部分集合を予約するために<strong>アロケーター</strong>という特別なプログラムに依頼します。
割り当てが成功した場合、アロケーターは予約されたブロックの開始を指す<strong>ポインター</strong>を与えます。</p>
</blockquote>
<h2 id="no-automatic-de-allocation自動解放なし"><a class="header" href="#no-automatic-de-allocation自動解放なし">No automatic de-allocation（自動解放なし）</a></h2>
<p>The heap is structured quite differently from the stack.<br />
Heap allocations are not contiguous, they can be located anywhere inside the heap.</p>
<blockquote>
<p>ヒープはスタックとまったく異なる構造になっています。
ヒープ割り当ては連続的ではなく、それらはヒープ内のどこでも配置されます。</p>
</blockquote>
<pre><code class="language-text">+---+---+---+---+---+---+-...-+-...-+---+---+---+---+---+---+---+
|  Allocation 1 | Free  | ... | ... |  Allocation N |    Free   |
+---+---+---+---+---+---+ ... + ... +---+---+---+---+---+---+---+
</code></pre>
<p>It's the allocator's job to keep track of which parts of the heap are in use and which are free.
The allocator won't automatically free the memory you allocated, though: you need to be deliberate about it,
calling the allocator again to <strong>free</strong> the memory you no longer need.</p>
<blockquote>
<p>ヒープのどの部分が使用中で、どこが空いているのかを追跡することは、アロケーターの仕事です。
アロケーターは、割り当てられたメモリを自動的に解放しませんが、再度アロケーターを呼び出して、もはや必要のないメモリを<strong>開放</strong>することを、意図的にしなければなりません。</p>
</blockquote>
<h2 id="performance性能"><a class="header" href="#performance性能">Performance（性能）</a></h2>
<p>The heap's flexibility comes at a cost: heap allocations are <strong>slower</strong> than stack allocations.
There's a lot more bookkeeping involved!<br />
If you read articles about performance optimization you'll often be advised to minimize heap allocations
and prefer stack-allocated data whenever possible.</p>
<blockquote>
<p>ヒープの柔軟性はコストが掛かります。ヒープ割り当てはスタック割り当てよりも<strong>遅い</strong>です。
これらは、多くのブックキーピングが関係しています。
パフォーマンス最適化の記事を読んだ場合、ときどきヒープ割り当てを最小にして、可能なときはいつでもスタック割り当てを選ぶように勧められます。</p>
</blockquote>
<h2 id="strings-memory-layoutstringのメモリレイアウト"><a class="header" href="#strings-memory-layoutstringのメモリレイアウト"><code>String</code>'s memory layout（Stringのメモリレイアウト）</a></h2>
<p>When you create a local variable of type <code>String</code>,
Rust is forced to allocate on the heap<sup class="footnote-reference"><a href="#empty">1</a></sup>: it doesn't know in advance how much text you're going to put in it,
so it can't reserve the right amount of space on the stack.<br />
But a <code>String</code> is not <em>entirely</em> heap-allocated, it also keeps some data on the stack. In particular:</p>
<ul>
<li>The <strong>pointer</strong> to the heap region you reserved.</li>
<li>The <strong>length</strong> of the string, i.e. how many bytes are in the string.</li>
<li>The <strong>capacity</strong> of the string, i.e. how many bytes have been reserved on the heap.</li>
</ul>
<blockquote>
<p><code>String</code>型のローカル変数を作成したとき、Rustはヒープの割り当てを強制されます。
変数にどれだけのテキストをいれるか事前に知ることはできないため、それはスタックに正しい量の領域を予約することができません。
しかし、<code>String</code>は_完全に_ヒープ割り当てではなく、スタックにもいくつかデータを保持しています。特に・・・</p>
<ul>
<li>予約したヒープ領域への<strong>ポインター</strong></li>
<li>文字列の<strong>長さ</strong>、つまり文字列にあるバイト数</li>
<li>文字列の<strong>容量</strong>、つまりヒープに予約されているバイト数</li>
</ul>
</blockquote>
<p>Let's look at an example to understand this better:</p>
<blockquote>
<p>これをよく理解するために、例を確認しましょう。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut s = String::with_capacity(5);
<span class="boring">}</span></code></pre></pre>
<p>If you run this code, memory will be laid out like this:</p>
<blockquote>
<p>このコードを実行した場合、メモリは次のように配置されます。</p>
</blockquote>
<pre><code class="language-text">      +---------+--------+----------+
Stack | pointer | length | capacity |
      |  |      |   0    |    5     |
      +--|------+--------+----------+
         |
         |
         v
       +---+---+---+---+---+
Heap:  | ? | ? | ? | ? | ? |
       +---+---+---+---+---+
</code></pre>
<p>We asked for a <code>String</code> that can hold up to 5 bytes of text.<br />
<code>String::with_capacity</code> goes to the allocator and asks for 5 bytes of heap memory. The allocator returns
a pointer to the start of that memory block.<br />
The <code>String</code> is empty, though. On the stack, we keep track of this information by distinguishing between
the length and the capacity: this <code>String</code> can hold up to 5 bytes, but it currently holds 0 bytes of
actual text.</p>
<blockquote>
<p>5バイトのテキストを保持できる<code>String</code>を要求しました。
<code>String::with_capacity</code>はアロケーターに対して、ヒープメモリの５バイトを要求します。
アロケーターは、そのメモリブロックの開始を指すポインターを返します。
しかし、<code>String</code>は空です。
スタックで長さと容量を区別することでこの情報を追跡します。
この<code>String</code>は5バイトまで保持できますが、現在、実際のテキストの0バイトを保持します。</p>
</blockquote>
<p>If you push some text into the <code>String</code>, the situation will change:</p>
<blockquote>
<p><code>String</code>に任意のテキストを入れたとき、状況は変わります。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>s.push_str("Hey");
<span class="boring">}</span></code></pre></pre>
<pre><code class="language-text">      +---------+--------+----------+
Stack | pointer | length | capacity |
      |  |      |   3    |    5     |
      +--|  ----+--------+----------+
         |
         |
         v
       +---+---+---+---+---+
Heap:  | H | e | y | ? | ? |
       +---+---+---+---+---+
</code></pre>
<p><code>s</code> now holds 3 bytes of text. Its length is updated to 3, but capacity remains 5.
Three of the five bytes on the heap are used to store the characters <code>H</code>, <code>e</code>, and <code>y</code>.</p>
<blockquote>
<p>現在、<code>s</code>は3バイトのテキストを保持しています。
その長さは3に更新されますが、容量は5のままです。
ヒープ上の5バイトの3バイトは、文字<code>H</code>、<code>e</code>、<code>y</code>を保存するために使用されます。</p>
</blockquote>
<h3 id="usize"><a class="header" href="#usize"><code>usize</code></a></h3>
<p>How much space do we need to store pointer, length and capacity on the stack?<br />
It depends on the <strong>architecture</strong> of the machine you're running on.</p>
<blockquote>
<p>スタックにポインター、長さそして容量を保存するために必要な領域はどれくらいでしょうか？
それは、実行しているマシンの<strong>アーキテクチャ</strong>に依存します。</p>
</blockquote>
<p>Every memory location on your machine has an <a href="https://en.wikipedia.org/wiki/Memory_address"><strong>address</strong></a>, commonly
represented as an unsigned integer.
Depending on the maximum size of the address space (i.e. how much memory your machine can address),
this integer can have a different size. Most modern machines use either a 32-bit or a 64-bit address space.</p>
<blockquote>
<p>マシン上のそれぞれのメモリ位置は<strong>アドレス</strong>で、一般的に符号なし整数で表現されます。
アドレス空間の最大サイズに依存して（つまり、マシンが処理できるメモリの量）、この整数はさまざまなサイズになります。
最も現代的なマシンは、32ビットまたは64ビットのアドレス空間のどちらかを使用します。</p>
</blockquote>
<p>Rust abstracts away these architecture-specific details by providing the <code>usize</code> type:
an unsigned integer that's as big as the number of bytes needed to address memory on your machine.
On a 32-bit machine, <code>usize</code> is equivalent to <code>u32</code>. On a 64-bit machine, it matches <code>u64</code>.</p>
<blockquote>
<p>Rustは、<code>usize</code>型を提供することで、これらアーキテクチャ特有の詳細を抽象化します。
<code>usize</code>は、マシン上のメモリを指し示すために必要なほど大きなバイト数をもつ符号なし整数です。
32ビットマシンで<code>usize</code>は<code>u32</code>と同等です。64ビットマシンでそれは<code>u64</code>と一致します。</p>
</blockquote>
<p>Capacity, length and pointers are all represented as <code>usize</code>s in Rust<sup class="footnote-reference"><a href="#equivalence">2</a></sup>.</p>
<blockquote>
<p>Rustにおいて、容量、長さそしてポインターは、すべての<code>usize</code>として表現されます。</p>
</blockquote>
<h3 id="no-stdmemsize_of-for-the-heapヒープ用のstdmemsize_ofはない"><a class="header" href="#no-stdmemsize_of-for-the-heapヒープ用のstdmemsize_ofはない">No <code>std::mem::size_of</code> for the heap（ヒープ用のstd::mem::size_ofはない）</a></h3>
<p><code>std::mem::size_of</code> returns the amount of space a type would take on the stack,
which is also known as the <strong>size of the type</strong>.</p>
<blockquote>
<p><code>std::mem::size_of</code>は型がスタックに獲得する領域の量を返し、それは<strong>型のサイズ</strong>としても知られています。</p>
</blockquote>
<blockquote>
<p>What about the memory buffer that <code>String</code> is managing on the heap? Isn't that
part of the size of <code>String</code>?</p>
</blockquote>
<blockquote>
<p><code>String</code>がヒープ上で管理されるメモリバッファはどうでしょうか？
それは、<code>String</code>のサイズの一部ではないですか？</p>
</blockquote>
<p>No!<br />
That heap allocation is a <strong>resource</strong> that <code>String</code> is managing.
It's not considered to be part of the <code>String</code> type by the compiler.</p>
<blockquote>
<p>いいえ！
ヒープ割り当ては、<code>String</code>が管理している<strong>リソース</strong>です。
それは、コンパイラーによって<code>String</code>型の一部として考えられていません。</p>
</blockquote>
<p><code>std::mem::size_of</code> doesn't know (or care) about additional heap-allocated data
that a type might manage or refer to via pointers, as is the case with <code>String</code>,
therefore it doesn't track its size.</p>
<blockquote>
<p><code>std::mem::size_of</code>は、ポインターを介して型が管理または参照するヒープに割り当てられた追加データを知らないし、気にしていません。
よって、<code>std::mem::size_of</code>はそのサイズを追跡しません。</p>
</blockquote>
<p>Unfortunately there is no equivalent of <code>std::mem::size_of</code> to measure the amount of
heap memory that a certain value is allocating at runtime. Some types might
provide methods to inspect their heap usage (e.g. <code>String</code>'s <code>capacity</code> method),
but there is no general-purpose "API" to retrieve runtime heap usage in Rust.<br />
You can, however, use a memory profiler tool (e.g. <a href="https://valgrind.org/docs/manual/dh-manual.html">DHAT</a>
or <a href="https://docs.rs/dhat/latest/dhat/">a custom allocator</a>) to inspect the heap usage of your program.</p>
<blockquote>
<p>不運にも、ランタイムである値が割り当てられたヒープメモリの量を計測する<code>std::mem::size_of</code>と同等なものはありません。
ある型は、それらのヒープ使用を調査するためのメソッド（例えば、<code>String</code>の<code>capacity</code>メソッド）を提供していますが、Rustではラインタイムでヒープ使用を取得する一般的な目的の「API」はありません。
しかし、メモリプロファイラーツールを使用するか、プログラムのヒープ使用を調査する、例えば<code>DHAT</code>またはカスタムアロケーターを使用できます。</p>
</blockquote>
<div class="footnote-definition" id="empty"><sup class="footnote-definition-label">1</sup>
<p><code>std</code> doesn't allocate if you create an <strong>empty</strong> <code>String</code> (i.e. <code>String::new()</code>).
Heap memory will be reserved when you push data into it for the first time.
例えば<code>String::new()</code>などで<strong>空</strong>の<code>String</code>を作成した場合、<code>std</code>は割り当てしません。
最初にヒープにデータを入れたとき、ヒープメモリは予約されます。</p>
</div>
<div class="footnote-definition" id="equivalence"><sup class="footnote-definition-label">2</sup>
<p>The size of a pointer depends on the operating system too.
In certain environments, a pointer is <strong>larger</strong> than a memory address (e.g. <a href="https://blog.acolyer.org/2019/05/28/cheri-abi/">CHERI</a>).
Rust makes the simplifying assumption that pointers are the same size as memory addresses,
which is true for most modern systems you're likely to encounter.
ポインターのサイズはオペレーティングシステムにも依存します。
特定の環境では、ポインターはメモリアドレスよりも<strong>大きく</strong>なります（例えば<code>CHERI</code>）。
Rustは、メモリアドレスと同じサイズであるという単純化された仮定をして、それは遭遇する可能性のある最も現代的なシステムで当てはまります。</p>
</div>
<h2 id="exercise-22"><a class="header" href="#exercise-22">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/03_ticket_v1/09_heap"><code>03_ticket_v1/09_heap</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="references参照"><a class="header" href="#references参照">References（参照）</a></h1>
<p>What about references, like <code>&amp;String</code> or <code>&amp;mut String</code>? How are they represented in memory?</p>
<blockquote>
<p><code>&amp;String</code>または<code>&amp;mut String</code>のような参照についてはどうでしょうか？
それらはメモリ内でどのように表現されているのでしょうか？</p>
</blockquote>
<p>Most references<sup class="footnote-reference"><a href="#fat">1</a></sup> in Rust are represented, in memory, as a pointer to a memory location.<br />
It follows that their size is the same as the size of a pointer, a <code>usize</code>.</p>
<blockquote>
<p>Rustにおけるほとんどの参照は、メモリ内でメモリ位置を指し示すポインターとして表現されています。
それは、それらのサイズがポインターのサイズと同じで<code>usize</code>になります。</p>
</blockquote>
<p>You can verify this using <code>std::mem::size_of</code>:</p>
<blockquote>
<p>これを<code>std::mem::size_of</code>を使用して検証できます。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>assert_eq!(std::mem::size_of::&lt;&amp;String&gt;(), 8);
assert_eq!(std::mem::size_of::&lt;&amp;mut String&gt;(), 8);
<span class="boring">}</span></code></pre></pre>
<p>A <code>&amp;String</code>, in particular, is a pointer to the memory location where the <code>String</code>'s metadata is stored.<br />
If you run this snippet:</p>
<blockquote>
<p>特に、<code>&amp;String</code>は、<code>String</code>のメタデータが保存されたメモリ位置を指し示すポインターです。
このスニペットを実行した場合・・・</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from("Hey");
let r = &amp;s;
<span class="boring">}</span></code></pre></pre>
<p>you'll get something like this in memory:</p>
<blockquote>
<p>メモリ内でこれは次のようになります。</p>
</blockquote>
<pre><code class="language-text">           --------------------------------------
           |                                    |
      +----v----+--------+----------+      +----|----+
Stack | pointer | length | capacity |      | pointer |
      |  |      |   3    |    5     |      |         |
      +--|  ----+--------+----------+      +---------+
         |          s                           r
         |
         v
       +---+---+---+---+---+
Heap   | H | e | y | ? | ? |
       +---+---+---+---+---+
</code></pre>
<p>It's a pointer to a pointer to the heap-allocated data, if you will.
The same goes for <code>&amp;mut String</code>.</p>
<blockquote>
<p>もし、それをした場合、それはヒープに割り当てられたデータを指し示すポインターのポインターです。
同じことは<code>&amp;mut String</code>にも当てはまります。</p>
</blockquote>
<h2 id="not-all-pointers-point-to-the-heapすべてのポインターがヒープを指し示すわけではない"><a class="header" href="#not-all-pointers-point-to-the-heapすべてのポインターがヒープを指し示すわけではない">Not all pointers point to the heap（すべてのポインターがヒープを指し示すわけではない）</a></h2>
<p>The example above should clarify one thing: not all pointers point to the heap.<br />
They just point to a memory location, which <em>may</em> be on the heap, but doesn't have to be.</p>
<blockquote>
<p>上記例は、明確に1つのことを説明しています。すべてのポインターがヒープを指し示すわけではありません。
それらは、単にメモリの位置を指し示しており、それはヒープ上にある_かもしれません_が、そうである必要はありません。</p>
</blockquote>
<div class="footnote-definition" id="fat"><sup class="footnote-definition-label">1</sup>
<p><a href="03_ticket_v1/../04_traits/06_str_slice.html">Later in the course</a> we'll talk about <strong>fat pointers</strong>,
i.e. pointers with additional metadata. As the name implies, they are larger than
the pointers we discussed in this chapter, also known as <strong>thin pointers</strong>.
コースの後半で、例えば追加のメタデータを持つポインターである、<strong>ファットポインター</strong>について話します。
名前が暗に意味する通り、それらはこの章で議論した<strong>シンポインター</strong>としても知られているポインターよりも大きいです。</p>
</div>
<h2 id="exercise-23"><a class="header" href="#exercise-23">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/03_ticket_v1/10_references_in_memory"><code>03_ticket_v1/10_references_in_memory</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="destructorsデストラクター"><a class="header" href="#destructorsデストラクター">Destructors（デストラクター）</a></h1>
<p>When introducing the heap, we mentioned that you're responsible for freeing the memory you allocate.<br />
When introducing the borrow-checker, we also stated that you rarely have to manage memory directly in Rust.</p>
<blockquote>
<p>ヒープを紹介したとき、割り当てたメモリを解放する責任があることを言及しました。
借用チェッカーを紹介したとき、Rustでは、メモリを直接管理する必要がほとんどないことも述べました。</p>
</blockquote>
<p>These two statements might seem contradictory at first.
Let's see how they fit together by introducing <strong>scopes</strong> and <strong>destructors</strong>.</p>
<blockquote>
<p>最初は、2つの文が矛盾しているように見えるかもしれません。
<strong>スコープ</strong>と<strong>デストラクター</strong>を導入して、それらがどのように適合するか確認しましょう。</p>
</blockquote>
<h2 id="scopesスコープ"><a class="header" href="#scopesスコープ">Scopes（スコープ）</a></h2>
<p>The <strong>scope</strong> of a variable is the region of Rust code where that variable is valid, or <strong>alive</strong>.</p>
<blockquote>
<p>変数の<strong>スコープ</strong>は、その変数が有効または<strong>生きている</strong>Rustコードの領域です。</p>
</blockquote>
<p>The scope of a variable starts with its declaration.
It ends when one of the following happens:</p>
<ol>
<li>
<p>the block (i.e. the code between <code>{}</code>) where the variable was declared ends</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
   // `x` is not yet in scope here
   let y = "Hello".to_string();
   let x = "World".to_string(); // &lt;-- x's scope starts here...
   let h = "!".to_string(); //   |
} //  &lt;-------------- ...and ends here</code></pre></pre>
</li>
<li>
<p>ownership of the variable is transferred to someone else (e.g. a function or another variable)</p>
<pre><pre class="playground"><code class="language-rust">fn compute(t: String) {
   // Do something [...]
}

fn main() {
    let s = "Hello".to_string(); // &lt;-- s's scope starts here...
                //                    |
    compute(s); // &lt;------------------- ..and ends here
                //   because `s` is moved into `compute`
}</code></pre></pre>
</li>
</ol>
<blockquote>
<p>変数のスコープは、その宣言で始まります。
それは、次のうち1つが発生すると終わります。</p>
<ol>
<li>その変数が宣言された、例えば<code>{}</code>間のコードなどのブロックが終了する。</li>
<li>変数の所有権が、例えば関数または他の変数など、他の誰かに移動される。</li>
</ol>
</blockquote>
<h2 id="destructorsデストラクター-1"><a class="header" href="#destructorsデストラクター-1">Destructors（デストラクター）</a></h2>
<p>When the owner of a value goes out of scope, Rust invokes its <strong>destructor</strong>.<br />
The destructor tries to clean up the resources used by that value—in particular, whatever memory it allocated.</p>
<blockquote>
<p>値の所有者がスコープ外になると、Rustはその<strong>デストラクター</strong>を呼び出します。
デストラクターは、その値によって使用されたリソース、特に割り当てられたメモリをクリーンアップすることを試みます。</p>
</blockquote>
<p>You can manually invoke the destructor of a value by passing it to <code>std::mem::drop</code>.<br />
That's why you'll often hear Rust developers saying "that value has been <strong>dropped</strong>" as a way to state that a value
has gone out of scope and its destructor has been invoked.</p>
<blockquote>
<p>値を<code>std::mem::drop</code>に渡すことで、値のデストラクターを手動で呼び出すことができます。
Rustの開発者が、値がスコープ外になり、そのデストラクターが呼び出されたことを述べる方法として、「その値は<strong>ドロップ</strong>されました」と言うことをよく聞くでしょう。</p>
</blockquote>
<h3 id="visualizing-drop-pointsドロップポイントの可視化"><a class="header" href="#visualizing-drop-pointsドロップポイントの可視化">Visualizing drop points（ドロップポイントの可視化）</a></h3>
<p>We can insert explicit calls to <code>drop</code> to "spell out" what the compiler does for us. Going back to the previous example:</p>
<blockquote>
<p>コンパイラーがしてくれることを「記述して伝える」ために、明示的な<code>drop</code>呼び出しを挿入できます。
前の例に戻りましょう。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">fn main() {
   let y = "Hello".to_string();
   let x = "World".to_string();
   let h = "!".to_string();
}</code></pre></pre>
<p>It's equivalent to:</p>
<blockquote>
<p>上記は次と等価です。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">fn main() {
   let y = "Hello".to_string();
   let x = "World".to_string();
   let h = "!".to_string();
   // Variables are dropped in reverse order of declaration
   // 変数は、宣言の逆順でドロップされます。
   drop(h);
   drop(x);
   drop(y);
}</code></pre></pre>
<p>Let's look at the second example instead, where <code>s</code>'s ownership is transferred to <code>compute</code>:</p>
<blockquote>
<p>代わりに、<code>s</code>の所有権が<code>compute</code>に移動した、2つ目の例を確認しましょう。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">fn compute(s: String) {
   // Do something [...]
   // なにかします。
}

fn main() {
   let s = "Hello".to_string();
   compute(s);
}</code></pre></pre>
<p>It's equivalent to this:</p>
<blockquote>
<p>それは次と等価です。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">fn compute(t: String) {
    // Do something [...]
    // なにかします。
    drop(t); // &lt;-- Assuming `t` wasn't dropped or moved
             //     before this point, the compiler will call
             //     `drop` here, when it goes out of scope
             //    この時点まで`t`がドロップされたり移動されていないと仮定して、
             //    それがスコープ外になったとき、コンパイラーはここで｀drop`を呼び出します。
}

fn main() {
    let s = "Hello".to_string();
    compute(s);
}</code></pre></pre>
<p>Notice the difference: even though <code>s</code> is no longer valid after <code>compute</code> is called in <code>main</code>, there is no <code>drop(s)</code>
in <code>main</code>.
When you transfer ownership of a value to a function, you're also <strong>transferring the responsibility of cleaning it up</strong>.</p>
<blockquote>
<p>違いに注意してください。<code>main</code>内で<code>compute</code>が呼び出された後、<code>s</code>はもはや有効ではありませんが、<code>main</code>内に<code>drop(s)</code>はありません。
関数に値の所有権を移動したとき、<strong>それをクリーンアップする責任も移動</strong>します。</p>
</blockquote>
<p>This ensures that the destructor for a value is called <strong>at most<sup class="footnote-reference"><a href="#leak">1</a></sup> once</strong>, preventing
<a href="https://owasp.org/www-community/vulnerabilities/Doubly_freeing_memory">double free bugs</a> by design.</p>
<blockquote>
<p>値のためのデストラクターは、設計によって二重解放のバグを避けるために、<strong>最大で一度</strong>呼び出されます。</p>
</blockquote>
<h3 id="use-after-dropドロップのあとで使用する"><a class="header" href="#use-after-dropドロップのあとで使用する">Use after drop（ドロップのあとで使用する）</a></h3>
<p>What happens if you try to use a value after it's been dropped?</p>
<blockquote>
<p>値がドロップされた後で、値を使用することを試みると何が発生するでしょうか？</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = "Hello".to_string();
drop(x);
println!("{}", x);
<span class="boring">}</span></code></pre></pre>
<p>If you try to compile this code, you'll get an error:</p>
<blockquote>
<p>このコードをコンパイルすることを試みると、次のエラーが発生します。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>error[E0382]: use of moved value: `x`
 --&gt; src/main.rs:4:20
  |
3 |     drop(x);
  |          - value moved here
4 |     println!("{}", x);
  |                    ^ value used here after move
<span class="boring">}</span></code></pre></pre>
<p>Drop <strong>consumes</strong> the value it's called on, meaning that the value is no longer valid after the call.<br />
The compiler will therefore prevent you from using it, avoiding <a href="https://owasp.org/www-community/vulnerabilities/Using_freed_memory">use-after-free bugs</a>.</p>
<blockquote>
<p>ドロップは、それが呼ばれた値を<strong>消費する</strong>ため、呼び出した後、その値はもはや有効ではないことを意味します。
よって、コンパイラーは、解放後に使用するバグを回避するために、それを使用することを防ぎます。</p>
</blockquote>
<h3 id="dropping-references参照のドロップ"><a class="header" href="#dropping-references参照のドロップ">Dropping references（参照のドロップ）</a></h3>
<p>What if a variable contains a reference?<br />
For example:</p>
<blockquote>
<p>変数が参照を含んでいた場合はどうなるでしょうか？
例えば・・・</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 42i32;
let y = &amp;x;
drop(y);
<span class="boring">}</span></code></pre></pre>
<p>When you call <code>drop(y)</code>... nothing happens.<br />
If you actually try to compile this code, you'll get a warning:</p>
<blockquote>
<p><code>drop(y)</code>を呼び出したとき・・・何も発生しません。
実際にこのコードをコンパイルすることを試みた場合、警告が発生します。</p>
</blockquote>
<pre><code class="language-text">warning: calls to `std::mem::drop` with a reference
         instead of an owned value does nothing
 --&gt; src/main.rs:4:5
  |
4 |     drop(y);
  |     ^^^^^-^
  |          |
  |          argument has type `&amp;i32`
  |
</code></pre>
<p>It goes back to what we said earlier: we only want to call the destructor once.<br />
You can have multiple references to the same value—if we called the destructor for the value they point at
when one of them goes out of scope, what would happen to the others?
They would refer to a memory location that's no longer valid: a so-called <a href="https://en.wikipedia.org/wiki/Dangling_pointer"><strong>dangling pointer</strong></a>,
a close relative of <a href="https://owasp.org/www-community/vulnerabilities/Using_freed_memory"><strong>use-after-free bugs</strong></a>.
Rust's ownership system rules out these kinds of bugs by design.</p>
<blockquote>
<p>これは、前述のことに戻ります：デストラクターを一度だけ呼び出したいだけです。
同じ値への複数の参照を持つことができます。それらの1つがスコープ外になったときにその値のデストラクターを呼び出した場合、他に何が発生するでしょうか？
それらは、ダングリングポインターとも呼ばれる、もはや有効でないメモリ位置を参照して、解放した後に使用するバグに密接に関連します。
Rustの所有権システムは、設計によってこれらの種類のバグを排除します。</p>
</blockquote>
<div class="footnote-definition" id="leak"><sup class="footnote-definition-label">1</sup>
<p>Rust doesn't guarantee that destructors will run. They won't, for example, if
you explicitly choose to <a href="03_ticket_v1/../07_threads/03_leak.html">leak memory</a>.
Rustは、デストラクターが実行されることを保証しません。
例えば、メモリリークを明示的に選択した場合、デストラクターの呼び出しはされません。</p>
</div>
<h2 id="exercise-24"><a class="header" href="#exercise-24">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/03_ticket_v1/11_destructor"><code>03_ticket_v1/11_destructor</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wrapping-up仕上げ"><a class="header" href="#wrapping-up仕上げ">Wrapping up（仕上げ）</a></h1>
<p>We've covered a lot of foundational Rust concepts in this chapter.<br />
Before moving on, let's go through one last exercise to consolidate what we've learned.
You'll have minimal guidance this time—just the exercise description and the tests to guide you.</p>
<blockquote>
<p>この章では、多くの基礎的なRustの概念を説明しました。
次に進む前に、学んだことを強固にするために最後の演習を1つ行いましょう。
今回、最小限の案内があります。単なる演習の説明と、テストの案内です。</p>
</blockquote>
<h2 id="exercise-25"><a class="header" href="#exercise-25">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/03_ticket_v1/12_outro"><code>03_ticket_v1/12_outro</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="traitsトレイト"><a class="header" href="#traitsトレイト">Traits（トレイト）</a></h1>
<p>In the previous chapter we covered the basics of Rust's type and ownership system.<br />
It's time to dig deeper: we'll explore <strong>traits</strong>, Rust's take on interfaces.</p>
<blockquote>
<p>前の章で、Rustの型と所有権システムの基本を説明しました。
より深く掘り下げる時間です。Rustのインターフェイスに対する考え方である<strong>トレイト</strong>を探求します。</p>
</blockquote>
<p>Once you learn about traits, you'll start seeing their fingerprints all over the place.<br />
In fact, you've already seen traits in action throughout the previous chapter, e.g. <code>.into()</code> invocations as well
as operators like <code>==</code> and <code>+</code>.</p>
<blockquote>
<p>一旦、トレイトについて学ぶと、その指紋があらゆる場所で見るようになります。
事実、前の章を通じて実際にトレイトを見ました。例えば、<code>.into()</code>呼び出しと同様に<code>==</code>や<code>+</code>のような演算子です。</p>
</blockquote>
<p>On top of traits as a concept, we'll also cover some of the key traits that are defined in Rust's standard library:</p>
<ul>
<li>Operator traits (e.g. <code>Add</code>, <code>Sub</code>, <code>PartialEq</code>, etc.)</li>
<li><code>From</code> and <code>Into</code>, for infallible conversions</li>
<li><code>Clone</code> and <code>Copy</code>, for copying values</li>
<li><code>Deref</code> and deref coercion</li>
<li><code>Sized</code>, to mark types with a known size</li>
<li><code>Drop</code>, for custom cleanup logic</li>
</ul>
<blockquote>
<p>概念としてのトレイトを踏まえた上で、Rust標準ライブラリ内に定義されたいくつか主要なトレイトを説明します。</p>
</blockquote>
<p>Since we'll be talking about conversions, we'll seize the opportunity to plug some of the "knowledge gaps"
from the previous chapter—e.g. what is <code>"A title"</code>, exactly? Time to learn more about slices too!</p>
<blockquote>
<p>変換について話す予定であるため、前の章からのいくつかの「知識の乖離」を埋めるために機会を掴みます。
例えば、正確に「<code>"A title"</code>」とは何でしょうか？またスライスについてより学ぶ時です！</p>
</blockquote>
<h2 id="exercise-26"><a class="header" href="#exercise-26">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/04_traits/00_intro"><code>04_traits/00_intro</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="traitsトレイト-1"><a class="header" href="#traitsトレイト-1">Traits（トレイト）</a></h1>
<p>Let's look again at our <code>Ticket</code> type:</p>
<p><code>Ticket</code>型を再度確認しましょう。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Ticket {
    title: String,
    description: String,
    status: String,
}
<span class="boring">}</span></code></pre></pre>
<p>All our tests, so far, have been making assertions using <code>Ticket</code>'s fields.</p>
<blockquote>
<p>これまで、すべてのテストは、<code>Ticket</code>のフィールドを使用してアサーションしてきました。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>assert_eq!(ticket.title(), "A new title");
<span class="boring">}</span></code></pre></pre>
<p>What if we wanted to compare two <code>Ticket</code> instances directly?</p>
<blockquote>
<p>直接2つの<code>Ticket</code>インスタンスを比較したい場合、どうすればいいでしょうか？</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let ticket1 = Ticket::new(/* ... */);
let ticket2 = Ticket::new(/* ... */);
ticket1 == ticket2
<span class="boring">}</span></code></pre></pre>
<p>The compiler will stop us:</p>
<blockquote>
<p>コンパイラーは止めます。</p>
</blockquote>
<pre><code class="language-text">error[E0369]: binary operation `==` cannot be applied to type `Ticket`
  --&gt; src/main.rs:18:13
   |
18 |     ticket1 == ticket2
   |     ------- ^^ ------- Ticket
   |     |
   |     Ticket
   |
note: an implementation of `PartialEq` might be missing for `Ticket`
</code></pre>
<p><code>Ticket</code> is a new type. Out of the box, there is <strong>no behavior attached to it</strong>.<br />
Rust doesn't magically infer how to compare two <code>Ticket</code> instances just because they contain <code>String</code>s.</p>
<blockquote>
<p><code>Ticket</code>は新しい型です。組み込みで、<strong>それには振る舞いが付属していません</strong>。
Rustは、<code>Ticket</code>が<code>String</code>を含んでいるため、2つの<code>Ticket</code>インスタンスを比較する方法を魔法のように推測しません。</p>
</blockquote>
<p>The Rust compiler is nudging us in the right direction though: it's suggesting that we might be missing an implementation
of <code>PartialEq</code>. <code>PartialEq</code> is a <strong>trait</strong>!</p>
<blockquote>
<p>しかし、Rustコンパイラーは、正しい方向へそっと突いています。それは<code>PartialEq</code>の実装が不足しているかもしれないことを示唆しています。
<code>PartialEq</code>は<strong>トレイト</strong>です！</p>
</blockquote>
<h2 id="what-are-traitsトレイトとは"><a class="header" href="#what-are-traitsトレイトとは">What are traits?（トレイトとは？）</a></h2>
<p>Traits are Rust's way of defining <strong>interfaces</strong>.<br />
A trait defines a set of methods that a type must implement to satisfy the trait's contract.</p>
<blockquote>
<p>トレイトは、<strong>インターフェイス</strong>を定義するRustの方法です。
トレイトは、トレイトの契約を満たすために、型が実装しなくてはならないメソッドの集合を定義します。</p>
</blockquote>
<h3 id="defining-a-traitトレイトの定義"><a class="header" href="#defining-a-traitトレイトの定義">Defining a trait（トレイトの定義）</a></h3>
<p>The syntax for a trait definition goes like this:</p>
<blockquote>
<p>トレイトを定義する構文は次のようになります。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait &lt;TraitName&gt; {
    fn &lt;method_name&gt;(&lt;parameters&gt;) -&gt; &lt;return_type&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p>We might, for example, define a trait named <code>MaybeZero</code> that requires its implementors to define an <code>is_zero</code> method:</p>
<blockquote>
<p>例えば、<code>is_zero</code>メソッドを定義するために、実装者にそれを要求する<code>MaybeZero</code>と名付けられたトレイトを定義するかもしれません。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait MaybeZero {
    fn is_zero(self) -&gt; bool;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="implementing-a-traitトレイトの実装"><a class="header" href="#implementing-a-traitトレイトの実装">Implementing a trait（トレイトの実装）</a></h3>
<p>To implement a trait for a type we use the <code>impl</code> keyword, just like we do for regular<sup class="footnote-reference"><a href="#inherent">1</a></sup> methods,
but the syntax is a bit different:</p>
<blockquote>
<p>型にトレイトを実装するために、ちょうど通常のメソッドでしたように、<code>impl</code>キーワードを使用しますが、構文は少し異なります。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl &lt;TraitName&gt; for &lt;TypeName&gt; {
    fn &lt;method_name&gt;(&lt;parameters&gt;) -&gt; &lt;return_type&gt; {
        // Method body
    }
}
<span class="boring">}</span></code></pre></pre>
<p>For example, to implement the <code>MaybeZero</code> trait for a custom number type, <code>WrappingU32</code>:</p>
<blockquote>
<p>例えば、カスタムな数値型の<code>WrappingU32</code>に<code>MaybeZero</code>トレイトを実装するには・・・</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct WrappingU32 {
    inner: u32,
}

impl MaybeZero for WrappingU32 {
    fn is_zero(self) -&gt; bool {
        self.inner == 0
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="invoking-a-trait-methodトレイトメソッドの呼び出し"><a class="header" href="#invoking-a-trait-methodトレイトメソッドの呼び出し">Invoking a trait method（トレイトメソッドの呼び出し）</a></h3>
<p>To invoke a trait method, we use the <code>.</code> operator, just like we do with regular methods:</p>
<p>トレイトメソッドを呼び出すために、ちょうど通常のメソッドでしたように、<code>.</code>演算子を使用します。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = WrappingU32 { inner: 5 };
assert!(!x.is_zero());
<span class="boring">}</span></code></pre></pre>
<p>To invoke a trait method, two things must be true:</p>
<ul>
<li>The type must implement the trait.</li>
<li>The trait must be in scope.</li>
</ul>
<blockquote>
<p>トレイトメソッドを呼び出すために、次の2つが成立しなければなりません。</p>
<ul>
<li>型がそのトレイトを実装していなくてはなりません。</li>
<li>トレイトがスコープ内になければなりません。</li>
</ul>
</blockquote>
<p>To satisfy the latter, you may have to add a <code>use</code> statement for the trait:</p>
<blockquote>
<p>後者を満たすために、そのトレイトのために<code>use</code>文を追加しなければならないかもしれません。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::MaybeZero;
<span class="boring">}</span></code></pre></pre>
<p>This is not necessary if:</p>
<ul>
<li>The trait is defined in the same module where the invocation occurs.</li>
<li>The trait is defined in the standard library's <strong>prelude</strong>.
The prelude is a set of traits and types that are automatically imported into every Rust program.
It's as if <code>use std::prelude::*;</code> was added at the beginning of every Rust module.</li>
</ul>
<blockquote>
<p>次の場合は、これは必要ありません。</p>
<ul>
<li>トレイトが、呼び出しが発生する同じモジュール内で定義されている。</li>
<li>トレイトが、標準ライブラリの<strong>prelude</strong>に定義されている。
<code>prelude</code>は、すべてのRustプログラム内に自動的にインポートされるトレイトや型の集合です。
それは、<code>use::std::prelude:**;</code>として、すべてのRustモジュールの開始に追加されたかのようです。</li>
</ul>
</blockquote>
<p>You can find the list of traits and types in the prelude in the
<a href="https://doc.rust-lang.org/std/prelude/index.html">Rust documentation</a>.</p>
<blockquote>
<p>prelude内のトレイトと型のリストは、Rustドキュメントで見つけることができます。</p>
</blockquote>
<div class="footnote-definition" id="inherent"><sup class="footnote-definition-label">1</sup>
<p>A method defined directly on a type, without using a trait, is also known as an <strong>inherent method</strong>.
トレイトを使用しないで、型に直接定義されたメソッドは、<strong>継承メソッド</strong>とも知られています。</p>
</div>
<h2 id="exercise-27"><a class="header" href="#exercise-27">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/04_traits/01_trait"><code>04_traits/01_trait</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="implementing-traitsトレイトの実装"><a class="header" href="#implementing-traitsトレイトの実装">Implementing traits（トレイトの実装）</a></h1>
<p>When a type is defined in another crate (e.g. <code>u32</code>, from Rust's standard library), you
can't directly define new methods for it. If you try:</p>
<blockquote>
<p>例えば、Rust標準ライブラリの<code>u32</code>など、型が他のクレートに定義されているとき、それに直接新しいメソッドを定義できません。
それを試みると・・・</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl u32 {
    fn is_even(&amp;self) -&gt; bool {
        self % 2 == 0
    }
}
<span class="boring">}</span></code></pre></pre>
<p>the compiler will complain:</p>
<blockquote>
<p>コンパイラは文句を言うでしょう。</p>
</blockquote>
<pre><code class="language-text">error[E0390]: cannot define inherent `impl` for primitive types
  |
1 | impl u32 {
  | ^^^^^^^^
  |
  = help: consider using an extension trait instead
</code></pre>
<h2 id="extension-trait拡張トレイト"><a class="header" href="#extension-trait拡張トレイト">Extension trait（拡張トレイト）</a></h2>
<p>An <strong>extension trait</strong> is a trait whose primary purpose is to attach new methods
to foreign types, such as <code>u32</code>.
That's exactly the pattern you deployed in the previous exercise, by defining
the <code>IsEven</code> trait and then implementing it for <code>i32</code> and <code>u32</code>. You are then
free to call <code>is_even</code> on those types as long as <code>IsEven</code> is in scope.</p>
<blockquote>
<p><strong>拡張トレイト</strong>は、<code>u32</code>のような外部の型に新しいメソッドを取り付けることが主な目的のトレイトです。
これは、<code>IsEven</code>トレイトを定義して、そして<code>i32</code>と<code>u32</code>に実装した、まさしく前の演習で展開したパターンです。
そして、<code>IsEven</code>がスコープ内にある限り、それらの型の<code>is_even</code>呼び出しは自由です。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">// Bring the trait in scope
// トレイトをスコープ内に持ち込みます。
use my_library::IsEven;

fn main() {
    // Invoke its method on a type that implements it
    // それを実装した型のそのメソッドを呼び出します。
    if 4.is_even() {
        // [...]
    }
}</code></pre></pre>
<h2 id="one-implementation1つの実装"><a class="header" href="#one-implementation1つの実装">One implementation（1つの実装）</a></h2>
<p>There are limitations to the trait implementations you can write.<br />
The simplest and most straight-forward one: you can't implement the same trait twice,
in a crate, for the same type.</p>
<p>For example:</p>
<blockquote>
<p>記述できるトレイトの実装には制限があります。
最も単純で最も簡単な1つは、クレート内で任意の型に同じトレイトを2回実装できないことです。</p>
<p>例えば・・・</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait IsEven {
    fn is_even(&amp;self) -&gt; bool;
}

impl IsEven for u32 {
    fn is_even(&amp;self) -&gt; bool {
        true
    }
}

impl IsEven for u32 {
    fn is_even(&amp;self) -&gt; bool {
        false
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The compiler will reject it:</p>
<blockquote>
<p>コンパイラーはそれを拒否します。</p>
</blockquote>
<pre><code class="language-text">error[E0119]: conflicting implementations of trait `IsEven` for type `u32`
   |
5  | impl IsEven for u32 {
   | ------------------- first implementation here
...
11 | impl IsEven for u32 {
   | ^^^^^^^^^^^^^^^^^^^ conflicting implementation for `u32`
</code></pre>
<p>There can be no ambiguity as to what trait implementation should be used when <code>IsEven::is_even</code>
is invoked on a <code>u32</code> value, therefore there can only be one.</p>
<blockquote>
<p><code>u32</code>値に対して<code>IsEven::is_even</code>が呼び出されたとき、どのトレイトの実装を使用するべきかについて曖昧さがあってはなりません。
従って、1つしか存在できません。</p>
</blockquote>
<h2 id="orphan-rule孤立ルール"><a class="header" href="#orphan-rule孤立ルール">Orphan rule（孤立ルール）</a></h2>
<p>Things get more nuanced when multiple crates are involved.
In particular, at least one of the following must be true:</p>
<ul>
<li>The trait is defined in the current crate</li>
<li>The implementor type is defined in the current crate</li>
</ul>
<blockquote>
<p>複数のクレートが巻き込まれると、ものはより微妙な差異がでてきます。
特に、次の内、少なくとも1つは成立しなくてはなりません。</p>
<ul>
<li>トレイトが、現在のクレートで定義されている。</li>
<li>実装型（トレイトを実装する型）が、現在のクレートで定義されている。</li>
</ul>
</blockquote>
<p>This is known as Rust's <strong>orphan rule</strong>. Its goal is to make the method resolution
process unambiguous.</p>
<blockquote>
<p>これはRustの<strong>孤立ルール</strong>として知られています。
その目的は、メソッド解決処理を曖昧ににしないことです。</p>
</blockquote>
<p>Imagine the following situation:</p>
<ul>
<li>Crate <code>A</code> defines the <code>IsEven</code> trait</li>
<li>Crate <code>B</code> implements <code>IsEven</code> for <code>u32</code></li>
<li>Crate <code>C</code> provides a (different) implementation of the <code>IsEven</code> trait for <code>u32</code></li>
<li>Crate <code>D</code> depends on both <code>B</code> and <code>C</code> and calls <code>1.is_even()</code></li>
</ul>
<blockquote>
<p>次の状況を想像してください。</p>
<ul>
<li>クレート<code>A</code>が、<code>IsEven</code>トレイトを定義する。</li>
<li>クレート<code>B</code>が、<code>u32</code>に対して<code>IsEven</code>を実装する。</li>
<li>クレート<code>C</code>が、<code>u32</code>に対して、<code>IsEven</code>の異なる実装を提供する。</li>
<li>クレート<code>D</code>は、<code>B</code>と<code>C</code>の両方に依存しており、<code>1.is_even()</code>を呼び出す。</li>
</ul>
</blockquote>
<p>Which implementation should be used? The one defined in <code>B</code>? Or the one defined in <code>C</code>?<br />
There's no good answer, therefore the orphan rule was defined to prevent this scenario.
Thanks to the orphan rule, neither crate <code>B</code> nor crate <code>C</code> would compile.</p>
<blockquote>
<p>どちらの実装が使用されるべきでしょうか？<code>B</code>で定義されたものでしょうか？それとも<code>C</code>で定義されたものでしょうか？
良い答えはありません。従って、孤立ルールはこのシナリオを避けるために定義されました。
孤立ルールのおかげで、<code>B</code>クレートと<code>C</code>クレートはどちらもコンパイルされません。</p>
</blockquote>
<h2 id="further-reading参考資料-6"><a class="header" href="#further-reading参考資料-6">Further reading（参考資料）</a></h2>
<ul>
<li>There are some caveats and exceptions to the orphan rule as stated above.
Check out <a href="https://doc.rust-lang.org/reference/items/implementations.html#trait-implementation-coherence">the reference</a>
if you want to get familiar with its nuances.</li>
</ul>
<blockquote>
<ul>
<li>上記で述べた孤立ルールには、いくつかの注意事項と例外があります。
その微妙な差異に慣れたい場合は、リファレンスを確認してください。</li>
</ul>
</blockquote>
<h2 id="exercise-28"><a class="header" href="#exercise-28">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/04_traits/02_orphan_rule"><code>04_traits/02_orphan_rule</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="operator-overloading演算子のオーバーロード"><a class="header" href="#operator-overloading演算子のオーバーロード">Operator overloading（演算子のオーバーロード）</a></h1>
<p>Now that we have a basic understanding of what traits are, let's circle back to <strong>operator overloading</strong>.
Operator overloading is the ability to define custom behavior for operators like <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>==</code>, <code>!=</code>, etc.</p>
<blockquote>
<p>現在、トレイトが何か基本的な理解を得たので、<strong>演算子のオーバーロード</strong>に戻りましょう。
演算子のオーバーロードは、<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>==</code>、<code>!=</code>などの演算子のカスタムな振る舞いを定義する能力です。</p>
</blockquote>
<h2 id="operators-are-traits演算子はトレイト"><a class="header" href="#operators-are-traits演算子はトレイト">Operators are traits（演算子はトレイト）</a></h2>
<p>In Rust, operators are traits.<br />
For each operator, there is a corresponding trait that defines the behavior of that operator.
By implementing that trait for your type, you <strong>unlock</strong> the usage of the corresponding operators.</p>
<blockquote>
<p>Rustにおいて、演算子はトレイトです。
それぞれの演算子には、その演算子の振る舞いを定義するために、対応したトレイトがあります。
型にそのトレイトを実装することで、対応する演算子の使用を<strong>解除</strong>します。</p>
</blockquote>
<p>For example, the <a href="https://doc.rust-lang.org/std/cmp/trait.PartialEq.html"><code>PartialEq</code> trait</a> defines the behavior of
the <code>==</code> and <code>!=</code> operators:</p>
<blockquote>
<p>例えば、<code>PartialEq</code>トレイトは、<code>==</code>と<code>!=</code>演算子の振る舞いを定義します。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// The `PartialEq` trait definition, from Rust's standard library
// (It is *slightly* simplified, for now)
// Rust標準ライブラリの`PartialEq`トレイトの定義です。
// （ここでは、それは*すこし*簡略化されています）
pub trait PartialEq {
    // Required method
    // 要求されるメソッドです。
    //
    // `Self` is a Rust keyword that stands for
    // "the type that is implementing the trait"
    // `Self`は「トレイトを実装した型」を表すRustのキーワードです。
    fn eq(&amp;self, other: &amp;Self) -&gt; bool;

    // Provided method
    // 提供されたメソッドです。
    fn ne(&amp;self, other: &amp;Self) -&gt; bool { ... }
}
<span class="boring">}</span></code></pre></pre>
<p>When you write <code>x == y</code> the compiler will look for an implementation of the <code>PartialEq</code> trait for the types of <code>x</code> and <code>y</code>
and replace <code>x == y</code> with <code>x.eq(y)</code>. It's syntactic sugar!</p>
<blockquote>
<p><code>x == y</code>を記述すると、<code>x</code>と<code>y</code>の型の<code>PartialEq</code>トレイトの実装を探し、<code>x == y</code>を<code>x.eq(y)</code>に置き換えます。
それは糖衣構文です！</p>
</blockquote>
<p>This is the correspondence for the main operators:</p>
<blockquote>
<p>次は主要な演算子の対応です。</p>
</blockquote>
<div class="table-wrapper"><table><thead><tr><th>Operator</th><th>Trait</th></tr></thead><tbody>
<tr><td><code>+</code></td><td><a href="https://doc.rust-lang.org/std/ops/trait.Add.html"><code>Add</code></a></td></tr>
<tr><td><code>-</code></td><td><a href="https://doc.rust-lang.org/std/ops/trait.Sub.html"><code>Sub</code></a></td></tr>
<tr><td><code>*</code></td><td><a href="https://doc.rust-lang.org/std/ops/trait.Mul.html"><code>Mul</code></a></td></tr>
<tr><td><code>/</code></td><td><a href="https://doc.rust-lang.org/std/ops/trait.Div.html"><code>Div</code></a></td></tr>
<tr><td><code>%</code></td><td><a href="https://doc.rust-lang.org/std/ops/trait.Rem.html"><code>Rem</code></a></td></tr>
<tr><td><code>==</code> and <code>!=</code></td><td><a href="https://doc.rust-lang.org/std/cmp/trait.PartialEq.html"><code>PartialEq</code></a></td></tr>
<tr><td><code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, and <code>&gt;=</code></td><td><a href="https://doc.rust-lang.org/std/cmp/trait.PartialOrd.html"><code>PartialOrd</code></a></td></tr>
</tbody></table>
</div>
<p>Arithmetic operators live in the <a href="https://doc.rust-lang.org/std/ops/index.html"><code>std::ops</code></a> module,
while comparison ones live in the <a href="https://doc.rust-lang.org/std/cmp/index.html"><code>std::cmp</code></a> module.</p>
<blockquote>
<p>算術演算子は、<code>std::ops</code>モジュールにあり、比較演算子は<code>std::cmp</code>モジュールにあります。</p>
</blockquote>
<h2 id="default-implementationsデフォルト実装"><a class="header" href="#default-implementationsデフォルト実装">Default implementations（デフォルト実装）</a></h2>
<p>The comment on <code>PartialEq::ne</code> states that "<code>ne</code> is a provided method".<br />
It means that <code>PartialEq</code> provides a <strong>default implementation</strong> for <code>ne</code> in the trait definition—the <code>{ ... }</code> elided
block in the definition snippet.<br />
If we expand the elided block, it looks like this:</p>
<blockquote>
<p><code>PartialEq::ne</code>のコメントは、「<code>ne</code>は提供されたメソッドです」と述べています。
それは、<code>PartialEq</code>がトレイト定義内で<code>ne</code>の<strong>デフォルト実装</strong>を提供していることを意味します。
それは、定義スニペット内の省略されたブロック<code>{ ... }</code>です。
省略されたブロックを展開すると、次が表示されます。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait PartialEq {
    fn eq(&amp;self, other: &amp;Self) -&gt; bool;

    fn ne(&amp;self, other: &amp;Self) -&gt; bool {
        !self.eq(other)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>It's what you expect: <code>ne</code> is the negation of <code>eq</code>.<br />
Since a default implementation is provided, you can skip implementing <code>ne</code> when you implement <code>PartialEq</code> for your type.
It's enough to implement <code>eq</code>:</p>
<blockquote>
<p>それは期待したものです。<code>ne</code>は<code>eq</code>の否定です。
デフォルト実装が提供されているため、型に<code>PartialEq</code>を実装する時、<code>ne</code>の実装をスキップできます。
<code>eq</code>の実装で十分です。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct WrappingU8 {
    inner: u8,
}

impl PartialEq for WrappingU8 {
    fn eq(&amp;self, other: &amp;WrappingU8) -&gt; bool {
        self.inner == other.inner
    }

    // No `ne` implementation here
    // ここに`ne`の実装はありません。
}
<span class="boring">}</span></code></pre></pre>
<p>You are not forced to use the default implementation though.
You can choose to override it when you implement the trait:</p>
<blockquote>
<p>しかし、デフォルト実装を使用することを強制されません。
トレイを実装するとき、上書きすることを選択できます。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MyType;

impl PartialEq for MyType {
    fn eq(&amp;self, other: &amp;MyType) -&gt; bool {
        // Custom implementation
        // 独自の実装
    }

    fn ne(&amp;self, other: &amp;MyType) -&gt; bool {
        // Custom implementation
        // 独自の実装
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="exercise-29"><a class="header" href="#exercise-29">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/04_traits/03_operator_overloading"><code>04_traits/03_operator_overloading</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="derive-macros導出マクロ"><a class="header" href="#derive-macros導出マクロ">Derive macros（導出マクロ）</a></h1>
<p>Implementing <code>PartialEq</code> for <code>Ticket</code> was a bit tedious, wasn't it?
You had to manually compare each field of the struct.</p>
<blockquote>
<p><code>Ticket</code>の<code>PartialEq</code>の実装は少し退屈ではないですか？
構造体のそれぞれのフィールドを手動で比較しなくてはなりませんでした。</p>
</blockquote>
<h2 id="destructuring-syntax分割構文"><a class="header" href="#destructuring-syntax分割構文">Destructuring syntax（分割構文）</a></h2>
<p>Furthermore, the implementation is brittle: if the struct definition changes
(e.g. a new field is added), you have to remember to update the <code>PartialEq</code> implementation.</p>
<blockquote>
<p>さらに、その実装は壊れやすいです。
新しいフィールドが追加されるなど、構造体の定義が変更した場合、<code>PartialEq</code>の実装を更新することを忘れないようにしなくてはなりません。</p>
</blockquote>
<p>You can mitigate the risk by <strong>destructuring</strong> the struct into its fields:</p>
<blockquote>
<p>構造体をそのフィールドに<strong>分割</strong>することで、そのリスクを軽減できます。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl PartialEq for Ticket {
    fn eq(&amp;self, other: &amp;Self) -&gt; bool {
        let Ticket {
            title,
            description,
            status,
        } = self;
        // [...]
    }
}
<span class="boring">}</span></code></pre></pre>
<p>If the definition of <code>Ticket</code> changes, the compiler will error out, complaining that your
destructuring is no longer exhaustive.<br />
You can also rename struct fields, to avoid variable shadowing:</p>
<blockquote>
<p><code>Ticket</code>の定義が変更された場合、コンパイラーは、分割がもはや網羅的でないとしてエラーを出力します。
また、変数のシャドーイングを防ぐために、構造体のフィールドの名前を変更できます。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl PartialEq for Ticket {
    fn eq(&amp;self, other: &amp;Self) -&gt; bool {
        let Ticket {
            title,
            description,
            status,
        } = self;
        let Ticket {
            title: other_title,
            description: other_description,
            status: other_status,
        } = other;
        // [...]
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Destructuring is a useful pattern to have in your toolkit, but
there's an even more convenient way to do this: <strong>derive macros</strong>.</p>
<blockquote>
<p>分割はツールキット内にあると便利なパターンですが、実装するために、より便利な方法があります。
それは<strong>導出マクロ</strong>です。</p>
</blockquote>
<h2 id="macrosマクロ"><a class="header" href="#macrosマクロ">Macros（マクロ）</a></h2>
<p>You've already encountered a few macros in past exercises:</p>
<ul>
<li><code>assert_eq!</code> and <code>assert!</code>, in the test cases</li>
<li><code>println!</code>, to print to the console</li>
</ul>
<blockquote>
<p>過去の演習ですでにいくつかのマクロに遭遇しています。</p>
<ul>
<li>テストケース内の<code>assert_eq!</code>と<code>assert!</code></li>
<li>コンソールに出力するための<code>println!</code></li>
</ul>
</blockquote>
<p>Rust macros are <strong>code generators</strong>.<br />
They generate new Rust code based on the input you provide, and that generated code is then compiled alongside
the rest of your program. Some macros are built into Rust's standard library, but you can also
write your own. We won't be creating our own macro in this course, but you can find some useful
pointers in the <a href="04_traits/04_derive.html#further-reading%E5%8F%82%E8%80%83%E8%B3%87%E6%96%99">"Further reading" section</a></p>
<blockquote>
<p>Rustのマクロは<strong>コードジェネレーター</strong>です。
それらは、提供した入力に基づいて新しいRustコードを生成して、生成されたコードはプログラムの残りと一緒にコンパイルされます。
いくつかのマクロは、Rust標準ライブラリ内に組み込まれていますが、独自に記述することもできます。
このコースで独自のマクロを作成するつもりはありませんが、参考資料の節にいくつかの有益な指針を見つけれます。</p>
</blockquote>
<h3 id="inspection検査"><a class="header" href="#inspection検査">Inspection（検査）</a></h3>
<p>Some IDEs let you expand a macro to inspect the generated code. If that's not possible, you can use
<a href="https://github.com/dtolnay/cargo-expand"><code>cargo-expand</code></a>.</p>
<blockquote>
<p>一部のIDEは、生成されるコードを検査するためにマクロを展開します。
それが不可能な場合、<code>cargo-expand</code>を使用できます。</p>
</blockquote>
<h3 id="derive-macros導出マクロ-1"><a class="header" href="#derive-macros導出マクロ-1">Derive macros（導出マクロ）</a></h3>
<p>A <strong>derive macro</strong> is a particular flavour of Rust macro. It is specified as an <strong>attribute</strong> on top of a struct.</p>
<blockquote>
<p><strong>導出マクロ</strong>は、Rustマクロの特別な風味です。
それは、構造体の上に<strong>属性</strong>として指定されます。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(PartialEq)]
struct Ticket {
    title: String,
    description: String,
    status: String
}
<span class="boring">}</span></code></pre></pre>
<p>Derive macros are used to automate the implementation of common (and "obvious") traits for custom types.
In the example above, the <code>PartialEq</code> trait is automatically implemented for <code>Ticket</code>.
If you expand the macro, you'll see that the generated code is functionally equivalent to the one you wrote manually,
although a bit more cumbersome to read:</p>
<blockquote>
<p>導出マクロは、カスタム型に一般的なトレイトの実装を自動化するために使用されます。
上記例において、<code>PartialEq</code>トレイトは<code>Ticket</code>に自動で実装されます。
マクロを展開した場合、読むのがより少し煩わしいですが、手動で記述したものと機能的に等価なコードが生成されることを確認できます。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[automatically_derived]
impl ::core::cmp::PartialEq for Ticket {
    #[inline]
    fn eq(&amp;self, other: &amp;Ticket) -&gt; bool {
        self.title == other.title &amp;&amp; self.description == other.description
            &amp;&amp; self.status == other.status
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The compiler will nudge you to derive traits when possible.</p>
<blockquote>
<p>コンパイラーは、可能な場合にトレイトを導出することを推奨します。</p>
</blockquote>
<h2 id="further-reading参考資料-7"><a class="header" href="#further-reading参考資料-7">Further reading（参考資料）</a></h2>
<ul>
<li><a href="https://veykril.github.io/tlborm/">The little book of Rust macros</a></li>
<li><a href="https://github.com/dtolnay/proc-macro-workshop">Proc macro workshop</a></li>
</ul>
<h2 id="exercise-30"><a class="header" href="#exercise-30">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/04_traits/04_derive"><code>04_traits/04_derive</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="trait-boundsトレイト制約"><a class="header" href="#trait-boundsトレイト制約">Trait bounds（トレイト制約）</a></h1>
<p>We've seen two use cases for traits so far:</p>
<ul>
<li>Unlocking "built-in" behaviour (e.g. operator overloading)</li>
<li>Adding new behaviour to existing types (i.e. extension traits)</li>
</ul>
<blockquote>
<p>これまで、トレイトの2つのユースケースを確認しました。</p>
<ul>
<li>例えば、演算子のオーバーロードなど、「組み込み機能」の振る舞いを解除する。</li>
<li>拡張トレイトなど、既存の型に新しい振る舞いを追加する。</li>
</ul>
</blockquote>
<p>There's a third use case: <strong>generic programming</strong>.</p>
<blockquote>
<p>3つ目のユースケースがあります。それは<strong>ジェネリックプログラミング</strong>です。</p>
</blockquote>
<h2 id="the-problem課題"><a class="header" href="#the-problem課題">The problem（課題）</a></h2>
<p>All our functions and methods, so far, have been working with <strong>concrete types</strong>.<br />
Code that operates on concrete types is usually straightforward to write and understand. But it's also
limited in its reusability.<br />
Let's imagine, for example, that we want to write a function that returns <code>true</code> if an integer is even.
Working with concrete types, we'd have to write a separate function for each integer type we want to
support:</p>
<blockquote>
<p>これまで、すべての関数とメソッドは、<strong>具象型</strong>と機能してきました。
具象型に対して操作するコードは、通常、記述することや理解することが簡単です。
しかし、それはその再利用性を制限されます。
例えば、整数が偶数である場合に<code>true</code>を返す関数を記述したいとしましょう。
具象型と機能する場合、サポートしたい整数型それぞれに対して、別々の関数を記述しなければなりません。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn is_even_i32(n: i32) -&gt; bool {
    n % 2 == 0
}

fn is_even_i64(n: i64) -&gt; bool {
    n % 2 == 0
}

// Etc.
<span class="boring">}</span></code></pre></pre>
<p>Alternatively, we could write a single extension trait and then different implementations for each integer type:</p>
<p>代わりに、1つの拡張トレイトと整数型それぞれに異なる実装を記述することができます。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait IsEven {
    fn is_even(&amp;self) -&gt; bool;
}

impl IsEven for i32 {
    fn is_even(&amp;self) -&gt; bool {
        self % 2 == 0
    }
}

impl IsEven for i64 {
    fn is_even(&amp;self) -&gt; bool {
        self % 2 == 0
    }
}

// Etc.
<span class="boring">}</span></code></pre></pre>
<p>The duplication remains.</p>
<blockquote>
<p>重複は残ります。</p>
</blockquote>
<h2 id="generic-programmingジェネリックプログラミング"><a class="header" href="#generic-programmingジェネリックプログラミング">Generic programming（ジェネリックプログラミング）</a></h2>
<p>We can do better using <strong>generics</strong>.<br />
Generics allow us to write code that works with a <strong>type parameter</strong> instead of a concrete type:</p>
<blockquote>
<p><strong>ジェネリック</strong>を使用することで、より良くできます。
ジェネリックは、具象型の代わりに<strong>型パラメーター</strong>と機能するコードを記述できるようにします。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn print_if_even&lt;T&gt;(n: T)
where
    T: IsEven + Debug
{
    if n.is_even() {
        println!("{n:?} is even");
    }
}
<span class="boring">}</span></code></pre></pre>
<p><code>print_if_even</code> is a <strong>generic function</strong>.<br />
It isn't tied to a specific input type. Instead, it works with any type <code>T</code> that:</p>
<ul>
<li>Implements the <code>IsEven</code> trait.</li>
<li>Implements the <code>Debug</code> trait.</li>
</ul>
<blockquote>
<p><code>print_if_even</code>は、<strong>ジェネリック関数</strong>です。
それは、特定の入力型に結びついていません。代わりに、それは次の任意の<code>T</code>型と機能します。</p>
<ul>
<li><code>IsEven</code>トレイトを実装している。</li>
<li><code>Debug</code>トレイトを実装している。</li>
</ul>
</blockquote>
<p>This contract is expressed with a <strong>trait bound</strong>: <code>T: IsEven + Debug</code>.<br />
The <code>+</code> symbol is used to require that <code>T</code> implements multiple traits. <code>T: IsEven + Debug</code> is equivalent to
"where <code>T</code> implements <code>IsEven</code> <strong>and</strong> <code>Debug</code>".</p>
<blockquote>
<p>この契約は、<code>T: IsEven + Debug</code>という、<strong>トレイト制約</strong>で表現されています。
<code>+</code>記号は、<code>T</code>が複数のトレイトを実装していることを要求するために使用されます。
<code>T: IsEven + Debug</code>は、「<code>T</code>が<code>IsEven</code> <strong>と</strong> <code>Debug</code>を実装している」と同等です。</p>
</blockquote>
<h2 id="trait-boundsトレイト制約-1"><a class="header" href="#trait-boundsトレイト制約-1">Trait bounds（トレイト制約）</a></h2>
<p>What purpose do trait bounds serve in <code>print_if_even</code>?<br />
To find out, let's try to remove them:</p>
<blockquote>
<p><code>print_if_even</code>において、トレイト制約はどのような目的があるのでしょうか？
それを見出すために、それらを削除してみましょう。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn print_if_even&lt;T&gt;(n: T) {
    if n.is_even() {
        println!("{n:?} is even");
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This code won't compile:</p>
<blockquote>
<p>このコードはコンパイルされません。</p>
</blockquote>
<pre><code class="language-text">error[E0599]: no method named `is_even` found for type parameter `T` in the current scope
 --&gt; src/lib.rs:2:10
  |
1 | fn print_if_even&lt;T&gt;(n: T) {
  |                  - method `is_even` not found for this type parameter
2 |     if n.is_even() {
  |          ^^^^^^^ method not found in `T`

error[E0277]: `T` doesn't implement `Debug`
 --&gt; src/lib.rs:3:19
  |
3 |         println!("{n:?} is even");
  |                   ^^^^^ `T` cannot be formatted using `{:?}` because it doesn't implement `Debug`
  |
help: consider restricting type parameter `T`
  |
1 | fn print_if_even&lt;T: std::fmt::Debug&gt;(n: T) {
  |                   +++++++++++++++++
</code></pre>
<p>Without trait bounds, the compiler doesn't know what <code>T</code> <strong>can do</strong>.<br />
It doesn't know that <code>T</code> has an <code>is_even</code> method, and it doesn't know how to format <code>T</code> for printing.
From the compiler point of view, a bare <code>T</code> has no behaviour at all.<br />
Trait bounds restrict the set of types that can be used by ensuring that the behaviour required by the function
body is present.</p>
<blockquote>
<p>トレイト制約なしで、コンパイラーは<code>T</code>が<strong>できること</strong>を知りません。
コンパイラーは、<code>T</code>が<code>is_even</code>メソッドを持っていることを知らず、出力するために<code>T</code>を書式化する方法を知りません。
コンパイラーの観点から、素の<code>T</code>はまったく振る舞いを持っていません。
トレイト制約は、関数本体に存在する要求された振る舞いを確実にすることで、使用できる型の集合を制約します。</p>
</blockquote>
<h2 id="syntax-inlining-trait-bounds構文インライントレイト制約"><a class="header" href="#syntax-inlining-trait-bounds構文インライントレイト制約">Syntax: inlining trait bounds（構文：インライントレイト制約）</a></h2>
<p>All the examples above used a <strong><code>where</code> clause</strong> to specify trait bounds:</p>
<blockquote>
<p>上記例すべては、トレイト制約を指定するために<strong>where節</strong>を使用しました。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn print_if_even&lt;T&gt;(n: T)
where
    T: IsEven + Debug
//  ^^^^^^^^^^^^^^^^^
//  This is a `where` clause
{
    // [...]
}
<span class="boring">}</span></code></pre></pre>
<p>If the trait bounds are simple, you can <strong>inline</strong> them directly next to the type parameter:</p>
<blockquote>
<p>トレイト制約が単純であれば、型パラメーターの次にそれらを直接<strong>インライン</strong>で記述できます。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn print_if_even&lt;T: IsEven + Debug&gt;(n: T) {
    //           ^^^^^^^^^^^^^^^^^
    //           This is an inline trait bound
    // [...]
}
<span class="boring">}</span></code></pre></pre>
<h2 id="syntax-meaningful-names構文意味のある名前"><a class="header" href="#syntax-meaningful-names構文意味のある名前">Syntax: meaningful names（構文：意味のある名前）</a></h2>
<p>In the examples above, we used <code>T</code> as the type parameter name. This is a common convention when a function has
only one type parameter.<br />
Nothing stops you from using a more meaningful name, though:</p>
<blockquote>
<p>上記例において、型パラメーター名として<code>T</code>を使用しました。
これは、関数がたった1つの型パラメーターを持つときの慣例です。
しかし、より意味のある名前を使用することは妨げられません。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn print_if_even&lt;Number: IsEven + Debug&gt;(n: Number) {
    // [...]
}
<span class="boring">}</span></code></pre></pre>
<p>It is actually <strong>desirable</strong> to use meaningful names when there are multiple type parameters at play or when the name
<code>T</code> doesn't convey enough information about the type's role in the function.
Maximize clarity and readability when naming type parameters, just as you would with variables or function parameters.
Follow Rust's conventions, though: use <a href="https://rust-lang.github.io/api-guidelines/naming.html#casing-conforms-to-rfc-430-c-case">upper camel case for type parameter names</a>.</p>
<blockquote>
<p>複数の型パラメーターが関与するときや、関数内の型の役目について、名前<code>T</code>が十分な情報を伝えていないとき、実際、意味のある名前を使用することは<strong>望ましい</strong>です。
型パラメーターに名前を付けるときの最大限の明確化と読みやすさは、ちょうど変数や関数の引数に名前を付けるときと同じです。
ただし、型パラメーターに大文字のキャメルケースを使用する、Rustの慣習に従ってください。</p>
</blockquote>
<h2 id="the-function-signature-is-king関数のシグネチャーは王様"><a class="header" href="#the-function-signature-is-king関数のシグネチャーは王様">The function signature is king（関数のシグネチャーは王様）</a></h2>
<p>You may wonder why we need trait bounds at all. Can't the compiler infer the required traits from the function's body?<br />
It could, but it won't.<br />
The rationale is the same as for <a href="04_traits/../02_basic_calculator/02_variables.html#function-arguments-are-variables">explicit type annotations on function parameters</a>:
each function signature is a contract between the caller and the callee, and the terms must be explicitly stated.
This allows for better error messages, better documentation, less unintentional breakages across versions,
and faster compilation times.</p>
<blockquote>
<p>トレイト制約が必要な理由に戸惑っているかもしれません。コンパイラーは、関数の本体から要求されるトレイトを推測することができないのでしょうか？
できるかもしれませんが、しません。
論理的根拠は、明示的な関数引数の型注釈と同じです。
それぞれの関数のシグネチャーは、呼び出される側と呼び出す側の間の契約であり、その表現は明示的に述べられなければなりません。
これは、良いエラーメッセージ、良いドキュメント、バージョン間の意図しない破壊の減少、そしてコンパイル時間の短縮を可能にします。</p>
</blockquote>
<h2 id="exercise-31"><a class="header" href="#exercise-31">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/04_traits/05_trait_bounds"><code>04_traits/05_trait_bounds</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="string-slices文字列スライス"><a class="header" href="#string-slices文字列スライス">String slices（文字列スライス）</a></h1>
<p>Throughout the previous chapters you've seen quite a few <strong>string literals</strong> being used in the code,
like <code>"To-Do"</code> or <code>"A ticket description"</code>.
They were always followed by a call to <code>.to_string()</code> or <code>.into()</code>. It's time to understand why!</p>
<blockquote>
<p>前の章を通じて、コード内で使用された<code>"To-Do"</code>または<code>"A ticket description"</code>のような、<strong>文字列リテラル</strong>をいくつか確認しました。
それらは常に、<code>to_string()</code>または<code>into()</code>の呼び出しが続きました。それがなぜなのかを理解する時がきました！</p>
</blockquote>
<h2 id="string-literals文字列リテラル"><a class="header" href="#string-literals文字列リテラル">String literals（文字列リテラル）</a></h2>
<p>You define a string literal by enclosing the raw text in double quotes:</p>
<blockquote>
<p>ダブルクウォートで素のテキストを囲むことで、文字列リテラルを定義します。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = "Hello, world!";
<span class="boring">}</span></code></pre></pre>
<p>The type of <code>s</code> is <code>&amp;str</code>, a <strong>reference to a string slice</strong>.</p>
<blockquote>
<p><code>s</code>の型は<code>&amp;str</code>で、<strong>文字列スライスへの参照</strong>です。</p>
</blockquote>
<h2 id="memory-layoutメモリレイアウト-1"><a class="header" href="#memory-layoutメモリレイアウト-1">Memory layout（メモリレイアウト）</a></h2>
<p><code>&amp;str</code> and <code>String</code> are different types—they're not interchangeable.<br />
Let's recall the memory layout of a <code>String</code> from our
<a href="04_traits/../03_ticket_v1/09_heap.html">previous exploration</a>.
If we run:</p>
<blockquote>
<p><code>&amp;str</code>と<code>String</code>は異なる型で、それらは交換できません。
前の探求から<code>String</code>のメモリレイアウトを思い出しましょう。
もし、次を実行した場合・・・</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut s = String::with_capacity(5);
s.push_str("Hello");
<span class="boring">}</span></code></pre></pre>
<p>we'll get this scenario in memory:</p>
<blockquote>
<p>メモリ上で次のシナリオが得られます。</p>
</blockquote>
<pre><code class="language-text">      +---------+--------+----------+
Stack | pointer | length | capacity |
      |  |      |   5    |    5     |
      +--|------+--------+----------+
         |
         |
         v
       +---+---+---+---+---+
Heap:  | H | e | l | l | o |
       +---+---+---+---+---+
</code></pre>
<p>If you remember, we've <a href="04_traits/../03_ticket_v1/10_references_in_memory.html">also examined</a>
how a <code>&amp;String</code> is laid out in memory:</p>
<blockquote>
<p>覚えている場合、メモリ内で<code>&amp;String</code>が配置される方法も調査しました。</p>
</blockquote>
<pre><code class="language-text">     --------------------------------------
     |                                    |
+----v----+--------+----------+      +----|----+
| pointer | length | capacity |      | pointer |
|    |    |   5    |    5     |      |         |
+----|----+--------+----------+      +---------+
     |        s                          &amp;s
     |
     v
   +---+---+---+---+---+
   | H | e | l | l | o |
   +---+---+---+---+---+
</code></pre>
<p><code>&amp;String</code> points to the memory location where the <code>String</code>'s metadata is stored.<br />
If we follow the pointer, we get to the heap-allocated data. In particular, we get to the first byte of the string, <code>H</code>.</p>
<blockquote>
<p><code>&amp;String</code>は、<code>String</code>のメタデータを保存したメモリの場所を指し示しています。
ポインタをたどった場合、ヒープに割り当てられたデータに到達します。特に、文字列の最初のバイトの<code>H</code>に到達します。</p>
</blockquote>
<p>What if we wanted a type that represents a <strong>substring</strong> of <code>s</code>? E.g. <code>ello</code> in <code>Hello</code>?</p>
<blockquote>
<p>例えば、<code>Hello</code>内の<code>ello</code>のように、<code>s</code>の<strong>部分文字列</strong>を表現する型が欲しい場合どうなるでしょうか？</p>
</blockquote>
<h2 id="string-slices文字列スライス-1"><a class="header" href="#string-slices文字列スライス-1">String slices（文字列スライス）</a></h2>
<p>A <code>&amp;str</code> is a <strong>view</strong> into a string, a <strong>reference</strong> to a sequence of UTF-8 bytes stored elsewhere.
You can, for example, create a <code>&amp;str</code> from a <code>String</code> like this:</p>
<blockquote>
<p><code>&amp;str</code>は文字列内部への<strong>ビュー</strong>であり、他の場所に保存されたUTF-8バイトシーケンスへの参照です。
例えば、次のように<code>String</code>から<code>&amp;str</code>を作成できます。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut s = String::with_capacity(5);
s.push_str("Hello");
// Create a string slice reference from the `String`, skipping the first byte.
// 最初のバイトをスキップして、`String`から文字列スライスの参照を作成します。
let slice: &amp;str = &amp;s[1..];
<span class="boring">}</span></code></pre></pre>
<p>In memory, it'd look like this:</p>
<blockquote>
<p>メモリ内で、それは次のように見えます。</p>
</blockquote>
<pre><code class="language-text">                    s                              slice
      +---------+--------+----------+      +---------+--------+
Stack | pointer | length | capacity |      | pointer | length |
      |    |    |   5    |    5     |      |    |    |   4    |
      +----|----+--------+----------+      +----|----+--------+
           |        s                           |
           |                                    |
           v                                    |
         +---+---+---+---+---+                  |
Heap:    | H | e | l | l | o |                  |
         +---+---+---+---+---+                  |
               ^                                |
               |                                |
               +--------------------------------+
</code></pre>
<p><code>slice</code> stores two pieces of information on the stack:</p>
<ul>
<li>A pointer to the first byte of the slice.</li>
<li>The length of the slice.</li>
</ul>
<blockquote>
<p><code>スライス</code>は、スタック上の2つの情報を蓄積します。</p>
<ul>
<li>スライスの最初のバイトへのポインター</li>
<li>スライスの長さ</li>
</ul>
</blockquote>
<p><code>slice</code> doesn't own the data, it just points to it: it's a <strong>reference</strong> to the <code>String</code>'s heap-allocated data.<br />
When <code>slice</code> is dropped, the heap-allocated data won't be deallocated, because it's still owned by <code>s</code>.
That's why <code>slice</code> doesn't have a <code>capacity</code> field: it doesn't own the data, so it doesn't need to know how much
space it was allocated for it; it only cares about the data it references.</p>
<blockquote>
<p><code>スライス</code>は単にデータを指し示すため、<code>スライス</code>はデータを所有しません。それは<code>String</code>のヒープに割り当てられたデータへの<strong>参照</strong>です。
<code>スライス</code>がドロップされたとき、それはまだ<code>s</code>によって所有されているため、ヒープに割り当てられたデータは解放されません。
それが、<code>スライス</code>が<code>capacity</code>フィールドを持たない理由です。それはデータを所有しないため、それはそのために割り当てられた領域の量を知る必要はありません。
単にそれは、それが参照するデータについてのみ気にかけています。</p>
</blockquote>
<h2 id="str-vs-stringstrとstring"><a class="header" href="#str-vs-stringstrとstring"><code>&amp;str</code> vs <code>&amp;String</code>（&amp;strと&amp;String）</a></h2>
<p>As a rule of thumb, use <code>&amp;str</code> rather than <code>&amp;String</code> whenever you need a reference to textual data.<br />
<code>&amp;str</code> is more flexible and generally considered more idiomatic in Rust code.</p>
<blockquote>
<p>経験則から、テキストデータへの参照が必要なときはいつでも、<code>&amp;String</code>よりも<code>&amp;str</code>を使用してください。
<code>&amp;str</code>はより柔軟で、一般的にRustにおいてより慣習的であると考えられています。</p>
</blockquote>
<p>If a method returns a <code>&amp;String</code>, you're promising that there is heap-allocated UTF-8 text somewhere that
<strong>matches exactly</strong> the one you're returning a reference to.<br />
If a method returns a <code>&amp;str</code>, instead, you have a lot more freedom: you're just saying that <em>somewhere</em> there's a
bunch of text data and that a subset of it matches what you need, therefore you're returning a reference to it.</p>
<blockquote>
<p>メソッドが<code>&amp;String</code>を返す場合、参照を返すものと<strong>完全に一致する</strong>、ヒープに割り当てられたUTF-8テキストがどこかにあることを約束しています。
代わりにメソッドが<code>&amp;str</code>を返す場合、より自由度が高くなります。
どこかにテキストデータの束があり、そのサブセットが必要なものと一致しているので、その参照を返すだけであることを単に言っています。</p>
</blockquote>
<h2 id="exercise-32"><a class="header" href="#exercise-32">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/04_traits/06_str_slice"><code>04_traits/06_str_slice</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deref-traitderefトレイト"><a class="header" href="#deref-traitderefトレイト"><code>Deref</code> trait（Derefトレイト）</a></h1>
<p>In the previous exercise you didn't have to do much, did you?</p>
<blockquote>
<p>前の演習において、あまり多くのことをする必要はありませんでしたよね？</p>
</blockquote>
<p>Changing</p>
<blockquote>
<p>変更前</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Ticket {
    pub fn title(&amp;self) -&gt; &amp;String {
        &amp;self.title
    }
}
<span class="boring">}</span></code></pre></pre>
<p>to</p>
<blockquote>
<p>変更後</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Ticket {
    pub fn title(&amp;self) -&gt; &amp;str {
        &amp;self.title
    }
}
<span class="boring">}</span></code></pre></pre>
<p>was all you needed to do to get the code to compile and the tests to pass.
Some alarm bells should be ringing in your head though.</p>
<blockquote>
<p>コンパイルできるようにコードをして、テストにパスするために必要なことは、これだけでした。
しかし、頭の中で警報が鳴っているはずです。</p>
</blockquote>
<h2 id="it-shouldnt-work-but-it-doesそれは機能素べきではないが動作します"><a class="header" href="#it-shouldnt-work-but-it-doesそれは機能素べきではないが動作します">It shouldn't work, but it does（それは機能素べきではないが、動作します）</a></h2>
<p>Let's review the facts:</p>
<ul>
<li><code>self.title</code> is a <code>String</code></li>
<li><code>&amp;self.title</code> is, therefore, a <code>&amp;String</code></li>
<li>The output of the (modified) <code>title</code> method is <code>&amp;str</code></li>
</ul>
<blockquote>
<p>事実を振り返りましょう。</p>
<ul>
<li><code>self.title</code>は<code>String</code></li>
<li><code>&amp;self.title</code>は、よって<code>&amp;String</code></li>
<li>修正した<code>title</code>メソッドの出力は<code>&amp;str</code></li>
</ul>
</blockquote>
<p>You would expect a compiler error, wouldn't you? <code>Expected &amp;String, found &amp;str</code> or something similar.
Instead, it just works. <strong>Why</strong>?</p>
<blockquote>
<p>コンパイルエラーを期待したのではないでしょうか？<code>&amp;Stringを期待しましたが、&amp;strを見つけました</code>または何か同様なものを。
代わりに、それは単純に機能します。<strong>なぜでしょうか</strong>？</p>
</blockquote>
<h2 id="deref-to-the-rescuederefが救出します"><a class="header" href="#deref-to-the-rescuederefが救出します"><code>Deref</code> to the rescue（<code>Deref</code>が救出します）</a></h2>
<p>The <code>Deref</code> trait is the mechanism behind the language feature known as <a href="https://doc.rust-lang.org/std/ops/trait.Deref.html#deref-coercion"><strong>deref coercion</strong></a>.<br />
The trait is defined in the standard library, in the <code>std::ops</code> module:</p>
<blockquote>
<p><code>Deref</code>トレイトは、<strong>参照外し型強制</strong>として知られる言語機能の背後にあるメカニズムです。
そのトレイトは、標準ライブラリの<code>std::ops</code>モジュールで定義されています。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// I've slightly simplified the definition for now.
// We'll see the full definition later on.
// ここでは、定義を少し簡略化しています。
// 後で完全な定義を確認するつもりです。
pub trait Deref {
    type Target;

    fn deref(&amp;self) -&gt; &amp;Self::Target;
}
<span class="boring">}</span></code></pre></pre>
<p><code>type Target</code> is an <strong>associated type</strong>.<br />
It's a placeholder for a concrete type that must be specified when the trait is implemented.</p>
<blockquote>
<p><code>type Target</code>は<strong>関連型</strong>です。
それは、トレイトが実装されたときに指定される必要がある具象型のプレースホルダーです。</p>
</blockquote>
<h2 id="deref-coercion参照外し型強制"><a class="header" href="#deref-coercion参照外し型強制">Deref coercion（参照外し型強制）</a></h2>
<p>By implementing <code>Deref&lt;Target = U&gt;</code> for a type <code>T</code> you're telling the compiler that <code>&amp;T</code> and <code>&amp;U</code> are
somewhat interchangeable.<br />
In particular, you get the following behavior:</p>
<ul>
<li>References to <code>T</code> are implicitly converted into references to <code>U</code> (i.e. <code>&amp;T</code> becomes <code>&amp;U</code>)</li>
<li>You can call on <code>&amp;T</code> all the methods defined on <code>U</code> that take <code>&amp;self</code> as input.</li>
</ul>
<blockquote>
<p>型<code>T</code>に対して<code>Deref&lt;Target = U&gt;</code>を実装することにより、<code>&amp;T</code>と<code>&amp;U</code>が交換可能であることをコンパイラに伝えます。
特に、次のような振る舞いを得られます。</p>
<ul>
<li><code>T</code>への参照は、暗黙的に<code>U</code>への参照に変換されます（つまり、<code>&amp;T</code>は<code>&amp;U</code>になります）。</li>
<li>入力として<code>&amp;self</code>を受け取る<code>U</code>で定義されたすべてのメソッドを<code>&amp;T</code>で呼び出すことができます。</li>
</ul>
</blockquote>
<p>There is one more thing around the dereference operator, <code>*</code>, but we don't need it yet (see <code>std</code>'s docs
if you're curious).</p>
<blockquote>
<p>参照外し演算子<code>*</code>には、もう1つありますが、まだそれは必要ありません（好奇心が強いのであれば、<code>std</code>のドキュメントを参照してください）。</p>
</blockquote>
<h2 id="string-implements-derefstringはderefを実装しています"><a class="header" href="#string-implements-derefstringはderefを実装しています"><code>String</code> implements <code>Deref</code>（StringはDerefを実装しています）</a></h2>
<p><code>String</code> implements <code>Deref</code> with <code>Target = str</code>:</p>
<blockquote>
<p><code>String</code>は、<code>Target = str</code>を持つ<code>Deref</code>を実装しています。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Deref for String {
    type Target = str;

    fn deref(&amp;self) -&gt; &amp;str {
        // [...]
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Thanks to this implementation and deref coercion, a <code>&amp;String</code> is automatically converted into a <code>&amp;str</code> when needed.</p>
<blockquote>
<p>この実装と参照外し型強制のおかげで、必要なときに<code>&amp;String</code>は自動的に<code>&amp;str</code>に変換されます。</p>
</blockquote>
<h2 id="dont-abuse-deref-coercion参照外し型強制を乱用しない"><a class="header" href="#dont-abuse-deref-coercion参照外し型強制を乱用しない">Don't abuse deref coercion（参照外し型強制を乱用しない）</a></h2>
<p>Deref coercion is a powerful feature, but it can lead to confusion.<br />
Automatically converting types can make the code harder to read and understand. If a method with the same name
is defined on both <code>T</code> and <code>U</code>, which one will be called?</p>
<blockquote>
<p>参照外し型強制は強力な機能ですが、混乱を招く可能性があります。
型の自動変換は、コードを読むことと理解することを難しくする可能性があります。
<code>T</code>と<code>U</code>の両方に定義された同じ名前のメソッドがある場合、どちらが呼び出されるでしょうか？</p>
</blockquote>
<p>We'll examine later in the course the "safest" use cases for deref coercion: smart pointers.</p>
<blockquote>
<p>このコースの後半で、参照外し型強制の「最も安全な」ユースケースを調査します。それはスマートポインターです。</p>
</blockquote>
<h2 id="exercise-33"><a class="header" href="#exercise-33">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/04_traits/07_deref"><code>04_traits/07_deref</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sized"><a class="header" href="#sized"><code>Sized</code></a></h1>
<p>There's more to <code>&amp;str</code> than meets the eye, even after having
investigated deref coercion.<br />
From our previous <a href="04_traits/../03_ticket_v1/10_references_in_memory.html">discussion on memory layouts</a>,
it would have been reasonable to expect <code>&amp;str</code> to be represented as a single <code>usize</code> on
the stack, a pointer. That's not the case though. <code>&amp;str</code> stores some <strong>metadata</strong> next
to the pointer: the length of the slice it points to. Going back to the example from
<a href="04_traits/06_str_slice.html">a previous section</a>:</p>
<blockquote>
<p>参照外し型強制を調査した後でも、目に見える以上のことが<code>&amp;str</code>にあります。
前のメモリレイアウトで議論した内容から、それは<code>&amp;str</code>がスタック上の単一の<code>usize</code>、つまりポインターとして表現されることを期待することは理由がありした。
しかし、この場合は違い、<code>&amp;str</code>はポインターの隣にいくつかの<strong>メタデータ</strong>を保存しています。
それが指し示すスライスの長さです。
前の節の例に戻ります。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut s = String::with_capacity(5);
s.push_str("Hello");
// Create a string slice reference from the `String`, skipping the first byte.
// 最初のバイトをスキップした、`String`からの文字列スライスの参照を作成します。
let slice: &amp;str = &amp;s[1..];
<span class="boring">}</span></code></pre></pre>
<p>In memory, we get:</p>
<pre><code class="language-text">                    s                              slice
      +---------+--------+----------+      +---------+--------+
Stack | pointer | length | capacity |      | pointer | length |
      |    |    |   5    |    5     |      |    |    |   4    |
      +----|----+--------+----------+      +----|----+--------+
           |        s                           |
           |                                    |
           v                                    |
         +---+---+---+---+---+                  |
Heap:    | H | e | l | l | o |                  |
         +---+---+---+---+---+                  |
               ^                                |
               |                                |
               +--------------------------------+
</code></pre>
<p>What's going on?</p>
<blockquote>
<p>何が起こっているのでしょうか？</p>
</blockquote>
<h2 id="dynamically-sized-types動的サイズ型"><a class="header" href="#dynamically-sized-types動的サイズ型">Dynamically sized types（動的サイズ型）</a></h2>
<p><code>str</code> is a <strong>dynamically sized type</strong> (DST).<br />
A DST is a type whose size is not known at compile time. Whenever you have a
reference to a DST, like <code>&amp;str</code>, it has to include additional
information about the data it points to. It is a <strong>fat pointer</strong>.<br />
In the case of <code>&amp;str</code>, it stores the length of the slice it points to.
We'll see more examples of DSTs in the rest of the course.</p>
<blockquote>
<p><code>str</code>は<strong>動的サイズ型</strong>（DST）です。
DSTは、コンパイル時にサイズがわからない型です。
<code>&amp;str</code>のような、DSTへの参照を持つときはいつでも、それはそれが指し示すデータについての追加情報を含む必要があります。
それは<strong>ファットポインター</strong>です。
<code>&amp;str</code>の場合、それはそれが指し示すスライスの長さを保存します。
コースの残りで、DSTのさらなる例を確認します。</p>
</blockquote>
<h2 id="the-sized-traitsizedトレイト"><a class="header" href="#the-sized-traitsizedトレイト">The <code>Sized</code> trait（<code>Sized</code>トレイト）</a></h2>
<p>Rust's <code>std</code> library defines a trait called <code>Sized</code>.</p>
<blockquote>
<p>Rustの<code>std</code>ライブラリは、<code>Sized</code>と呼ばれるトレイトを定義しています。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Sized {
    // This is an empty trait, no methods to implement.
    // これは空のトレイトで、実装するメソッドはありません。
}
<span class="boring">}</span></code></pre></pre>
<p>A type is <code>Sized</code> if its size is known at compile time. In other words, it's not a DST.</p>
<blockquote>
<p>コンパイル時にそのサイズがわかっている場合、その型は<code>Sized</code>です。言い換えれば、DSTではありません。</p>
</blockquote>
<h3 id="marker-traitsマーカートレイト"><a class="header" href="#marker-traitsマーカートレイト">Marker traits（マーカートレイト）</a></h3>
<p><code>Sized</code> is your first example of a <strong>marker trait</strong>.<br />
A marker trait is a trait that doesn't require any methods to be implemented. It doesn't define any behavior.
It only serves to <strong>mark</strong> a type as having certain properties.
The mark is then leveraged by the compiler to enable certain behaviors or optimizations.</p>
<blockquote>
<p><code>Sized</code>は<strong>マーカートレイト</strong>の最初の例です。
マーカートレイトは、実装されるメソッドを要求しないトレイトです。それは何の振る舞いも定義しません。
それは、特定の属性を持つ型として<strong>マーク</strong>することのみ提供します。
そして、マークは特定の振る舞いまたは最適化を有効にするためにコンパイラーによって利用されます。</p>
</blockquote>
<h3 id="auto-traits自動トレイト"><a class="header" href="#auto-traits自動トレイト">Auto traits（自動トレイト）</a></h3>
<p>In particular, <code>Sized</code> is also an <strong>auto trait</strong>.<br />
You don't need to implement it explicitly; the compiler implements it automatically for you
based on the type's definition.</p>
<blockquote>
<p>特に、<code>Sized</code>は<strong>自動トレイト</strong>でもあります。
それを明示的に実装する必要はありません。
コンパイラーは、それを型の定義に基づいて自動的に実装します。</p>
</blockquote>
<h3 id="examples例"><a class="header" href="#examples例">Examples（例）</a></h3>
<p>All the types we've seen so far are <code>Sized</code>: <code>u32</code>, <code>String</code>, <code>bool</code>, etc.</p>
<blockquote>
<p>これまでに見てきた<code>u32</code>、<code>String</code>、<code>bool</code>などのすべての型は<code>Sized</code>です。</p>
</blockquote>
<p><code>str</code>, as we just saw, is not <code>Sized</code>.<br />
<code>&amp;str</code> is <code>Sized</code> though! We know its size at compile time: two <code>usize</code>s, one for the pointer
and one for the length.</p>
<blockquote>
<p>ちょうど確認した通り、<code>str</code>は<code>Sized</code>ではありません。
しかし、<code>&amp;str</code>は<code>Sized</code>です！
コンパイル時にそのサイズを知っています。
2つの<code>usize</code>で、1つはポインターで、1つはその長さです。</p>
</blockquote>
<h2 id="exercise-34"><a class="header" href="#exercise-34">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/04_traits/08_sized"><code>04_traits/08_sized</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="from-and-intfromとinto"><a class="header" href="#from-and-intfromとinto"><code>From</code> and <code>Int</code>（FromとInto）</a></h1>
<p>Let's go back to where our string journey started:</p>
<blockquote>
<p>文字列の旅を始めたことろに戻りましょう。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let ticket = Ticket::new("A title".into(), "A description".into(), "To-Do".into());
<span class="boring">}</span></code></pre></pre>
<p>We now know enough to start unpacking what <code>.into()</code> is doing here.</p>
<blockquote>
<p>現在、<code>.into()</code>が何をしているのかを解明を始める、十分な知識があります。</p>
</blockquote>
<h2 id="the-problem課題-1"><a class="header" href="#the-problem課題-1">The problem（課題）</a></h2>
<p>This is the signature of the <code>new</code> method:</p>
<blockquote>
<p>これは、<code>new</code>メソッドのシグネチャーです。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Ticket {
    pub fn new(title: String, description: String, status: String) -&gt; Self {
        // [...]
    }
}
<span class="boring">}</span></code></pre></pre>
<p>We've also seen that string literals (such as <code>"A title"</code>) are of type <code>&amp;str</code>.<br />
We have a type mismatch here: a <code>String</code> is expected, but we have a <code>&amp;str</code>.
No magical coercion will come to save us this time; we need <strong>to perform a conversion</strong>.</p>
<p>また、<code>"A title"</code>のような文字列リテラルが<code>&amp;str</code>型であることを確認しました。
ここで、型のミスマッチがあります。<code>String</code>が期待されていますが、<code>&amp;str</code>があります。
今回は、魔法の強制はこれを救ってはくれません。<strong>変換を実行する</strong>必要があります。</p>
<h2 id="from-and-intofromとinto"><a class="header" href="#from-and-intofromとinto"><code>From</code> and <code>Into</code>（FromとInto）</a></h2>
<p>The Rust standard library defines two traits for <strong>infallible conversions</strong>: <code>From</code> and <code>Into</code>,
in the <code>std::convert</code> module.</p>
<blockquote>
<p>Rust標準ライブラリは、<code>From</code>と<code>Into</code>という<strong>失敗しない変換</strong>のための2つのトレイトを<code>std::convert</code>モジュールで定義しています。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait From&lt;T&gt;: Sized {
    fn from(value: T) -&gt; Self;
}

pub trait Into&lt;T&gt;: Sized {
    fn into(self) -&gt; T;
}
<span class="boring">}</span></code></pre></pre>
<p>These trait definitions showcase a few concepts that we haven't seen before: <strong>supertraits</strong> and <strong>implicit trait bounds</strong>.
Let's unpack those first.</p>
<blockquote>
<p>これらのトレイトの定義は、前に確認したいくつかの概念を披露しています。<strong>スーパートレイト</strong>と<strong>暗黙的なトレイト制約</strong>です。
まず、それらを解明しましょう。</p>
</blockquote>
<h3 id="supertrait--subtraitスーパートレイト--サブトレイト"><a class="header" href="#supertrait--subtraitスーパートレイト--サブトレイト">Supertrait / Subtrait（スーパートレイト / サブトレイト）</a></h3>
<p>The <code>From: Sized</code> syntax implies that <code>From</code> is a <strong>subtrait</strong> of <code>Sized</code>: any type that
implements <code>From</code> must also implement <code>Sized</code>.
Alternatively, you could say that <code>Sized</code> is a <strong>supertrait</strong> of <code>From</code>.</p>
<blockquote>
<p><code>From: Sized</code>構文は、<code>From</code>が<code>Sized</code>のサブトレイトであることを暗に意味しています。
<code>From</code>を実装する任意の型は、<code>Sized</code>も実装しなければなりません。
代わりに、<code>Sized</code>は<code>From</code>のスーパートレイトであると言うことができます。</p>
</blockquote>
<h3 id="implicit-trait-bounds暗黙的なトレイト制約"><a class="header" href="#implicit-trait-bounds暗黙的なトレイト制約">Implicit trait bounds（暗黙的なトレイト制約）</a></h3>
<p>Every time you have a generic type parameter, the compiler implicitly assumes that it's <code>Sized</code>.</p>
<p>For example:</p>
<blockquote>
<p>ジェネリックな型パラメーターがあるときはいつでも、コンパイラーは暗黙的にそれが<code>Sized</code>であることを仮定します。</p>
<p>例えば・・・</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Foo&lt;T&gt; {
    inner: T,
}
<span class="boring">}</span></code></pre></pre>
<p>is actually equivalent to:</p>
<blockquote>
<p>上記は実際に次と等価です。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Foo&lt;T: Sized&gt;
{
    inner: T,
}
<span class="boring">}</span></code></pre></pre>
<p>In the case of <code>From&lt;T&gt;</code>, the trait definition is equivalent to:</p>
<blockquote>
<p><code>From&lt;T&gt;</code>の場合、トレイトの定義は次と等価です。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait From&lt;T: Sized&gt;: Sized {
    fn from(value: T) -&gt; Self;
}
<span class="boring">}</span></code></pre></pre>
<p>In other words, <em>both</em> <code>T</code> and the type implementing <code>From&lt;T&gt;</code> must be <code>Sized</code>, even
though the former bound is implicit.</p>
<blockquote>
<p>言い換えると、<code>T</code>と　<code>From&lt;T&gt;</code>を実装した型は両方とも<code>Sized</code>でなければならず、前者の制約は暗黙的です。</p>
</blockquote>
<h3 id="negative-trait-boundsネガティブトレイト制約"><a class="header" href="#negative-trait-boundsネガティブトレイト制約">Negative trait bounds（ネガティブトレイト制約）</a></h3>
<p>You can opt out of the implicit <code>Sized</code> bound with a <strong>negative trait bound</strong>:</p>
<blockquote>
<p><strong>ネガティブトレイト制約</strong>を使用して、暗黙的な<code>Sized</code>制約を外すことができます。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Foo&lt;T: ?Sized&gt; {
    //            ^^^^^^^
    //            This is a negative trait bound
    //            これはネガティブトレイト制約です。
    inner: T,
}
<span class="boring">}</span></code></pre></pre>
<p>This syntax reads as "<code>T</code> may or may not be <code>Sized</code>", and it allows you to
bind <code>T</code> to a DST (e.g. <code>Foo&lt;str&gt;</code>). It is a special case, though: negative trait bounds are exclusive to <code>Sized</code>,
you can't use them with other traits.</p>
<blockquote>
<p>この構文は、「<code>T</code>は<code>Sized</code>かもしれないし、そうでないかもしれない」と読み取れ、例えば<code>Foo&lt;str&gt;</code>のように、それは<code>T</code>をDSTに束縛されるようにします。</p>
</blockquote>
<h2 id="str-to-stringstrからstringへ"><a class="header" href="#str-to-stringstrからstringへ"><code>&amp;str</code> to <code>String</code>（&amp;strからStringへ）</a></h2>
<p>In <a href="https://doc.rust-lang.org/std/convert/trait.From.html#implementors"><code>std</code>'s documentation</a>
you can see which <code>std</code> types implement the <code>From</code> trait.<br />
You'll find that <code>String</code> implements <code>From&lt;&amp;str&gt; for String</code>. Thus, we can write:</p>
<blockquote>
<p><code>std</code>のドキュメント内で、どの<code>std</code>の型が<code>From</code>トレイトを実装しているか確認できます。
<code>String</code>が<code>From&lt;&amp;str&gt;</code>を実装していることを確認できます。よって、次のように記述できました。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let title = String::from("A title");
<span class="boring">}</span></code></pre></pre>
<p>We've been primarily using <code>.into()</code>, though.<br />
If you check out the <a href="https://doc.rust-lang.org/std/convert/trait.Into.html#implementors">implementors of <code>Into</code></a>
you won't find <code>Into&lt;&amp;str&gt; for String</code>. What's going on?</p>
<blockquote>
<p>しかし、主に<code>.into()</code>を使用してきました。
<code>Into</code>の実装を確認した場合、<code>Into&lt;&amp;str&gt; for String</code>は見つかりません。何が起こっているのでしょうか？</p>
</blockquote>
<p><code>From</code> and <code>Into</code> are <strong>dual traits</strong>.<br />
In particular, <code>Into</code> is implemented for any type that implements <code>From</code> using a <strong>blanket implementation</strong>:</p>
<blockquote>
<p><code>From</code>と<code>Into</code>は<strong>デュアルトレイト</strong>です。
特に、<code>Into</code>は、<strong>ブランケット実装</strong>を使用して、<code>From</code>を実装する任意の型に対して実装されます。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T, U&gt; Into&lt;U&gt; for T
where
    U: From&lt;T&gt;,
{
    fn into(self) -&gt; U {
        U::from(self)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>If a type <code>U</code> implements <code>From&lt;T&gt;</code>, then <code>Into&lt;U&gt; for T</code> is automatically implemented. That's why
we can write <code>let title = "A title".into();</code>.</p>
<blockquote>
<p>型<code>U</code>が<code>From&lt;T&gt;</code>を実装している場合、<code>Into&lt;U&gt; for T</code>は自動的に実装されます。
これが、<code>let title = "A title".into();</code>と記述できた理由です。</p>
</blockquote>
<h2 id="into"><a class="header" href="#into"><code>.into()</code></a></h2>
<p>Every time you see <code>.into()</code>, you're witnessing a conversion between types.<br />
What's the target type, though?</p>
<blockquote>
<p><code>.into()</code>を確認するたびに、型間の変換を目撃します。
しかし、目的の型はなんでしょうか？</p>
</blockquote>
<p>In most cases, the target type is either:</p>
<ul>
<li>Specified by the signature of a function/method (e.g. <code>Ticket::new</code> in our example above)</li>
<li>Specified in the variable declaration with a type annotation (e.g. <code>let title: String = "A title".into();</code>)</li>
</ul>
<blockquote>
<p>ほとんどの場合、目的の型は次のいずれかです。</p>
<ul>
<li>関数/メソッドのシグネチャーによって指定される（例えば、上記列の<code>Ticket::new</code>）</li>
<li>型注釈を持つ変数宣言で指定される（例えば、<code>let title: String = "A title".into();</code>）</li>
</ul>
</blockquote>
<p><code>.into()</code> will work out of the box as long as the compiler can infer the target type from the context without ambiguity.</p>
<blockquote>
<p><code>.into()</code>は、コンパイラーが曖昧なく文脈から目的の型を推測できる限り、そのまま機能します。</p>
</blockquote>
<h2 id="exercise-35"><a class="header" href="#exercise-35">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/04_traits/09_from"><code>04_traits/09_from</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generics-and-associated-typesジェネリックと関連型"><a class="header" href="#generics-and-associated-typesジェネリックと関連型">Generics and associated types（ジェネリックと関連型）</a></h1>
<p>Let's re-examine the definition for two of the traits we studied so far, <code>From</code> and <code>Deref</code>:</p>
<blockquote>
<p>これまでに学んだ<code>From</code>と<code>Deref</code>の2つのトレイトの定義を再調査しましょう。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait From&lt;T&gt; {
    fn from(value: T) -&gt; Self;
}

pub trait Deref {
    type Target;

    fn deref(&amp;self) -&gt; &amp;Self::Target;
}
<span class="boring">}</span></code></pre></pre>
<p>They both feature type parameters.<br />
In the case of <code>From</code>, it's a generic parameter, <code>T</code>.<br />
In the case of <code>Deref</code>, it's an associated type, <code>Target</code>.</p>
<blockquote>
<p>それら両方は、型パラメーターが特徴です。
<code>From</code>の場合、<code>T</code>はジェネリックパラメーターです。
<code>Deref</code>の場合、<code>Target</code>は関連型です。</p>
</blockquote>
<p>What's the difference? Why use one over the other?</p>
<blockquote>
<p>違いは何でしょうか？なぜどちらかを使うのでしょうか？</p>
</blockquote>
<h2 id="at-most-one-implementation最大1つの実装"><a class="header" href="#at-most-one-implementation最大1つの実装">At most one implementation（最大1つの実装）</a></h2>
<p>Due to how deref coercion works, there can only be one "target" type for a given type. E.g. <code>String</code> can
only deref to <code>str</code>.
It's about avoiding ambiguity: if you could implement <code>Deref</code> multiple times for a type,
which <code>Target</code> type should the compiler choose when you call a <code>&amp;self</code> method?</p>
<blockquote>
<p>参照外し型強制が機能する仕組みにより、特定の型に対する1つの「目的」型が存在します。
例えば、<code>String</code>は、<code>str</code>にのみ参照外しされます。
それは曖昧さを避けるためです。ある型に対して複数回<code>Deref</code>を実装した場合、<code>&amp;self</code>メソッドを呼び出した時、コンパイラーはどの<code>Target</code>型を選択するべきでしょうか？</p>
</blockquote>
<p>That's why <code>Deref</code> uses an associated type, <code>Target</code>.<br />
An associated type is uniquely determined <strong>by the trait implementation</strong>.
Since you can't implement <code>Deref</code> more than once, you'll only be able to specify one <code>Target</code> for a given type
and there won't be any ambiguity.</p>
<blockquote>
<p>それが、<code>Deref</code>が関連型<code>Target</code>を使用する理由です。
関連型は、<strong>トレイトの実装によって</strong>一意に決定されます。
<code>Deref</code>を1つ以上実装できないため、特定の型に対してたった1つの<code>Target</code>を指定することができ、曖昧さはありません。</p>
</blockquote>
<h2 id="generic-traitsジェネリックトレイト"><a class="header" href="#generic-traitsジェネリックトレイト">Generic traits（ジェネリックトレイト）</a></h2>
<p>On the other hand, you can implement <code>From</code> multiple times for a type, <strong>as long as the input type <code>T</code> is different</strong>.
For example, you can implement <code>From</code> for <code>WrappingU32</code> using both <code>u32</code> and <code>u16</code> as input types:</p>
<blockquote>
<p>一方、任意の型に対して、<strong>入力型<code>T</code>が異なる限り</strong>、複数回<code>From</code>を実装できます。
例えば、<code>u32</code>と<code>u16</code>の両方を入力型として使用して、<code>WrappingU321に対して</code>From`を実装できます。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl From&lt;u32&gt; for WrappingU32 {
    fn from(value: u32) -&gt; Self {
        WrappingU32 { inner: value }
    }
}

impl From&lt;u16&gt; for WrappingU32 {
    fn from(value: u16) -&gt; Self {
        WrappingU32 { inner: value.into() }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This works because <code>From&lt;u16&gt;</code> and <code>From&lt;u32&gt;</code> are considered <strong>different traits</strong>.<br />
There is no ambiguity: the compiler can determine which implementation to use based on type of the value being converted.</p>
<blockquote>
<p><code>From&lt;u16&gt;</code>と<code>From&lt;u32&gt;</code>は<strong>異なるトレイト</strong>とみなされるため、これは機能します。
曖昧さはありません。コンパイラーは、値が変換される型に基づいて、どの実装を使用するか決定できます。</p>
</blockquote>
<h2 id="case-study-add事例研究-add"><a class="header" href="#case-study-add事例研究-add">Case study: <code>Add</code>（事例研究: Add）</a></h2>
<p>As a closing example, consider the <code>Add</code> trait from the standard library:</p>
<blockquote>
<p>最後の例として、標準ライブラリの<code>Add</code>トレイトを考えてみましょう。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Add&lt;RHS = Self&gt; {
    type Output;

    fn add(self, rhs: RHS) -&gt; Self::Output;
}
<span class="boring">}</span></code></pre></pre>
<p>It uses both mechanisms:</p>
<ul>
<li>it has a generic parameter, <code>RHS</code> (right-hand side), which defaults to <code>Self</code></li>
<li>it has an associated type, <code>Output</code>, the type of the result of the addition</li>
</ul>
<blockquote>
<p>それは両方のメカニズムを使用しています。</p>
<ul>
<li><code>Self</code>をデフォルトに持つ<code>RHS</code>（右辺）というジェネリックパラメーターがあります。</li>
<li>加算の結果の型である<code>Output</code>という関連型があります。</li>
</ul>
</blockquote>
<h3 id="rhs"><a class="header" href="#rhs"><code>RHS</code></a></h3>
<p><code>RHS</code> is a generic parameter to allow for different types to be added together.<br />
For example, you'll find these two implementations in the standard library:</p>
<p><code>RHS</code>は、異なる型を一緒に加算されるようにするためのジェネリックパラメーターです。
例えば、標準ライブラリにこれら2つの実装を見つけるでしょう。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Add&lt;u32&gt; for u32 {
    type Output = u32;

    fn add(self, rhs: u32) -&gt; u32 {
      //                      ^^^
      // This could be written as `Self::Output` instead.
      // The compiler doesn't care, as long as the type you
      // specify here matches the type you assigned to `Output`
      // right above.
      // これは、代わりに`Self::Output`と記述できます。
      // コンパイラーは、ここで指定した型が、上記`Output`の右に指定されている型と一致している限り気にしません。
      // [...]
    }
}

impl Add&lt;&amp;u32&gt; for u32 {
    type Output = u32;

    fn add(self, rhs: &amp;u32) -&gt; u32 {
        // [...]
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This allows the following code to compile:</p>
<p>これは、次のコードをコンパイルできるようにします。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5u32 + &amp;5u32 + 6u32;
<span class="boring">}</span></code></pre></pre>
<p>because <code>u32</code> implements <code>Add&lt;&amp;u32&gt;</code> <em>as well as</em> <code>Add&lt;u32&gt;</code>.</p>
<blockquote>
<p>なぜなら、<code>u32</code>は<code>Add&lt;u32&gt;</code>と <em>同様に</em> 、<code>Add&lt;&amp;u32&gt;</code>を実装しているからです。</p>
</blockquote>
<h3 id="output"><a class="header" href="#output"><code>Output</code></a></h3>
<p><code>Output</code> represents the type of the result of the addition.</p>
<blockquote>
<p><code>Output</code>は、加算の結果の型を表現します。</p>
</blockquote>
<p>Why do we need <code>Output</code> in the first place? Can't we just use <code>Self</code> as output, the type implementing <code>Add</code>?
We could, but it would limit the flexibility of the trait. In the standard library, for example, you'll find
this implementation:</p>
<blockquote>
<p>なぜ、そもそも<code>Output</code>が必要なのでしょうか？
出力として単に<code>Self</code>を使用できないのでしょうか？
できますが、そのトレイトの柔軟性を制限します。
例えば、標準ライブラリにおいて、次の実装を見つけるでしょう。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Add&lt;&amp;u32&gt; for &amp;u32 {
    type Output = u32;

    fn add(self, rhs: &amp;u32) -&gt; u32 {
        // [...]
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The type they're implementing the trait for is <code>&amp;u32</code>, but the result of the addition is <code>u32</code>.<br />
It would be impossible<sup class="footnote-reference"><a href="#flexible">1</a></sup> to provide this implementation if <code>add</code> had to return <code>Self</code>, i.e. <code>&amp;u32</code> in this case.
<code>Output</code> lets <code>std</code> decouple the implementor from the return type, thus supporting this case.</p>
<blockquote>
<p>トレイトを実装している型は<code>&amp;u32</code>ですが、加算の結果の型は<code>u32</code>です。
<code>add</code>が<code>Self</code>を返さなければならないとき、例えば<code>&amp;u32</code>の場合、この実装を提供することは不可能です。</p>
</blockquote>
<p>On the other hand, <code>Output</code> can't be a generic parameter. The output type of the operation <strong>must</strong> be uniquely determined
once the types of the operands are known. That's why it's an associated type: for a given combination of implementor
and generic parameters, there is only one <code>Output</code> type.</p>
<blockquote>
<p>一方、<code>Output</code>はジェネリックパラメーターにすることはできません。
操作の出力型は、一度、オペランドの型が知られると、一意に決定されなければなりません。
それが、関連型のの理由です。実装者とジェネリックパラメーターの組が与えられると、たった1つの<code>Output</code>型しかありません。</p>
</blockquote>
<h2 id="conclusion結論"><a class="header" href="#conclusion結論">Conclusion（結論）</a></h2>
<p>To recap:</p>
<ul>
<li>Use an <strong>associated type</strong> when the type must be uniquely determined for a given trait implementation.</li>
<li>Use a <strong>generic parameter</strong> when you want to allow multiple implementations of the trait for the same type,
with different input types.</li>
</ul>
<blockquote>
<p>要約します。</p>
<ul>
<li>特定のトレイトの実装のために、型が一意に決定されなければならないとき、<strong>関連型</strong>を使用します。</li>
<li>異なる入力型を持つ同じ型に対して複数のトレイトの実装できるようにしたいとき、<strong>ジェネリックパラメーター</strong>を使用します。</li>
</ul>
</blockquote>
<div class="footnote-definition" id="flexible"><sup class="footnote-definition-label">1</sup>
<p>Flexibility is rarely free: the trait definition is more complex due to <code>Output</code>, and implementors have to reason about
what they want to return. The trade-off is only justified if that flexibility is actually needed. Keep that in mind
when designing your own traits.
柔軟性が、コストなしになることはほとんどありません。
トレイトの定義が、<code>Output</code>によってより複雑になり、実装者は何を返したいのか理由を考えなければなりません。
トレードオフは、柔軟性が実際に必要な場合にのみ正当化されます。
独自のトレイトを設計するとき、これを覚えておいてください。</p>
</div>
<h2 id="exercise-36"><a class="header" href="#exercise-36">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/04_traits/10_assoc_vs_generic"><code>04_traits/10_assoc_vs_generic</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="copying-values-pt-1値をコピーするその1"><a class="header" href="#copying-values-pt-1値をコピーするその1">Copying values, pt. 1（値をコピーする、その1）</a></h1>
<p>In the previous chapter we introduced ownership and borrowing.<br />
We stated, in particular, that:</p>
<ul>
<li>Every value in Rust has a single owner at any given time.</li>
<li>When a function takes ownership of a value ("it consumes it"), the caller can't use that value anymore.</li>
</ul>
<blockquote>
<p>前の章において、所有権と借用を紹介しました。
特に、次のことを述べました。</p>
<ul>
<li>Rustにおけるすべての値は、特定の時点で単独の所有者を持ちます。</li>
<li>関数が値の所有権を得た時（「関数は値を消費します」）、呼び出し元はそれ以上値を使用できません。</li>
</ul>
</blockquote>
<p>These restrictions can be somewhat limiting.<br />
Sometimes we might have to call a function that takes ownership of a value, but we still need to use
that value afterward.</p>
<blockquote>
<p>これらの制約は、何らかの制限があります。
時々、値の所有権を得る関数を呼び出さなくてはなりませんが、その後も、まだその値を使用する必要があるかもしれません。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn consumer(s: String) { /* */ }

fn example() {
     let mut s = String::from("hello");
     consumer(s);
     s.push_str(", world!"); // error: value borrowed here after move
                             // エラー: 移動後に、ここで値が借用されています。
}
<span class="boring">}</span></code></pre></pre>
<p>That's where <code>Clone</code> comes in.</p>
<blockquote>
<p>そこで、<code>Clone</code>が登場します。</p>
</blockquote>
<h2 id="clone"><a class="header" href="#clone"><code>Clone</code></a></h2>
<p><code>Clone</code> is a trait defined in Rust's standard library:</p>
<blockquote>
<p><code>Clone</code>は、Rust標準ライブラリ内に定義されたトレイトです。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Clone {
    fn clone(&amp;self) -&gt; Self;
}
<span class="boring">}</span></code></pre></pre>
<p>Its method, <code>clone</code>, takes a reference to <code>self</code> and returns a new <strong>owned</strong> instance of the same type.</p>
<blockquote>
<p>そのメソッドの<code>clone</code>は、<code>self</code>への参照を受け取り、同じ型の新しい<strong>所有された</strong>インスタンスを返します。</p>
</blockquote>
<h2 id="in-action活動中"><a class="header" href="#in-action活動中">In action（活動中）</a></h2>
<p>Going back to the example above, we can use <code>clone</code> to create a new <code>String</code> instance before calling <code>consumer</code>:</p>
<blockquote>
<p>上記例に戻り、<code>consumer</code>を呼び出す前に、新しい<code>String</code>インスタンスを作成するために<code>clone</code>を使用できます。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn consumer(s: String) { /* */ }

fn example() {
     let mut s = String::from("hello");
     let t = s.clone();
     consumer(t);
     s.push_str(", world!"); // no error
                             // エラーなし
}
<span class="boring">}</span></code></pre></pre>
<p>Instead of giving ownership of <code>s</code> to <code>consumer</code>, we create a new <code>String</code> (by cloning <code>s</code>) and give
that to <code>consumer</code> instead.<br />
<code>s</code> remains valid and usable after the call to <code>consumer</code>.</p>
<blockquote>
<p><code>s</code>の所有権を<code>consumer</code>に与える代わりに、<code>s</code>をクローンして新しい<code>String</code>を作成して、代わりにそれを<code>consumer</code>に与えます。
<code>s</code>は有効のままで、<code>consumer</code>の呼び出し後も使用できます。</p>
</blockquote>
<h2 id="in-memoryメモリ内"><a class="header" href="#in-memoryメモリ内">In memory（メモリ内）</a></h2>
<p>Let's look at what happened in memory in the example above.
When <code>let mut s: String::from("hello");</code> is executed, the memory looks like this:</p>
<blockquote>
<p>上記例において、メモリ内で何が起こっているか確認しましょう。
<code>let mut s: String::from("hello");</code>が実行されたとき、メモリは次のようになります。</p>
</blockquote>
<pre><code class="language-text">                    s
      +---------+--------+----------+
Stack | pointer | length | capacity |
      |  |      |   5    |    5     |
      +--|------+--------+----------+
         |
         |
         v
       +---+---+---+---+---+
Heap:  | H | e | l | l | o |
       +---+---+---+---+---+
</code></pre>
<p>When <code>let t = s.clone()</code> is executed, a whole new region is allocated on the heap to store a copy of the data:</p>
<blockquote>
<p><code>let t = s.clone()</code>が実行されると、データのコピーを保存するために、新しい領域全体がヒープ上に割り当てられます。</p>
</blockquote>
<pre><code class="language-text">                    s                                    t
      +---------+--------+----------+      +---------+--------+----------+
Stack | pointer | length | capacity |      | pointer | length | capacity |
      |  |      |   5    |    5     |      |  |      |   5    |    5     |
      +--|------+--------+----------+      +--|------+--------+----------+
         |                                    |
         |                                    |
         v                                    v
       +---+---+---+---+---+                +---+---+---+---+---+
Heap:  | H | e | l | l | o |                | H | e | l | l | o |
       +---+---+---+---+---+                +---+---+---+---+---+
</code></pre>
<p>If you're coming from a language like Java, you can think of <code>clone</code> as a way to create a deep copy of an object.</p>
<blockquote>
<p>Javaのような言語では、<code>clone</code>をオブジェクトのディープコピーを作成する方法のように考えることができます。</p>
</blockquote>
<h2 id="implementing-clonecloneの実装"><a class="header" href="#implementing-clonecloneの実装">Implementing <code>Clone</code>（Cloneの実装）</a></h2>
<p>To make a type <code>Clone</code>-able, we have to implement the <code>Clone</code> trait for it.<br />
You almost always implement <code>Clone</code> by deriving it:</p>
<blockquote>
<p>型を<code>Clone</code>可能にするために、<code>Cone</code>トレイトを実装しなければなりません。
ほとんど常に、<code>Clone</code>の導出によって<code>Clone</code>を実装します。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone)]
struct MyType {
    // fields
}
<span class="boring">}</span></code></pre></pre>
<p>The compiler implements <code>Clone</code> for <code>MyType</code> as you would expect: it clones each field of <code>MyType</code> individually and
then constructs a new <code>MyType</code> instance using the cloned fields.<br />
Remember that you can use <code>cargo expand</code> (or your IDE) to explore the code generated by <code>derive</code> macros.</p>
<blockquote>
<p>コンパイラーは、期待する通りに<code>MyType</code>に対して<code>Clone</code>を実装します。
それは、<code>MyType</code>のそれぞれのフィールドを個々にクローンして、その後、クローンされたフィールドを使用して、新しい<code>MyType</code>インスタンスを構築します。
<code>derive</code>マクロによって生成されたコードを探求するために、<code>cargo expand</code>（またはIDE）を使用できることを覚えておいてください。</p>
</blockquote>
<h2 id="exercise-37"><a class="header" href="#exercise-37">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/04_traits/11_clone"><code>04_traits/11_clone</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="copying-values-pt-2値をコピーするその2"><a class="header" href="#copying-values-pt-2値をコピーするその2">Copying values, pt. 2（値をコピーする、その2）</a></h1>
<p>Let's consider the same example as before, but with a slight twist: using <code>u32</code> rather than <code>String</code> as a type.</p>
<blockquote>
<p>前と同様に同じ例を考えますが、少し変更して、型に<code>String</code>ではなく<code>u32</code>を使用します。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn consumer(s: u32) { /* */ }

fn example() {
     let s: u32 = 5;
     consumer(s);
     let t = s + 1;
}
<span class="boring">}</span></code></pre></pre>
<p>It'll compile without errors! What's going on here? What's the difference between <code>String</code> and <code>u32</code>
that makes the latter work without <code>.clone()</code>?</p>
<blockquote>
<p>それはエラーなしでコンパイルされます。何が起こっているのでしょうか？
<code>.clone()</code>なしで後者を機能させる<code>String</code>と<code>u32</code>の違いは何でしょうか？</p>
</blockquote>
<h2 id="copy"><a class="header" href="#copy"><code>Copy</code></a></h2>
<p><code>Copy</code> is another trait defined in Rust's standard library:</p>
<blockquote>
<p><code>Copy</code>は、Rust標準ライブラリに定義された別のトレイトです。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Copy: Clone { }
<span class="boring">}</span></code></pre></pre>
<p>It is a marker trait, just like <code>Sized</code>.</p>
<blockquote>
<p>それは、ちょうど<code>Sized</code>のようなマーカートレイトです。</p>
</blockquote>
<p>If a type implements <code>Copy</code>, there's no need to call <code>.clone()</code> to create a new instance of the type:
Rust does it <strong>implicitly</strong> for you.<br />
<code>u32</code> is an example of a type that implements <code>Copy</code>, which is why the example above compiles without errors:
when <code>consumer(s)</code> is called, Rust creates a new <code>u32</code> instance by performing a <strong>bitwise copy</strong> of <code>s</code>,
and then passes that new instance to <code>consumer</code>. It all happens behind the scenes, without you having to do anything.</p>
<blockquote>
<p>型が<code>Copy</code>を実装する場合、その型の新しいインスタンスを作成するために<code>.clone()</code>を呼び出す必要はありません。
Rustは、<strong>暗黙的に</strong>それを行います。
<code>u32</code>は<code>Copy</code>を実装する型の例で、それが、エラーなしで上記例をコンパイルできた理由です。
<code>consumer(s)</code>が呼び出されたとき、Rustは<code>s</code>の<strong>ビット単位のコピー</strong>を行うことで、新しい<code>u32</code>インスタンスを作成して、新しいインスタンスを<code>consumer</code>に渡します。
それが背後で発生した全てで、何もする必要はありません。</p>
</blockquote>
<h2 id="what-can-be-copy何がcopyになれるのか"><a class="header" href="#what-can-be-copy何がcopyになれるのか">What can be <code>Copy</code>?（何がCopyになれるのか？）</a></h2>
<p><code>Copy</code> is not equivalent to "automatic cloning", although it implies it.<br />
Types must meet a few requirements in order to be allowed to implement <code>Copy</code>.</p>
<blockquote>
<p><code>Copy</code>は、「自動クローン」と同等ではありませんが、それを暗に意味します。
<code>Copy</code>の実装を許可するために、型はいくつかの要件を満たさなければなりません。</p>
</blockquote>
<p>First of all, it must implement <code>Clone</code>, since <code>Copy</code> is a subtrait of <code>Clone</code>.
This makes sense: if Rust can create a new instance of a type <em>implicitly</em>, it should
also be able to create a new instance <em>explicitly</em> by calling <code>.clone()</code>.</p>
<blockquote>
<p>まず最初に、<code>Copy</code>は<code>Clone</code>のサブトレイトであるため、型は<code>Clone</code>を実装しなくてはなりません。
これには意味があります。Rustがある型の新しいインスタンスを<strong>暗黙的に</strong>作成できる場合、それは<code>.clone()</code>を呼び出すことで<strong>明示的に</strong>新しいインスタンスを作成できるべきです。</p>
</blockquote>
<p>That's not all, though. A few more conditions must be met:</p>
<ol>
<li>The type doesn't manage any <em>additional</em> resources (e.g. heap memory, file handles, etc.) beyond the <code>std::mem::size_of</code>
bytes that it occupies in memory.</li>
<li>The type is not a mutable reference (<code>&amp;mut T</code>).</li>
</ol>
<blockquote>
<p>ただし、それが全てではありません。いくつかの条件が満たされなければなりません。</p>
<ol>
<li>その型は、メモリ内にそれが専有する<code>std::mem::size_of</code>で得られるバイトを超えて、例えばヒープメモリ、ファイルハンドルなど、任意の_追加_リソースを管理できません。</li>
<li>その型は、可変参照（<code>&amp;mut T</code>）であってはなりません。</li>
</ol>
</blockquote>
<p>If both conditions are met, then Rust can safely create a new instance of the type by performing a <strong>bitwise copy</strong>
of the original instance—this is often referred to as a <code>memcpy</code> operation, after the C standard library function
that performs the bitwise copy.</p>
<blockquote>
<p>両方の条件を満たす場合、Rustはオリジナルのインスタンスの<strong>ビット単位のコピー</strong>を行うことで、その型の新しいインスタンスを安全に作成できます。
これは、ビット単位のコピーをするC標準ライブラリの関数に由来して、<code>memcpy</code>操作と呼ばれることがよくあります。</p>
</blockquote>
<h3 id="case-study-1-string事例解説1-string"><a class="header" href="#case-study-1-string事例解説1-string">Case study 1: <code>String</code>（事例解説1: String）</a></h3>
<p><code>String</code> is a type that doesn't implement <code>Copy</code>.<br />
Why? Because it manages an additional resource: the heap-allocated memory buffer that stores the string's data.</p>
<blockquote>
<p><code>String</code>は<code>Copy</code>を実装していない型です。
なぜでしょうか？それは、<code>String</code>が文字列のデータを保存したヒープに割り当てられたメモリバッファーを追加リソースとして管理するからです。</p>
</blockquote>
<p>Let's imagine that Rust allowed <code>String</code> to implement <code>Copy</code>.<br />
Then, when a new <code>String</code> instance is created by performing a bitwise copy of the original instance, both the original
and the new instance would point to the same memory buffer:</p>
<blockquote>
<p>Rustが<code>Copy</code>を実装した<code>String</code>を許可したことを想像してください。
そして、新しい<code>String</code>インスタンスが、オリジナルのインスタンスのビット単位のコピーを実行して作成されたとき、オリジナルと新しいインスタンスの両方は、同じメモリバッファーを指し示します。</p>
</blockquote>
<pre><code class="language-text">              s                                 copied_s
+---------+--------+----------+      +---------+--------+----------+
| pointer | length | capacity |      | pointer | length | capacity |
|  |      |   5    |    5     |      |  |      |   5    |    5     |
+--|------+--------+----------+      +--|------+--------+----------+
   |                                    |
   |                                    |
   v                                    |
 +---+---+---+---+---+                  |
 | H | e | l | l | o |                  |
 +---+---+---+---+---+                  |
   ^                                    |
   |                                    |
   +------------------------------------+
</code></pre>
<p>This is bad!
Both <code>String</code> instances would try to free the memory buffer when they go out of scope,
leading to a double-free error.
You could also create two distinct <code>&amp;mut String</code> references that point to the same memory buffer,
violating Rust's borrowing rules.</p>
<blockquote>
<p>これは良くないことです！
両方の<code>String</code>インスタンスがスコープ外になったとき、両方の<code>String</code>インスタンスがメモリバッファーを解放することを試み、二重開放エラーを招きます。
また、同じメモリバッファーを指し示す2つの別の<code>&amp;mut String</code>参照を作成でき、Rustの借用ルールに違反します。</p>
</blockquote>
<h3 id="case-study-2-u32事例解説2-u32"><a class="header" href="#case-study-2-u32事例解説2-u32">Case study 2: <code>u32</code>（事例解説2: u32）</a></h3>
<p><code>u32</code> implements <code>Copy</code>. All integer types do, in fact.<br />
An integer is "just" the bytes that represent the number in memory. There's nothing more!
If you copy those bytes, you get another perfectly valid integer instance.
Nothing bad can happen, so Rust allows it.</p>
<blockquote>
<p><code>u32</code>は<code>Copy</code>を実装しています。実際、すべての整数型が実装しています。
整数は、数を表現するメモリ内の「単なる」バイトです。それ以上のものではありません！
それらのバイトをコピーした場合、完全に有効な別の整数インスタンスを得られます。
良くないことは何も発生しないため、Rustはそれを許可します。</p>
</blockquote>
<h3 id="case-study-3-mut-u32事例解説3-mut-u32"><a class="header" href="#case-study-3-mut-u32事例解説3-mut-u32">Case study 3: <code>&amp;mut u32</code>（事例解説3: &amp;mut u32）</a></h3>
<p>When we introduced ownership and mutable borrows, we stated one rule quite clearly: there
can only ever be <em>one</em> mutable borrow of a value at any given time.<br />
That's why <code>&amp;mut u32</code> doesn't implement <code>Copy</code>, even though <code>u32</code> does.</p>
<blockquote>
<p>所有権と可変参照を導入したとき、とても明確な1つのルールを述べました。
特定の時点で、値の可変参照がたった1つのみ存在できます。
それが、<code>u32</code>が実装しているにも関わらず、<code>&amp;mut u32</code>が<code>Copy</code>を実装していない理由です。</p>
</blockquote>
<p>If <code>&amp;mut u32</code> implemented <code>Copy</code>, you could create multiple mutable references to
the same value and modify it in multiple places at the same time.
That'd be a violation of Rust's borrowing rules!
It follows that <code>&amp;mut T</code> never implements <code>Copy</code>, no matter what <code>T</code> is.</p>
<blockquote>
<p><code>&amp;mut u32</code>が<code>Copy</code>を実装した場合、同じ値への複数の可変参照を作成でき、同時に複数の箇所でそれを修正できます。
それは、Rustの借用ルールに違反します！
それが、<code>&amp;mut T</code>が<code>Copy</code>を実装しない理由で、<code>T</code>が何であれそうです。</p>
</blockquote>
<h2 id="implementing-copycopyの実装"><a class="header" href="#implementing-copycopyの実装">Implementing <code>Copy</code>（Copyの実装）</a></h2>
<p>In most cases, you don't need to manually implement <code>Copy</code>.
You can just derive it, like this:</p>
<blockquote>
<p>ほとんどの場合で、手動で<code>Copy</code>を実装する必要はありません。
次のように、単にそれを導出できます。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Copy, Clone)]
struct MyStruct {
    field: u32,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="exercise-38"><a class="header" href="#exercise-38">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/04_traits/12_copy"><code>04_traits/12_copy</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-drop-traitdropトレイト"><a class="header" href="#the-drop-traitdropトレイト">The <code>Drop</code> trait（Dropトレイト）</a></h1>
<p>When we introduced <a href="04_traits/../03_ticket_v1/11_destructor.html">destructors</a>,
we mentioned that the <code>drop</code> function:</p>
<ol>
<li>reclaims the memory occupied by the type (i.e. <code>std::mem::size_of</code> bytes)</li>
<li>cleans up any additional resources that the value might be managing (e.g. the heap buffer of a <code>String</code>)</li>
</ol>
<blockquote>
<p>デストラクターを導入したとき、<code>drop</code>関数について言及しました。</p>
<ol>
<li>例えば<code>std::mem::size_of</code>バイトで、その型によって専有されるメモリを回収します。</li>
<li>例えば<code>String</code>のヒープバッファーなど、その値が管理しているかもしれない任意の追加リソースをクリーンアップします。</li>
</ol>
</blockquote>
<p>Step 2. is where the <code>Drop</code> trait comes in.</p>
<blockquote>
<p>ステップ2は、<code>Drop</code>トレイトが登場する場面です。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Drop {
    fn drop(&amp;mut self);
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>Drop</code> trait is a mechanism for you to define <em>additional</em> cleanup logic for your types,
beyond what the compiler does for you automatically.<br />
Whatever you put in the <code>drop</code> method will be executed when the value goes out of scope.</p>
<blockquote>
<p><code>Drop</code>トレイトは、コンパイラーが自動的に行うこと以上に、型の_追加の_クリーンアップロジックを定義するためのメカニズムです。
<code>drop</code>メソッド内に入れたものは何でも、値がスコープ外になったときに実行されます。</p>
</blockquote>
<h2 id="drop-and-copydropとcopy"><a class="header" href="#drop-and-copydropとcopy"><code>Drop</code> and <code>Copy</code>（DropとCopy）</a></h2>
<p>When talking about the <code>Copy</code> trait, we said that a type can't implement <code>Copy</code> if it
manages additional resources beyond the <code>std::mem::size_of</code> bytes that it occupies in memory.</p>
<blockquote>
<p><code>Copy</code>トレイトについて話しているとき、型がメモリ内に専有する<code>std::mem::size_of</code>バイトを超える追加リソースを管理している場合、その型は<code>Copy</code>を実装できないと言いました。</p>
</blockquote>
<p>You might wonder: how does the compiler know if a type manages additional resources?
That's right: <code>Drop</code> trait implementations!<br />
If your type has an explicit <code>Drop</code> implementation, the compiler will assume
that your type has additional resources attached to it and won't allow you to implement <code>Copy</code>.</p>
<blockquote>
<p>困惑しているかもしれません。コンパイラーは、型が追加リソースを管理していることをどのように知るのでしょうか？
そのとおりです。<code>Drop</code>トレイトの実装です！
型が明示的に<code>Drop</code>実装を持っている場合、コンパイラーは型が型に付属する追加リソースを持っていると仮定して、<code>Copy</code>を実装することを許可しません。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// This is a unit struct, i.e. a struct with no fields.
// これはユニット構造体で、つまりフィールドのない構造体です。
#[derive(Clone, Copy)]
struct MyType;

impl Drop for MyType {
    fn drop(&amp;mut self) {
       // We don't need to do anything here,
       // it's enough to have an "empty" Drop implementation
       // ここで何もする必要はありません。
       // 「空の」Drop実装があれば十分です。
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The compiler will complain with this error message:</p>
<blockquote>
<p>コンパイラは、次のメッセージで文句を言うでしょう。</p>
</blockquote>
<pre><code class="language-text">error[E0184]: the trait `Copy` cannot be implemented for this type; the type has a destructor
 --&gt; src/lib.rs:2:17
  |
2 | #[derive(Clone, Copy)]
  |                 ^^^^ `Copy` not allowed on types with destructors
</code></pre>
<h2 id="exercise-39"><a class="header" href="#exercise-39">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/04_traits/13_drop"><code>04_traits/13_drop</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wrapping-up仕上げ-1"><a class="header" href="#wrapping-up仕上げ-1">Wrapping up（仕上げ）</a></h1>
<p>We've covered quite a few different traits in this chapter—and we've only scratched the surface!
It may feel like you have a lot to remember, but don't worry: you'll bump into these traits
so often when writing Rust code that they'll soon become second nature.</p>
<blockquote>
<p>この章において、かなり多くのトレイトを説明しました。そしてまだ表面を引っ掻いただけです！
覚えておくべき多くのことがあるように感じるかもしれませんが、心配しないでください。
Rustでコードを記述するとき、頻繁にこれらのトレイトに遭遇するため、すぐにそれが2つ目の習慣になるでしょう。</p>
</blockquote>
<h2 id="closing-thoughts最後に言っておきたいこと"><a class="header" href="#closing-thoughts最後に言っておきたいこと">Closing thoughts（最後に言っておきたいこと）</a></h2>
<p>Traits are powerful, but don't overuse them.<br />
A few guidelines to keep in mind:</p>
<ul>
<li>Don't make a function generic if it is always invoked with a single type. It introduces indirection in your
codebase, making it harder to understand and maintain.</li>
<li>Don't create a trait if you only have one implementation. It's a sign that the trait is not needed.</li>
<li>Implement standard traits for your types (<code>Debug</code>, <code>PartialEq</code>, etc.) whenever it makes sense.
It will make your types more idiomatic and easier to work with, unlocking a lot of functionality provided
by the standard library and ecosystem crates.</li>
<li>Implement traits from third-party crates if you need the functionality they unlock within their ecosystem.</li>
<li>Beware of making code generic solely to use mocks in your tests. The maintainability cost of this approach
can be high, and it's often better to use a different testing strategy. Check out the
<a href="https://github.com/mainmatter/rust-advanced-testing-workshop">testing masterclass</a>
for details on high-fidelity testing.</li>
</ul>
<blockquote>
<p>トレイトは強力ですが、それらを乱用しないでください。
次のいくつかのガイドラインを心に留めておいてください。</p>
<ul>
<li>常に単一の型で関数が呼び出される場合はジェネリックにしないでください。
それはコードベースに間接性を導入して、理解することと維持することを難しくします。</li>
<li>単一の実装しかない場合、トレイトを作成しないでください。それはトレイトが必要とされない合図です。</li>
<li><code>Debug</code>、<code>PartialEq</code>など標準トレイトを型に実装するときはいつでも、意味があるようにしてください。
それは、型をより慣用的に、一緒に機能することを容易にして、標準ライブラリやエコシステムクレートによって提供される多くの機能を解放します。</li>
<li>必要に応じてサードパーティクレイトのトレイトを実装して、それらのエコシステムが持つ機能を解放してください。</li>
<li>テストでモックを使用するためだけにコードをジェネリックにすることに注意してください。
このアプローチの保守コストは高くなり、時々異なるテスト戦略を使用する方が良いことがあります。
高い忠実度をもつテストについての詳細は、テストマスタークラスを確認してください。</li>
</ul>
</blockquote>
<h2 id="testing-your-knowledge知識のテスト"><a class="header" href="#testing-your-knowledge知識のテスト">Testing your knowledge（知識のテスト）</a></h2>
<p>Before moving on, let's go through one last exercise to consolidate what we've learned.
You'll have minimal guidance this time—just the exercise description and the tests to guide you.</p>
<blockquote>
<p>次に進む前に、学んだことを固めるために最後の演習を1つ行いましょう。
今回は、最小限の案内があります。それは、単なる演習の説明と、テストの案内です。</p>
</blockquote>
<h2 id="exercise-40"><a class="header" href="#exercise-40">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/04_traits/14_outro"><code>04_traits/14_outro</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="modelling-a-ticket-pt-2チケットのモデリングその2"><a class="header" href="#modelling-a-ticket-pt-2チケットのモデリングその2">Modelling A Ticket, pt. 2（チケットのモデリング、その2）</a></h1>
<p>The <code>Ticket</code> struct we worked on in the previous chapters is a good start,
but it still screams "I'm a beginner Rustacean!".</p>
<blockquote>
<p>前の章で作業した<code>Ticket</code>構造体は、良いスタートですが、それでも「私は初心者のRustaceanです！」と叫んでいます。</p>
</blockquote>
<p>We'll use this chapter to refine our Rust domain modelling skills.
We'll need to introduce a few more concepts along the way:</p>
<ul>
<li><code>enum</code>s, one of Rust's most powerful features for data modeling</li>
<li>The <code>Option</code> type, to model nullable values</li>
<li>The <code>Result</code> type, to model recoverable errors</li>
<li>The <code>Debug</code> and <code>Display</code> traits, for printing</li>
<li>The <code>Error</code> trait, to mark error types</li>
<li>The <code>TryFrom</code> and <code>TryInto</code> traits, for fallible conversions</li>
<li>Rust's package system, explaining what's a library, what's a binary, how to use third-party crates</li>
</ul>
<blockquote>
<p>Rustドメインモデリング技術を洗練するためにこの章を使用します。
途中でいくつかの概念を紹介する必要があります。</p>
<ul>
<li>Rustのデータモデリングの最も強力な機能の1つである<code>enum</code></li>
<li>null可能な値をモデル化する<code>Option</code>型</li>
<li>回復可能なエラーをモデル化する<code>Result</code>型</li>
<li>印字するための<code>Debug</code>と<code>Display</code>トレイト</li>
<li>エラー型を作成する<code>Error</code>トレイト</li>
<li>失敗する可能性のある変換用のための<code>TryFrom</code>と<code>TryInto</code>トレイト</li>
<li>Rustのパッケージシステム、ライブラリとは何か、バイナリとは何か、サードパーティのクレートを使用方法の説明</li>
</ul>
</blockquote>
<h2 id="exercise-41"><a class="header" href="#exercise-41">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/05_ticket_v2/00_intro"><code>05_ticket_v2/00_intro</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enumerations列挙型"><a class="header" href="#enumerations列挙型">Enumerations（列挙型）</a></h1>
<p>Based on the validation logic you wrote <a href="05_ticket_v2/../03_ticket_v1/02_validation.html">in a previous chapter</a>,
there are only a few valid statuses for a ticket: <code>To-Do</code>, <code>InProgress</code> and <code>Done</code>.<br />
This is not obvious if we look at the <code>status</code> field in the <code>Ticket</code> struct or at the type of the <code>status</code>
parameter in the <code>new</code> method:</p>
<blockquote>
<p>前の章で記述した検証ロジックに基づいて、チケットの有効な状態は、<code>To-Do</code>、<code>InProgress</code>そして<code>Done</code>のみです。
<code>Ticket</code>構造体の<code>status</code>フィールドや<code>new</code>メソッドの<code>status</code>の型を見ても、これは明確ではありません。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, PartialEq)]
pub struct Ticket {
    title: String,
    description: String,
    status: String,
}

impl Ticket {
    pub fn new(title: String, description: String, status: String) -&gt; Self {
        // [...]
    }
}
<span class="boring">}</span></code></pre></pre>
<p>In both cases we're using <code>String</code> to represent the <code>status</code> field.
<code>String</code> is a very general type—it doesn't immediately convey the information that the <code>status</code> field
has a limited set of possible values. Even worse, the caller of <code>Ticket::new</code> will only find out <strong>at runtime</strong>
if the status they provided is valid or not.</p>
<blockquote>
<p>両方のケースで、<code>status</code>フィールドを表現するために<code>String</code>を使用しています。
<code>String</code>はとても一般的な型で、<code>status</code>フィールドが可能な値の制限された集合を持っているという情報をすぐに伝えることができません。
さらに悪いことに、<code>Ticket::new</code>の呼び出し元は、提供した状態が有効かどうかを<strong>ランタイム</strong>でのみ知ります。</p>
</blockquote>
<p>We can do better than that with <strong>enumerations</strong>.</p>
<blockquote>
<p><strong>列挙型</strong>を使用して、それよりうまく行えます。</p>
</blockquote>
<h2 id="enum"><a class="header" href="#enum"><code>enum</code></a></h2>
<p>An enumeration is a type that can have a fixed set of values, called <strong>variants</strong>.<br />
In Rust, you define an enumeration using the <code>enum</code> keyword:</p>
<blockquote>
<p>列挙型は、<strong>バリアント</strong>と呼ばれる固定された値の集合を持てる型です。
Rustにおいて、<code>enum</code>キーワードを使用して列挙型を定義します。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Status {
    ToDo,
    InProgress,
    Done,
}
<span class="boring">}</span></code></pre></pre>
<p><code>enum</code>, just like <code>struct</code>, defines <strong>a new Rust type</strong>.</p>
<blockquote>
<p>ちょうど<code>struct</code>のように、<code>enum</code>は<strong>新しいRustの型</strong>を定義します。</p>
</blockquote>
<h2 id="exercise-42"><a class="header" href="#exercise-42">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/05_ticket_v2/01_enum"><code>05_ticket_v2/01_enum</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="match"><a class="header" href="#match"><code>match</code></a></h1>
<p>You may be wondering—what can you actually <strong>do</strong> with an enum?<br />
The most common operation is to <strong>match</strong> on it.</p>
<blockquote>
<p>戸惑っているかもしれません。列挙型で実際に<strong>何ができる</strong>のでしょうか？</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Status {
    ToDo,
    InProgress,
    Done
}

impl Status {
    fn is_done(&amp;self) -&gt; bool {
        match self {
            Status::Done =&gt; true,
            // The `|` operator lets you match multiple patterns.
            // It reads as "either `Status::ToDo` or `Status::InProgress`".
            // `|`演算子は複数のパターンにマッチします。
            // それは、「`Status::ToDo`または`Status::InProgress`のどちらか」と読みます。
            Status::InProgress | Status::ToDo =&gt; false
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>A <code>match</code> statement that lets you compare a Rust value against a series of <strong>patterns</strong>.<br />
You can think of it as a type-level <code>if</code>. If <code>status</code> is a <code>Done</code> variant, execute the first block;
if it's a <code>InProgress</code> or <code>ToDo</code> variant, execute the second block.</p>
<blockquote>
<p><code>match</code>文は、一連の<strong>パターン</strong>に対してRustの値を比較させます。
それを型レベルの<code>if</code>と考えることができます。<code>status</code>が<code>Done</code>バリアントであれば、最初のブロックを実行します。
それが<code>InProgress</code>または<code>ToDo</code>バリアントの場合、2番目のブロックを実行します。</p>
</blockquote>
<h2 id="exhaustiveness網羅的であること"><a class="header" href="#exhaustiveness網羅的であること">Exhaustiveness（網羅的であること）</a></h2>
<p>There's one key detail here: <code>match</code> is <strong>exhaustive</strong>. You must handle all enum variants.<br />
If you forget to handle a variant, Rust will stop you <strong>at compile-time</strong> with an error.</p>
<blockquote>
<p>ここに1つの重要な詳細があります。<code>match</code>は<strong>網羅的</strong>です。すべての列挙型のバリアントを処理しなければなりません。
バリアントを処理することを忘れた場合、Rustは<strong>コンパイル時に</strong>エラーで停止します。</p>
</blockquote>
<p>E.g. if we forget to handle the <code>ToDo</code> variant:</p>
<blockquote>
<p>例えば、<code>ToDo</code>バリアントを処理することを忘れた場合・・・</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match self {
    Status::Done =&gt; true,
    Status::InProgress =&gt; false,
}
<span class="boring">}</span></code></pre></pre>
<p>the compiler will complain:</p>
<blockquote>
<p>コンパイラーは文句を言うでしょう。</p>
</blockquote>
<pre><code class="language-text">error[E0004]: non-exhaustive patterns: `ToDo` not covered
 --&gt; src/main.rs:5:9
  |
5 |     match status {
  |     ^^^^^^^^^^^^ pattern `ToDo` not covered
</code></pre>
<p>This is a big deal!<br />
Codebases evolve over time—you might add a new status down the line, e.g. <code>Blocked</code>. The Rust compiler
will emit an error for every single <code>match</code> statement that's missing logic for the new variant.
That's why Rust developers often sing the praises of "compiler-driven refactoring"—the compiler tells you
what to do next, you just have to fix what it reports.</p>
<blockquote>
<p>これは大問題です！
コードベースは時間とともに進化します。例えば<code>Blocked</code>など、将来、新しい状態を追加するかもしれません。
Rustコンパイラーは、新しいバリアントに対してロジックが不足していることを、それぞれの単一の<code>match</code>文に対してエラーを出力します。
それが、Rustの開発者が時々「コンパイラー駆動のリファクタリング」を称賛する理由です。
コンパイラーは次に何をするか伝え、単に報告されたものを修正しなければならないだけです。</p>
</blockquote>
<h2 id="catch-allすべてをキャッチ"><a class="header" href="#catch-allすべてをキャッチ">Catch-all（すべてをキャッチ）</a></h2>
<p>If you don't care about one or more variants, you can use the <code>_</code> pattern as a catch-all:</p>
<blockquote>
<p>1つ以上のバリアントに気にしない場合、すべてをキャッチするために<code>_</code>パターンを使用できます。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match status {
    Status::Done =&gt; true,
    _ =&gt; false
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>_</code> pattern matches anything that wasn't matched by the previous patterns.</p>
<blockquote>
<p><code>_</code>パターンは、前のパターンによってマッチしなかったものにマッチします。</p>
</blockquote>
<h2 id="exercise-43"><a class="header" href="#exercise-43">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/05_ticket_v2/02_match"><code>05_ticket_v2/02_match</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="variants-can-hold-dataバリアントはデータを保持できる"><a class="header" href="#variants-can-hold-dataバリアントはデータを保持できる">Variants can hold data（バリアントはデータを保持できる）</a></h1>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Status {
    ToDo,
    InProgress,
    Done,
}
<span class="boring">}</span></code></pre></pre>
<p>Our <code>Status</code> enum is what's usually called a <strong>C-style enum</strong>.<br />
Each variant is a simple label, a bit like a named constant. You can find this kind of enum in many programming
languages, like C, C++, Java, C#, Python, etc.</p>
<blockquote>
<p><code>Status</code>列挙型は、通常<strong>Cスタイルの列挙型</strong>と呼ばれます。
それぞれのバリアントは1つのラベルで、すこし名前付きの定数のようです。
C、C++、Java、C#、Pythonなどのような多くのプログラミング言語で、この種類の列挙型を見つけれます。</p>
</blockquote>
<p>Rust enums can go further though. We can <strong>attach data to each variant</strong>.</p>
<blockquote>
<p>しかし、Rustの列挙型は進んでいます。<strong>それぞれのバリアントにデータを付属できます</strong>。</p>
</blockquote>
<h2 id="variantsバリアント"><a class="header" href="#variantsバリアント">Variants（バリアント）</a></h2>
<p>Let's say that we want to store the name of the person who's currently working on a ticket.<br />
We would only have this information if the ticket is in progress. It wouldn't be there for a to-do ticket or
a done ticket.
We can model this by attaching a <code>String</code> field to the <code>InProgress</code> variant:</p>
<blockquote>
<p>現在チケットを処理している人の名前を保存したいとします。
この情報は、チケットが進行中の場合のみ持てるとします。
これは、未完了のチケットまたは完了したチケットにはありません。
<code>InProgress</code>バリアントに<code>String</code>フィールドを付けることで、これをモデル化できます。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Status {
    ToDo,
    InProgress {
        assigned_to: String,
    },
    Done,
}
<span class="boring">}</span></code></pre></pre>
<p><code>InProgress</code> is now a <strong>struct-like variant</strong>.<br />
The syntax mirrors, in fact, the one we used to define a struct—it's just "inlined" inside the enum, as a variant.</p>
<blockquote>
<p><code>InProgress</code>は、現在、<strong>構造体のようなバリアント</strong>です。
実際、構文は、構造体を定義するときに使用したものを反映しています。ちょうどそれはバリアントとして列挙型の内部を「インライン化」しています。</p>
</blockquote>
<h2 id="accessing-variant-dataバリアントのデータにアクセスする"><a class="header" href="#accessing-variant-dataバリアントのデータにアクセスする">Accessing variant data（バリアントのデータにアクセスする）</a></h2>
<p>If we try to access <code>assigned_to</code> on a <code>Status</code> instance,</p>
<blockquote>
<p><code>Status</code>インスタンスの<code>assigned_to</code>にアクセスすることを試みた場合、</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let status: Status = /* */;

// This won't compile
println!("Assigned to: {}", status.assigned_to);
<span class="boring">}</span></code></pre></pre>
<p>the compiler will stop us:</p>
<blockquote>
<p>コンパイラは止めるでしょう。</p>
</blockquote>
<pre><code class="language-text">error[E0609]: no field `assigned_to` on type `Status`
 --&gt; src/main.rs:5:40
  |
5 |     println!("Assigned to: {}", status.assigned_to);
  |                                        ^^^^^^^^^^^ unknown field
</code></pre>
<p><code>assigned_to</code> is <strong>variant-specific</strong>, it's not available on all <code>Status</code> instances.<br />
To access <code>assigned_to</code>, we need to use <strong>pattern matching</strong>:</p>
<blockquote>
<p><code>assigned_to</code>は<strong>バリアント固有</strong>です。それはすべての<code>Status</code>インスタンスで利用できません。
<code>assigned_to</code>にアクセスするために、<strong>パターンマッチング</strong>を使用する必要があります。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match status {
    Status::InProgress { assigned_to } =&gt; {
        println!("Assigned to: {}", assigned_to);
    },
    Status::ToDo | Status::Done =&gt; {
        println!("Done");
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="bindingsバインディング"><a class="header" href="#bindingsバインディング">Bindings（バインディング）</a></h2>
<p>In the match pattern <code>Status::InProgress { assigned_to }</code>, <code>assigned_to</code> is a <strong>binding</strong>.<br />
We're <strong>destructuring</strong> the <code>Status::InProgress</code> variant and binding the <code>assigned_to</code> field to
a new variable, also named <code>assigned_to</code>.<br />
If we wanted, we could bind the field to a different variable name:</p>
<blockquote>
<p><code>Status::InProgress { assigned_to }</code>のマッチングパターンにおいて、<code>assigned_to</code>は<strong>バインディング</strong>です。
<code>Status::InProgress</code>バリアントを<strong>分割して</strong>、新しい<code>assigned_to</code>変数に<code>assigned_to</code>フィールドをバインディングしています。
必要であれば、フィールドを異なる変数名に束縛できます。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match status {
    Status::InProgress { assigned_to: person } =&gt; {
        println!("Assigned to: {}", person);
    },
    Status::ToDo | Status::Done =&gt; {
        println!("Done");
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="exercise-44"><a class="header" href="#exercise-44">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/05_ticket_v2/03_variants_with_data"><code>05_ticket_v2/03_variants_with_data</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="concise-branching簡潔なブランチ分かれ"><a class="header" href="#concise-branching簡潔なブランチ分かれ">Concise branching（簡潔なブランチ分かれ）</a></h1>
<p>Your solution to the previous exercise probably looks like this:</p>
<blockquote>
<p>前の演習の解答は、おそらく次のようになっているでしょう。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Ticket {
    pub fn assigned_to(&amp;self) -&gt; &amp;str {
        match &amp;self.status {
            Status::InProgress { assigned_to } =&gt; assigned_to,
            Status::Done | Status::ToDo =&gt; {
                panic!("Only `In-Progress` tickets can be assigned to someone")
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>You only care about the <code>Status::InProgress</code> variant.
Do you really need to match on all the other variants?</p>
<blockquote>
<p><code>Status::InProgress</code>バリアントについて気にかけるだけです。
本当にすべての他のバリアントにマッチする必要があるのでしょうか？</p>
</blockquote>
<p>New constructs to the rescue!</p>
<blockquote>
<p>新しい構築物が救援します。</p>
</blockquote>
<h2 id="if-let"><a class="header" href="#if-let"><code>if let</code></a></h2>
<p>The <code>if let</code> construct allows you to match on a single variant of an enum,
without having to handle all the other variants.</p>
<blockquote>
<p><code>if let</code>構築は、他のバリアントすべてを処理することなく、列挙型の1つのバリアントにマッチさせます。</p>
</blockquote>
<p>Here's how you can use <code>if let</code> to simplify the <code>assigned_to</code> method:</p>
<blockquote>
<p><code>assigned_to</code>メソッドを単純化するために、<code>if let</code>を使用する方法をここに示します。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Ticket {
    pub fn assigned_to(&amp;self) -&gt; &amp;str {
        if let Status::InProgress { assigned_to } = &amp;self.status {
            assigned_to
        } else {
            panic!("Only `In-Progress` tickets can be assigned to someone");
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="letelse"><a class="header" href="#letelse"><code>let/else</code></a></h2>
<p>If the <code>else</code> branch is meant to return early (a panic counts as returning early!),
you can use the <code>let/else</code> construct:</p>
<blockquote>
<p><code>else</code>ブランチが早期リターン（パニックを早期リターンとして考慮します）を意図する場合、<code>let/else</code>構築を使用できます。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Ticket {
    pub fn assigned_to(&amp;self) -&gt; &amp;str {
        let Status::InProgress { assigned_to } = &amp;self.status else {
            panic!("Only `In-Progress` tickets can be assigned to someone");
        };
        assigned_to
    }
}
<span class="boring">}</span></code></pre></pre>
<p>It allows you to assign the destructured variable without incurring
any "right drift", i.e. the variable is assigned at the same indentation level
as the code that precedes it.</p>
<blockquote>
<p>それは、「右ドリフト」を招くことなく、分割された変数を割り当てさせます。
例えば、変数はそれに先立つコードと同じインデントレベルで割り当てられます。</p>
</blockquote>
<h2 id="styleスタイル"><a class="header" href="#styleスタイル">Style（スタイル）</a></h2>
<p>Both <code>if let</code> and <code>let/else</code> are idiomatic Rust constructs.<br />
Use them as you see fit to improve the readability of your code,
but don't overdo it: <code>match</code> is always there when you need it.</p>
<blockquote>
<p><code>if let</code>と<code>let/else</code>の両方は、Rustの慣用的な構築物です。
それらの使用は、コードの可読性を改善するために適切のように見えますが、それを過度に使用しないでください。
<code>match</code>は常に必要なときに使用できます。</p>
</blockquote>
<h2 id="exercise-45"><a class="header" href="#exercise-45">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/05_ticket_v2/04_if_let"><code>05_ticket_v2/04_if_let</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nullabilitynull可能性"><a class="header" href="#nullabilitynull可能性">Nullability（Null可能性）</a></h1>
<p>Our implementation of the <code>assigned</code> method is fairly blunt: panicking for to-do and done tickets is far from ideal.<br />
We can do better using <strong>Rust's <code>Option</code> type</strong>.</p>
<blockquote>
<p><code>assigned</code>メソッドの実装は、かなり切れ味が悪いです。<code>to-do</code>と<code>done</code>チケットのためにパニックすることは、理想からほど遠いです。
<strong>Rustの<code>Option</code>型</strong>を使用して、うまく行えます。</p>
</blockquote>
<h2 id="option"><a class="header" href="#option"><code>Option</code></a></h2>
<p><code>Option</code> is a Rust type that represents <strong>nullable values</strong>.<br />
It is an enum, defined in Rust's standard library:</p>
<blockquote>
<p><code>Option</code>は<strong>null可能な値</strong>を表現するRustの型です。
それは、Rust標準ライブラリに定義された列挙型です。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
    Some(T),
    None,
}
<span class="boring">}</span></code></pre></pre>
<p><code>Option</code> encodes the idea that a value might be present (<code>Some(T)</code>) or absent (<code>None</code>).<br />
It also forces you to <strong>explicitly handle both cases</strong>. You'll get a compiler error if you are working with
a nullable value and you forget to handle the <code>None</code> case.<br />
This is a significant improvement over "implicit" nullability in other languages, where you can forget to check
for <code>null</code> and thus trigger a runtime error.</p>
<blockquote>
<p><code>Option</code>は、値が存在する（<code>Some(T)</code>）、または存在しない（<code>None</code>）の考えを符号化します。
また、それは、<strong>明示的に両方のケースを処理</strong>することを強制します。
null可能な値で作業して、<code>None</code>ケースを処理することを忘れた場合、コンパイルエラーが発生します。
これは、他の言語の「暗黙的なnull可能性」を大幅に改善して、他の言語では、<code>null</code>チェックを忘れた箇所で、ランタイムエラーを発します。</p>
</blockquote>
<h2 id="options-definitionoptionの定義"><a class="header" href="#options-definitionoptionの定義"><code>Option</code>'s definition（Optionの定義）</a></h2>
<p><code>Option</code>'s definition uses a Rust construct that you haven't seen before: <strong>tuple-like variants</strong>.</p>
<blockquote>
<p><code>Option</code>の定義は、<strong>タプルのようなバリアント</strong>という、前に確認していないRustの構成要素を使用します。</p>
</blockquote>
<h3 id="tuple-like-variantsタプルのようなバリアント"><a class="header" href="#tuple-like-variantsタプルのようなバリアント">Tuple-like variants（タプルのようなバリアント）</a></h3>
<p><code>Option</code> has two variants: <code>Some(T)</code> and <code>None</code>.<br />
<code>Some</code> is a <strong>tuple-like variant</strong>: it's a variant that holds <strong>unnamed fields</strong>.</p>
<blockquote>
<p><code>Option</code>は、<code>Some(T)</code>と<code>None</code>の2つのバリアントがあります。
<code>Some</code>は<strong>タプルのようなバリアント</strong>で、それは<strong>無名のフィールド</strong>を保持するバリアントです。</p>
</blockquote>
<p>Tuple-like variants are often used when there is a single field to store, especially when we're looking at a
"wrapper" type like <code>Option</code>.</p>
<blockquote>
<p>タプルのようなバリアントは、保存するために1つのフィールドがあるとき、特に<code>Option</code>のような「ラッパー」型を確認しているときに、よく使用されます。</p>
</blockquote>
<h3 id="tuple-like-structsタプルのような構造体"><a class="header" href="#tuple-like-structsタプルのような構造体">Tuple-like structs（タプルのような構造体）</a></h3>
<p>They're not specific to enums—you can define tuple-like structs too:</p>
<blockquote>
<p>それらは列挙型に特有ではありません。タプルのような構造体も定義できます。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Point(i32, i32);
<span class="boring">}</span></code></pre></pre>
<p>You can then access the two fields of a <code>Point</code> instance using their positional index:</p>
<blockquote>
<p>そして、それらの位置インデックスを使用して、<code>Point</code>インスタンスの2つのフィールドにアクセスできます。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let point = Point(3, 4);
let x = point.0;
let y = point.1;
<span class="boring">}</span></code></pre></pre>
<h3 id="tuplesタプル"><a class="header" href="#tuplesタプル">Tuples（タプル）</a></h3>
<p>It's weird to say that something is tuple-like when we haven't seen tuples yet!<br />
Tuples are another example of a primitive Rust type.
They group together a fixed number of values with (potentially different) types:</p>
<blockquote>
<p>まだタプルを確認していないときに、何かがタプルのようだと言うことは奇妙です！
タプルは、プリミティブなRustの型の別の例です。
それらは、潜在的に異なる型の値の固定数をグループ化します。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Two values, same type
// 2つの値は同じ型です。
let first: (i32, i32) = (3, 4);
// Three values, different types
// 3つの値は異なる型です。
let second: (i32, u32, u8) = (-42, 3, 8);
<span class="boring">}</span></code></pre></pre>
<p>The syntax is simple: you list the types of the values between parentheses, separated by commas.
You can access the fields of a tuple using the dot notation and the field index:</p>
<blockquote>
<p>構文は単純です。カッコの間にカンマで区切られた値の型をリストします。
ドット記法とフィールドのインデックスを使用して、タプルのフィールドにアクセスできます。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>assert_eq!(second.0, -42);
assert_eq!(second.1, 3);
assert_eq!(second.2, 8);
<span class="boring">}</span></code></pre></pre>
<p>Tuples are a convenient way of grouping values together when you can't be bothered to define a dedicated struct type.</p>
<blockquote>
<p>専用の構造体型を定義することが面倒なとき、タプルは値をグループ化する便利な方法です。</p>
</blockquote>
<h2 id="exercise-46"><a class="header" href="#exercise-46">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/05_ticket_v2/05_nullability"><code>05_ticket_v2/05_nullability</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fallibility誤りを逃れられない性質"><a class="header" href="#fallibility誤りを逃れられない性質">Fallibility（誤りを逃れられない性質）</a></h1>
<p>Let's revisit the <code>Ticket::new</code> function from the previous exercise:</p>
<blockquote>
<p>前の演習の<code>Ticket::new</code>関数を再度確認しましょう。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Ticket {
    pub fn new(title: String, description: String, status: Status) -&gt; Ticket {
        if title.is_empty() {
            panic!("Title cannot be empty");
        }
        if title.len() &gt; 50 {
            panic!("Title cannot be longer than 50 bytes");
        }
        if description.is_empty() {
            panic!("Description cannot be empty");
        }
        if description.len() &gt; 500 {
            panic!("Description cannot be longer than 500 bytes");
        }

        Ticket {
            title,
            description,
            status,
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>As soon as one of the checks fails, the function panics.
This is not ideal, as it doesn't give the caller a chance to <strong>handle the error</strong>.</p>
<blockquote>
<p>1つの検証が失敗したらすぐに、関数はパニックします。
<strong>エラーを処理する</strong>機会を呼び出し側に与えないため、これは理想的ではありません。</p>
</blockquote>
<p>It's time to introduce the <code>Result</code> type, Rust's primary mechanism for error handling.</p>
<blockquote>
<p>エラーを処理するためにRustの主要なメカニズムである、<code>Result</code>型を導入するときです。</p>
</blockquote>
<h2 id="the-result-typeresult型"><a class="header" href="#the-result-typeresult型">The <code>Result</code> type（Result型）</a></h2>
<p>The <code>Result</code> type is an enum defined in the standard library:</p>
<blockquote>
<p><code>Result</code>型は、標準ライブラリに定義された列挙型です。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
<span class="boring">}</span></code></pre></pre>
<p>It has two variants:</p>
<ul>
<li><code>Ok(T)</code>: represents a successful operation. It holds <code>T</code>, the output of the operation.</li>
<li><code>Err(E)</code>: represents a failed operation. It holds <code>E</code>, the error that occurred.</li>
</ul>
<blockquote>
<p>それは2つのバリアントがあります。</p>
<ul>
<li><code>Ok(T)</code>: 成功した操作を表現します。それは操作の出力である<code>T</code>を保持します。</li>
<li><code>Err(E)</code>: 失敗した操作を表現します。それは発生したエラーである<code>E</code>を保持します。</li>
</ul>
</blockquote>
<p>Both <code>Ok</code> and <code>Err</code> are generic, allowing you to specify your own types for the success and error cases.</p>
<blockquote>
<p><code>Ok</code>と<code>Err</code>の両方はジェネリックで、成功と失敗の場合の独自の型を指定できるようにします。</p>
</blockquote>
<h2 id="no-exceptions例外はない"><a class="header" href="#no-exceptions例外はない">No exceptions（例外はない）</a></h2>
<p>Recoverable errors in Rust are <strong>represented as values</strong>.<br />
They're just an instance of a type, being passed around and manipulated like any other value.
This is a significant difference from other languages, such as Python or C#, where <strong>exceptions</strong> are used to signal errors.</p>
<blockquote>
<p>Rustにおいて、復旧可能なエラーは<strong>値として表現</strong>されます。
単にそれらは型のインスタンスで、他の任意の値のように、周辺に渡され、操作されます。
これは、<strong>例外</strong>がエラーの合図として使用されるPythonまたはC#のような他の言語と大きく異なります。</p>
</blockquote>
<p>Exceptions create a separate control flow path that can be hard to reason about.<br />
You don't know, just by looking at a function's signature, if it can throw an exception or not.
You don't know, just by looking at a function's signature, <strong>which</strong> exception types it can throw.<br />
You must either read the function's documentation or look at its implementation to find out.</p>
<blockquote>
<p>例外は、理由を知ることが難しくなる分離した制御フローのパスを作成します。
関数が例外を投げるか投げないかは、関数のシグネチャーを見てもわかりまっせん。
関数がどの例外を投げるかは、関数のシグネチャーを見てもわかりません。
理由を見つけるために、関数のドキュメントまたはその実装のどちらかを読まなくてはなりません。</p>
</blockquote>
<p>Exception handling logic has very poor locality: the code that throws the exception is far removed from the code
that catches it, and there's no direct link between the two.</p>
<blockquote>
<p>例外処理ロジックは、とても貧弱な局所性があります。例外を投げるコードは、それを受け取るコードから遠く離れており、それは2つの間を直接結びつけられません。</p>
</blockquote>
<h2 id="fallibility-is-encoded-in-the-type-system誤りを逃れられない性質は型システム内に符号化される"><a class="header" href="#fallibility-is-encoded-in-the-type-system誤りを逃れられない性質は型システム内に符号化される">Fallibility is encoded in the type system（誤りを逃れられない性質は型システム内に符号化される）</a></h2>
<p>Rust, with <code>Result</code>, forces you to <strong>encode fallibility in the function's signature</strong>.<br />
If a function can fail (and you want the caller to have a shot at handling the error), it must return a <code>Result</code>.</p>
<blockquote>
<p><code>Result</code>を持つRustは、<strong>関数シグネチャーに誤りを逃れられない性質を符号化</strong>することを強制します。
関数が失敗する可能性があり、エラーを処理する機会を呼び出し側に与えたい場合、それは<code>Result</code>を返さなくてはなりません。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Just by looking at the signature, you know that this function can fail.
// You can also inspect `ParseIntError` to see what kind of failures to expect.
// シグネチャーを見ただけで、この関数が失敗する可能性があることがわかります。
// また、期待する失敗の種類が何かを確認するために、`ParseIntError`を調査することもできます。
fn parse_int(s: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>That's the big advantage of <code>Result</code>: it makes fallibility explicit.</p>
<blockquote>
<p>それは<code>Result</code>の大きな利点です。それは誤りを逃れられない性質を明示的にします。</p>
</blockquote>
<p>Keep in mind, though, that panics exist. They aren't tracked by the type system, just like exceptions in other languages.
But they're meant for <strong>unrecoverable errors</strong> and should be used sparingly.</p>
<blockquote>
<p>ただし、パニックが存在することを忘れないでください。それらは型システムによって追跡されず、他の言語の例外とちょうど同じです。
しかし、それらは<strong>回復不可能なエラー</strong>を意図しており、控えめに使用されるべきです。</p>
</blockquote>
<h2 id="exercise-47"><a class="header" href="#exercise-47">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/05_ticket_v2/06_fallibility"><code>05_ticket_v2/06_fallibility</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unwrapping包みを解く"><a class="header" href="#unwrapping包みを解く">Unwrapping（包みを解く）</a></h1>
<p><code>Ticket::new</code> now returns a <code>Result</code> instead of panicking on invalid inputs.<br />
What does this mean for the caller?</p>
<blockquote>
<p>現在、<code>Ticket::new</code>は、無効な入力に対して<code>Result</code>を返します。
これは呼び出し側にとって何を意味するのでしょうか？</p>
</blockquote>
<h2 id="failures-cant-be-implicitly-ignored失敗は暗黙的に無視できない"><a class="header" href="#failures-cant-be-implicitly-ignored失敗は暗黙的に無視できない">Failures can't be (implicitly) ignored（失敗は暗黙的に無視できない）</a></h2>
<p>Unlike exceptions, Rust's <code>Result</code> forces you to <strong>handle errors at the call site</strong>.<br />
If you call a function that returns a <code>Result</code>, Rust won't allow you to implicitly ignore the error case.</p>
<blockquote>
<p>例外と異なり、Rustの<code>Result</code>は、<strong>呼び出し側でエラーを処理する</strong>ことを強制します。
<code>Result</code>を返す関数を呼び出した場合、Rustはエラーケースを暗黙的に無視させません。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn parse_int(s: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    // ...
}

// This won't compile: we're not handling the error case.
// We must either use `match` or one of the combinators provided by `Result`
// to "unwrap" the success value or handle the error.
// これはコンパイルされません。エラーケースを処理していないからです。
// 成功値の「包を解く」か、エラーを処理するために、`Result`によって提供される`match`またはコンビネーターの1つのどちらかを使用しなくてはなりません。
let number = parse_int("42") + 2;
<span class="boring">}</span></code></pre></pre>
<h2 id="you-got-a-result-now-whatresultを得ましたでは何をすればいいのでしょうか"><a class="header" href="#you-got-a-result-now-whatresultを得ましたでは何をすればいいのでしょうか">You got a <code>Result</code>. Now what?（Resultを得ました。では、何をすればいいのでしょうか？）</a></h2>
<p>When you call a function that returns a <code>Result</code>, you have two key options:</p>
<blockquote>
<p><code>Result</code>を返す関数を呼び出したとき、主に2つの選択肢があります。</p>
</blockquote>
<ul>
<li>
<p>Panic if the operation failed.
This is done using either the <code>unwrap</code> or <code>expect</code> methods.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Panics if `parse_int` returns an `Err`.
let number = parse_int("42").unwrap();
// `expect` lets you specify a custom panic message.
let number = parse_int("42").expect("Failed to parse integer");
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Destructure the <code>Result</code> using a <code>match</code> expression to deal with the error case explicitly.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match parse_int("42") {
    Ok(number) =&gt; println!("Parsed number: {}", number),
    Err(err) =&gt; eprintln!("Error: {}", err),
}
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<blockquote>
<ul>
<li>操作が失敗した場合パニックします。これは<code>unwrap</code>または<code>expect</code>メソッドのどちらかを使用して行います。</li>
<li>明示的にエラーケースを扱うために、<code>match</code>式を使用して、<code>Result</code>を分解します。</li>
</ul>
</blockquote>
<h2 id="exercise-48"><a class="header" href="#exercise-48">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/05_ticket_v2/07_unwrap"><code>05_ticket_v2/07_unwrap</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-enumserror列挙型"><a class="header" href="#error-enumserror列挙型">Error enums（Error列挙型）</a></h1>
<p>Your solution to the previous exercise may have felt awkward: matching on strings is not ideal!<br />
A colleague might rework the error messages returned by <code>Ticket::new</code> (e.g. to improve readability) and,
all of a sudden, your calling code would break.</p>
<blockquote>
<p>前の演習の解答は、洗練されていないかもしれません。文字列にマッチングすることは理想的ではありません！
同僚は、例えば可読性を改善するために<code>Ticket::new</code>によって返されたメッセージを再構築するかもしれず、突然コードの呼び出しは壊れます。</p>
</blockquote>
<p>You already know the machinery required to fix this: enums!</p>
<blockquote>
<p>列挙型でこれを修正するために要求されるメカニズムをすでに知っています！</p>
</blockquote>
<h2 id="reacting-to-errorsエラーに反応する"><a class="header" href="#reacting-to-errorsエラーに反応する">Reacting to errors（エラーに反応する）</a></h2>
<p>When you want to allow the caller to behave differently based on the specific error that occurred, you can
use an enum to represent the different error cases:</p>
<blockquote>
<p>発生した特定のエラーに基づいて、呼び出し側に異なる振る舞いをさせたいとき、異なるエラーケースを表現する列挙型を使用できます。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// An error enum to represent the different error cases
// that may occur when parsing a `u32` from a string.
// 文字列から`u32`にパースするときに発生するかもしれない異なるエラーケースを表現するエラー列挙型です。
enum U32ParseError {
    NotANumber,
    TooLarge,
    Negative,
}
<span class="boring">}</span></code></pre></pre>
<p>Using an error enum, you're encoding the different error cases in the type system—they become part of the
signature of the fallible function.<br />
This simplifies error handling for the caller, as they can use a <code>match</code> expression to react to the different
error cases:</p>
<blockquote>
<p>エラー列挙型を使用することは、型システムにさまざまなエラーケースを符号化することです。
それらは、失敗する可能性のある関数のシグネチャーの一部になります。
異なるエラーケースに対して反応するために<code>match</code>式を使用できるため、これは呼び出し側のエラー処理を簡素化します。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match s.parse_u32() {
    Ok(n) =&gt; n,
    Err(U32ParseError::Negative) =&gt; 0,
    Err(U32ParseError::TooLarge) =&gt; u32::MAX,
    Err(U32ParseError::NotANumber) =&gt; {
        panic!("Not a number: {}", s);
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="exercise-49"><a class="header" href="#exercise-49">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/05_ticket_v2/08_error_enums"><code>05_ticket_v2/08_error_enums</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-traiterrorトレイト"><a class="header" href="#error-traiterrorトレイト">Error trait（Errorトレイト）</a></h1>
<h2 id="error-reportingエラー報告"><a class="header" href="#error-reportingエラー報告">Error reporting（エラー報告）</a></h2>
<p>In the previous exercise you had to destructure the <code>TitleError</code> variant to extract the error message and
pass it to the <code>panic!</code> macro.<br />
This is a (rudimentary) example of <strong>error reporting</strong>: transforming an error type into a representation that can be
shown to a user, a service operator, or a developer.</p>
<blockquote>
<p>前の演習において、エラーメッセージを抽出して、<code>panic!</code>マクロにそれを渡すために、<code>TitleError</code>バリアントを分解しなければなりませんでした。
これは、<strong>エラー報告</strong>の初歩的な例で、ユーザー、サービスオペレーターまたは開発者に表示される表現にエラー型を変換しています。</p>
</blockquote>
<p>It's not practical for each Rust developer to come up with their own error reporting strategy: it'd be a waste of time
and it wouldn't compose well across projects.
That's why Rust provides the <code>std::error::Error</code> trait.</p>
<blockquote>
<p>それは、独自のエラー報告戦略を採用するそれぞれのRust開発者にとって実用的ではありません。
それは時間を浪費して、プロジェクト間でうまく構成されません。
それが、Rustが<code>std::error::Error</code>トレイトを提供する理由です。</p>
</blockquote>
<h2 id="the-error-traiterrorトレイト"><a class="header" href="#the-error-traiterrorトレイト">The <code>Error</code> trait（Errorトレイト）</a></h2>
<p>There are no constraints on the type of the <code>Err</code> variant in a <code>Result</code>, but it's a good practice to use a type
that implements the <code>Error</code> trait.
<code>Error</code> is the cornerstone of Rust's error handling story:</p>
<blockquote>
<p><code>Result</code>の<code>Err</code>バリアントの型に制約はありませんが、<code>Error</code>トレイトを実装する型を使用することは良い実践です。
<code>Error</code>は、Rustのエラー処理の基本理念です。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Slightly simplified definition of the `Error` trait
// `Error`トレイトの定義を少し簡素化しています。
pub trait Error: Debug + Display {}
<span class="boring">}</span></code></pre></pre>
<p>You might recall the <code>:</code> syntax from <a href="05_ticket_v2/../04_traits/08_sized.html">the <code>Sized</code> trait</a>—it's used to specify <strong>supertraits</strong>.
For <code>Error</code>, there are two supertraits: <code>Debug</code> and <code>Display</code>. If a type wants to implement <code>Error</code>, it must also
implement <code>Debug</code> and <code>Display</code>.</p>
<blockquote>
<p><code>Sized</code>トレイトの<code>:</code>構文を思い出したかもしれません。
それは<strong>スーパートレイト</strong>を指定するために使用されます。
<code>Error</code>には、2つのスーパートレイトがあり、それらは<code>Debug</code>と<code>Display</code>です。
型に<code>Error</code>を実装したい場合、その型は<code>Debug</code>と<code>Display</code>を実装しなければなりません。</p>
</blockquote>
<h2 id="display-and-debugdisplayとdebug"><a class="header" href="#display-and-debugdisplayとdebug"><code>Display</code> and <code>Debug</code>（DisplayとDebug）</a></h2>
<p>We've already encountered the <code>Debug</code> trait in <a href="05_ticket_v2/../04_traits/04_derive.html">a previous exercise</a>—it's the trait used by
<code>assert_eq!</code> to display the values of the variables it's comparing when the assertion fails.</p>
<blockquote>
<p>前の演習ですでに<code>Debug</code>トレイトに遭遇しました。
アサーションが失敗したときに、比較している変数の値を表示するために<code>assert_eq!</code>によって使用されるトレイトです。</p>
</blockquote>
<p>From a "mechanical" perspective, <code>Display</code> and <code>Debug</code> are identical—they encode how a type should be converted
into a string-like representation:</p>
<blockquote>
<p>「機械的」な観点から、<code>Display</code>と<code>Debug</code>は同一です。
それらは、型を文字列のような表現に変換する方法を符号化しています。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// `Debug`
pub trait Debug {
    fn fmt(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; Result&lt;(), Error&gt;;
}

// `Display`
pub trait Display {
    fn fmt(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; Result&lt;(), Error&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p>The difference is in their <em>purpose</em>: <code>Display</code> returns a representation that's meant for "end-users",
while <code>Debug</code> provides a low-level representation that's more suitable to developers and service operators.<br />
That's why <code>Debug</code> can be automatically implemented using the <code>#[derive(Debug)]</code> attribute, while <code>Display</code>
<strong>requires</strong> a manual implementation.</p>
<blockquote>
<p>違いはそれらの <em>目的</em> です。
<code>Display</code>は「エンドユーザー」を意図した表現を返しますが、<code>Debug</code>は開発者やサービスオペレーターにより適した低水準な表現を提供します。
それが、<code>Debug</code>が<code>#[derive(Debug)]</code>属性を使用して自動的に実装できる一方で、<code>Display</code>は手動の実装を<strong>要求する</strong>理由です。</p>
</blockquote>
<h2 id="exercise-50"><a class="header" href="#exercise-50">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/05_ticket_v2/09_error_trait"><code>05_ticket_v2/09_error_trait</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="libraries-and-binariesライブラリとバイナリ"><a class="header" href="#libraries-and-binariesライブラリとバイナリ">Libraries and binaries（ライブラリとバイナリ）</a></h1>
<p>It took a bit of code to implement the <code>Error</code> trait for <code>TicketNewError</code>, didn't it?<br />
A manual <code>Display</code> implementation, plus an <code>Error</code> impl block.</p>
<blockquote>
<p><code>TicketNewError</code>に対して<code>Error</code>トレイトを実装するために、少しのコードが必要でしたか？
手動の<code>Display</code>の実装は、<code>Error</code>の<code>impl</code>ブロックに加えられました。</p>
</blockquote>
<p>We can remove some of the boilerplate by using <a href="https://docs.rs/thiserror/latest/thiserror/"><code>thiserror</code></a>,
a Rust crate that provides a <strong>procedural macro</strong> to simplify the creation of custom error types.<br />
But we're getting ahead of ourselves: <code>thiserror</code> is a third-party crate, it'd be our first dependency!</p>
<blockquote>
<p>カスタムエラー型の作成を簡素化する<strong>手続きマクロ</strong>を提供するRustのクレートである<code>thiserror</code>を使用して、いくつかのボイラープレートを削除できます。
しかし、私たちは先走っています。<code>thiserror</code>はサードパーティのクレートであり、これが最初の依存関係になります！</p>
</blockquote>
<p>Let's take a step back to talk about Rust's packaging system before we dive into dependencies.</p>
<blockquote>
<p>依存関係に深入りする前にRustのパッケージシステムについて話すために、一歩後退しましょう。</p>
</blockquote>
<h2 id="what-is-a-packageパッケージとは"><a class="header" href="#what-is-a-packageパッケージとは">What is a package?（パッケージとは？）</a></h2>
<p>A Rust package is defined by the <code>[package]</code> section in a <code>Cargo.toml</code> file, also known as its <strong>manifest</strong>.
Within <code>[package]</code> you can set the package's metadata, such as its name and version.</p>
<blockquote>
<p>Rustパッケージは、<code>Cargo.toml</code>ファイル内の<code>[package]</code>節によって定義され、<strong>マニフェスト</strong>としても知られています。
<code>[package]</code>内で、パッケージの名前やバージョンなどのメタデータも設定できます。</p>
</blockquote>
<p>Go check the <code>Cargo.toml</code> file in the directory of this section's exercise!</p>
<blockquote>
<p>この節の演習ディレクトリ内の<code>Cargo.toml</code>ファイルを確認してください。</p>
</blockquote>
<h2 id="what-is-a-crateクレートとは"><a class="header" href="#what-is-a-crateクレートとは">What is a crate?（クレートとは？）</a></h2>
<p>Inside a package, you can have one or more <strong>crates</strong>, also known as <strong>targets</strong>.<br />
The two most common crate types are <strong>binary crates</strong> and <strong>library crates</strong>.</p>
<blockquote>
<p>パッケージの内部で、<strong>ターゲット</strong>とも知られる1つ以上の<strong>クレート</strong>を持つことができます。
2つの最も一般的なクレートのタイプは、<strong>バイナリークレート</strong>と<strong>ライブラリクレート</strong>です。</p>
</blockquote>
<h3 id="binariesバイナリー"><a class="header" href="#binariesバイナリー">Binaries（バイナリー）</a></h3>
<p>A binary is a program that can be compiled to an <strong>executable file</strong>.<br />
It must include a function named <code>main</code>—the program's entry point. <code>main</code> is invoked when the program is executed.</p>
<blockquote>
<p>バイナリーは、<strong>実行ファイル</strong>にコンパイルされるプログラムです。
それは、プログラムのエントリポイントである<code>main</code>と名付けられた関数を含まなくてはなりません。
<code>main</code>は、プログラムが実行されたときに呼び出されます。</p>
</blockquote>
<h3 id="librariesライブラリ"><a class="header" href="#librariesライブラリ">Libraries（ライブラリ）</a></h3>
<p>Libraries, on the other hand, are not executable on their own. You can't <em>run</em> a library,
but you can <em>import its code</em> from another package that depends on it.<br />
A library groups together code (i.e. functions, types, etc.) that can be leveraged by other packages as a <strong>dependency</strong>.</p>
<blockquote>
<p>一方、ライブラリはそれ自身で実行可能ではありません。ライブラリを<strong>実行</strong>することはできませんが、それに依存する他のパッケージから<strong>そのコードをインポート</strong>できます。
ライブラリは、<strong>依存関係</strong>として他のパッケージによって利用されるコード（例えば、関数、型など）を一緒にグループ化します。</p>
</blockquote>
<p>All the exercises you've solved so far have been structured as libraries, with a test suite attached to them.</p>
<blockquote>
<p>これまでに解いてきたすべての演習は、それらに付属するテストスイートと一緒に、ライブラリとして構成されています。</p>
</blockquote>
<h3 id="conventions慣例"><a class="header" href="#conventions慣例">Conventions（慣例）</a></h3>
<p>There are some conventions around Rust packages that you need to keep in mind:</p>
<ul>
<li>The package's source code is usually located in the <code>src</code> directory.</li>
<li>If there's a <code>src/lib.rs</code> file, <code>cargo</code> will infer that the package contains a library crate.</li>
<li>If there's a <code>src/main.rs</code> file, <code>cargo</code> will infer that the package contains a binary crate.</li>
</ul>
<blockquote>
<p>Rustパッケージのまわりに、気に留めておくべき慣例がいくつかあります。</p>
<ul>
<li>パッケージのソースコードは、通常<code>src</code>ディレクトリ内に配置されます。</li>
<li><code>src/lib.rs</code>ファイルが存在する場合、<code>cargo</code>はパッケージがライブラリクレートを含んでいると推測します。</li>
<li><code>src/main.rs</code>ファイルが存在する場合、<code>cargo</code>はパッケージがバイナリークレートを含んでいると推測します。</li>
</ul>
</blockquote>
<p>You can override these defaults by explicitly declaring your targets in the <code>Cargo.toml</code> file—see
<a href="https://doc.rust-lang.org/cargo/reference/cargo-targets.html#cargo-targets"><code>cargo</code>'s documentation</a> for more details.</p>
<blockquote>
<p><code>Cargo.toml</code>ファイルで明示的にターゲットを宣言することによって、これらのデフォルトを上書きできます。
詳細は<code>cargo</code>のドキュメントを参照してください。</p>
</blockquote>
<p>Keep in mind that while a package can contain multiple crates, it can only contain one library crate.</p>
<blockquote>
<p>パッケージは複数のクレートを含むことができる一方で、パッケージはたった1つのライブラリクレートのみを含むことができます。</p>
</blockquote>
<h2 id="scaffolding-a-new-package新しいパッケージの足場"><a class="header" href="#scaffolding-a-new-package新しいパッケージの足場">Scaffolding a new package（新しいパッケージの足場）</a></h2>
<p>You can use <code>cargo</code> to scaffold a new package:</p>
<blockquote>
<p>新しいパッケージの足場とするために<code>cargo</code>を使用できます。</p>
</blockquote>
<pre><code class="language-bash">cargo new my-binary
</code></pre>
<p>This will create a new folder, <code>my-binary</code>, containing a new Rust package with the same name and a single
binary crate inside. If you want to create a library crate instead, you can use the <code>--lib</code> flag:</p>
<blockquote>
<p>これは、<code>my-binary</code>という新しいフォルダを作成して、内部に同じ名前で単独のバイナリークレートを持つ新しいRustパッケージを含めます。
代わりにライブラリクレートを作成する場合、<code>--lib</code>フラグを使用できます。</p>
</blockquote>
<pre><code class="language-bash">cargo new my-library --lib
</code></pre>
<h2 id="exercise-51"><a class="header" href="#exercise-51">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/05_ticket_v2/10_packages"><code>05_ticket_v2/10_packages</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dependencies依存関係"><a class="header" href="#dependencies依存関係">Dependencies（依存関係）</a></h1>
<p>A package can depend on other packages by listing them in the <code>[dependencies]</code> section of its <code>Cargo.toml</code> file.<br />
The most common way to specify a dependency is by providing its name and version:</p>
<blockquote>
<p>パッケージは、その<code>Cargo.toml</code>ファイルの<code>[dependencies]</code>節内にリストすることで、他のパッケージに依存できます。
依存関係を指定する最も一般的な方法は、その名前とバージョンを提供することです。</p>
</blockquote>
<pre><code class="language-toml">[dependencies]
thiserror = "1"
</code></pre>
<p>This will add <code>thiserror</code> as a dependency to your package, with a <strong>minimum</strong> version of <code>1.0.0</code>.
<code>thiserror</code> will be pulled from <a href="https://crates.io">crates.io</a>, Rust's official package registry.
When you run <code>cargo build</code>, <code>cargo</code> will go through a few stages:</p>
<ul>
<li>Dependency resolution</li>
<li>Downloading the dependencies</li>
<li>Compiling your project (your own code and the dependencies)</li>
</ul>
<blockquote>
<p>これは、<code>1.0.0</code>の<strong>最小</strong>バージョンで、パッケージの依存関係として<code>thiserror</code>を追加します。
<code>thiserror</code>は、Rustの公式パッケージレジストリである<code>crates.io</code>から引き出されます。
<code>cargo build</code>を実行したとき、<code>cargo</code>はいくつかのステージを通過します。</p>
<ul>
<li>依存関係の解決</li>
<li>依存関係のダウンロード</li>
<li>プロジェクトのコンパイル（独自のコードと依存関係）</li>
</ul>
</blockquote>
<p>Dependency resolution is skipped if your project has a <code>Cargo.lock</code> file and your manifest files are unchanged.
A lockfile is automatically generated by <code>cargo</code> after a successful round of dependency resolution: it contains
the exact versions of all dependencies used in your project, and is used to ensure that the same versions are
consistently used across different builds (e.g. in CI). If you're working on a project with multiple developers,
you should commit the <code>Cargo.lock</code> file to your version control system.</p>
<blockquote>
<p>プロジェクトが<code>Cargo.lock</code>ファイルを持っていて、マニフェストファイルが変更されていない場合、依存関係の解決はスキップされます。
ロックファイルは、依存関係の解決のラウンドが成功した後、<code>cargo</code>によって自動的に生成されます。
ロックファイルは、プロジェクトで使用されるすべての依存関係の正確なバージョンを含み、それは、例えばCIなどの異なるビルドで、同じバーションが一貫して使用されることを確実にするために使用されます。</p>
</blockquote>
<p>You can use <code>cargo update</code> to update the <code>Cargo.lock</code> file with the latest (compatible) versions of all your dependencies.</p>
<blockquote>
<p>すべての依存関係の互換性のある最新バージョンで<code>Cargo.lock</code>ファイルを更新するために、<code>cargo update</code>を使用できます。</p>
</blockquote>
<h2 id="path-dependenciesパス依存関係"><a class="header" href="#path-dependenciesパス依存関係">Path dependencies（パス依存関係）</a></h2>
<p>You can also specify a dependency using a <strong>path</strong>. This is useful when you're working on multiple local packages.</p>
<blockquote>
<p><strong>パス</strong>を使用して依存関係を指定することもできます。これは、複数のローカルパッケージで作業しているときに便利です。</p>
</blockquote>
<pre><code class="language-toml">[dependencies]
my-library = { path = "../my-library" }
</code></pre>
<p>The path is relative to the <code>Cargo.toml</code> file of the package that's declaring the dependency.</p>
<blockquote>
<p>パスは、依存関係を宣言したパッケージの<code>Cargo.toml</code>ファイルに対して相対的です。</p>
</blockquote>
<h3 id="other-sources他のソース"><a class="header" href="#other-sources他のソース">Other sources（他のソース）</a></h3>
<p>Check out the <a href="https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html">Cargo documentation</a> for more
details on where you can get dependencies from and how to specify them in your <code>Cargo.toml</code> file.</p>
<blockquote>
<p>依存関係を取得できる場所と、<code>Cargo.toml</code>ファイル内でそれらを指定する方法の詳細は、Cargoドキュメントを確認してください。</p>
</blockquote>
<h2 id="dev-dependencies開発依存関係"><a class="header" href="#dev-dependencies開発依存関係">Dev dependencies（開発依存関係）</a></h2>
<p>You can also specify dependencies that are only needed for development—i.e. they only get pulled in when you're
running <code>cargo test</code>.<br />
They go in the <code>[dev-dependencies]</code> section of your <code>Cargo.toml</code> file:</p>
<blockquote>
<p>例えば、<code>cargo test</code>を実行しているときのみ引き出されるように、開発でのみ必要な依存関係も指定できます。</p>
</blockquote>
<pre><code class="language-toml">[dev-dependencies]
static_assertions = "1.1.0"
</code></pre>
<p>We've been using a few of these throughout the book to shorten our tests.</p>
<blockquote>
<p>本書全体でテストを短縮するために、これらをいくつか使用してきました。</p>
</blockquote>
<h2 id="exercise-52"><a class="header" href="#exercise-52">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/05_ticket_v2/11_dependencies"><code>05_ticket_v2/11_dependencies</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="thiserror"><a class="header" href="#thiserror"><code>thiserror</code></a></h1>
<p>That was a bit of detour, wasn't it? But a necessary one!<br />
Let's get back on track now: custom error types and <code>thiserror</code>.</p>
<blockquote>
<p>少し回り道をしましたか？しかしそれは必要でした！
ここで、カスタムエラー型と<code>thiserror</code>の追跡に戻りましょう。</p>
</blockquote>
<h2 id="custom-error-typesカスタムエラー型"><a class="header" href="#custom-error-typesカスタムエラー型">Custom error types（カスタムエラー型）</a></h2>
<p>We've seen how to implement the <code>Error</code> trait "manually" for a custom error type.<br />
Imagine that you have to do this for most error types in your codebase. That's a lot of boilerplate, isn't it?</p>
<blockquote>
<p>カスタムエラー型に対して「手動で」<code>Error</code>トレイトを実装する方法を確認しました。
コードベースでほとんどのエラー型に対してこれをしなければならないことを想像してください。それは多くのボイラープレートではありませんか？</p>
</blockquote>
<p>We can remove some of the boilerplate by using <a href="https://docs.rs/thiserror/latest/thiserror/"><code>thiserror</code></a>,
a Rust crate that provides a <strong>procedural macro</strong> to simplify the creation of custom error types.</p>
<blockquote>
<p>カスタムエラー型の作成を簡素化するための<strong>手続きマクロ</strong>を提供するRustクレートの<code>thiserror</code>を使用することで、いくつかの定型文を削除できます。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(thiserror::Error, Debug)]
enum TicketNewError {
    #[error("{0}")]
    TitleError(String),
    #[error("{0}")]
    DescriptionError(String),
}
<span class="boring">}</span></code></pre></pre>
<h2 id="you-can-write-your-own-macros独自のマクロを記述できます"><a class="header" href="#you-can-write-your-own-macros独自のマクロを記述できます">You can write your own macros（独自のマクロを記述できます）</a></h2>
<p>All the <code>derive</code> macros we've seen so far were provided by the Rust standard library.<br />
<code>thiserror::Error</code> is the first example of a <strong>third-party</strong> <code>derive</code> macro.</p>
<blockquote>
<p>これまでに見てきたすべての<code>derive</code>マクロは、Rust標準ライブラリによって提供されています。
<code>thiserror::Error</code>は、<strong>サードパーティ</strong>の<code>derive</code>マクロの最初の例です。</p>
</blockquote>
<p><code>derive</code> macros are a subset of <strong>procedural macros</strong>, a way to generate Rust code at compile time.
We won't get into the details of how to write a procedural macro in this course, but it's important
to know that you can write your own!<br />
A topic to approach in a more advanced Rust course.</p>
<blockquote>
<p><code>derive</code>マクロは、<strong>手続きマクロ</strong>の部分集合で、コンパイル時にRustコードを生成する方法です。
このコースにおいて、手続きマクロを記述する方法の詳細に入るつもりはありませんが、独自に記述できることを知ることは重要です。
それは、より高度なRustのコースで説明するトピックです。</p>
</blockquote>
<h2 id="custom-syntaxカスタム構文"><a class="header" href="#custom-syntaxカスタム構文">Custom syntax（カスタム構文）</a></h2>
<p>Each procedural macro can define its own syntax, which is usually explained in the crate's documentation.
In the case of <code>thiserror</code>, we have:</p>
<ul>
<li><code>#[derive(thiserror::Error)]</code>: this is the syntax to derive the <code>Error</code> trait for a custom error type, helped by <code>thiserror</code>.</li>
<li><code>#[error("{0}")]</code>: this is the syntax to define a <code>Display</code> implementation for each variant of the custom error type.
<code>{0}</code> is replaced by the zero-th field of the variant (<code>String</code>, in this case) when the error is displayed.</li>
</ul>
<blockquote>
<p>それぞれの手続マクロはそれ独自の構文を定義でき、通常、それはクレートのドキュメントで説明されています。
<code>thiserror</code>の場合、次のようになります。</p>
<ul>
<li><code>#[derive(thiserror::Error)]</code>: これは、<code>thiserror</code>によって支援される、カスタムエラー型に<code>Error</code>トレイトを導出する構文です。</li>
<li><code>#[error("{0}")]</code>: これは、カスタムエラー型のそれぞれのバリアントに対して<code>Display</code>の実装を定義する構文です。</li>
<li><code>{0}</code>は、エラーが表示されるときに、バリアントの0番目のフィールド（この場合は<code>String</code>）に置き換えられます。</li>
</ul>
</blockquote>
<h2 id="exercise-53"><a class="header" href="#exercise-53">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/05_ticket_v2/12_thiserror"><code>05_ticket_v2/12_thiserror</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tryfrom-and-tryintotryfromとtryinto"><a class="header" href="#tryfrom-and-tryintotryfromとtryinto"><code>TryFrom</code> and <code>TryInto</code>（TryFromとTryInto）</a></h1>
<p>In the previous chapter we looked at the <a href="05_ticket_v2/../04_traits/09_from.html"><code>From</code> and <code>Into</code> traits</a>,
Rust's idiomatic interfaces for <strong>infallible</strong> type conversions.<br />
But what if the conversion is not guaranteed to succeed?</p>
<blockquote>
<p>前の演習において、Rustの<strong>失敗しない</strong>型変換の慣用的なインターフェイスである、<code>From</code>と<code>Into</code>トレイトを確認しました。
しかし、成功することが保証されていない変換の場合はどうなるでしょうか？</p>
</blockquote>
<p>We now know enough about errors to discuss the <strong>fallible</strong> counterparts of <code>From</code> and <code>Into</code>:
<code>TryFrom</code> and <code>TryInto</code>.</p>
<blockquote>
<p>現在、<code>From</code>と<code>Into</code>の<strong>失敗する可能性がある</strong>に対応する<code>TryFrom</code>と<code>TryInto</code>について議論できるほど、エラーを十分に理解しています。</p>
</blockquote>
<h2 id="tryfrom-and-tryintotryfromとtryinto-1"><a class="header" href="#tryfrom-and-tryintotryfromとtryinto-1"><code>TryFrom</code> and <code>TryInto</code>（TryFromとTryInto）</a></h2>
<p>Both <code>TryFrom</code> and <code>TryInto</code> are defined in the <code>std::convert</code> module, just like <code>From</code> and <code>Into</code>.</p>
<blockquote>
<p><code>TryFrom</code>と<code>TryInto</code>両方とも、ちょうど<code>From</code>と<code>Into</code>と同様に、<code>std::convert</code>モジュールに定義されています。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait TryFrom&lt;T&gt;: Sized {
    type Error;
    fn try_from(value: T) -&gt; Result&lt;Self, Self::Error&gt;;
}

pub trait TryInto&lt;T&gt;: Sized {
    type Error;
    fn try_into(self) -&gt; Result&lt;T, Self::Error&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p>The main difference between <code>From</code>/<code>Into</code> and <code>TryFrom</code>/<code>TryInto</code> is that the latter return a <code>Result</code> type.<br />
This allows the conversion to fail, returning an error instead of panicking.</p>
<blockquote>
<p><code>From</code>/<code>Into</code>と<code>TryFrom</code>/<code>TryInto</code>の主な違いは、後者が<code>Result</code>型を返すことです。
これは、変換が失敗することを許可して、パニックの代わりにエラーを返します。</p>
</blockquote>
<h2 id="selferror"><a class="header" href="#selferror"><code>Self::Error</code></a></h2>
<p>Both <code>TryFrom</code> and <code>TryInto</code> have an associated <code>Error</code> type.
This allows each implementation to specify its own error type, ideally the most appropriate for the conversion
being attempted.</p>
<blockquote>
<p><code>TryFrom</code>と<code>TryInto</code>両方は、関連型<code>Error</code>があります。
これは、それぞれの実装に、変換の試みに対して理想的に最も適切な独自のエラー型を指定させます。</p>
</blockquote>
<p><code>Self::Error</code> is a way to refer to the <code>Error</code> associated type defined in the trait itself.</p>
<blockquote>
<p><code>Self::Error</code>は、それ自身のトレイトに定義された<code>Error</code>関連型を参照する方法です。</p>
</blockquote>
<h2 id="duality二重性"><a class="header" href="#duality二重性">Duality（二重性）</a></h2>
<p>Just like <code>From</code> and <code>Into</code>, <code>TryFrom</code> and <code>TryInto</code> are dual traits.<br />
If you implement <code>TryFrom</code> for a type, you get <code>TryInto</code> for free.</p>
<blockquote>
<p><code>From</code>と<code>Into</code>と同様に、<code>TryFrom</code>と<code>TryInto</code>は双対トレイトです。
型に<code>TryFrom</code>を実装すると、<code>TryInto</code>が無料で提供されます。</p>
</blockquote>
<h2 id="exercise-54"><a class="header" href="#exercise-54">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/05_ticket_v2/13_try_from"><code>05_ticket_v2/13_try_from</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="errorsource"><a class="header" href="#errorsource"><code>Error::source</code></a></h1>
<p>There's one more thing we need to talk about to complete our coverage of the <code>Error</code> trait: the <code>source</code> method.</p>
<blockquote>
<p><code>Error</code>トレイトの説明を完了するために、話す必要があることがもう1つあります。それは<code>source</code>メソッドです。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Full definition this time!
// 今回は完全な定義です。
pub trait Error: Debug + Display {
    fn source(&amp;self) -&gt; Option&lt;&amp;(dyn Error + 'static)&gt; {
        None
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>source</code> method is a way to access the <strong>error cause</strong>, if any.<br />
Errors are often chained, meaning that one error is the cause of another: you have a high-level error (e.g.
cannot connect to the database) that is caused by a lower-level error (e.g. can't resolve the database hostname).
The <code>source</code> method allows you to "walk" the full chain of errors, often used when capturing error context in logs.</p>
<blockquote>
<p><code>source</code>メソッドは、もしある場合、<strong>エラーの原因</strong>にアクセスする方法です。
時々、エラーは連鎖され、それは1つのエラーが他の原因になることを意味します。
例えばデータベースのホスト名を解決できないなどの低水準のエラーによって引き起こされた、例えばデータベースに接続できないなどの高水準なエラーがあります。
<code>source</code>メソッドは、エラーの完全なつながりを「横断」させて、時々ログでエラーの文脈をキャプチャーするときに使用されます。</p>
</blockquote>
<h2 id="implementing-sourcesourceの実装"><a class="header" href="#implementing-sourcesourceの実装">Implementing <code>source</code>（sourceの実装）</a></h2>
<p>The <code>Error</code> trait provides a default implementation that always returns <code>None</code> (i.e. no underlying cause). That's why
you didn't have to care about <code>source</code> in the previous exercises.<br />
You can override this default implementation to provide a cause for your error type.</p>
<blockquote>
<p><code>Error</code>トレイトは、例えば根本的な原因のない<code>None</code>を常に返すデフォルト実装を提供しています。
それが、前の演習で<code>source</code>について気にする必要がなかった理由です。
独自のエラー型で原因を提供するためにデフォルト実装を上書きできます。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::error::Error;

#[derive(Debug)]
struct DatabaseError {
    source: std::io::Error
}

impl std::fmt::Display for DatabaseError {
    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter) -&gt; std::fmt::Result {
        write!(f, "Failed to connect to the database")
    }
}

impl std::error::Error for DatabaseError {
    fn source(&amp;self) -&gt; Option&lt;&amp;(dyn Error + 'static)&gt; {
        Some(&amp;self.source)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>In this example, <code>DatabaseError</code> wraps an <code>std::io::Error</code> as its source.
We then override the <code>source</code> method to return this source when called.</p>
<blockquote>
<p>この例において、<code>DatabaseError</code>は、そのソースとして<code>std::io::Error</code>をラップしています。
そして、呼び出されたときに、このソースを返すために<code>source</code>メソッドを上書きします。</p>
</blockquote>
<h2 id="dyn-error--static"><a class="header" href="#dyn-error--static"><code>&amp;(dyn Error + 'static)</code></a></h2>
<p>What's this <code>&amp;(dyn Error + 'static)</code> type?<br />
Let's unpack it:</p>
<ul>
<li><code>dyn Error</code> is a <strong>trait object</strong>. It's a way to refer to any type that implements the <code>Error</code> trait.</li>
<li><code>'static</code> is a special <strong>lifetime specifier</strong>.
<code>'static</code> implies that the reference is valid for "as long as we need it", i.e. the entire program execution.</li>
</ul>
<blockquote>
<p>この<code>&amp;(dyn Error + 'static)</code>型はなんでしょうか？
それを分解してみましょう。</p>
<ul>
<li><code>dyn Error</code>は<strong>トレイトオブジェクト</strong>です。それは、<code>Error</code>トレイトを実装する任意の型を参照する方法です。</li>
<li><code>'static</code>は特別な<strong>ライフタイム注釈</strong>です。
<code>'static</code>は、例えばプログラムの実行全体でなど、参照が「それが必要とされる限り」有効であることを暗黙的に示しています。</li>
</ul>
</blockquote>
<p>Combined: <code>&amp;(dyn Error + 'static)</code> is a reference to a trait object that implements the <code>Error</code> trait
and is valid for the entire program execution.</p>
<blockquote>
<p>組み合わせると: <code>&amp;(dyn Error + 'static)</code>は、<code>Error</code>トレイトを実装したトレイトオブジェクトへの参照で、プログラムの実行全体で有効です。</p>
</blockquote>
<p>Don't worry too much about either of these concepts for now. We'll cover them in more detail in future chapters.</p>
<blockquote>
<p>今のところ、これらの概念についてあまり心配しないでください。将来の章でより詳細にそれらを説明します。</p>
</blockquote>
<h2 id="implementing-source-using-thiserrorthiserrorを使用してsourceを実装する"><a class="header" href="#implementing-source-using-thiserrorthiserrorを使用してsourceを実装する">Implementing <code>source</code> using <code>thiserror</code>（thiserrorを使用してsourceを実装する）</a></h2>
<p><code>thiserror</code> provides three ways to automatically implement <code>source</code> for your error types:</p>
<blockquote>
<p><code>thiserror</code>は、独自のエラー型に対して<code>source</code>を自動的に実装する3つの方法を提供します。</p>
</blockquote>
<ul>
<li>
<p>A field named <code>source</code> will automatically be used as the source of the error.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use thiserror::Error;

#[derive(Error, Debug)]
pub enum MyError {
    #[error("Failed to connect to the database")]
    DatabaseError {
        source: std::io::Error
    }
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>A field annotated with the <code>#[source]</code> attribute will automatically be used as the source of the error.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use thiserror::Error;

#[derive(Error, Debug)]
pub enum MyError {
    #[error("Failed to connect to the database")]
    DatabaseError {
        #[source]
        inner: std::io::Error
    }
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>A field annotated with the <code>#[from]</code> attribute will automatically be used as the source of the error <strong>and</strong>
<code>thiserror</code> will automatically generate a <code>From</code> implementation to convert the annotated type into your error type.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use thiserror::Error;

#[derive(Error, Debug)]
pub enum MyError {
    #[error("Failed to connect to the database")]
    DatabaseError {
        #[from]
        inner: std::io::Error
    }
}
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<blockquote>
<ul>
<li>フィールド名<code>source</code>は、エラーのソースとして自動的に使用されます。</li>
<li><code>#[source]</code>属性で注釈されたフィールドは、エラーのソースとして自動的に使用されます。</li>
<li><code>#[from]</code>属性で注釈されたフィールドは、エラーのソースとして自動的に使用され、<strong>さらに</strong> <code>thiserror</code>は、注釈された型を独自のエラー型に変換する<code>From</code>実装を自動的に生成します。</li>
</ul>
</blockquote>
<h2 id="the--operator演算子"><a class="header" href="#the--operator演算子">The <code>?</code> operator（?演算子）</a></h2>
<p>The <code>?</code> operator is a shorthand for propagating errors.<br />
When used in a function that returns a <code>Result</code>, it will return early with an error if the <code>Result</code> is <code>Err</code>.</p>
<p>For example:</p>
<blockquote>
<p><code>?</code>演算子はエラーを伝播するための省略記法です。
<code>Result</code>を返す関数内で使用したとき、<code>Result</code>が<code>Err</code>である場合、エラーで早期リターンします。</p>
<p>例えば・・・</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;

fn read_file() -&gt; Result&lt;String, std::io::Error&gt; {
    let mut file = File::open("file.txt")?;
    let mut contents = String::new();
    file.read_to_string(&amp;mut contents)?;
    Ok(contents)
}
<span class="boring">}</span></code></pre></pre>
<p>is equivalent to:</p>
<blockquote>
<p>上記は次と同等です。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;

fn read_file() -&gt; Result&lt;String, std::io::Error&gt; {
    let mut file = match File::open("file.txt") {
        Ok(file) =&gt; file,
        Err(e) =&gt; {
            return Err(e);
        }
    };
    let mut contents = String::new();
    match file.read_to_string(&amp;mut contents) {
        Ok(_) =&gt; (),
        Err(e) =&gt; {
            return Err(e);
        }
    }
    Ok(contents)
}
<span class="boring">}</span></code></pre></pre>
<p>You can use the <code>?</code> operator to shorten your error handling code significantly.<br />
In particular, the <code>?</code> operator will automatically convert the error type of the fallible operation into the error type
of the function, if a conversion is possible (i.e. if there is a suitable <code>From</code> implementation)</p>
<blockquote>
<p>エラー処理コードを大幅に短くするために<code>?</code>演算子を使用できます。
特に、<code>?</code>演算子は、例えば適切な<code>From</code>実装がある場合など、変換が可能な場合、失敗する可能性がある操作のエラー型を関数のエラー型に自動的に変換します。</p>
</blockquote>
<h2 id="exercise-55"><a class="header" href="#exercise-55">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/05_ticket_v2/14_source"><code>05_ticket_v2/14_source</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wrapping-up仕上げ-2"><a class="header" href="#wrapping-up仕上げ-2">Wrapping up（仕上げ）</a></h1>
<p>When it comes to domain modelling, the devil is in the details.<br />
Rust offers a wide range of tools to help you represent the constraints of your domain directly in the type system,
but it takes some practice to get it right and write code that looks idiomatic.</p>
<blockquote>
<p>ドメインモデリングにおいて、悪魔は詳細に宿ります。
Rustは、型システム内に直接ドメインの一貫性を表現するための幅広いツールを提供していますが、
正しく理解して慣用的なコードを記述するためには、ある程度の実践が必要です。</p>
</blockquote>
<p>Let's close the chapter with one final refinement of our <code>Ticket</code> model.<br />
We'll introduce a new type for each of the fields in <code>Ticket</code> to encapsulate the respective constraints.<br />
Every time someone accesses a <code>Ticket</code> field, they'll get back a value that's guaranteed to be valid—i.e. a
<code>TicketTitle</code> instead of a <code>String</code>. They won't have to worry about the title being empty elsewhere in the code:
as long as they have a <code>TicketTitle</code>, they know it's valid <strong>by construction</strong>.</p>
<blockquote>
<p><code>Ticket</code>モデルの最後の改良で章を終了しましょう。
それぞれの制約をカプセル化するために<code>Ticket</code>内のそれぞれのフィールドに対して新しい型を導入します。
誰かが<code>Ticket</code>のフィールドにアクセスするたびに、それらは有効であることを保証された値、例えば<code>String</code>の代わりに<code>TicketTitle</code>を返します。
コードの何処かでタイトルが空であることを心配する必要はありません。
<code>TicketTitle</code>がある限り、<strong>構築によって</strong>有効であることがわかります。</p>
</blockquote>
<p>This is just an example of how you can use Rust's type system to make your code safer and more expressive.</p>
<blockquote>
<p>これは、ちょうどコードを安全そしてより表現を豊かにするに、Rustの型システムを使用する方法を示す例です。</p>
</blockquote>
<h2 id="further-reading参考資料-8"><a class="header" href="#further-reading参考資料-8">Further reading（参考資料）</a></h2>
<ul>
<li><a href="https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/">Parse, don't validate</a></li>
<li><a href="https://www.lpalmieri.com/posts/2020-12-11-zero-to-production-6-domain-modelling/">Using types to guarantee domain invariants</a></li>
</ul>
<h2 id="exercise-56"><a class="header" href="#exercise-56">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/05_ticket_v2/15_outro"><code>05_ticket_v2/15_outro</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="intro"><a class="header" href="#intro">Intro</a></h1>
<p>In the previous chapter we modelled <code>Ticket</code> in a vacuum: we defined its fields and their constraints, we learned
how to best represent them in Rust, but we didn't consider how <code>Ticket</code> fits into a larger system.
We'll use this chapter to build a simple workflow around <code>Ticket</code>, introducing a (rudimentary) management system to
store and retrieve tickets.</p>
<blockquote>
<p>前の章において、世間から孤立して<code>Ticket</code>をモデリングしました。
そのフィールドとそれらの制約を定義して、Rustでそれらを表現する最良の方法を学びましたが、大きなシステムに<code>Ticket</code>を適用する方法を考えていません。
チケットを保存、そして取得するための基本的な管理システムを導入して、<code>Ticket</code>に関する単純なワークフローを構築するためにこの章を使用します。</p>
</blockquote>
<p>The task will give us an opportunity to explore new Rust concepts, such as:</p>
<ul>
<li>Stack-allocated arrays</li>
<li><code>Vec</code>, a growable array type, and slices</li>
<li><code>Iterator</code> and <code>IntoIterator</code>, for iterating over collections</li>
<li>Slices (<code>&amp;[T]</code>), to work with parts of a collection</li>
<li>Lifetimes, to describe how long references are valid</li>
<li><code>HashMap</code> and <code>BTreeMap</code>, two key-value data structures</li>
<li><code>Eq</code> and <code>Hash</code>, to compare keys in a <code>HashMap</code></li>
<li><code>Ord</code> and <code>PartialOrd</code>, to work with a <code>BTreeMap</code></li>
<li><code>Index</code> and <code>IndexMut</code>, to access elements in a collection</li>
</ul>
<blockquote>
<p>そのタスクは、次のような新しいRustの概念を探求する機会を与えてくれます。</p>
<ul>
<li>スタックに割り当てられた配列</li>
<li>成長可能な配列型である<code>Vec</code>とスライス</li>
<li>コレクションを反復処理する<code>Iterator</code>と<code>IntoIterator</code></li>
<li>コレクションの一部で動作するスライス（<code>&amp;[T]</code>）</li>
<li>参照が有効な期間を説明するライフタイム</li>
<li>キーと値のデータ構造である2つの<code>HashMap</code>と<code>BTreeMap</code></li>
<li><code>HashMap</code>内のキーを比較する<code>Eq</code>と<code>Hash</code></li>
<li><code>BTreeMap</code>で必要な<code>Ord</code>と<code>PartialOrd</code></li>
<li>コレクション内の要素にアクセスする<code>Index</code>と<code>IndexMut</code></li>
</ul>
</blockquote>
<h2 id="exercise-57"><a class="header" href="#exercise-57">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/06_ticket_management/00_intro"><code>06_ticket_management/00_intro</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="arrays配列"><a class="header" href="#arrays配列">Arrays（配列）</a></h1>
<p>As soon as we start talking about "ticket management" we need to think about a way to store <em>multiple</em> tickets.
In turn, this means we need to think about collections. In particular, homogeneous collections:
we want to store multiple instances of the same type.</p>
<blockquote>
<p>「チケットの管理」について話し始めるとすぐに、<em>複数の</em> チケットを保存する方法について考え始める必要があります。
次に、これはコレクションについて考える必要があることを意味します。特に、同種のコレクション、同じ型の複数のインスタンスを保存したいと思います。</p>
</blockquote>
<p>What does Rust have to offer in this regard?</p>
<blockquote>
<p>この観点に関してRustは何を提供するでしょうか？</p>
</blockquote>
<h2 id="arrays配列-1"><a class="header" href="#arrays配列-1">Arrays（配列）</a></h2>
<p>A first attempt could be to use an <strong>array</strong>.<br />
Arrays in Rust are fixed-size collections of elements of the same type.</p>
<blockquote>
<p>最初の試みは、<strong>配列</strong>を使うことです。
Rustにおける配列は、同じ型の要素の固定サイズのコレクションです。</p>
</blockquote>
<p>Here's how you can define an array:</p>
<blockquote>
<p>ここに、配列を定義する方法を示します。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Array type syntax: [ &lt;type&gt; ; &lt;number of elements&gt; ]
let numbers: [u32; 3] = [1, 2, 3];
<span class="boring">}</span></code></pre></pre>
<p>This creates an array of 3 integers, initialized with the values <code>1</code>, <code>2</code>, and <code>3</code>.<br />
The type of the array is <code>[u32; 3]</code>, which reads as "an array of <code>u32</code>s with a length of 3".</p>
<blockquote>
<p>これは、3つの整数の配列を作成して、値<code>1</code>、<code>2</code>、<code>3</code>で初期化します。
配列の型は<code>[u32; 3]</code>で、それは「3の長さを持つ<code>u32</code>の配列」と読みます。</p>
</blockquote>
<h3 id="accessing-elements要素へのアクセス"><a class="header" href="#accessing-elements要素へのアクセス">Accessing elements（要素へのアクセス）</a></h3>
<p>You can access elements of an array using square brackets:</p>
<blockquote>
<p>角括弧を使用して配列の要素にアクセスできます。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let first = numbers[0];
let second = numbers[1];
let third = numbers[2];
<span class="boring">}</span></code></pre></pre>
<p>The index must be of type <code>usize</code>.<br />
Arrays are <strong>zero-indexed</strong>, like everything in Rust. You've seen this before with string slices and field indexing in
tuples/tuple-like variants.</p>
<blockquote>
<p>インデックスは<code>usize</code>型でなくてはなりません。
Rustにおいてすべてのものと同様に、配列は<strong>ゼロベース</strong>です。
前の文字列スライスと、タプル／タプルのようなバリアントにおけるフィールドインデックスでこれを確認しました。</p>
</blockquote>
<h3 id="out-of-bounds-access範囲外アクセス"><a class="header" href="#out-of-bounds-access範囲外アクセス">Out-of-bounds access（範囲外アクセス）</a></h3>
<p>If you try to access an element that's out of bounds, Rust will panic:</p>
<blockquote>
<p>範囲外の要素にアクセスすることを試みた場合、Rustはパニックします。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let numbers: [u32; 3] = [1, 2, 3];
let fourth = numbers[3]; // This will panic
                         // これはパニックします。
<span class="boring">}</span></code></pre></pre>
<p>This is enforced at runtime using <strong>bounds checking</strong>. It comes with a small performance overhead, but it's how
Rust prevents buffer overflows.<br />
In some scenarios the Rust compiler can optimize away bounds checks, especially if iterators are involved—we'll speak
more about this later on.</p>
<blockquote>
<p>これは<strong>境界チェック</strong>を使用してランタイムで強制されます。
それは小さな性能のオーバーヘッドを伴いますが、それはRustがバッファーオーバーフローを避ける方法です。
いくつかのシナリオにおいて、特にイテレーターを含む場合、Rustコンパイラーは境界チェックを最適化できます。
この後で詳しく説明します。</p>
</blockquote>
<p>If you don't want to panic, you can use the <code>get</code> method, which returns an <code>Option&lt;&amp;T&gt;</code>:</p>
<blockquote>
<p>パニックしたくない場合は、<code>Option&lt;&amp;T&gt;</code>を返す<code>get</code>メソッドを使用できます。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let numbers: [u32; 3] = [1, 2, 3];
assert_eq!(numbers.get(0), Some(&amp;1));
// You get a `None` if you try to access an out-of-bounds index
// rather than a panic.
// 範囲外のインデックスにアクセスを試みた場合、パニックするのではなく、`None`を得ます。
assert_eq!(numbers.get(3), None);
<span class="boring">}</span></code></pre></pre>
<h3 id="performance性能-1"><a class="header" href="#performance性能-1">Performance（性能）</a></h3>
<p>Since the size of an array is known at compile-time, the compiler can allocate the array on the stack.
If you run the following code:</p>
<blockquote>
<p>配列のサイズはコンパイル時にわかっているため、コンパイラーはスタックに配列を割り当てることができます。
次のコードを実行すると・・・</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let numbers: [u32; 3] = [1, 2, 3];
<span class="boring">}</span></code></pre></pre>
<p>You'll get the following memory layout:</p>
<blockquote>
<p>次のメモリレイアウトが得られます。</p>
</blockquote>
<pre><code class="language-text">        +---+---+---+
Stack:  | 1 | 2 | 3 |
        +---+---+---+
</code></pre>
<p>In other words, the size of an array is <code>std::mem::size_of::&lt;T&gt;() * N</code>, where <code>T</code> is the type of the elements and <code>N</code> is
the number of elements.<br />
You can access and replace each element in <code>O(1)</code> time.</p>
<blockquote>
<p>言い換えると、配列のサイズは<code>std::mem::size_of::&lt;T&gt;() * N</code>であり、<code>T</code>は要素の型で、<code>N</code>は要素の数です。
<code>O(1)</code>時間でそれぞれの要素にアクセスまたは入れ替えできます。</p>
</blockquote>
<h2 id="exercise-58"><a class="header" href="#exercise-58">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/06_ticket_management/01_arrays"><code>06_ticket_management/01_arrays</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vectorsベクター"><a class="header" href="#vectorsベクター">Vectors（ベクター）</a></h1>
<p>Arrays' strength is also their weakness: their size must be known upfront, at compile-time.
If you try to create an array with a size that's only known at runtime, you'll get a compilation error:</p>
<blockquote>
<p>配列の強みは、それらの弱点でもあります。それらのサイズは、コンパイル時に前もってわかっていなくてはなりません。
ランタイム時しかわからないサイズを持つ配列を作成することを試みた場合、コンパイルエラーを得ます。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let n = 10;
let numbers: [u32; n];
<span class="boring">}</span></code></pre></pre>
<pre><code class="language-text">error[E0435]: attempt to use a non-constant value in a constant
 --&gt; src/main.rs:3:20
  |
2 | let n = 10;
3 | let numbers: [u32; n];
  |                    ^ non-constant value
</code></pre>
<p>Arrays wouldn't work for our ticket management system—we don't know how many tickets we'll need to store at compile-time.
This is where <code>Vec</code> comes in.</p>
<blockquote>
<p>配列は、チケット管理システムには適していません。
コンパイル時に保存する必要のあるチケットの数を知ることができません。
ここで<code>Vec</code>が登場します。</p>
</blockquote>
<h2 id="vec"><a class="header" href="#vec"><code>Vec</code></a></h2>
<p><code>Vec</code> is a growable array type, provided by the standard library.<br />
You can create an empty array using the <code>Vec::new</code> function:</p>
<blockquote>
<p><code>Vec</code>は成長する配列型で、標準ライブラリで提供されています。
<code>Vec::new</code>関数を使用して空の配列を作成できます。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut numbers: Vec&lt;u32&gt; = Vec::new();
<span class="boring">}</span></code></pre></pre>
<p>You would then push elements into the vector using the <code>push</code> method:</p>
<blockquote>
<p>その後、<code>push</code>メソッドを使用してベクター内に要素を追加します。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>numbers.push(1);
numbers.push(2);
numbers.push(3);
<span class="boring">}</span></code></pre></pre>
<p>New values are added to the end of the vector.<br />
You can also create an initialized vector using the <code>vec!</code> macro, if you know the values at creation time:</p>
<blockquote>
<p>新しい値はベクターの末尾に追加されます。
作成時に値がわかっている場合、<code>vec!</code>マクロを使用して初期化されたベクターを作成することもできます。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let numbers = vec![1, 2, 3];
<span class="boring">}</span></code></pre></pre>
<h2 id="accessing-elements要素へのアクセス-1"><a class="header" href="#accessing-elements要素へのアクセス-1">Accessing elements（要素へのアクセス）</a></h2>
<p>The syntax for accessing elements is the same as with arrays:</p>
<blockquote>
<p>要素にアクセスする構文は、配列と同じです。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let numbers = vec![1, 2, 3];
let first = numbers[0];
let second = numbers[1];
let third = numbers[2];
<span class="boring">}</span></code></pre></pre>
<p>The index must be of type <code>usize</code>.<br />
You can also use the <code>get</code> method, which returns an <code>Option&lt;&amp;T&gt;</code>:</p>
<blockquote>
<p>インデックスは<code>usize</code>型でなくてはなりません。
<code>Option&lt;&amp;T&gt;</code>を返す<code>get</code>メソッドを使用することもできます。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let numbers = vec![1, 2, 3];
assert_eq!(numbers.get(0), Some(&amp;1));
// You get a `None` if you try to access an out-of-bounds index
// rather than a panic.
assert_eq!(numbers.get(3), None);
<span class="boring">}</span></code></pre></pre>
<p>Access is bounds-checked, just like element access with arrays. It has O(1) complexity.</p>
<blockquote>
<p>アクセスは境界チェックされ、ちょうど配列の要素アクセスと同じです。
それは、O(1)の複雑さがあります。</p>
</blockquote>
<h2 id="memory-layoutメモリレイアウト-2"><a class="header" href="#memory-layoutメモリレイアウト-2">Memory layout（メモリレイアウト）</a></h2>
<p><code>Vec</code> is a heap-allocated data structure.<br />
When you create a <code>Vec</code>, it allocates memory on the heap to store the elements.</p>
<blockquote>
<p><code>Vec</code>はヒープに割り当てられたデータ構造です。
<code>Vec</code>を作成するとき、それは要素を保存するためにヒープにメモリを割り当てます。</p>
</blockquote>
<p>If you run the following code:</p>
<blockquote>
<p>次のコードを実行した場合・・・</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut numbers = Vec::with_capacity(3);
numbers.push(1);
numbers.push(2);
<span class="boring">}</span></code></pre></pre>
<p>you'll get the following memory layout:</p>
<blockquote>
<p>次のメモリレイアウトを得ます。</p>
</blockquote>
<pre><code class="language-text">      +---------+--------+----------+
Stack | pointer | length | capacity |
      |  |      |   2    |    3     |
      +--|------+--------+----------+
         |
         |
         v
       +---+---+---+
Heap:  | 1 | 2 | ? |
       +---+---+---+
</code></pre>
<p><code>Vec</code> keeps track of three things:</p>
<ul>
<li>The <strong>pointer</strong> to the heap region you reserved.</li>
<li>The <strong>length</strong> of the vector, i.e. how many elements are in the vector.</li>
<li>The <strong>capacity</strong> of the vector, i.e. the number of elements that can fit in the space reserved on the heap.</li>
</ul>
<blockquote>
<p><code>Vec</code>は次の3つを追跡します。</p>
<ul>
<li>予約したヒープ領域への<strong>ポインター</strong></li>
<li>例えばベクター内にある要素の数である、ベクターの<strong>長さ</strong></li>
<li>例えばヒープに予約された領域に収められる要素の数である、ベクターの<strong>容量</strong></li>
</ul>
</blockquote>
<p>This layout should look familiar: it's exactly the same as <code>String</code>!<br />
That's not a coincidence: <code>String</code> is defined as a vector of bytes, <code>Vec&lt;u8&gt;</code>, under the hood:</p>
<blockquote>
<p>このレイアウトは慣れているはずです。それは<code>String</code>と正確に同じです。
これは偶然の一致ではありません。<code>String</code>は、内部的にバイトのベクターである<code>Vec&lt;u8&gt;</code>として定義されています。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct String {
    vec: Vec&lt;u8&gt;,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="exercise-59"><a class="header" href="#exercise-59">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/06_ticket_management/02_vec"><code>06_ticket_management/02_vec</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="resizingリサイズ"><a class="header" href="#resizingリサイズ">Resizing（リサイズ）</a></h1>
<p>We said that <code>Vec</code> is a "growable" vector type, but what does that mean?
What happens if you try to insert an element into a <code>Vec</code> that's already at maximum capacity?</p>
<blockquote>
<p><code>Vec</code>が「成長可能な」ベクター型であると言いましたが、それは何を意味するのでしょうか？
すでに最大容量になっている<code>Vec</code>に要素を挿入することを試みた場合、何が起こるのでしょうか？</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut numbers = Vec::with_capacity(3);
numbers.push(1);
numbers.push(2);
numbers.push(3); // Max capacity reached（最大容量に達した）
numbers.push(4); // What happens here?（ここで何が起こるのか？）
<span class="boring">}</span></code></pre></pre>
<p>The <code>Vec</code> will <strong>resize</strong> itself.<br />
It will ask the allocator for a new (larger) chunk of heap memory, copy the elements over, and deallocate the old memory.</p>
<blockquote>
<p><code>Vec</code>は自分自身で<strong>リサイズ</strong>します。
ヒープメモリの新しく大きな塊をアロケーターに要求して、要素をコピーして、古いメモリを解放します。</p>
</blockquote>
<p>This operation can be expensive, as it involves a new memory allocation and copying all existing elements.</p>
<blockquote>
<p>新しい割り当てと、既存の要素のすべてのコピーを巻き込むため、この操作はコストが高くなる可能性があります。</p>
</blockquote>
<h2 id="vecwith_capacity"><a class="header" href="#vecwith_capacity"><code>Vec::with_capacity</code></a></h2>
<p>If you have a rough idea of how many elements you'll store in a <code>Vec</code>, you can use the <code>Vec::with_capacity</code>
method to pre-allocate enough memory upfront.<br />
This can avoid a new allocation when the <code>Vec</code> grows, but it may waste memory if you overestimate actual usage.</p>
<blockquote>
<p><code>Vec</code>に保存する要素のおおよその数がわかっている場合、前もって十分なメモリを事前割り当てするために<code>Vec::with_capacity</code>メソッドを使用できます。
これは、<code>Vec</code>が成長したとき新しい割り当てを避けることができますが、実際の使用量を過大評価した場合、メモリを浪費するかもしれません。</p>
</blockquote>
<p>Evaluate on a case-by-case basis.</p>
<blockquote>
<p>ケースによって評価することが基本です。</p>
</blockquote>
<h2 id="exercise-60"><a class="header" href="#exercise-60">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/06_ticket_management/03_resizing"><code>06_ticket_management/03_resizing</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iteration反復操作"><a class="header" href="#iteration反復操作">Iteration（反復操作）</a></h1>
<p>During the very first exercises, you learned that Rust lets you iterate over collections using <code>for</code> loops.
We were looking at ranges at that point (e.g. <code>0..5</code>), but the same holds true for collections like arrays and vectors.</p>
<blockquote>
<p>とても前の方の演習の間、Rustが<code>for</code>ループを使用してコレクションを反復操作させることを学びました。
その時、例えば<code>0..5</code>のような範囲を確認しましたが、配列やベクターのようなコレクションについても同じことが当てはまります。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// It works for `Vec`s
// それは`Vec`で機能します。
let v = vec![1, 2, 3];
for n in v {
    println!("{}", n);
}

// It also works for arrays
// それは配列でも機能します。
let a: [u32; 3] = [1, 2, 3];
for n in a {
    println!("{}", n);
}
<span class="boring">}</span></code></pre></pre>
<p>It's time to understand how this works under the hood.</p>
<blockquote>
<p>現在、内部でこれが機能する方法を理解する時間です。</p>
</blockquote>
<h2 id="for-desugaringforの脱糖"><a class="header" href="#for-desugaringforの脱糖"><code>for</code> desugaring（forの脱糖）</a></h2>
<p>Every time you write a <code>for</code> loop in Rust, the compiler <em>desugars</em> it into the following code:</p>
<blockquote>
<p>Rustで<code>for</code>ループを記述するたびに、コンパイラーはそれを次のコードに「脱糖」します。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut iter = IntoIterator::into_iter(v);
loop {
    match iter.next() {
        Some(n) =&gt; {
            println!("{}", n);
        }
        None =&gt; break,
    }
}
<span class="boring">}</span></code></pre></pre>
<p><code>loop</code> is another looping construct, on top of <code>for</code> and <code>while</code>.<br />
A <code>loop</code> block will run forever, unless you explicitly <code>break</code> out of it.</p>
<blockquote>
<p><code>loop</code>は<code>for</code>と<code>while</code>の上にある別のループ構造です。
<code>loop</code>ブロックは、それを明示的に<code>break</code>するまで、永遠に実行されます。</p>
</blockquote>
<h2 id="iterator-traititeratorトレイト"><a class="header" href="#iterator-traititeratorトレイト"><code>Iterator</code> trait（Iteratorトレイト）</a></h2>
<p>The <code>next</code> method in the previous code snippet comes from the <code>Iterator</code> trait.
The <code>Iterator</code> trait is defined in Rust's standard library and provides a shared interface for
types that can produce a sequence of values:</p>
<blockquote>
<p>前のコードスニペットの<code>next</code>メソッドは<code>Iterator</code>トレイトから由来します。
<code>Iterator</code>トレイトはRust標準ライブラリに定義され、値のシーケンスを生成できる型に対して共有されたインターフェイスを提供します。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Iterator {
    type Item;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>Item</code> associated type specifies the type of the values produced by the iterator.</p>
<blockquote>
<p><code>Item</code>関連型は、イテレーターによって生成される値の型を指定します。</p>
</blockquote>
<p><code>next</code> returns the next value in the sequence.<br />
It returns <code>Some(value)</code> if there's a value to return, and <code>None</code> when there isn't.</p>
<blockquote>
<p><code>next</code>はシーケンスの次の値を返します。
値が存在する場合にそれは<code>Some(value)</code>を返し、存在しない場合は<code>None</code>を返します。</p>
</blockquote>
<p>Be careful: there is no guarantee that an iterator is exhausted when it returns <code>None</code>. That's only
guaranteed if the iterator implements the (more restrictive)
<a href="https://doc.rust-lang.org/std/iter/trait.FusedIterator.html"><code>FusedIterator</code></a> trait.</p>
<blockquote>
<p>イテレーターが<code>None</code>を返したとき、イテレーターが使い果たされたことを保証しないことに注意してください。
それは、イテレーターがより制限された<code>FusedIterator</code>トレイトを実装している場合のみ保証されます。</p>
</blockquote>
<h2 id="intoiterator-traitintoiteratorトレイト"><a class="header" href="#intoiterator-traitintoiteratorトレイト"><code>IntoIterator</code> trait（IntoIteratorトレイト）</a></h2>
<p>Not all types implement <code>Iterator</code>, but many can be converted into a type that does.<br />
That's where the <code>IntoIterator</code> trait comes in:</p>
<blockquote>
<p>すべての型が<code>Iterator</code>を実装しているわけではありませんが、多くはその型に変換できます。
ここで<code>IntoIterator</code>トレイトが登場します。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait IntoIterator {
    type Item;
    type IntoIter: Iterator&lt;Item = Self::Item&gt;;
    fn into_iter(self) -&gt; Self::IntoIter;
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>into_iter</code> method consumes the original value and returns an iterator over its elements.<br />
A type can only have one implementation of <code>IntoIterator</code>: there can be no ambiguity as to what <code>for</code> should desugar to.</p>
<blockquote>
<p><code>into_iter</code>メソッドは、オリジナルの値を消費して、その要素のイテレーターを返します。
型は<code>IntoIterator</code>の実装を1つだけ持つことができ、<code>for</code>がどのように脱糖されるべきかについての曖昧さはありません。</p>
</blockquote>
<p>One detail: every type that implements <code>Iterator</code> automatically implements <code>IntoIterator</code> as well.
They just return themselves from <code>into_iter</code>!</p>
<blockquote>
<p>1つの詳細: <code>Iterator</code>を実装するすべての型は、自動的に<code>IntoIterator</code>も同様に実装します。
それらは単に、<code>into_iter</code>から返されたそれら自身を返します。</p>
</blockquote>
<h2 id="bounds-checks境界チェック"><a class="header" href="#bounds-checks境界チェック">Bounds checks（境界チェック）</a></h2>
<p>Iterating over iterators has a nice side effect: you can't go out of bounds, by design.<br />
This allows Rust to remove bounds checks from the generated machine code, making iteration faster.</p>
<blockquote>
<p>イテレーターの反復操作は、良い副作用があります。設計上、境界を超えることはできません。
これは、Rustに生成された機械語から境界チェックを削除することを許可するため、反復操作を高速にします。</p>
</blockquote>
<p>In other words,</p>
<blockquote>
<p>言い換えれば・・・</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = vec![1, 2, 3];
for n in v {
    println!("{}", n);
}
<span class="boring">}</span></code></pre></pre>
<p>is usually faster than</p>
<blockquote>
<p>通常、上記は次よりも早いです。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = vec![1, 2, 3];
for i in 0..v.len() {
    println!("{}", v[i]);
}
<span class="boring">}</span></code></pre></pre>
<p>There are exceptions to this rule: the compiler can sometimes prove that you're not going out of bounds even
with manual indexing, thus removing the bounds checks anyway. But in general, prefer iteration to indexing
where possible.</p>
<blockquote>
<p>このルールには例外があります。
時々、コンパイラーは、手動でインデックスで指定しても境界を越えていないことを証明できるため、その場合は境界チェックが削除されます。
ただし、可能であれば、インデックスよりも反復処理を優先してください。</p>
</blockquote>
<h2 id="exercise-61"><a class="header" href="#exercise-61">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/06_ticket_management/04_iterators"><code>06_ticket_management/04_iterators</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iter"><a class="header" href="#iter"><code>.iter()</code></a></h1>
<p><code>IntoIterator</code> <strong>consumes</strong> <code>self</code> to create an iterator.</p>
<blockquote>
<p><code>IntoIterator</code>は、イテレーターを作成するために<code>self</code>を<strong>消費</strong>します。</p>
</blockquote>
<p>This has its benefits: you get <strong>owned</strong> values from the iterator.
For example: if you call <code>.into_iter()</code> on a <code>Vec&lt;Ticket&gt;</code> you'll get an iterator that returns <code>Ticket</code> values.</p>
<blockquote>
<p>これには利点があります。イテレーターから値を<strong>所有</strong>できることです。
例えば、<code>Vec&lt;Ticket&gt;</code>に<code>.into_iter()</code>を呼び出した場合、<code>Ticket</code>値を返すイテレーターを得られます。</p>
</blockquote>
<p>That's also its downside: you can no longer use the original collection after calling <code>.into_iter()</code> on it.
Quite often you want to iterate over a collection without consuming it, looking at <strong>references</strong> to the values instead.
In the case of <code>Vec&lt;Ticket&gt;</code>, you'd want to iterate over <code>&amp;Ticket</code> values.</p>
<blockquote>
<p>またこれには欠点があります。それに<code>.into_iter()</code>を呼び出した後、もはやオリジナルのコレクションを使用できなくなることです。
かなりの頻度で、コレクションを消費することなく、代わりに値の<strong>参照</strong>を確認するために、コレクションを反復操作していときがあります。
<code>Vec&lt;Ticket&gt;</code>の場合、<code>&amp;Ticket</code>値を反復操作したいと思います。</p>
</blockquote>
<p>Most collections expose a method called <code>.iter()</code> that returns an iterator over references to the collection's elements.
For example:</p>
<blockquote>
<p>ほとんどのコレクションは、コレクションの要素への参照を返すイテレーターを返す<code>.iter()</code>と呼ばれるメソッドを公開しています。
例えば・・・</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let numbers: Vec&lt;u32&gt; = vec![1, 2];
// `n` has type `&amp;u32` here
for n in numbers.iter() {
    // [...]
}
<span class="boring">}</span></code></pre></pre>
<p>This pattern can be simplified by implementing <code>IntoIterator</code> for a <strong>reference to the collection</strong>.
In our example above, that would be <code>&amp;Vec&lt;Ticket&gt;</code>.<br />
The standard library does this, that's why the following code works:</p>
<blockquote>
<p>このパターンは、<strong>コレクションへの参照</strong>に対して、<code>IntoIterator</code>を実装することで簡略化できます。
上記例において、それは<code>&amp;Vec&lt;Ticket&gt;</code>です。
標準ライブラリはこれを行うため、次のコードは機能します。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let numbers: Vec&lt;u32&gt; = vec![1, 2];
// `n` has type `&amp;u32` here
// We didn't have to call `.iter()` explicitly
// It was enough to use `&amp;numbers` in the `for` loop
// ここで`n`は`&amp;u32`型です。
// 明示的に`.iter()`を呼び出す必要はありません。
// それは`for`ループで`&amp;numbers`を使用するだけで十分でした。
for n in &amp;numbers {
    // [...]
}
<span class="boring">}</span></code></pre></pre>
<p>It's idiomatic to provide both options:</p>
<ul>
<li>An implementation of <code>IntoIterator</code> for a reference to the collection.</li>
<li>An <code>.iter()</code> method that returns an iterator over references to the collection's elements.</li>
</ul>
<blockquote>
<p>それは次の両方の選択肢を提供することは慣用的です。</p>
<ul>
<li>コレクションへの参照に対する<code>IntoIterator</code>の実装</li>
<li>コレクションの要素への参照に対するイテレーターを返す<code>.iter()</code>メソッド</li>
</ul>
</blockquote>
<p>The former is convenient in <code>for</code> loops, the latter is more explicit and can be used in other contexts.</p>
<blockquote>
<p>前者は<code>for</code>ループで便利で、後者はより明示的に他の文脈で使用されます。</p>
</blockquote>
<h2 id="exercise-62"><a class="header" href="#exercise-62">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/06_ticket_management/05_iter"><code>06_ticket_management/05_iter</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lifetimesライブタイム"><a class="header" href="#lifetimesライブタイム">Lifetimes（ライブタイム）</a></h1>
<p>Let's try to complete the previous exercise by adding an implementation of <code>IntoIterator</code> for <code>&amp;TicketStore</code>, for
maximum convenience in <code>for</code> loops.</p>
<blockquote>
<p><code>for</code>ループを最大限に便利にするために、<code>&amp;TicketStore</code>に対して<code>IntoIterator</code>の実装を追加して、前の演習を完成することを試みましょう。</p>
</blockquote>
<p>Let's start by filling in the most "obvious" parts of the implementation:</p>
<blockquote>
<p>実装の最も「明確な」部分を埋めることから始めましょう。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl IntoIterator for &amp;TicketStore {
    type Item = &amp;Ticket;
    type IntoIter = // What goes here?

    fn into_iter(self) -&gt; Self::IntoIter {
        self.tickets.iter()
    }
}
<span class="boring">}</span></code></pre></pre>
<p>What should <code>type IntoIter</code> be set to?<br />
Intuitively, it should be the type returned by <code>self.tickets.iter()</code>, i.e. the type returned by <code>Vec::iter()</code>.<br />
If you check the standard library documentation, you'll find that <code>Vec::iter()</code> returns an <code>std::slice::Iter</code>.
The definition of <code>Iter</code> is:</p>
<blockquote>
<p><code>type IntoIter</code>は何を設定するべきでしょうか？
直感的に、それは、<code>self.tickets.iter()</code>によって返される型、例えば<code>Vec::iter()</code>によって返される型であるべきです。
標準ライブラリのドキュメントを確認した場合、<code>Vec::iter()</code>は<code>std::slice::Iter</code>を返すことを見つけるはずです。
<code>Iter</code>の定義は・・・</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Iter&lt;'a, T&gt; { /* fields omitted */ }
<span class="boring">}</span></code></pre></pre>
<p><code>'a</code> is a <strong>lifetime parameter</strong>.</p>
<blockquote>
<p><code>'a</code>は<strong>ライフタイムパラメーター</strong>です。</p>
</blockquote>
<h2 id="lifetime-parametersライフタイムパラメーター"><a class="header" href="#lifetime-parametersライフタイムパラメーター">Lifetime parameters（ライフタイムパラメーター）</a></h2>
<p>Lifetimes are <strong>labels</strong> used by the Rust compiler to keep track of how long a reference (either mutable or
immutable) is valid.<br />
The lifetime of a reference is constrained by the scope of the value it refers to. Rust always makes sure, at compile-time,
that references are not used after the value they refer to has been dropped, to avoid dangling pointers and use-after-free bugs.</p>
<blockquote>
<p>ライフタイムは、可変または不変参照が有効な長さを追跡するためにRustコンパイラーによって使用されます。
参照のライフタイムは、それが参照する値のスコープによって制限されます。
Rustは、ダングリングポインターと解放された後に使用するバグを避けるために、コンパイル時に、参照している値がドロップされた後で、参照が使用されないことを常に確認します。</p>
</blockquote>
<p>This should sound familiar: we've already seen these concepts in action when we discussed ownership and borrowing.
Lifetimes are just a way to <strong>name</strong> how long a specific reference is valid.</p>
<blockquote>
<p>これは、おなじみのはずです。所有権と借用を議論した後に、実際にこれらの概念をすでに確認しました。
ライフタイムは、特定の参照が有効な期間を<strong>名前付け</strong>する単なる方法です。</p>
</blockquote>
<p>Naming becomes important when you have multiple references and you need to clarify how they <strong>relate to each other</strong>.
Let's look at the signature of <code>Vec::iter()</code>:</p>
<blockquote>
<p>複数の参照があり、それらがどのように<strong>お互いに関連している</strong>かを明確にする必要があるとき、名前付けは重要になります。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl &lt;T&gt; Vec&lt;T&gt; {
    // Slightly simplified
    // 少し簡略化してあります。
    pub fn iter&lt;'a&gt;(&amp;'a self) -&gt; Iter&lt;'a, T&gt; {
        // [...]
    }
}
<span class="boring">}</span></code></pre></pre>
<p><code>Vec::iter()</code> is generic over a lifetime parameter, named <code>'a</code>.<br />
<code>'a</code> is used to <strong>tie together</strong> the lifetime of the <code>Vec</code> and the lifetime of the <code>Iter</code> returned by <code>iter()</code>.
In plain English: the <code>Iter</code> returned by <code>iter()</code> cannot outlive the <code>Vec</code> reference (<code>&amp;self</code>) it was created from.</p>
<blockquote>
<p><code>Vec::iter()</code>は、<code>'a</code>という名前が付けられた、ジェネリックなライフタイムパラメーターです。
<code>'a</code>は、<code>Vec</code>のライフタイムと<code>iter()</code>によって返される<code>Iter</code>のライフタイムを<strong>一緒に縛り付ける</strong>ために使用されます。
簡単な英語で言えば、<code>Iter()</code>によって返された<code>Iter</code>は、それが作成された<code>Vec</code>の参照（<code>&amp;self</code>）よりも長生きできません。</p>
</blockquote>
<p>This is important because <code>Vec::iter</code>, as we discussed, returns an iterator over <strong>references</strong> to the <code>Vec</code>'s elements.
If the <code>Vec</code> is dropped, the references returned by the iterator would be invalid. Rust must make sure this doesn't happen,
and lifetimes are the tool it uses to enforce this rule.</p>
<blockquote>
<p>議論したように<code>Vec::iter</code>は、<code>Vec</code>の要素への参照を返すイテレーターを返すため重要です。
<code>Vec</code>がドロップされた場合、そのイテレーターによって返された参照は無効になります。
Rustは、これが発生しないことを確実にしなければならず、ライフタイムはこのルールを強制するために使用されるツールです。</p>
</blockquote>
<h2 id="lifetime-elisionライフタイムの省略"><a class="header" href="#lifetime-elisionライフタイムの省略">Lifetime elision（ライフタイムの省略）</a></h2>
<p>Rust has a set of rules, called <strong>lifetime elision rules</strong>, that allow you to omit explicit lifetime annotations in many cases.
For example, <code>Vec::iter</code>'s definition looks like this in <code>std</code>'s source code:</p>
<blockquote>
<p>Rustは<strong>ライフタイムの省略ルール</strong>と呼ばれるルールの集合を持っており、多くの場合で明示的なライフタイム注釈を省略することができます。
例えば、<code>Vec::iter</code>の定義は、<code>std</code>のソースコードでは次のようになります。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl &lt;T&gt; Vec&lt;T&gt; {
    pub fn iter(&amp;self) -&gt; Iter&lt;'_, T&gt; {
        // [...]
    }
}
<span class="boring">}</span></code></pre></pre>
<p>No explicit lifetime parameter is present in the signature of <code>Vec::iter()</code>.
Elision rules imply that the lifetime of the <code>Iter</code> returned by <code>iter()</code> is tied to the lifetime of the <code>&amp;self</code> reference.
You can think of <code>'_</code> as a <strong>placeholder</strong> for the lifetime of the <code>&amp;self</code> reference.</p>
<blockquote>
<p><code>Vec::iter()</code>のシグネチャーに、明示的なライフタイムパラメーターは存在しません。
省略ルールは、<code>iter()</code>によって返された<code>Iter</code>のライフタイムは、<code>&amp;self</code>参照のライフタイムに縛り付けられていることを暗示します。
<code>'_</code>を<code>&amp;self</code>参照のライフタイムの<strong>プレースホルダー</strong>として考えれます。</p>
</blockquote>
<p>See the <a href="06_ticket_management/06_lifetimes.html#references">References</a> section for a link to the official documentation on lifetime elision.<br />
In most cases, you can rely on the compiler telling you when you need to add explicit lifetime annotations.</p>
<blockquote>
<p>ライフタイムの省略に関する公式ドキュメントへのリンクについては、参照節を参照してください。
ほとんどの場合、明示的なライフタイム注釈を追加する必要があるときは、コンパイラーからの通知に頼れます。</p>
</blockquote>
<h2 id="references"><a class="header" href="#references">References</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.iter">std::vec::Vec::iter</a></li>
<li><a href="https://doc.rust-lang.org/std/slice/struct.Iter.html">std::slice::Iter</a></li>
<li><a href="https://doc.rust-lang.org/reference/lifetime-elision.html">Lifetime elision rules</a></li>
</ul>
<h2 id="exercise-63"><a class="header" href="#exercise-63">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/06_ticket_management/06_lifetimes"><code>06_ticket_management/06_lifetimes</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="combinatorsコンビネーター"><a class="header" href="#combinatorsコンビネーター">Combinators（コンビネーター）</a></h1>
<p>Iterators can do so much more than <code>for</code> loops!<br />
If you look at the documentation for the <code>Iterator</code> trait, you'll find a <strong>vast</strong> collections of
methods that you can leverage to transform, filter, and combine iterators in various ways.</p>
<blockquote>
<p>イテレーターは<code>for</code>ループ以上のことができます！
<code>Iterator</code>トレイトのドキュメントを確認した場合、さまざまな方法でイテレーターを変換、フィルターそして結合して利用するメソッドの<strong>膨大な</strong>コレクションを見つけるでしょう。</p>
</blockquote>
<p>Let's mention the most common ones:</p>
<ul>
<li><code>map</code> applies a function to each element of the iterator.</li>
<li><code>filter</code> keeps only the elements that satisfy a predicate.</li>
<li><code>filter_map</code> combines <code>filter</code> and <code>map</code> in one step.</li>
<li><code>cloned</code> converts an iterator of references into an iterator of values, cloning each element.</li>
<li><code>enumerate</code> returns a new iterator that yields <code>(index, value)</code> pairs.</li>
<li><code>skip</code> skips the first <code>n</code> elements of the iterator.</li>
<li><code>take</code> stops the iterator after <code>n</code> elements.</li>
<li><code>chain</code> combines two iterators into one.</li>
</ul>
<blockquote>
<p>最も一般的なものを言及しましょう。</p>
<ul>
<li><code>map</code>は、イテレーターのそれぞれの要素に関数を適用します。</li>
<li><code>filter</code>は、述語を満足する要素のみを保持します。</li>
<li><code>filter_map</code>は、1ステップで<code>filter</code>と<code>map</code>を組み合わせます。</li>
<li><code>cloned</code>は、それぞれの要素をクローンして、参照のイテレーターを値のイテレーターに変換します。</li>
<li><code>enumerate</code>は、<code>(index, value)</code>のペアを生成する新しいイテレーターを返します。</li>
<li><code>skip</code>はイテレーターの最初の<code>n</code>要素をスキップします。</li>
<li><code>take</code>は、<code>n</code>要素後にイテレーターを停止します。</li>
<li><code>chain</code>は、2つのイテレーターを1つに結合します。</li>
</ul>
</blockquote>
<p>These methods are called <strong>combinators</strong>.<br />
They are usually <strong>chained</strong> together to create complex transformations in a concise and readable way:</p>
<blockquote>
<p>これらのメソッドは<strong>コンビネーター</strong>と呼ばれます。
それらは、通常、簡潔で読みやすい方法で、複雑な変換を作成するために一緒に<strong>連鎖</strong>されます。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let numbers = vec![1, 2, 3, 4, 5];
// The sum of the squares of the even numbers
// 偶数の二乗の合計
let outcome: u32 = numbers.iter()
    .filter(|&amp;n| n % 2 == 0)
    .map(|&amp;n| n * n)
    .sum();
<span class="boring">}</span></code></pre></pre>
<h2 id="closuresクロージャー"><a class="header" href="#closuresクロージャー">Closures（クロージャー）</a></h2>
<p>What's going on with the <code>filter</code> and <code>map</code> methods above?<br />
They take <strong>closures</strong> as arguments.</p>
<blockquote>
<p>上記の<code>filter</code>と<code>map</code>メソッドは何をしているのでしょうか？
それらは引数として<strong>クロージャー</strong>を受け取ります。</p>
</blockquote>
<p>Closures are <strong>anonymous functions</strong>, i.e. functions that are not defined using the <code>fn</code> syntax we are used to.<br />
They are defined using the <code>|args| body</code> syntax, where <code>args</code> are the arguments and <code>body</code> is the function body.
<code>body</code> can be a block of code or a single expression.
For example:</p>
<blockquote>
<p>クロージャーは<strong>匿名関数</strong>です。つまり、使用してきた<code>fn</code>構文を使用して定義されない関数です。
それらは<code>|args| body</code>構文を使用して定義され、<code>args</code>は引数で<code>body</code>は関数の本体です。
<code>body</code>はコードのブロックまたは、単独の式になります。
例えば・・・</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// An anonymous function that adds 1 to its argument
// 引数に1を足す匿名関数
let add_one = |x| x + 1;
// Could be written with a block too:
// ブロックで記述することもできます。
let add_one = |x| { x + 1 };
<span class="boring">}</span></code></pre></pre>
<p>Closures can take more than one argument:</p>
<blockquote>
<p>クロージャーは1つ以上の引数を受け取ることができます。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let add = |x, y| x + y;
let sum = add(1, 2);
<span class="boring">}</span></code></pre></pre>
<p>They can also capture variables from their environment:</p>
<blockquote>
<p>それらは、それらの環境から変数をキャプチャーすることもできます。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 42;
let add_x = |y| x + y;
let sum = add_x(1);
<span class="boring">}</span></code></pre></pre>
<p>If necessary, you can specify the types of the arguments and/or the return type:</p>
<blockquote>
<p>必要に応じて、引数の型及び戻り値の型を指定できます。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Just the input type
// 単なる引数の型です。
let add_one = |x: i32| x + 1;
// Or both input and output types, using the `fn` syntax
// `fn`構文を使用した、引数と出力の型の両方です。
let add_one: fn(i32) -&gt; i32 = |x| x + 1;
<span class="boring">}</span></code></pre></pre>
<h2 id="collect"><a class="header" href="#collect"><code>collect</code></a></h2>
<p>What happens when you're done transforming an iterator using combinators?<br />
You either iterate over the transformed values using a <code>for</code> loop, or you collect them into a collection.</p>
<blockquote>
<p>コンビネーターを使用してイテレータを変換した後、何が起こるでしょうか？
<code>for</code>ループを使用して変換された値を反復処理することも、コレクション内にそれらを集めることもできます。</p>
</blockquote>
<p>The latter is done using the <code>collect</code> method.<br />
<code>collect</code> consumes the iterator and collects its elements into a collection of your choice.</p>
<blockquote>
<p>後者は、<code>collect</code>メソッドを使用して行われます。
<code>collect</code>はイテレーターを消費して、選択したコレクション内にその要素を集めます。</p>
</blockquote>
<p>For example, you can collect the squares of the even numbers into a <code>Vec</code>:</p>
<blockquote>
<p>例えば、<code>Vec</code>に偶数の二乗を集めることができます。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let numbers = vec![1, 2, 3, 4, 5];
let squares_of_evens: Vec&lt;u32&gt; = numbers.iter()
    .filter(|&amp;n| n % 2 == 0)
    .map(|&amp;n| n * n)
    .collect();
<span class="boring">}</span></code></pre></pre>
<p><code>collect</code> is generic over its <strong>return type</strong>.<br />
Therefore you usually need to provide a type hint to help the compiler infer the correct type.
In the example above, we annotated the type of <code>squares_of_evens</code> to be <code>Vec&lt;u32&gt;</code>.
Alternatively, you can use the <strong>turbofish syntax</strong> to specify the type:</p>
<blockquote>
<p><code>collect</code>は、その<strong>戻り値の型</strong>に対してジェネリックです。
従って、通常、コンパイラーが正確な型を推論することを助けるために、型ヒントを提供する必要があります。
上記の例において、<code>squares_of_evens</code>の型が<code>Vec&lt;u32&gt;</code>になることを注釈しました。
代わりに、型を指定するために<strong>ターボフィッシュ構文</strong>を使用できます。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let squares_of_evens = numbers.iter()
    .filter(|&amp;n| n % 2 == 0)
    .map(|&amp;n| n * n)
    // Turbofish syntax: `&lt;method_name&gt;::&lt;type&gt;()`
    // It's called turbofish because `::&lt;&gt;` looks like a fish
    // ターボフィッシュ構文: `&lt;メソッド名&gt;::&lt;型&gt;()`
    // `::&lt;&gt;`が魚のように見えるため、ターボフィッシュと呼ばれます。
    .collect::&lt;Vec&lt;u32&gt;&gt;();
<span class="boring">}</span></code></pre></pre>
<h2 id="further-reading参考資料-9"><a class="header" href="#further-reading参考資料-9">Further reading（参考資料）</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html"><code>Iterator</code>'s documentation</a> gives you an
overview of the methods available for iterators in <code>std</code>.</li>
<li><a href="https://docs.rs/itertools/">The <code>itertools</code> crate</a> defines even <strong>more</strong> combinators for iterators.</li>
</ul>
<h2 id="exercise-64"><a class="header" href="#exercise-64">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/06_ticket_management/07_combinators"><code>06_ticket_management/07_combinators</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="impl-trait"><a class="header" href="#impl-trait"><code>impl Trait</code></a></h1>
<p><code>TicketStore::to_dos</code> returns a <code>Vec&lt;&amp;Ticket&gt;</code>.<br />
That signature introduces a new heap allocation every time <code>to_dos</code> is called, which may be unnecessary depending
on what the caller needs to do with the result.
It'd be better if <code>to_dos</code> returned an iterator instead of a <code>Vec</code>, thus empowering the caller to decide whether to
collect the results into a <code>Vec</code> or just iterate over them.</p>
<blockquote>
<p><code>TicketStore::to_dos</code>は<code>Vec&lt;&amp;Ticket&gt;</code>を返します。
そのシグネチャーは、<code>to_dos</code>が呼ばれるたびに新しいヒープ割り当てを招き、それは呼び出し側が結果で行う必要があることによって、不必要になるかもしれません。
<code>to_dos</code>が<code>Vec</code>の代わりにイテレーターを返したほうが良く、それにより呼び出し側が<code>Vec</code>に結果を集めるか、それらを単に反復操作するか決定することができます。</p>
</blockquote>
<p>That's tricky though!
What's the return type of <code>to_dos</code>, as implemented below?</p>
<blockquote>
<p>ただし、それはトリッキーです。
次に実装された<code>to_dos</code>の戻り値の型は何でしょうか？</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl TicketStore {
    pub fn to_dos(&amp;self) -&gt; ??? {
        self.tickets.iter().filter(|t| t.status == Status::ToDo)
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="unnameable-types名前を持たない型"><a class="header" href="#unnameable-types名前を持たない型">Unnameable types（名前を持たない型）</a></h2>
<p>The <code>filter</code> method returns an instance of <code>std::iter::Filter</code>, which has the following definition:</p>
<blockquote>
<p><code>filter</code>メソッドは<code>std::iter::Filter</code>のインスタンスを返し、それは次の定義を持ちます。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Filter&lt;I, P&gt; { /* fields omitted */ }
<span class="boring">}</span></code></pre></pre>
<p>where <code>I</code> is the type of the iterator being filtered on and <code>P</code> is the predicate used to filter the elements.<br />
We know that <code>I</code> is <code>std::slice::Iter&lt;'_, Ticket&gt;</code> in this case, but what about <code>P</code>?<br />
<code>P</code> is a closure, an <strong>anonymous function</strong>. As the name suggests, closures don't have a name,
so we can't write them down in our code.</p>
<blockquote>
<p><code>I</code>はフィルターされるイテレーターの型で、<code>P</code>は要素をフィルターする述語です。
この場合、<code>I</code>は<code>std::slice::Iter&lt;'_, Ticket&gt;</code>であることを知っていますが、<code>P</code>についてはどうでしょうか？</p>
</blockquote>
<p>Rust has a solution for this: <strong>impl Trait</strong>.</p>
<blockquote>
<p>Rustはこのための解決策があります。それは<strong>impl Trait</strong>です。</p>
</blockquote>
<h2 id="impl-trait-1"><a class="header" href="#impl-trait-1"><code>impl Trait</code></a></h2>
<p><code>impl Trait</code> is a feature that allows you to return a type without specifying its name.
You just declare what trait(s) the type implements, and Rust figures out the rest.</p>
<blockquote>
<p><code>impl Trait</code>は、その名前を指定されずに型を返すことができる機能です。
型がどのトレイトを実装しているかだけを宣言して、Rustが残りを見出します。</p>
</blockquote>
<p>In this case, we want to return an iterator of references to <code>Ticket</code>s:</p>
<blockquote>
<p>この場合、<code>Ticket</code>への参照のイテレーターを返したいです。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl TicketStore {
    pub fn to_dos(&amp;self) -&gt; impl Iterator&lt;Item = &amp;Ticket&gt; {
        self.tickets.iter().filter(|t| t.status == Status::ToDo)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>That's it!</p>
<blockquote>
<p>これだけです。</p>
</blockquote>
<h2 id="generic"><a class="header" href="#generic">Generic?</a></h2>
<p><code>impl Trait</code> in return position is <strong>not</strong> a generic parameter.</p>
<blockquote>
<p><code>戻り値の位置にある</code>impl Trait`は、ジェネリックパラメーターでは<strong>ありません</strong>。</p>
</blockquote>
<p>Generics are placeholders for types that are filled in by the caller of the function.
A function with a generic parameter is <strong>polymorphic</strong>: it can be called with different types, and the compiler will generate
a different implementation for each type.</p>
<blockquote>
<p>ジェネリックは、関数の呼び出し側によって充填される型に対するプレースホルダーです。
ジェネリックパラメーターを持つ関数は<strong>多態性</strong>です。
それは、異なる型で呼び出されることができ、コンパイラーはそれぞれの方に対して異なる実装を生成します。</p>
</blockquote>
<p>That's not the case with <code>impl Trait</code>.
The return type of a function with <code>impl Trait</code> is <strong>fixed</strong> at compile time, and the compiler will generate
a single implementation for it.
This is why <code>impl Trait</code> is also called <strong>opaque return type</strong>: the caller doesn't know the exact type of the return value,
only that it implements the specified trait(s). But the compiler knows the exact type, there is no polymorphism involved.</p>
<blockquote>
<p><code>impl Trait</code>の場合はそうではありません。
<code>impl Trait</code>を持つ関数の戻り値の型は、コンパイル時に<strong>固定</strong>され、コンパイラーはそれに対して単一の実装を生成します。
これが、<code>impl Trait</code>が<strong>不透明な戻り値型</strong>とも呼ばれる理由です。
呼び出し側は戻り値の正確な型を知りませんが、それが指定されたトレイトを実装していることのみを知っています。
しかし、コンパイラーは正確な型を知っており、多態性は発生しません。</p>
</blockquote>
<h2 id="rpit"><a class="header" href="#rpit">RPIT</a></h2>
<p>If you read RFCs or deep-dives about Rust, you might come across the acronym <strong>RPIT</strong>.<br />
It stands for <strong>"Return Position Impl Trait"</strong> and refers to the use of <code>impl Trait</code> in return position.</p>
<blockquote>
<p>Rustに関するRFCまたは深い探求をを読んでいる場合、<strong>RPIT</strong>という頭字語に出くわすかもしれません。
それは、<strong>「戻り値の位置のImpl Trait」</strong> からなり、戻り値の位置で<code>impl Trait</code>を使用することを示しています。</p>
</blockquote>
<h2 id="exercise-65"><a class="header" href="#exercise-65">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/06_ticket_management/08_impl_trait"><code>06_ticket_management/08_impl_trait</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="impl-trait-in-argument-position引数の位置にあるimpl-trait"><a class="header" href="#impl-trait-in-argument-position引数の位置にあるimpl-trait"><code>impl Trait</code> in argument position（引数の位置にあるimpl Trait）</a></h1>
<p>In the previous section, we saw how <code>impl Trait</code> can be used to return a type without specifying its name.<br />
The same syntax can also be used in <strong>argument position</strong>:</p>
<blockquote>
<p>前の節において、その名前を指定しないで型を返すために<code>impl Trait</code>を使用する方法を確認しました。
同じ構文は、<strong>引数の位置</strong>でも使用できます。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn print_iter(iter: impl Iterator&lt;Item = i32&gt;) {
    for i in iter {
        println!("{}", i);
    }
}
<span class="boring">}</span></code></pre></pre>
<p><code>print_iter</code> takes an iterator of <code>i32</code>s and prints each element.<br />
When used in <strong>argument position</strong>, <code>impl Trait</code> is equivalent to a generic parameter with a trait bound:</p>
<blockquote>
<p><code>print_iter</code>は、<code>i32</code>のイテレーターを受け取り、それぞれの要素を出力します。
<strong>引数の位置</strong>で使用された場合、<code>impl Trait</code>はトレイト境界を持つジェネリックなパラメーターと同じです。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn print_iter&lt;T&gt;(iter: T)
where
    T: Iterator&lt;Item = i32&gt;
{
    for i in iter {
        println!("{}", i);
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="downsides欠点"><a class="header" href="#downsides欠点">Downsides（欠点）</a></h2>
<p>As a rule of thumb, prefer generics over <code>impl Trait</code> in argument position.<br />
Generics allow the caller to explicitly specify the type of the argument, using the turbofish syntax (<code>::&lt;&gt;</code>),
which can be useful for disambiguation. That's not the case with <code>impl Trait</code>.</p>
<blockquote>
<p>経験則として、引数の位置に<code>impl Trait</code>よりもジェネリックを好むようにしてください。
ジェネリックは、ターボフィッシュ構文（<code>::&lt;&gt;</code>）を使用して、呼び出し側に引数の型を明示的に指定できるようにして、曖昧さを解消するために役立ちます。
それは<code>impl Trait</code>を使用したケースには当てはまりません。</p>
</blockquote>
<h2 id="exercise-66"><a class="header" href="#exercise-66">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/06_ticket_management/09_impl_trait_2"><code>06_ticket_management/09_impl_trait_2</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="slicesスライス"><a class="header" href="#slicesスライス">Slices（スライス）</a></h1>
<p>Let's go back to the memory layout of a <code>Vec</code>:</p>
<blockquote>
<p><code>Vec</code>のメモリレイアウトに戻りましょう。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut numbers = Vec::with_capacity(3);
numbers.push(1);
numbers.push(2);
<span class="boring">}</span></code></pre></pre>
<pre><code class="language-text">      +---------+--------+----------+
Stack | pointer | length | capacity |
      |  |      |   2    |    3     |
      +--|------+--------+----------+
         |
         |
         v
       +---+---+---+
Heap:  | 1 | 2 | ? |
       +---+---+---+
</code></pre>
<p>We already remarked how <code>String</code> is just a <code>Vec&lt;u8&gt;</code> in disguise.<br />
The similarity should prompt you to ask: "What's the equivalent of <code>&amp;str</code> for <code>Vec</code>?"</p>
<blockquote>
<p><code>String</code>が単なる<code>Vec&lt;u8&gt;</code>の変装であることをすでに述べました。
この類似性は、「<code>Vec</code>に対して<code>&amp;str</code>に相当するものはなんですか？」と質問することを促すはずです。</p>
</blockquote>
<h2 id="t"><a class="header" href="#t"><code>&amp;[T]</code></a></h2>
<p><code>[T]</code> is a <strong>slice</strong> of a contiguous sequence of elements of type <code>T</code>.<br />
It's most commonly used in its borrowed form, <code>&amp;[T]</code>.</p>
<blockquote>
<p><code>[T]</code>は、型<code>T</code>の要素の連続したシーケンスの<strong>スライス</strong>です。
それは、その借用された形式である<code>&amp;[T]</code>として最も一般的に使用されます。</p>
</blockquote>
<p>There are various ways to create a slice reference from a <code>Vec</code>:</p>
<blockquote>
<p><code>Vec</code>からスライス参照を作成する方法がいくつかあります。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let numbers = vec![1, 2, 3];
// Via index syntax
// インデックス構文を介して
let slice: &amp;[i32] = &amp;numbers[..];
// Via a method
// メソッドを介して
let slice: &amp;[i32] = numbers.as_slice();
// Or for a subset of the elements
// また、要素のサブセットの場合
let slice: &amp;[i32] = &amp;numbers[1..];
<span class="boring">}</span></code></pre></pre>
<p><code>Vec</code> implements the <code>Deref</code> trait using <code>[T]</code> as the target type, so you can use slice methods on a <code>Vec</code> directly
thanks to deref coercion:</p>
<blockquote>
<p><code>Vec</code>は、目的の型として<code>[T]</code>を使用した<code>Deref</code>トレイトを実装しているため、参照外し型強制のおかげて、スライスメソッドに直接<code>Vec</code>を使用できます。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let numbers = vec![1, 2, 3];
// Surprise, surprise: `iter` is not a method on `Vec`!
// It's a method on `&amp;[T]`, but you can call it on a `Vec`
// thanks to deref coercion.
// 驚き、驚き: `iter`は`Vec`のメソッドではありません！
// それは`&amp;[T]`のメソッドですが、参照外し型強制のおかげで`Vec`でそれを呼び出せます。
let sum: i32 = numbers.iter().sum();
<span class="boring">}</span></code></pre></pre>
<h3 id="memory-layoutメモリレイアウト-3"><a class="header" href="#memory-layoutメモリレイアウト-3">Memory layout（メモリレイアウト）</a></h3>
<p>A <code>&amp;[T]</code> is a <strong>fat pointer</strong>, just like <code>&amp;str</code>.<br />
It consists of a pointer to the first element of the slice and the length of the slice.</p>
<blockquote>
<p><code>&amp;[T]</code>は、ちょうど<code>&amp;str</code>のように<strong>ファットポインター</strong>です。
それは、スライスの最初の要素を指し示すポインターと、スライスの長さで構成されています。</p>
</blockquote>
<p>If you have a <code>Vec</code> with three elements:</p>
<blockquote>
<p>3つの要素を持つ<code>Vec</code>がある場合・・・</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let numbers = vec![1, 2, 3];
<span class="boring">}</span></code></pre></pre>
<p>and then create a slice reference:</p>
<blockquote>
<p>そして、スライスの参照を作成すると・・・</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let slice: &amp;[i32] = &amp;numbers[1..];
<span class="boring">}</span></code></pre></pre>
<p>you'll get this memory layout:</p>
<blockquote>
<p>次のメモリレイアウトが得られます。</p>
</blockquote>
<pre><code class="language-text">                  numbers                          slice
      +---------+--------+----------+      +---------+--------+
Stack | pointer | length | capacity |      | pointer | length |
      |    |    |   3    |    4     |      |    |    |   2    |
      +----|----+--------+----------+      +----|----+--------+
           |                                    |
           |                                    |
           v                                    |
         +---+---+---+---+                      |
Heap:    | 1 | 2 | 3 | ? |                      |
         +---+---+---+---+                      |
               ^                                |
               |                                |
               +--------------------------------+
</code></pre>
<h3 id="vect-vs-t"><a class="header" href="#vect-vs-t"><code>&amp;Vec&lt;T&gt;</code> vs <code>&amp;[T]</code></a></h3>
<p>When you need to pass an immutable reference to a <code>Vec</code> to a function, prefer <code>&amp;[T]</code> over <code>&amp;Vec&lt;T&gt;</code>.<br />
This allows the function to accept any kind of slice, not necessarily one backed by a <code>Vec</code>.</p>
<blockquote>
<p>関数に<code>Vec</code>への不変参照を渡す必要があるとき、<code>&amp;Vec&lt;T&gt;</code>よりも<code>&amp;[T]</code>を選択してください。
これは、必ず<code>Vec</code>によってサーポートされる物に限らず、関数に任意の種類のスライスにアクセスできるようにします。</p>
</blockquote>
<p>For example, you can then pass a subset of the elements in a <code>Vec</code>.
But it goes further than that—you could also pass a <strong>slice of an array</strong>:</p>
<blockquote>
<p>例えば、<code>Vec</code>の要素の部分集合を渡すことができます。
しかし、それはそれ以上のことです。<strong>配列のスライス</strong>も渡すことができます。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let array = [1, 2, 3];
let slice: &amp;[i32] = &amp;array;
<span class="boring">}</span></code></pre></pre>
<p>Array slices and <code>Vec</code> slices are the same type: they're fat pointers to a contiguous sequence of elements.
In the case of arrays, the pointer points to the stack rather than the heap, but that doesn't matter
when it comes to using the slice.</p>
<blockquote>
<p>配列のスライスと<code>Vec</code>のスライスは同じ型です。それらは連続した要素のシーケンスへのファットポインターです。
配列の場合、ポインターはヒープではなくスタックを指し示しますが、スライスを使用する際は問題ありません。</p>
</blockquote>
<h2 id="exercise-67"><a class="header" href="#exercise-67">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/06_ticket_management/10_slices"><code>06_ticket_management/10_slices</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mutable-slices可変スライス"><a class="header" href="#mutable-slices可変スライス">Mutable slices（可変スライス）</a></h1>
<p>Every time we've talked about slice types (like <code>str</code> and <code>[T]</code>), we've used their immutable borrow form (<code>&amp;str</code> and <code>&amp;[T]</code>).<br />
But slices can also be mutable!</p>
<blockquote>
<p><code>str</code>と<code>[T]</code>のようなスライス型について話すたびに、<code>&amp;str</code>と<code>&amp;[T]</code>のようなそれらの不変借用を使用してきました。
しかし、スライスは可変にもなれます。</p>
</blockquote>
<p>Here's how you create a mutable slice:</p>
<blockquote>
<p>ここに、可変スライスを作成する方法を示します。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut numbers = vec![1, 2, 3];
let slice: &amp;mut [i32] = &amp;mut numbers;
<span class="boring">}</span></code></pre></pre>
<p>You can then modify the elements in the slice:</p>
<blockquote>
<p>その後、スライス内の要素を修正できます。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>slice[0] = 42;
<span class="boring">}</span></code></pre></pre>
<p>This will change the first element of the <code>Vec</code> to <code>42</code>.</p>
<blockquote>
<p>これは、<code>Vec</code>の先頭の要素を<code>42</code>に変更します。</p>
</blockquote>
<h2 id="limitations制限事項-1"><a class="header" href="#limitations制限事項-1">Limitations（制限事項）</a></h2>
<p>When working with immutable borrows, the recommendation was clear: prefer slice references over references to
the owned type (e.g. <code>&amp;[T]</code> over <code>&amp;Vec&lt;T&gt;</code>).<br />
That's <strong>not</strong> the case with mutable borrows.</p>
<blockquote>
<p>不変借用で作業するとき、推奨は明確でした。
例えば、<code>&amp;Vec&lt;T&gt;</code>よりも<code>&amp;[T]</code>のように、所有された型の参照よりも、スライス参照を選択することです。
しかし、可変借用の場合は<strong>そうではありません</strong>。</p>
</blockquote>
<p>Consider this scenario:</p>
<blockquote>
<p>次のシナリオを考えてください。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut numbers = Vec::with_capacity(2);
let mut slice: &amp;mut [i32] = &amp;mut numbers;
slice.push(1);
<span class="boring">}</span></code></pre></pre>
<p>It won't compile!<br />
<code>push</code> is a method on <code>Vec</code>, not on slices. This is the manifestation of a more general principle: Rust won't
allow you to add or remove elements from a slice. You will only be able to modify/replace the elements that are
already there.</p>
<blockquote>
<p>これはコンパイルされません。
<code>push</code>は<code>Vec</code>のメソッドで、スライスではありません。これはより一般的な原則の現れです。
Rustは、スライスから要素を追加または削除させません。
（可変スライスは、）すでに存在する要素のみを修正／置き換えできます。</p>
</blockquote>
<p>In this regard, a <code>&amp;mut Vec</code> or a <code>&amp;mut String</code> are strictly more powerful than a <code>&amp;mut [T]</code> or a <code>&amp;mut str</code>.<br />
Choose the type that best fits based on the operations you need to perform.</p>
<blockquote>
<p>この観点から、<code>&amp;mut Vec</code>または<code>&amp;mut String</code>は、<code>&amp;mut [T]</code>または<code>&amp;mut str</code>よりも非常に強力です。
実行する必要がある操作に基づいて、最適な型を選択してください。</p>
</blockquote>
<h2 id="exercise-68"><a class="header" href="#exercise-68">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/06_ticket_management/11_mutable_slices"><code>06_ticket_management/11_mutable_slices</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ticket-idsチケットのid"><a class="header" href="#ticket-idsチケットのid">Ticket ids（チケットのID）</a></h1>
<p>Let's think again about our ticket management system.<br />
Our ticket model right now looks like this:</p>
<blockquote>
<p>チケット管理システムについて再び考えましょう。
現在、チケットモデルは次のようになっています。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Ticket {
    pub title: TicketTitle,
    pub description: TicketDescription,
    pub status: Status
}
<span class="boring">}</span></code></pre></pre>
<p>One thing is missing here: an <strong>identifier</strong> to uniquely identify a ticket.<br />
That identifier should be unique for each ticket. That can be guaranteed by generating it automatically when
a new ticket is created.</p>
<blockquote>
<p>ここで1つ欠けているものがあります。チケットを一意に識別する<strong>識別子</strong>です。
その識別子はそれぞれのチケットで一意になるべきです。
それは、新しいチケットが作成されたとき、自動的に識別子が生成されることにより保証されます。</p>
</blockquote>
<h2 id="refining-the-modelモデルを洗練する"><a class="header" href="#refining-the-modelモデルを洗練する">Refining the model（モデルを洗練する）</a></h2>
<p>Where should the id be stored?<br />
We could add a new field to the <code>Ticket</code> struct:</p>
<blockquote>
<p>IDをどこに保存するべきでしょうか？
<code>Ticket</code>構造体に新しいフィールドを追加できます。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Ticket {
    pub id: TicketId,
    pub title: TicketTitle,
    pub description: TicketDescription,
    pub status: Status
}
<span class="boring">}</span></code></pre></pre>
<p>But we don't know the id before creating the ticket. So it can't be there from the get-go.<br />
It'd have to be optional:</p>
<blockquote>
<p>しかし、チケットを作成する前にIDはわかりません。よって、最初からそこにはありません。
それは、オプションでなければなりません。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Ticket {
    pub id: Option&lt;TicketId&gt;,
    pub title: TicketTitle,
    pub description: TicketDescription,
    pub status: Status
}
<span class="boring">}</span></code></pre></pre>
<p>That's also not ideal—we'd have to handle the <code>None</code> case every single time we retrieve a ticket from the store,
even though we know that the id should always be there once the ticket has been created.</p>
<blockquote>
<p>それもまた理想的ではありません。チケットをストアから取得するたびに、一旦、チケットが作成されたら、IDが常に存在することを知っているにも関わらず、<code>None</code>のケースを処理しなければなりません。</p>
</blockquote>
<p>The best solution is to have two different ticket <strong>states</strong>, represented by two separate types:
a <code>TicketDraft</code> and a <code>Ticket</code>:</p>
<blockquote>
<p>最善の解決策は、<code>TicketDraft</code>と<code>Ticket</code>の2つの異なる型によって表現される、2つのチケットの<strong>状態</strong>を持つことです。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct TicketDraft {
    pub title: TicketTitle,
    pub description: TicketDescription
}

pub struct Ticket {
    pub id: TicketId,
    pub title: TicketTitle,
    pub description: TicketDescription,
    pub status: Status
}
<span class="boring">}</span></code></pre></pre>
<p>A <code>TicketDraft</code> is a ticket that hasn't been created yet. It doesn't have an id, and it doesn't have a status.<br />
A <code>Ticket</code> is a ticket that has been created. It has an id and a status.<br />
Since each field in <code>TicketDraft</code> and <code>Ticket</code> embeds its own constraints, we don't have to duplicate logic
across the two types.</p>
<blockquote>
<p><code>TicketDraft</code>は、まだ作成されていないチケットです。それはIDを持たず、また状態も持ちません。
<code>Ticket</code>は、作成されたチケットです。それはIDと状態を持ちます。
<code>TicketDraft</code>と<code>Ticket</code>のそれぞれのフィールドは、それ独自の制約を埋め込んでいるため、2つの型の間でロジックを重複しないようにしなければなりません。</p>
</blockquote>
<h2 id="exercise-69"><a class="header" href="#exercise-69">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/06_ticket_management/12_two_states"><code>06_ticket_management/12_two_states</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="indexingインデックス"><a class="header" href="#indexingインデックス">Indexing（インデックス）</a></h1>
<p><code>TicketStore::get</code> returns an <code>Option&lt;&amp;Ticket&gt;</code> for a given <code>TicketId</code>.<br />
We've seen before how to access elements of arrays and vectors using Rust's
indexing syntax:</p>
<blockquote>
<p><code>TicketStore::get</code>は、特定の<code>TicketId</code>に対して<code>Option&lt;&amp;Ticket&gt;</code>を返します。
前に、Rustのインデックス構文を使用して、配列とベクターの要素にアクセスする方法を確認しました。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = vec![0, 1, 2];
assert_eq!(v[0], 0);
<span class="boring">}</span></code></pre></pre>
<p>How can we provide the same experience for <code>TicketStore</code>?<br />
You guessed right: we need to implement a trait, <code>Index</code>!</p>
<blockquote>
<p><code>TicketStore</code>に対して同じ経験をどのように提供できるでしょうか？
正しい推測です。<code>Index</code>トレイトを実装する必要があります。</p>
</blockquote>
<h2 id="index"><a class="header" href="#index"><code>Index</code></a></h2>
<p>The <code>Index</code> trait is defined in Rust's standard library:</p>
<blockquote>
<p><code>Index</code>トレイトは、Rust標準ライブラリに定義されています。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Slightly simplified
// 少し簡素化されています。
pub trait Index&lt;Idx&gt;
{
    type Output;

    // Required method
    // 要求されたメソッドです。
    fn index(&amp;self, index: Idx) -&gt; &amp;Self::Output;
}
<span class="boring">}</span></code></pre></pre>
<p>It has:</p>
<ul>
<li>One generic parameter, <code>Idx</code>, to represent the index type</li>
<li>One associated type, <code>Output</code>, to represent the type we retrieved using the index</li>
</ul>
<blockquote>
<p>それは次を持っています。</p>
<ul>
<li>インデックスの型を表現する<code>Idx</code>という1つのジェネリックパラメーター</li>
<li>インデックスを使用して取得される型を表現する関連型の<code>Output</code></li>
</ul>
</blockquote>
<p>Notice how the <code>index</code> method doesn't return an <code>Option</code>. The assumption is that
<code>index</code> will panic if you try to access an element that's not there, as it happens
for array and vec indexing.</p>
<blockquote>
<p><code>index</code>メソッドが<code>Option</code>を返さないことに注意してください。
想定は、配列やベクターのインデックスに対して発生したように、存在しない要素にアクセスを試みた場合、<code>index</code>がパニックすることです。</p>
</blockquote>
<h2 id="exercise-70"><a class="header" href="#exercise-70">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/06_ticket_management/13_index"><code>06_ticket_management/13_index</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mutable-indexing可変インデックス"><a class="header" href="#mutable-indexing可変インデックス">Mutable indexing（可変インデックス）</a></h1>
<p><code>Index</code> allows read-only access. It doesn't let you mutate the value you
retrieved.</p>
<blockquote>
<p><code>Index</code>は読み込み専用アクセスを許可します。それは取得した値を変更させません。</p>
</blockquote>
<h2 id="indexmut"><a class="header" href="#indexmut"><code>IndexMut</code></a></h2>
<p>If you want to allow mutability, you need to implement the <code>IndexMut</code> trait.</p>
<blockquote>
<p>変異性を許可したい場合、<code>IndexMut</code>トレイトを実装する必要があります。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Slightly simplified
pub trait IndexMut&lt;Idx&gt;: Index&lt;Idx&gt;
{
    // Required method
    fn index_mut(&amp;mut self, index: Idx) -&gt; &amp;mut Self::Output;
}
<span class="boring">}</span></code></pre></pre>
<p><code>IndexMut</code> can only be implemented if the type already implements <code>Index</code>,
since it unlocks an <em>additional</em> capability.</p>
<blockquote>
<p><code>IndexMut</code>は、それが <em>追加</em> 能力をアンロックするため、型がすでに<code>Index</code>を実装している場合にのみ実装できます。</p>
</blockquote>
<h2 id="exercise-71"><a class="header" href="#exercise-71">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/06_ticket_management/14_index_mut"><code>06_ticket_management/14_index_mut</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hashmap"><a class="header" href="#hashmap"><code>HashMap</code></a></h1>
<p>Our implementation of <code>Index</code>/<code>IndexMut</code> is not ideal: we need to iterate over the entire
<code>Vec</code> to retrieve a ticket by id; the algorithmic complexity is <code>O(n)</code>, where
<code>n</code> is the number of tickets in the store.</p>
<blockquote>
<p><code>Index</code>/<code>IndexMut</code>の実装は理想的ではありません。
IDによってチケットを取得するために、<code>Vec</code>全体を反復操作する必要があります。
そのアルゴリズムの複雑さは<code>O(n)</code>で、<code>n</code>はストア内のチケットの数です。</p>
</blockquote>
<p>We can do better by using a different data structure for storing tickets: a <code>HashMap&lt;K, V&gt;</code>.</p>
<blockquote>
<p>チケットを格納するために異なるデータ構造である<code>HashMap&lt;K, V&gt;</code>を使用して、より良く行うことができます。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

// Type inference lets us omit an explicit type signature (which
// would be `HashMap&lt;String, String&gt;` in this example).
// 型推論は、明示的な型のシグネチャーを省略できるようにして、この例では`HashMap&lt;String, String&gt;`になります。
let mut book_reviews = HashMap::new();

book_reviews.insert(
    "Adventures of Huckleberry Finn".to_string(),
    "My favorite book.".to_string(),
);
<span class="boring">}</span></code></pre></pre>
<p><code>HashMap</code> works with key-value pairs. It's generic over both: <code>K</code> is the generic
parameter for the key type, while <code>V</code> is the one for the value type.</p>
<blockquote>
<p><code>HashMap</code>は、キーと値のペアで機能します。それは両方ともジェネリックです。
<code>K</code>はキー型のジェネリックパラメーターで、<code>V</code>は値型のジェネリックパラメーターです。</p>
</blockquote>
<p>The expected cost of insertions, retrievals and removals is <strong>constant</strong>, <code>O(1)</code>.
That sounds perfect for our usecase, doesn't it?</p>
<blockquote>
<p>挿入、取得そして削除の期待されるコストは<strong>一定</strong>で、<code>O(1)</code>です。
ユースケースにとって完璧ですよね？</p>
</blockquote>
<h2 id="key-requirementsキーの要求事項"><a class="header" href="#key-requirementsキーの要求事項">Key requirements（キーの要求事項）</a></h2>
<p>There are no trait bounds on <code>HashMap</code>'s struct definition, but you'll find some
on its methods. Let's look at <code>insert</code>, for example:</p>
<blockquote>
<p><code>HashMap</code>構造体の定義はトレイト制約がありませんが、そのメソッドでいくつか確認できます。
例として、<code>insert</code>を確認しましょう。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Slightly simplified
impl&lt;K, V&gt; HashMap&lt;K, V&gt;
where
    K: Eq + Hash,
{
    pub fn insert(&amp;mut self, k: K, v: V) -&gt; Option&lt;V&gt; {
        // [...]
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The key type must implement the <code>Eq</code> and <code>Hash</code> traits.<br />
Let's dig into those two.</p>
<blockquote>
<p>キー型は、<code>Eq</code>と<code>Hash</code>トレイトを実装しなくてはなりません。
それら2つの深堀りしましょう。</p>
</blockquote>
<h2 id="hash"><a class="header" href="#hash"><code>Hash</code></a></h2>
<p>A hashing function (or hasher) maps a potentially infinite set of a values (e.g.
all possible strings) to a bounded range (e.g. a <code>u64</code> value).<br />
There are many different hashing functions around, each with different properties
(speed, collision risk, reversibility, etc.).</p>
<blockquote>
<p>ハッシュ関数またはハッシャーは、例えばすべての考えられる文字列など潜在的な値の無限集合を、例えば<code>u64</code>値などの制限された範囲にマッピングします。
多くの異なるハッシュ関数があり、それぞれは異なる特徴を持っています（早さ、衝突リスク、可逆性など）。</p>
</blockquote>
<p>A <code>HashMap</code>, as the name suggests, uses a hashing function behind the scene.
It hashes your key and then uses that hash to store/retrieve the associated value.
This strategy requires the key type must be hashable, hence the <code>Hash</code> trait bound on <code>K</code>.</p>
<blockquote>
<p>名前が示唆する通り<code>HashMap</code>は、背後でハッシュ関数を使用しています。
それはキーをハッシュ化して、関連した値を保存／取得するためにそのハッシュを使用します。
この戦略は、キー型がハッシュ可能でなくてはならず、そのため<code>Hash</code>トレイトが<code>K</code>に制約されています。</p>
</blockquote>
<p>You can find the <code>Hash</code> trait in the <code>std::hash</code> module:</p>
<blockquote>
<p><code>Hash</code>トレイトは<code>std::hash</code>モジュールにあります。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Hash {
    // Required method
    fn hash&lt;H&gt;(&amp;self, state: &amp;mut H)
       where H: Hasher;
}
<span class="boring">}</span></code></pre></pre>
<p>You will rarely implement <code>Hash</code> manually. Most of the times you'll derive it:</p>
<blockquote>
<p>まれに手動で<code>Hash</code>を実装します。ほとんどの場合、それを導出します。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Hash)]
struct Person {
    id: u32,
    name: String,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="eq"><a class="header" href="#eq"><code>Eq</code></a></h2>
<p><code>HashMap</code> must be able to compare keys for equality. This is particularly important
when dealing with hash collisions—i.e. when two different keys hash to the same value.</p>
<blockquote>
<p><code>HashMap</code>は、等価性のためにキーを比較できなくてはなりません。
例えば2つの異なるキーが同じ値にハッシュ化され、ハッシュの衝突を扱うとき、これは特に重要になります。</p>
</blockquote>
<p>You may wonder: isn't that what the <code>PartialEq</code> trait is for? Almost!<br />
<code>PartialEq</code> is not enough for <code>HashMap</code> because it doesn't guarantee reflexivity, i.e. <code>a == a</code> is always <code>true</code>.<br />
For example, floating point numbers (<code>f32</code> and <code>f64</code>) implement <code>PartialEq</code>,
but they don't satisfy the reflexivity property: <code>f32::NAN == f32::NAN</code> is <code>false</code>.<br />
Reflexivity is crucial for <code>HashMap</code> to work correctly: without it, you wouldn't be able to retrieve a value
from the map using the same key you used to insert it.</p>
<blockquote>
<p>困惑しているかもしれません。そのための<code>PartialEq</code>トレイトではないでしょうか？ほぼそうです！
例えば、<code>a == a</code>が常に<code>true</code>であるなど、<code>PartialEq</code>は反射性を保証しないため、<code>HashMap</code>には十分ではありません。
例えば、浮動小数点数（<code>f32</code>と<code>f64</code>）は<code>PartialEq</code>を実装していますが、<code>f32::NAN == f32::NAN</code>が<code>偽</code>になるように、それらは反射性の特徴を満たしていません。
反射性は、<code>HashMap</code>が正確に動作するために極めて重要です。
それ（反射性）なしで、挿入するために使用した同じキーを使用して、マップから値を取り出すことはできません。</p>
</blockquote>
<p>The <code>Eq</code> trait extends <code>PartialEq</code> with the reflexivity property:</p>
<blockquote>
<p><code>Eq</code>トレイトは、反射性の特性を持つ<code>PartialEq</code>を拡張します。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Eq: PartialEq {
    // No additional methods
}
<span class="boring">}</span></code></pre></pre>
<p>It's a marker trait: it doesn't add any new methods, it's just a way for you to say to the compiler
that the equality logic implemented in <code>PartialEq</code> is reflexive.</p>
<blockquote>
<p>それはマーカートレイトです。それは任意の新しいメソッドを追加せず、<code>PartialEq</code>内に実装された等価性ロジックが反射性であることをコンパイラーに伝える単なる方法です。</p>
</blockquote>
<p>You can derive <code>Eq</code> automatically when you derive <code>PartialEq</code>:</p>
<blockquote>
<p><code>PartialEq</code>を導出するとき、<code>Eq</code>を自動で導出できます。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(PartialEq, Eq)]
struct Person {
    id: u32,
    name: String,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="eq-and-hash-are-linkedeqとhashはリンクされている"><a class="header" href="#eq-and-hash-are-linkedeqとhashはリンクされている"><code>Eq</code> and <code>Hash</code> are linked（EqとHashはリンクされている）</a></h2>
<p>There is an implicit contract between <code>Eq</code> and <code>Hash</code>: if two keys are equal, their hashes must be equal too.
This is crucial for <code>HashMap</code> to work correctly. If you break this contract, you'll get nonsensical results
when using <code>HashMap</code>.</p>
<blockquote>
<p>暗黙的な契約が<code>Eq</code>と<code>Hash</code>間にあります。2つのキーが等しい場合、それらのハッシュも等しくならなければなりません。
これが、<code>HashMap</code>が正確に動作するために極めて重要です。
この契約を破った場合、<code>HashMap</code>を使用したとき、無意味な結果が得られます。</p>
</blockquote>
<h2 id="exercise-72"><a class="header" href="#exercise-72">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/06_ticket_management/15_hashmap"><code>06_ticket_management/15_hashmap</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ordering順序"><a class="header" href="#ordering順序">Ordering（順序）</a></h1>
<p>By moving from a <code>Vec</code> to a <code>HashMap</code> we have improved the performance of our ticket management system,
and simplified our code in the process.<br />
It's not all roses, though. When iterating over a <code>Vec</code>-backed store, we could be sure that the tickets
would be returned in the order they were added.<br />
That's not the case with a <code>HashMap</code>: you can iterate over the tickets, but the order is random.</p>
<blockquote>
<p><code>Vec</code>から<code>HashMap</code>への移行により、チケット管理システムの性能を改善して、その過程でコードを簡素化しました。
ただし、すべてがバラ色とは限りません。<code>Vec</code>に裏付けされたストアを反復操作するとき、チケットが追加された順番で返されることを確信できました。
<code>HashMap</code>ではそれは当てはまりません。チケットを反復操作できますが、順序はランダムです。</p>
</blockquote>
<p>We can recover a consistent ordering by switching from a <code>HashMap</code> to a <code>BTreeMap</code>.</p>
<blockquote>
<p><code>HashMap</code>から<code>BTreeMap</code>に切り替えることで、順番の一貫性を回復できます。</p>
</blockquote>
<h2 id="btreemap"><a class="header" href="#btreemap"><code>BTreeMap</code></a></h2>
<p>A <code>BTreeMap</code> guarantees that entries are sorted by their keys.<br />
This is useful when you need to iterate over the entries in a specific order, or if you need to
perform range queries (e.g. "give me all tickets with an id between 10 and 20").</p>
<blockquote>
<p><code>BTreeMap</code>は、エントリーがそれらのキーによって並べ替えされることを保証します。
特定の順番でエントリーを反復操作する必要があるとき、または、例えば、10と20の間のIDを持つすべてのチケットを取得するなど、範囲クエリを実行する必要があるとき、これは便利です。</p>
</blockquote>
<p>Just like <code>HashMap</code>, you won't find trait bounds on the definition of <code>BTreeMap</code>.
But you'll find trait bounds on its methods. Let's look at <code>insert</code>:</p>
<blockquote>
<p>ちょうど<code>HashMap</code>と同様に、<code>BTreeMap</code>の定義にトレイト制約を見つけれないでしょう。
しかし、そのメソッドにトレイト制約を見つけるでしょう。<code>insert</code>を確認しましょう。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// `K` and `V` stand for the key and value types, respectively,
// just like in `HashMap`.
// `K`と`V`は、ちょうど`HashMap`と同様に、それぞれキーと値の型を表します。
impl&lt;K, V&gt; BTreeMap&lt;K, V&gt; {
    pub fn insert(&amp;mut self, key: K, value: V) -&gt; Option&lt;V&gt;
    where
        K: Ord,
    {
        // implementation
    }
}
<span class="boring">}</span></code></pre></pre>
<p><code>Hash</code> is no longer required. Instead, the key type must implement the <code>Ord</code> trait.</p>
<blockquote>
<p><code>Hash</code>はもはや要求されません。代わりに、キー型は<code>Ord</code>トレイトを実装しなくてはなりませんん。</p>
</blockquote>
<h2 id="ord"><a class="header" href="#ord"><code>Ord</code></a></h2>
<p>The <code>Ord</code> trait is used to compare values.<br />
While <code>PartialEq</code> is used to compare for equality, <code>Ord</code> is used to compare for ordering.</p>
<blockquote>
<p><code>Ord</code>トレイトは値を比較するために使用されます。
<code>PartialEq</code>が等価性を比較するために使用される一方で、<code>Ord</code>は順序を比較するために使用されます。</p>
</blockquote>
<p>It's defined in <code>std::cmp</code>:</p>
<blockquote>
<p>それは<code>std::cmp</code>で定義されています。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Ord: Eq + PartialOrd {
    fn cmp(&amp;self, other: &amp;Self) -&gt; Ordering;
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>cmp</code> method returns an <code>Ordering</code> enum, which can be one
of <code>Less</code>, <code>Equal</code>, or <code>Greater</code>.<br />
<code>Ord</code> requires that two other traits are implemented: <code>Eq</code> and <code>PartialOrd</code>.</p>
<blockquote>
<p><code>cmp</code>メソッドは<code>Ordering</code>列挙型を返し、それは<code>Less</code>、<code>Equal</code>、または<code>Greater</code>のいずれかになります。
<code>Ord</code>は、<code>Eq</code>と<code>PartialOrd</code>の2つの他のトレイトが実装されていることを要求します。</p>
</blockquote>
<h2 id="partialord"><a class="header" href="#partialord"><code>PartialOrd</code></a></h2>
<p><code>PartialOrd</code> is a weaker version of <code>Ord</code>, just like <code>PartialEq</code> is a weaker version of <code>Eq</code>.
You can see why by looking at its definition:</p>
<blockquote>
<p><code>PartialOrd</code>は<code>Ord</code>の弱いバージョンで、ちょうど<code>PartialEq</code>が<code>Eq</code>の弱いバージョンであることと同じです。
その定義を確認することで、理由がわかります。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait PartialOrd: PartialEq {
    fn partial_cmp(&amp;self, other: &amp;Self) -&gt; Option&lt;Ordering&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p><code>PartialOrd::partial_cmp</code> returns an <code>Option</code>—it is not guaranteed that two values can
be compared.<br />
For example, <code>f32</code> doesn't implement <code>Ord</code> because <code>NaN</code> values are not comparable,
the same reason why <code>f32</code> doesn't implement <code>Eq</code>.</p>
<blockquote>
<p><code>PartialOrd::partial_cmp</code>は<code>Option</code>を返します。それは、2つの値が比較できることを保証しません。
例えば、<code>NaN</code>値は比較可能でないため、<code>f32</code>は<code>Ord</code>を実装しておらず、同じ理由で<code>f32</code>は<code>Eq</code>を実装していません。</p>
</blockquote>
<h2 id="implementing-ord-and-partialordordとpartialordの実装"><a class="header" href="#implementing-ord-and-partialordordとpartialordの実装">Implementing <code>Ord</code> and <code>PartialOrd</code>（OrdとPartialOrdの実装）</a></h2>
<p>Both <code>Ord</code> and <code>PartialOrd</code> can be derived for your types:</p>
<blockquote>
<p><code>Ord</code>と<code>PartialOrd</code>両方は、型から導出できます。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// You need to add `Eq` and `PartialEq` too,
// since `Ord` requires them.
// `Ord`が要求するため、`Eq`と`PartialEq`を追加する必要があります。
#[derive(Eq, PartialEq, Ord, PartialOrd)]
struct TicketId(u64);
<span class="boring">}</span></code></pre></pre>
<p>If you choose (or need) to implement them manually, be careful:</p>
<ul>
<li><code>Ord</code> and <code>PartialOrd</code> must be consistent with <code>Eq</code> and <code>PartialEq</code>.</li>
<li><code>Ord</code> and <code>PartialOrd</code> must be consistent with each other.</li>
</ul>
<blockquote>
<p>手動でそれらを実装することを選択または必要がある場合、次に注意してください。</p>
<ul>
<li><code>Ord</code>と<code>PartialOrd</code>は、<code>Eq</code>と<code>PartialEq</code>と一貫性を持たなければなりません。</li>
<li><code>Ord</code>と<code>PartialOrd</code>は、それぞれと一貫性を持たせなければなりません。</li>
</ul>
</blockquote>
<h2 id="exercise-73"><a class="header" href="#exercise-73">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/06_ticket_management/16_btreemap"><code>06_ticket_management/16_btreemap</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="intro導入"><a class="header" href="#intro導入">Intro（導入）</a></h1>
<p>One of Rust's big promises is <em>fearless concurrency</em>: making it easier to write safe, concurrent programs.
We haven't seen much of that yet. All the work we've done so far has been single-threaded.
Time to change that!</p>
<blockquote>
<p>Rustの大きな約束は、 <em>恐れを知らない同時並行</em> です。それは安全に並同時並行プログラムを記述できるようにします。
これまであまり確認てきませんでした。これまでに行ってきたすべての作業は単一スレッドでした。
それを変える時がきました！</p>
</blockquote>
<p>In this chapter we'll make our ticket store multithreaded.<br />
We'll have the opportunity to touch most of Rust's core concurrency features, including:</p>
<ul>
<li>Threads, using the <code>std::thread</code> module</li>
<li>Message passing, using channels</li>
<li>Shared state, using <code>Arc</code>, <code>Mutex</code> and <code>RwLock</code></li>
<li><code>Send</code> and <code>Sync</code>, the traits that encode Rust's concurrency guarantees</li>
</ul>
<blockquote>
<p>この章において、マルチスレッドなチケットストアを作成します。
次のようなRustの主要な同時並行機能のほとんどに触れる機会を持ちます。</p>
<ul>
<li><code>std::thread</code>モジュールを使用したスレッド</li>
<li>チャネルを使用したメッセージ送信</li>
<li><code>Arc</code>、<code>Mutex</code>そして<code>RwLock</code>を使用した共有された状態</li>
<li>Rustの同時並行性の保証を符号化する<code>Send</code>と<code>Sync</code>トレイト</li>
</ul>
</blockquote>
<p>We'll also discuss various design patterns for multithreaded systems and some of their trade-offs.</p>
<blockquote>
<p>また、マルチスレッドシステムのためのさまざまなデザインパターンと、それらのいくつかの二律背反についても議論します。</p>
</blockquote>
<h2 id="exercise-74"><a class="header" href="#exercise-74">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/07_threads/00_intro"><code>07_threads/00_intro</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="threadsスレッド"><a class="header" href="#threadsスレッド">Threads（スレッド）</a></h1>
<p>Before we start writing multithreaded code, let's take a step back and talk about what threads are
and why we might want to use them.</p>
<blockquote>
<p>マルチスレッドなコードの記述を開始する前に、一歩戻ってスレッドとは何か、そしてそれらを使用したい理由について話しましょう。</p>
</blockquote>
<h2 id="what-is-a-threadスレッドとは"><a class="header" href="#what-is-a-threadスレッドとは">What is a thread?（スレッドとは？）</a></h2>
<p>A <strong>thread</strong> is an execution context managed by the underlying operating system.<br />
Each thread has its own stack, instruction pointer, and program counter.</p>
<blockquote>
<p><strong>スレッド</strong>は、基礎となるオペレーティングシステムによって管理された実行コンテキストです。
それぞれのスレッドはそれ独自のスタック、命令ポインターそしてプログラムカウンターを持ちます。</p>
</blockquote>
<blockquote>
<p>命令ポインター≒プログラムカウンター？</p>
</blockquote>
<p>A single <strong>process</strong> can manage multiple threads.
These threads share the same memory space, which means they can access the same data.</p>
<blockquote>
<p>単一<strong>プロセス</strong>は、複数のスレッドを管理できます。
これらのスレッドは、同じメモリ空間を共有するため、それらは同じデータにアクセスできることを意味します。</p>
</blockquote>
<p>Threads are a <strong>logical</strong> construct. In the end, you can only run one set of instructions
at a time on a CPU core, the <strong>physical</strong> execution unit.<br />
Since there can be many more threads than there are CPU cores, the operating system's
<strong>scheduler</strong> is in charge of deciding which thread to run at any given time,
partitioning CPU time among them to maximize throughput and responsiveness.</p>
<blockquote>
<p>スレッドは<strong>論理的な</strong>構成要素です。最終的に、<strong>物理的な</strong>実行ユニットであるCPUコアで一度に1つの命令セットしか実行できません。
CPUコアよりも多くのスレッドが存在できるため、オペレーティングシステムの<strong>スケジューラー</strong>は、特定の時間に実行するスレッドを決定する責任があり、最大のスループットと応答性を確保するために、スレッド間でCPU時間を分配します。</p>
</blockquote>
<h2 id="main"><a class="header" href="#main"><code>main</code></a></h2>
<p>When a Rust program starts, it runs on a single thread, the <strong>main thread</strong>.<br />
This thread is created by the operating system and is responsible for running the <code>main</code>
function.</p>
<blockquote>
<p>Rustプログラムが開始したとき、それは<strong>メインスレッド</strong>という単一スレッドで実行されます。
このスレッドはオペレーティングシステムによって作成され、<code>main</code>関数を実行する責任があります。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::time::Duration;

fn main() {
    loop {
        thread::sleep(Duration::from_secs(2));
        println!("Hello from the main thread!");
    }
}</code></pre></pre>
<h2 id="stdthread"><a class="header" href="#stdthread"><code>std::thread</code></a></h2>
<p>Rust's standard library provides a module, <code>std::thread</code>, that allows you to create
and manage threads.</p>
<blockquote>
<p>Rust標準ライブラリは、スレッドを作成または管理する<code>std::thread</code>モジュールを提供します。</p>
</blockquote>
<h3 id="spawn"><a class="header" href="#spawn"><code>spawn</code></a></h3>
<p>You can use <code>std::thread::spawn</code> to create new threads and execute code on them.</p>
<p>For example:</p>
<blockquote>
<p>新しいスレッドを作成して、それらの上でコードを実行するために<code>std::thread::spawn</code>を使用できます。</p>
<p>例えば・・・</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        loop {
            thread::sleep(Duration::from_secs(1));
            println!("Hello from a thread!");
        }
    });

    loop {
        thread::sleep(Duration::from_secs(2));
        println!("Hello from the main thread!");
    }
}</code></pre></pre>
<p>If you execute this program on the <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=afedf7062298ca8f5a248bc551062eaa">Rust playground</a>
you'll see that the main thread and the spawned thread run concurrently.<br />
Each thread makes progress independently of the other.</p>
<blockquote>
<p>このプログラムをRust playgroundで実行した場合、メインスレッドと生み出されたスレッドが同時並行で実行することを確認できます。
それぞれのスレッドは、他と独立して進行します。</p>
</blockquote>
<blockquote>
<p>このプログラムは、<code>main</code>関数末尾にある無限ループを抜けることがないため、永遠に実行を継続する。</p>
</blockquote>
<h3 id="process-terminationプロセスの終了"><a class="header" href="#process-terminationプロセスの終了">Process termination（プロセスの終了）</a></h3>
<p>When the main thread finishes, the overall process will exit.<br />
A spawned thread will continue running until it finishes or the main thread finishes.</p>
<blockquote>
<p>メインスレッドが終了したとき、プロセス全体が終了します。
生み出されたスレッドは、それが終了する、またはメインスレッドが終了するまで実行を続けます。</p>
</blockquote>
<blockquote>
<p>次のプログラムは、<code>main</code>関数末尾にある5秒間のスリープが終わると、<code>main</code>関数が終了するため、無限ループに入る別スレッドも同時に終了する。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        loop {
            thread::sleep(Duration::from_secs(1));
            println!("Hello from a thread!");
        }
    });

    thread::sleep(Duration::from_secs(5));
}</code></pre></pre>
<p>In the example above, you can expect to see the message "Hello from a thread!" printed roughly five times.<br />
Then the main thread will finish (when the <code>sleep</code> call returns), and the spawned thread will be terminated
since the overall process exits.</p>
<blockquote>
<p>上記例において、大まかに5️回表示される「Hello from a thread!」を見ることを期待できます。
そして、<code>sleep</code>呼び出しが戻ったとき、メインスレッドが終了して、プロセス全体が終了するため、生み出されたスレッドも終了します。</p>
</blockquote>
<h3 id="join"><a class="header" href="#join"><code>join</code></a></h3>
<p>You can also wait for a spawned thread to finish by calling the <code>join</code> method on the <code>JoinHandle</code> that <code>spawn</code> returns.</p>
<blockquote>
<p><code>spawn</code>が返す<code>JoinHandle</code>に対して<code>join</code>メソッドを呼び出すことで、生み出されたスレッドが終了するまで待つこともできます。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">use std::thread;
fn main() {
    let handle = thread::spawn(|| {
        println!("Hello from a thread!");
    });

    handle.join().unwrap();
}</code></pre></pre>
<p>In this example, the main thread will wait for the spawned thread to finish before exiting.<br />
This introduces a form of <strong>synchronization</strong> between the two threads: you're guaranteed to see the message
"Hello from a thread!" printed before the program exits, because the main thread won't exit
until the spawned thread has finished.</p>
<blockquote>
<p>この例において、メインスレッドは終了する前に生み出されたスレッドが終了するまで待ちます。
これは、2つのスレッド間に<strong>同期</strong>の形式を導入します。
生み出されたスレッドが終了するまで、メインスレッドが終了しないため、プログラムが終了する前に「Hello from a thread!」メッセージを見ることが保証されます。</p>
</blockquote>
<h2 id="exercise-75"><a class="header" href="#exercise-75">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/07_threads/01_threads"><code>07_threads/01_threads</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="static"><a class="header" href="#static"><code>'static</code></a></h1>
<p>If you tried to borrow a slice from the vector in the previous exercise,
you probably got a compiler error that looks something like this:</p>
<blockquote>
<p>前の演習において、ベクターからスライスを借用することを試みた場合、おそらく次のようなコンパイルエラーが発生しました。</p>
</blockquote>
<pre><code class="language-text">error[E0597]: `v` does not live long enough
   |
11 | pub fn sum(v: Vec&lt;i32&gt;) -&gt; i32 {
   |            - binding `v` declared here
...
15 |     let right = &amp;v[split_point..];
   |                  ^ borrowed value does not live long enough
16 |     let left_handle = thread::spawn(move || left.iter().sum::&lt;i32&gt;());
   |                        ------------------------------------------------
                          argument requires that `v` is borrowed for `'static`
19 | }
   |  - `v` dropped here while still borrowed
</code></pre>
<p><code>argument requires that v is borrowed for 'static</code>, what does that mean?</p>
<blockquote>
<p><code>argument requires that v is borrowed for 'static</code>は、何を意味しているのでしょうか？</p>
</blockquote>
<p>The <code>'static</code> lifetime is a special lifetime in Rust.<br />
It means that the value will be valid for the entire duration of the program.</p>
<blockquote>
<p>Rustにおいて、<code>'static</code>ライフタイムは特別なライフタイムです。
それは、その値がプログラム全体の間で有効であることを意味します。</p>
</blockquote>
<h2 id="detached-threadsデタッチされたスレッド"><a class="header" href="#detached-threadsデタッチされたスレッド">Detached threads（デタッチされたスレッド）</a></h2>
<p>A thread launched via <code>thread::spawn</code> can <strong>outlive</strong> the thread that spawned it.<br />
For example:</p>
<blockquote>
<p><code>thread::spawn</code>を介して起動されたスレッドは、それを生成したスレッドよりも<strong>長生き</strong>することができます。
例えば・・・</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::thread;

fn f() {
    thread::spawn(|| {
        thread::spawn(|| {
            loop {
                thread::sleep(std::time::Duration::from_secs(1));
                println!("Hello from the detached thread!");
            }
        });
    });
}
<span class="boring">}</span></code></pre></pre>
<p>In this example, the first spawned thread will in turn spawn
a child thread that prints a message every second.<br />
The first thread will then finish and exit. When that happens,
its child thread will <strong>continue running</strong> for as long as the
overall process is running.<br />
In Rust's lingo, we say that the child thread has <strong>outlived</strong>
its parent.</p>
<blockquote>
<p>この例において、最初に生み出されたスレッドは、次々に毎秒メッセージを表示する子スレッドを生み出します。
そして、最初のスレッドは完了して終了します。
それが発生したとき、子スレッドは全体のプロセスが実行されている限り<strong>継続して実行</strong>します。
Rustの専門用語において、子スレッドはその親よりも<strong>長生きしている</strong>といいます。</p>
</blockquote>
<blockquote>
<p>関数<code>f</code>を<code>main</code>関数にした場合、親スレッドが終了しても、<code>main</code>関数が終了していない微小な時間がある。
その微小時間内で、子スレッドは実行を継続する。</p>
</blockquote>
<h2 id="static-lifetimestaticライフタイム"><a class="header" href="#static-lifetimestaticライフタイム"><code>'static</code> lifetime（'staticライフタイム）</a></h2>
<p>Since a spawned thread can:</p>
<ul>
<li>outlive the thread that spawned it (its parent thread)</li>
<li>run until the program exits</li>
</ul>
<blockquote>
<p>生み出されたスレッドは次ができるため・・・</p>
<ul>
<li>それを生成した親スレッドよりも長生きする。</li>
<li>プログラムが終了するまで実行する。</li>
</ul>
</blockquote>
<p>it must not borrow any values that might be dropped before the program exits;
violating this constraint would expose us to a use-after-free bug.<br />
That's why <code>std::thread::spawn</code>'s signature requires that the closure passed to it
has the <code>'static</code> lifetime:</p>
<blockquote>
<p>それ（子スレッド）は、プログラムが終了する前にドロップされるかもしれない値を借用してはなりません。
この制約に違反することは、「解放された後に使用する」バグをさらけ出します。
それが、<code>std::thread::spawn</code>のシグネチャーが<code>'static</code>ライフタイムを持つそれ（値）を渡されるクロージャーを要求している理由です。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt;
where
    F: FnOnce() -&gt; T + Send + 'static,
    T: Send + 'static
{
    // [..]
}
<span class="boring">}</span></code></pre></pre>
<h2 id="static-is-not-just-about-referencesstaticは単に参照についてだけではありません"><a class="header" href="#static-is-not-just-about-referencesstaticは単に参照についてだけではありません"><code>'static</code> is not (just) about references（'staticは（単に）参照についてだけではありません）</a></h2>
<p>All values in Rust have a lifetime, not just references.</p>
<blockquote>
<p>Rustにおいて、参照だけでなく、すべての値がライフタイムを持っています。</p>
</blockquote>
<p>In particular, a type that owns its data (like a <code>Vec</code> or a <code>String</code>)
satisfies the <code>'static</code> constraint: if you own it, you can keep working with it
for as long as you want, even after the function that originally created it
has returned.</p>
<blockquote>
<p>特に、<code>Vec</code>または<code>String</code>のようなデータを所有する型は、<code>'static</code>制約を満たします。
それを所有した場合、それを作成した関数が戻った後でも、望むだけそれと一緒に作業を続けることができます。</p>
</blockquote>
<blockquote>
<p><code>Vec</code>が<code>T</code>の参照である<code>&amp;T</code>を格納する場合、<code>&amp;T</code>自体の所有権をもち、<code>&amp;T</code>が参照する<code>T</code>は<code>'static</code>である必要がある。</p>
</blockquote>
<p>You can thus interpret <code>'static</code> as a way to say:</p>
<ul>
<li>Give me an owned value</li>
<li>Give me a reference that's valid for the entire duration of the program</li>
</ul>
<blockquote>
<p>よって、<code>'static</code>は次のように解釈できます。</p>
<ul>
<li>所有した値を与えてくれる</li>
<li>プログラム全体の期間で有効な参照を与えてくれる</li>
</ul>
</blockquote>
<p>The first approach is how you solved the issue in the previous exercise:
by allocating new vectors to hold the left and right parts of the original vector,
which were then moved into the spawned threads.</p>
<blockquote>
<p>最初の方法は、以前の演習の問題を解決した方法と同じで、オリジナルのベクターの左と右の部分を保持するために新しいベクターを割り当て、それらを生み出されたスレッド内に移動しました。</p>
</blockquote>
<h2 id="static-referencesstatic参照"><a class="header" href="#static-referencesstatic参照"><code>'static</code> references（'static参照）</a></h2>
<p>Let's talk about the second case, references that are valid for the entire
duration of the program.</p>
<blockquote>
<p>2つ目のケース、プログラム全体の間で有効な参照について話しましょう。</p>
</blockquote>
<h3 id="static-data静的なデータ"><a class="header" href="#static-data静的なデータ">Static data（静的なデータ）</a></h3>
<p>The most common case is a reference to <strong>static data</strong>, such as string literals:</p>
<blockquote>
<p>最も一般的なケースは、文字列リテラルのような<strong>静的データ</strong>への参照です。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s: &amp;'static str = "Hello world!";
<span class="boring">}</span></code></pre></pre>
<p>Since string literals are known at compile-time, Rust stores them <em>inside</em> your executable,
in a region known as <strong>read-only data segment</strong>.
All references pointing to that region will therefore be valid for as long as
the program runs; they satisfy the <code>'static</code> contract.</p>
<blockquote>
<p>文字列リテラルはコンパイル時にわかるため、Rustは実行形式の <em>内部</em> にある<strong>読み込み専用データセグメント</strong>として知られる領域にそれらを保存します。</p>
</blockquote>
<h2 id="further-reading参考資料-10"><a class="header" href="#further-reading参考資料-10">Further reading（参考資料）</a></h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Data_segment">The data segment</a></li>
</ul>
<h2 id="exercise-76"><a class="header" href="#exercise-76">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/07_threads/02_static"><code>07_threads/02_static</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="leaking-dataデータのリーク"><a class="header" href="#leaking-dataデータのリーク">Leaking data（データのリーク）</a></h1>
<p>The main concern around passing references to spawned threads is use-after-free bugs:
accessing data using a pointer to a memory region that's already been freed/de-allocated.<br />
If you're working with heap-allocated data, you can avoid the issue by
telling Rust that you'll never reclaim that memory: you choose to <strong>leak memory</strong>,
intentionally.</p>
<blockquote>
<p>生み出したスレッドに参照を渡すことに関する主要な懸念は、すでに解放／割り当てを解除されたメモリ領域へのポインターを使用したデータにアクセスする「開放した後に使用する」バグです。
ヒープに割り当てられたデータを扱っている場合、そのメモリを決して回収しないことをRustに伝えることで、その問題を回避できます。
つまり、<strong>メモリーリーク</strong>することを意図的に選択します。</p>
</blockquote>
<p>This can be done, for example, using the <code>Box::leak</code> method from Rust's standard library:</p>
<blockquote>
<p>例えば、Rust標準ライブラリの<code>Box::leak</code>メソッドを使用して、これを行えます。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Allocate a `u32` on the heap, by wrapping it in a `Box`.
// `Box`内にラップすることで、ヒープに`u32`を割り当てます。
let x = Box::new(41u32);
// Tell Rust that you'll never free that heap allocation
// using `Box::leak`. You can thus get back a 'static reference.
// `Box::leak`を使用して、そのヒープ割り当てを決して解放しないことをRustに伝えます。
// よって、`'static参照を得られます。
let static_ref: &amp;'static mut u32 = Box::leak(x);
<span class="boring">}</span></code></pre></pre>
<h2 id="data-leakage-is-process-scopedデータリークはプロセススコープです"><a class="header" href="#data-leakage-is-process-scopedデータリークはプロセススコープです">Data leakage is process-scoped（データリークはプロセススコープです）</a></h2>
<p>Leaking data is dangerous: if you keep leaking memory, you'll eventually
run out and crash with an out-of-memory error.</p>
<blockquote>
<p>データをリークさせることは危険です。
リークしたメモリを維持する場合、最終的にメモリが尽きて、アウトオブメモリーエラーでクラッシュします。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// If you leave this running for a while,
// it'll eventually use all the available memory.
// しばらくこれを実行した場合、最終的にすべての利用可能なメモリを使用します。
fn oom_trigger() {
    loop {
        let v: Vec&lt;usize&gt; = Vec::with_capacity(1024);
        v.leak();
    }
}
<span class="boring">}</span></code></pre></pre>
<p>At the same time, memory leaked via <code>leak</code> method is not truly forgotten.<br />
The operating system can map each memory region to the process responsible for it.
When the process exits, the operating system will reclaim that memory.</p>
<blockquote>
<p>同時に、<code>leak</code>メソッドを介したメモリリークは、完全に忘れ去られるわけではありません。
オペレーティングシステムは、それぞれのメモリ領域と、それに責任があるプロセスをマップできます。
プロセスが終了したとき、オペレーティングシステムはそのメモリを回収します。</p>
</blockquote>
<p>Keeping this in mind, it can be OK to leak memory when:</p>
<ul>
<li>The amount of memory you need to leak is not unbounded/known upfront, or</li>
<li>Your process is short-lived and you're confident you won't exhaust
all the available memory before it exits</li>
</ul>
<blockquote>
<p>これを念頭に置いて、メモリリークが許容される場合は次のとおりです。</p>
<ul>
<li>リークする必要があるメモリーの量が無制限でないか、事前にわかっている場合、または・・・</li>
<li>プロセスが短命で、それが終了する前に利用可能なメモリをすべて使い果たさない自信がある場合</li>
</ul>
</blockquote>
<p>"Let the OS deal with it" is a perfectly valid memory management strategy
if your usecase allows for it.</p>
<blockquote>
<p>ユースケースがそれ（上記）に従う場合、「OSにそれを処理させる」は、完全に妥当なメモリ管理戦略です。</p>
</blockquote>
<h2 id="exercise-77"><a class="header" href="#exercise-77">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/07_threads/03_leak"><code>07_threads/03_leak</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scoped-threadsスコープで制限されたスレッド"><a class="header" href="#scoped-threadsスコープで制限されたスレッド">Scoped threads（スコープで制限されたスレッド）</a></h1>
<p>All the lifetime issues we discussed so far have a common source:
the spawned thread can outlive its parent.<br />
We can sidestep this issue by using <strong>scoped threads</strong>.</p>
<blockquote>
<p>これまでに議論したすべてのライフタイムの問題は、よくある原因を持っています。
それは、生み出されたスレッドは、その親よりも長生きできることです。
<strong>スコープで制限されたスレッド</strong>を使用して、この問題を回避できます。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = vec![1, 2, 3];
let midpoint = v.len() / 2;

std::thread::scope(|scope| {
    scope.spawn(|| {
        let first = &amp;v[..midpoint];
        println!("Here's the first half of v: {first:?}");
    });
    scope.spawn(|| {
        let second = &amp;v[midpoint..];
        println!("Here's the second half of v: {second:?}");
    });
});

println!("Here's v: {v:?}");
<span class="boring">}</span></code></pre></pre>
<p>Let's unpack what's happening.</p>
<blockquote>
<p>何が起こっているか調べてみましょう。</p>
</blockquote>
<h2 id="scope"><a class="header" href="#scope"><code>scope</code></a></h2>
<p>The <code>std::thread::scope</code> function creates a new <strong>scope</strong>.<br />
<code>std::thread::scope</code> takes as input a closure, with a single argument: a <code>Scope</code> instance.</p>
<blockquote>
<p><code>std::thread::scope</code>関数は新しい<strong>スコープ</strong>を作成します。
<code>std::thread::scope</code>は、入力として<code>Scope</code>インスタンスを単一の引数にもつクロージャーを受け取ります。</p>
</blockquote>
<h2 id="scoped-spawnsスコープで制限された生み出し"><a class="header" href="#scoped-spawnsスコープで制限された生み出し">Scoped spawns（スコープで制限された生み出し）</a></h2>
<p><code>Scope</code> exposes a <code>spawn</code> method.<br />
Unlike <code>std::thread::spawn</code>, all threads spawned using a <code>Scope</code> will be
<strong>automatically joined</strong> when the scope ends.</p>
<blockquote>
<p><code>Scope</code>は<code>spawn</code>メソッドを公開します。
<code>std::thread::spawn</code>と異なり、<code>Scope</code>を使用して生み出されたすべてのスレッドは、スコープが終了したとき<strong>自動的に結合</strong>されます。</p>
</blockquote>
<blockquote>
<p><code>Scope</code>内で生み出されたスレッドは結合、つまりスレッドの終了を待つ。
よって、<code>Scope</code>と同じスコープにある変数は、<code>Scope</code>と同じだけ生存するため、<code>Scope</code>内で生み出されたスレッドで自由に参照できる。</p>
</blockquote>
<p>If we were to "translate" the previous example to <code>std::thread::spawn</code>,
it'd look like this:</p>
<blockquote>
<p>前の例を<code>std::thread::spawn</code>に「翻訳」すると、次のようになります。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = vec![1, 2, 3];
let midpoint = v.len() / 2;

let handle1 = std::thread::spawn(|| {
    let first = &amp;v[..midpoint];
    println!("Here's the first half of v: {first:?}");
});
let handle2 = std::thread::spawn(|| {
    let second = &amp;v[midpoint..];
    println!("Here's the second half of v: {second:?}");
});

handle1.join().unwrap();
handle2.join().unwrap();

println!("Here's v: {v:?}");
<span class="boring">}</span></code></pre></pre>
<h2 id="borrowing-from-the-environment環境から借用する"><a class="header" href="#borrowing-from-the-environment環境から借用する">Borrowing from the environment（環境から借用する）</a></h2>
<p>The translated example wouldn't compile, though: the compiler would complain
that <code>&amp;v</code> can't be used from our spawned threads since its lifetime isn't
<code>'static</code>.</p>
<blockquote>
<p>ただし、翻訳した例はコンパイルされません。
コンパイラーは、<code>&amp;v</code>のライフタイムが<code>'static</code>でないため、生み出したスレッドでそれを使用できないことに文句を言うでしょう。</p>
</blockquote>
<p>That's not an issue with <code>std::thread::scope</code>—you can <strong>safely borrow from the environment</strong>.</p>
<blockquote>
<p>それは、<code>std::thread::scope</code>で問題ではありません。<strong>環境から安全に借用</strong>できます。</p>
</blockquote>
<p>In our example, <code>v</code> is created before the spawning points.
It will only be dropped <em>after</em> <code>scope</code> returns. At the same time,
all threads spawned inside <code>scope</code> are guaranteed to finish <em>before</em> <code>scope</code> returns,
therefore there is no risk of having dangling references.</p>
<blockquote>
<p>例において、<code>v</code>は生み出された地点の前に作成されます。
それは、<code>scope</code>が戻った <em>後</em> にのみドロップされます。
それと同時に、<code>scope</code>内で生成されたすべてのスレッドは、<code>scope</code>が戻る <em>前</em> に終了することが保証されているため、ダングリング参照を持つリスクはありません。</p>
</blockquote>
<p>The compiler won't complain!</p>
<blockquote>
<p>コンパイラーは文句を言いません。</p>
</blockquote>
<h2 id="exercise-78"><a class="header" href="#exercise-78">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/07_threads/04_scoped_threads"><code>07_threads/04_scoped_threads</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="channelsチャネル"><a class="header" href="#channelsチャネル">Channels（チャネル）</a></h1>
<p>All our spawned threads have been fairly short-lived so far.<br />
Get some input, run a computation, return the result, shut down.</p>
<blockquote>
<p>これまで生み出したスレッドは、かなり短命でした。
何らかの入力を受け取り、計算を実行して、結果を返して、終了します。</p>
</blockquote>
<p>For our ticket management system, we want to do something different:
a client-server architecture.</p>
<blockquote>
<p>チケット管理システムでは、違ったことを行うつもりです。
それは、クライアントサーバーアーキテクチャーです。</p>
</blockquote>
<p>We will have <strong>one long-running server thread</strong>, responsible for managing
our state, the stored tickets.</p>
<blockquote>
<p><strong>1つの長時間実行するサーバースレッド</strong>をもち、状態を管理する責任を持ち、チケットを保存します。</p>
</blockquote>
<p>We will then have <strong>multiple client threads</strong>.<br />
Each client will be able to send <strong>commands</strong> and <strong>queries</strong> to
the stateful thread, in order to change its state (e.g. add a new ticket)
or retrieve information (e.g. get the status of a ticket).<br />
Client threads will run concurrently.</p>
<blockquote>
<p>そして、<strong>複数のクライアントスレッド</strong>を持ちます。
それぞれのクライアントは、新しいチケットを追加して状態を変更する、またチケットの状態を取得するために、状態を持ったスレッドに<strong>コマンド</strong>と<strong>クエリ</strong>を送信します。
クライアントスレッドは、同時並行で実行します。</p>
</blockquote>
<h2 id="communicationコミュニケーション"><a class="header" href="#communicationコミュニケーション">Communication（コミュニケーション）</a></h2>
<p>So far we've only had very limited parent-child communication:</p>
<ul>
<li>The spawned thread borrowed/consumed data from the parent context</li>
<li>The spawned thread returned data to the parent when joined</li>
</ul>
<blockquote>
<p>これまで、とても限定された親と子のコミュニケーションしかありませんでした。</p>
<ul>
<li>生み出したスレッドは、親コンテキストからのデータを借用／消費しました。</li>
<li>生み出したスレッドは、結合されたとき、親にデータを返しました。</li>
</ul>
</blockquote>
<p>This isn't enough for a client-server design.<br />
Clients need to be able to send and receive data from the server thread
<em>after</em> it has been launched.</p>
<blockquote>
<p>これは、クライアント・サーバーの十分な設計ではありません。
クライアントは、それが起動した <em>後</em> で、サーバースレッドにデータを送信または受信できる必要があります。</p>
</blockquote>
<p>We can solve the issue using <strong>channels</strong>.</p>
<blockquote>
<p><strong>チャネル</strong>を使用して、その問題を解決できます。</p>
</blockquote>
<h2 id="channelsチャネル-1"><a class="header" href="#channelsチャネル-1">Channels（チャネル）</a></h2>
<p>Rust's standard library provides <strong>multi-producer, single-consumer</strong> (mpsc) channels
in its <code>std::sync::mpsc</code> module.<br />
There are two channel flavours: bounded and unbounded. We'll stick to the unbounded
version for now, but we'll discuss the pros and cons later on.</p>
<blockquote>
<p>Rust標準ライブラリは<strong>マルチプロデューサー、シングルコンシューマー</strong>（mpsc）チャネルを、<code>std::sync::mpsc</code>モジュールで提供しています。
2つのチャネルの種類があります。それは制限されたものと制限されていないものです。
現時点で、制限されていないものに固執しますが、後で利点と欠点を議論する予定です。</p>
</blockquote>
<p>Channel creation looks like this:</p>
<blockquote>
<p>チャネルの作成は次のようになります。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::mpsc::channel;

let (sender, receiver) = channel();
<span class="boring">}</span></code></pre></pre>
<p>You get a sender and a receiver.<br />
You call <code>send</code> on the sender to push data into the channel.<br />
You call <code>recv</code> on the receiver to pull data from the channel.</p>
<blockquote>
<p>送信者と受信者を取得します。
チャネルにデータをいれるために、送信者で<code>send</code>を呼び出します。
チャネルからデータを引き出すために、受信者で<code>recv</code>を呼び出します。</p>
</blockquote>
<h3 id="multiple-senders複数の送信者"><a class="header" href="#multiple-senders複数の送信者">Multiple senders（複数の送信者）</a></h3>
<p><code>Sender</code> is clonable: we can create multiple senders (e.g. one for
each client thread) and they will all push data into the same channel.</p>
<blockquote>
<p><code>Sender</code>はクローン可能です。クライアントスレッドそれぞれに1つの送信者など、複数の送信者を作成でき、それらは同じチャネルにデータを入れます。</p>
</blockquote>
<p><code>Receiver</code>, instead, is not clonable: there can only be a single receiver
for a given channel.</p>
<blockquote>
<p>代わりに<code>Receiver</code>はクローンではありません。特定のチャネルに単独の受信者のみ存在できます。</p>
</blockquote>
<p>That's what <strong>mpsc</strong> (multi-producer single-consumer) stands for!</p>
<blockquote>
<p>それが<strong>mpsc</strong>（マルチプロデューサーシングルコンシューマー）の意味です！</p>
</blockquote>
<h3 id="message-typeメッセージの型"><a class="header" href="#message-typeメッセージの型">Message type（メッセージの型）</a></h3>
<p>Both <code>Sender</code> and <code>Receiver</code> are generic over a type parameter <code>T</code>.<br />
That's the type of the <em>messages</em> that can travel on our channel.</p>
<blockquote>
<p><code>Sender</code>と<code>Receiver</code>両方は、型パラメーター<code>T</code>に対してジェネリックです。
それは、チャネルを旅行する <em>メッセージ</em> の型です。</p>
</blockquote>
<p>It could be a <code>u64</code>, a struct, an enum, etc.</p>
<blockquote>
<p>それ（<code>T</code>）は、<code>u64</code>、構造体、列挙型などです。</p>
</blockquote>
<h3 id="errorsエラー"><a class="header" href="#errorsエラー">Errors（エラー）</a></h3>
<p>Both <code>send</code> and <code>recv</code> can fail.<br />
<code>send</code> returns an error if the receiver has been dropped.<br />
<code>recv</code> returns an error if all senders have been dropped and the channel is empty.</p>
<blockquote>
<p><code>send</code>と<code>recv</code>両方とも失敗する可能性があります。
<code>send</code>は、受信者がドロップされていた場合、エラーを返します。
<code>recv</code>は、すべての送信者がドロップされていて、チャネルが空の場合、エラーを返します。</p>
</blockquote>
<p>In other words, <code>send</code> and <code>recv</code> error when the channel is effectively closed.</p>
<blockquote>
<p>つまり、チャネルが実質的に閉じられたとき、<code>send</code>と<code>recv</code>はエラーは失敗します。</p>
</blockquote>
<h2 id="exercise-79"><a class="header" href="#exercise-79">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/07_threads/05_channels"><code>07_threads/05_channels</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interior-mutability内部可変性"><a class="header" href="#interior-mutability内部可変性">Interior mutability（内部可変性）</a></h1>
<p>Let's take a moment to reason about the signature of <code>Sender</code>'s <code>send</code>:</p>
<blockquote>
<p><code>Sender</code>の<code>send</code>のシグネチャーについて理由を考える瞬間です。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; Sender&lt;T&gt; {
    pub fn send(&amp;self, t: T) -&gt; Result&lt;(), SendError&lt;T&gt;&gt; {
        // [...]
    }
}
<span class="boring">}</span></code></pre></pre>
<p><code>send</code> takes <code>&amp;self</code> as its argument.<br />
But it's clearly causing a mutation: it's adding a new message to the channel.
What's even more interesting is that <code>Sender</code> is cloneable: we can have multiple instances of <code>Sender</code>
trying to modify the channel state <strong>at the same time</strong>, from different threads.</p>
<blockquote>
<p><code>send</code>はその引数として<code>&amp;self</code>を受け取ります。
しかし、それは明らかに変異を起こします。それは、チャネルに新しいメッセージを追加するからです。
より興味深いことは、<code>Sender</code>がクローン可能なことです。
異なるスレッドで<strong>同時に</strong>チャネルの状態を変更することを試みる、複数の<code>Sender</code>インスタンスを持てます。</p>
</blockquote>
<p>That's the key property we are using to build this client-server architecture. But why does it work?
Doesn't it violate Rust's rules about borrowing? How are we performing mutations via an <em>immutable</em> reference?</p>
<blockquote>
<p>それは、このクライアントサーバーアーキテクチャーを構築するために使用した重要な特徴です。
しかし、それはなぜ機能するのでしょうか？
それは、Rustの借用ルールを破っていませんか？
<em>不変</em> 参照を介して、どのように変異を行っているのでしょうか？</p>
</blockquote>
<h2 id="shared-rather-than-immutable-references不変参照ではなく共有"><a class="header" href="#shared-rather-than-immutable-references不変参照ではなく共有">Shared rather than immutable references（不変参照ではなく共有）</a></h2>
<p>When we introduced the borrow-checker, we named the two types of references we can have in Rust:</p>
<ul>
<li>immutable references (<code>&amp;T</code>)</li>
<li>mutable references (<code>&amp;mut T</code>)</li>
</ul>
<blockquote>
<p>借用チェッカーを紹介したとき、Rustで持てる2種類の参照を名付けました。</p>
<ul>
<li>不変参照（<code>&amp;T</code>）</li>
<li>可変参照（<code>&amp;mut T</code>）</li>
</ul>
</blockquote>
<p>It would have been more accurate to name them:</p>
<ul>
<li>shared references (<code>&amp;T</code>)</li>
<li>exclusive references (<code>&amp;mut T</code>)</li>
</ul>
<blockquote>
<p>それらはより正確な名前が付けられています。</p>
<ul>
<li>共有参照（<code>&amp;T</code>）</li>
<li>排他参照（<code>&amp;mut T</code>）</li>
</ul>
</blockquote>
<p>Immutable/mutable is a mental model that works for the vast majority of cases, and it's a great one to get started
with Rust. But it's not the whole story, as you've just seen: <code>&amp;T</code> doesn't actually guarantee that the data it
points to is immutable.<br />
Don't worry, though: Rust is still keeping its promises.
It's just that the terms are a bit more nuanced than they might seem at first.</p>
<blockquote>
<p>不変／可変は、ほとんどの大半のケースで機能する価値観（メンタルモデル）であり、Rustを始める最適なものです。
しかし、それは全体のストーリーではありません。ちょうど見たように、<code>&amp;T</code>はそれが指し示すデータが不変であることを、実際に保証していません。
ただし、心配しないでください。Rustはまだその約束を守っています。
それらを最初に見たときよりも、用語が少しより微妙になっただけです。</p>
</blockquote>
<h2 id="unsafecell"><a class="header" href="#unsafecell"><code>UnsafeCell</code></a></h2>
<p>Whenever a type allows you to mutate data through a shared reference, you're dealing with <strong>interior mutability</strong>.</p>
<blockquote>
<p>共有参照を介して型がデータを変更できるようにしたときはいつでも、<strong>内部可変性</strong>を扱っています。</p>
</blockquote>
<p>By default, the Rust compiler assumes that shared references are immutable. It <strong>optimises your code</strong> based on that assumption.<br />
The compiler can reorder operations, cache values, and do all sorts of magic to make your code faster.</p>
<blockquote>
<p>デフォルトで、Rustコンパイラーは、共有参照が不変であると仮定します。
コンパイラーはその仮定に基づいて、<strong>コードを最適化</strong>します。
コンパイラーは、操作を再配置、値をキャッシュ、そして、コードを早くするためにあらゆる種類の魔法をかけることができます。</p>
</blockquote>
<p>You can tell the compiler "No, this shared reference is actually mutable" by wrapping the data in an <code>UnsafeCell</code>.<br />
Every time you see a type that allows interior mutability, you can be certain that <code>UnsafeCell</code> is involved,
either directly or indirectly.<br />
Using <code>UnsafeCell</code>, raw pointers and <code>unsafe</code> code, you can mutate data through shared references.</p>
<blockquote>
<p><code>UnsafeCell</code>内にデータをラップすることで、「いいえ、この共有参照は、実際には変更可能です」とコンパイラーに伝えることができます。
内部可変性を許可する型を見るたびに、<code>UnsafeCell</code>が関与していることを確信できます。
<code>UnsafeCell</code>、生ポインターそして<code>unsafe</code>コードを使用して、共有参照を介してデータを変更できます。</p>
</blockquote>
<p>Let's be clear, though: <code>UnsafeCell</code> isn't a magic wand that allows you to ignore the borrow-checker!<br />
<code>unsafe</code> code is still subject to Rust's rules about borrowing and aliasing.
It's an (advanced) tool that you can leverage to build <strong>safe abstractions</strong> whose safety can't be directly expressed
in Rust's type system. Whenever you use the <code>unsafe</code> keyword you're telling the compiler:
"I know what I'm doing, I won't violate your invariants, trust me."</p>
<blockquote>
<p>ただし、明確にしましょう。<code>UnsafeCell</code>は、借用チェッカーを無視させる魔法の杖ではありません！
<code>unsafe</code>コードは、まだ借用とエイリアスに関するRustのルールの対象です。
それは、Rustの型システム内で、安全性を直接表現できない<strong>安全な抽象化</strong>を構築するために利用できる高度なツールです。
<code>unsafe</code>キーワードを使用するときはいつでも、コンパイラーに次を伝えています。
「私は何をしているか理解しています。あなたの不変条件を破るつもりはありません。信じてください。」</p>
</blockquote>
<p>Every time you call an <code>unsafe</code> function, there will be documentation explaining its <strong>safety preconditions</strong>:
under what circumstances it's safe to execute its <code>unsafe</code> block. You can find the ones for <code>UnsafeCell</code>
<a href="https://doc.rust-lang.org/std/cell/struct.UnsafeCell.html">in <code>std</code>'s documentation</a>.</p>
<blockquote>
<p><code>unsafe</code>関数を呼び出すたびに、その<code>unsafe</code>ブロックを実行する安全な環境の下で、その<strong>安全性の前提条件</strong>を説明するドキュメントがあります。
標準ライブラリの<code>UnsafeCell</code>で見つけることができます。</p>
</blockquote>
<p>We won't be using <code>UnsafeCell</code> directly in this course, nor will we be writing <code>unsafe</code> code.
But it's important to know that it's there, why it exists and how it relates to the types you use
every day in Rust.</p>
<blockquote>
<p>このコースにおいて、<code>UnsafeCell</code>を直接使用しませんし、<code>unsafe</code>コードを書くこともありません。
しかし、Rust内になぜそれが存在して、それがどのように毎日使用する型に関連するのかを理解することは重要です。</p>
</blockquote>
<h2 id="key-examples鍵となる例"><a class="header" href="#key-examples鍵となる例">Key examples（鍵となる例）</a></h2>
<p>Let's go through a couple of important <code>std</code> types that leverage interior mutability.<br />
These are types that you'll encounter somewhat often in Rust code, especially if you peek under the hood of
some the libraries you use.</p>
<blockquote>
<p>内部可変性を利用する重要な<code>std</code>の型の組を確認しましょう。
特に使用するライブラリの内部を覗いた場合、Rustコードでかなり頻繁に遭遇する型があります。</p>
</blockquote>
<h3 id="reference-counting参照カウンター"><a class="header" href="#reference-counting参照カウンター">Reference counting（参照カウンター）</a></h3>
<p><code>Rc</code> is a reference-counted pointer.<br />
It wraps around a value and keeps track of how many references to the value exist.
When the last reference is dropped, the value is deallocated.<br />
The value wrapped in an <code>Rc</code> is immutable: you can only get shared references to it.</p>
<blockquote>
<p><code>Rc</code>は参照をカウントするポインターです。
それは値をラップして、その値への参照が存在する数を追跡します。
最後の参照がドロップされたとき、その値は解放されます。
<code>Rc</code>にラップされた値は不変です。それから共有参照のみ得られます。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::rc::Rc;

let a: Rc&lt;String&gt; = Rc::new("My string".to_string());
// Only one reference to the string data exists.
// その文字列データへの参照が唯一存在します。
assert_eq!(Rc::strong_count(&amp;a), 1);

// When we call `clone`, the string data is not copied!
// Instead, the reference count for `Rc` is incremented.
// `clone`を呼び出したとき、文字列データはコピーされません！
// 代わりに、`Rc`の参照カウンターが増加されます。
let b = Rc::clone(&amp;a);
assert_eq!(Rc::strong_count(&amp;a), 2);
assert_eq!(Rc::strong_count(&amp;b), 2);
// ^ Both `a` and `b` point to the same string data
//   and share the same reference counter.
// `a`と`b`両方は、同じ文字列データを指し示して、同じ参照カウンターを共有しています。
<span class="boring">}</span></code></pre></pre>
<p><code>Rc</code> uses <code>UnsafeCell</code> internally to allow shared references to increment and decrement the reference count.</p>
<blockquote>
<p><code>Rc</code>は、共有参照が参照の数を増やしたり減らしたりするために、内部で<code>UnsafeCell</code>を使用しています。</p>
</blockquote>
<blockquote>
<p>上記例の<code>Rc</code>型の変数<code>a</code>と<code>b</code>は<code>mut</code>でないため不変である。
しかし、<code>a</code>と<code>b</code>が共有する参照カウンターを変更するために、内部で<code>UnsafeCell</code>を使用する必要がある。</p>
</blockquote>
<h3 id="refcell"><a class="header" href="#refcell"><code>RefCell</code></a></h3>
<p><code>RefCell</code> is one of the most common examples of interior mutability in Rust.
It allows you to mutate the value wrapped in a <code>RefCell</code> even if you only have an
immutable reference to the <code>RefCell</code> itself.</p>
<blockquote>
<p><code>RefCell</code>は、Rustにおいて内部可変性の最も一般的な例の1つです。
それは、<code>RefCell</code>自身への不変参照を持っていた場合でも、<code>RefCell</code>内にラップした値を変更させます。</p>
</blockquote>
<p>This is done via <strong>runtime borrow checking</strong>.
The <code>RefCell</code> keeps track of the number (and type) of references to the value it contains at runtime.
If you try to borrow the value mutably while it's already borrowed immutably,
the program will panic, ensuring that Rust's borrowing rules are always enforced.</p>
<blockquote>
<p>これは、<strong>ランタイム借用チェッカー</strong>を介して行われます。
<code>RefCell</code>は、ランタイムでそれが含む値への参照の数（と型）を追跡します。
値がすでに不変で借用されている間に、値を可変で借用することを試みた場合、プログラムはパニックして、Rustの借用ルールが常に強制されることを保証します。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::cell::RefCell;

let x = RefCell::new(42);

let y = x.borrow(); // Immutable borrow（不変借用）
let z = x.borrow_mut(); // Panics! There is an active immutable borrow.（パニックします！アクティブな不変借用があります）
<span class="boring">}</span></code></pre></pre>
<h2 id="exercise-80"><a class="header" href="#exercise-80">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/07_threads/06_interior_mutability"><code>07_threads/06_interior_mutability</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="two-way-communication双方向通信"><a class="header" href="#two-way-communication双方向通信">Two-way communication（双方向通信）</a></h1>
<p>In our current client-server implementation, communication flows in one direction: from the client to the server.<br />
The client has no way of knowing if the server received the message, executed it successfully, or failed.
That's not ideal.</p>
<blockquote>
<p>現在のクライアントサーバーの実装において、通信の流れはクライアントからサーバーへ向かう一方向です。
サーバーがメッセージを受け取った場合、正常に実行されたかそれとも失敗したか、クライアントは知る方法がありません。
これは理想的ではありません。</p>
</blockquote>
<p>To solve this issue, we can introduce a two-way communication system.</p>
<blockquote>
<p>この問題を解決するために、双方向通信システムを導入できます。</p>
</blockquote>
<h2 id="response-channel応答チャネル"><a class="header" href="#response-channel応答チャネル">Response channel（応答チャネル）</a></h2>
<p>We need a way for the server to send a response back to the client.<br />
There are various ways to do this, but the simplest option is to include a <code>Sender</code> channel in
the message that the client sends to the server. After processing the message, the server can use
this channel to send a response back to the client.</p>
<blockquote>
<p>サーバーがクライアントに応答を送信する方法が必要です。
これを行う様々な方法がありますが、最も単純な選択肢は、クライアントがサーバーに送信するメッセージ内に<code>Sender</code>チャネルを含めることです。
メッセージを処理した後、サーバーはクライアントにレスポンスを送信するために、このチャネルを使用できます。</p>
</blockquote>
<p>This is a fairly common pattern in Rust applications built on top of message-passing primitives.</p>
<blockquote>
<p>これは、メッセージパッシング構成要素の上に構築されたRustアプリケーションの中で、かなり一般的なパターンです。</p>
</blockquote>
<h2 id="exercise-81"><a class="header" href="#exercise-81">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/07_threads/07_ack"><code>07_threads/07_ack</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a-dedicated-client-type専用のclient型"><a class="header" href="#a-dedicated-client-type専用のclient型">A dedicated <code>Client</code> type（専用のClient型）</a></h1>
<p>All the interactions from the client side have been fairly low-level: you have to
manually create a response channel, build the command, send it to the server, and
then call <code>recv</code> on the response channel to get the response.</p>
<blockquote>
<p>クライアント側からのすべての相互作用は、かなり低水準でした。
手動でレスポンス用のチャネルを作成して、コマンドを構築、それ（レスポンス用のチャネル）をサーバーに送信、そしてレスポンスを得るためにレスポンス用のチャネルに<code>recv</code>を呼び出さなくてはなりません。</p>
</blockquote>
<p>This is a lot of boilerplate code that could be abstracted away, and that's
exactly what we're going to do in this exercise.</p>
<blockquote>
<p>これは、抽象化できる多くの定型コードで、さにそれがこの演習で行うことです。</p>
</blockquote>
<blockquote>
<p>通常の通信を行うチャネルの他に、クライアントはコマンドを送信するときに、サーバーがレスポンスを返すための別チャネルを作成して、その送信側をコマンドに含めてサーバーに送信する。
サーバーは、コマンドを処理後、コマンドに含まれた送信チャネルを使用してクライアントにレスポンスを返す。
クライアントは、作成した別チャネルの受信チャネルでサーバーから送信されるレスポンスを受信する。</p>
</blockquote>
<h2 id="exercise-82"><a class="header" href="#exercise-82">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/07_threads/08_client"><code>07_threads/08_client</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bounded-vs-unbounded-channels制限されたチャネルと非制限チャネル"><a class="header" href="#bounded-vs-unbounded-channels制限されたチャネルと非制限チャネル">Bounded vs unbounded channels（制限されたチャネルと非制限チャネル）</a></h1>
<p>So far we've been using unbounded channels.<br />
You can send as many messages as you want, and the channel will grow to accommodate them.<br />
In a multi-producer single-consumer scenario, this can be problematic: if the producers
enqueues messages at a faster rate than the consumer can process them, the channel will
keep growing, potentially consuming all available memory.</p>
<blockquote>
<p>これまで、非制限チャネルを使用してきました。
望むだけ多くのメッセージを送信でき、チャネルはそれらを収容するために成長します。
マルチプロデューサーシングルコンシューマーシナリオでは、これは問題になる可能性があります。
プロデューサーが、コンシューマーがそれらを処理するよりも早くメッセージをキューに入れた場合、チャネルは成長し続け、利用可能なメモリをすべて消費する可能性があります。</p>
</blockquote>
<p>Our recommendation is to <strong>never</strong> use an unbounded channel in a production system.<br />
You should always enforce an upper limit on the number of messages that can be enqueued using a
<strong>bounded channel</strong>.</p>
<blockquote>
<p>プロダクションシステムにおける推奨事項は、<strong>決して</strong>非制限チャネルを使用しないことです。
<strong>制限されたチャネル</strong>を使用して、常にキューに入れられるメッセージの上限を強制するべきです。</p>
</blockquote>
<h2 id="bounded-channels制限されたチャネル"><a class="header" href="#bounded-channels制限されたチャネル">Bounded channels（制限されたチャネル）</a></h2>
<p>A bounded channel has a fixed capacity.<br />
You can create one by calling <code>sync_channel</code> with a capacity greater than zero:</p>
<blockquote>
<p>制限されたチャネルは固定された容量を持ちます。
ゼロより大きい容量で<code>sync_channel</code>を呼び出すことで、それを作成できます。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::mpsc::sync_channel;

let (sender, receiver) = sync_channel(10);
<span class="boring">}</span></code></pre></pre>
<p><code>receiver</code> has the same type as before, <code>Receiver&lt;T&gt;</code>.<br />
<code>sender</code>, instead, is an instance of <code>SyncSender&lt;T&gt;</code>.</p>
<blockquote>
<p><code>receiver</code>は、前の<code>Receiver&lt;T&gt;</code>と同じ型を持ち、代わりに<code>sender</code>は<code>SyncSender&lt;T&gt;</code>のインスタンスです。</p>
</blockquote>
<h3 id="sending-messagesメッセージの送信"><a class="header" href="#sending-messagesメッセージの送信">Sending messages（メッセージの送信）</a></h3>
<p>You have two different methods to send messages through a <code>SyncSender</code>:</p>
<ul>
<li><code>send</code>: if there is space in the channel, it will enqueue the message and return <code>Ok(())</code>.<br />
If the channel is full, it will block and wait until there is space available.</li>
<li><code>try_send</code>: if there is space in the channel, it will enqueue the message and return <code>Ok(())</code>.<br />
If the channel is full, it will return <code>Err(TrySendError::Full(value))</code>, where <code>value</code> is the message that couldn't be sent.</li>
</ul>
<blockquote>
<p><code>SyncSender</code>を介してメッセージを送信する2つの異なるメソッドがあります。</p>
<ul>
<li><code>send</code>: チャネル内に空きがある場合、それはメッセージをキューに入れて<code>Ok(())</code>を返します。
チャネルがいっぱいの場合、それはブロックして、利用可能な空きができるまで待機します。</li>
<li><code>try_send</code>: チャネル内に空きがある場合、それはメッセージをキューに入れて<code>Ok(())</code>を返します。
チャネルがいっぱいの場合、それは<code>Err(TrySendError::Full(value))</code>を返して、返される<code>value</code>は送信されなかったメッセージです。</li>
</ul>
</blockquote>
<p>Depending on your use case, you might want to use one or the other.</p>
<blockquote>
<p>ユースケースに合わせて、どちらかを使用できます。</p>
</blockquote>
<h3 id="backpressure逆圧"><a class="header" href="#backpressure逆圧">Backpressure（逆圧）</a></h3>
<p>The main advantage of using bounded channels is that they provide a form of <strong>backpressure</strong>.<br />
They force the producers to slow down if the consumer can't keep up.
The backpressure can then propagate through the system, potentially affecting the whole architecture and
preventing end users from overwhelming the system with requests.</p>
<blockquote>
<p>制限されたチャネルを使用する主な利点は、それらが<strong>逆圧</strong>の形式を提供することです。
それら（逆圧）は、コンシューマー（サーバー）がついていけなくなった場合、遅くすることをプロデューサー（クライアント）に強制します。
そして、逆圧はシステムを介して伝播でき、全体のアーキテクチャーに影響を与える可能性があり、エンドユーザーがリクエストでシステムを圧倒することを回避します。</p>
</blockquote>
<h2 id="exercise-83"><a class="header" href="#exercise-83">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/07_threads/09_bounded"><code>07_threads/09_bounded</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="update-operations更新操作"><a class="header" href="#update-operations更新操作">Update operations（更新操作）</a></h1>
<p>So far we've implemented only insertion and retrieval operations.<br />
Let's see how we can expand the system to provide an update operation.</p>
<blockquote>
<p>これまで、挿入と取得操作のみを実装してきました。
更新操作を提供するためにシステムを拡張する方法を確認しましょう。</p>
</blockquote>
<h2 id="legacy-updates従来の更新"><a class="header" href="#legacy-updates従来の更新">Legacy updates（従来の更新）</a></h2>
<p>In the non-threaded version of the system, updates were fairly straightforward: <code>TicketStore</code> exposed a
<code>get_mut</code> method that allowed the caller to obtain a mutable reference to a ticket, and then modify it.</p>
<blockquote>
<p>システムの非スレッドバージョンにおいて、更新はかなり簡単です。
<code>TicketStore</code>は、呼び出し側にチケットの可変参照を取得する<code>get_mut</code>メソッドを公開し、そしてそれを更新します。</p>
</blockquote>
<h2 id="multithreaded-updatesマルチスレッドな更新"><a class="header" href="#multithreaded-updatesマルチスレッドな更新">Multithreaded updates（マルチスレッドな更新）</a></h2>
<p>The same strategy won't work in the current multi-threaded version,
because the mutable reference would have to be sent over a channel. The borrow checker would
stop us, because <code>&amp;mut Ticket</code> doesn't satisfy the <code>'static</code> lifetime requirement of <code>SyncSender::send</code>.</p>
<blockquote>
<p>可変参照はチャネルを通じて送信されなくてはならないため、現在のマルチスレッドバージョンにおいて現在の戦略は機能しません。
<code>&amp;mut Ticket</code>は<code>SyncSender::send</code>の<code>'static</code>ライフタイム要求を満足しないため、借用チェッカーは停止させます。</p>
</blockquote>
<p>There are a few ways to work around this limitation. We'll explore a few of them in the following exercises.</p>
<blockquote>
<p>この制限を回避するいくつかの方法があります。
次の演習でそれらのいくつかを探求する予定です。</p>
</blockquote>
<h3 id="patchingパッチ"><a class="header" href="#patchingパッチ">Patching（パッチ）</a></h3>
<p>We can't send a <code>&amp;mut Ticket</code> over a channel, therefore we can't mutate on the client-side.<br />
Can we mutate on the server-side?</p>
<blockquote>
<p>チャネルで<code>&amp;mut Ticket</code>を送信できないため、クライアント側でチケットを変更できません。
サーバー側で変更できるでしょうか？</p>
</blockquote>
<p>We can, if we tell the server what needs to be changed. In other words, if we send a <strong>patch</strong> to the server:</p>
<blockquote>
<p>サーバーに変更しなくてはならないものを伝えればできます。
言い換えれば、<strong>パッチ</strong>をサーバーに送信する場合です。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct TicketPatch {
    id: TicketId,
    title: Option&lt;TicketTitle&gt;,
    description: Option&lt;TicketDescription&gt;,
    status: Option&lt;TicketStatus&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>id</code> field is mandatory, since it's required to identify the ticket that needs to be updated.<br />
All other fields are optional:</p>
<ul>
<li>If a field is <code>None</code>, it means that the field should not be changed.</li>
<li>If a field is <code>Some(value)</code>, it means that the field should be changed to <code>value</code>.</li>
</ul>
<blockquote>
<p><code>id</code>フィールドは必須なため、それは更新されなければならないチケットを識別するために要求されます。
他のフィールドすべてはオプションです。</p>
<ul>
<li>フィールドが<code>None</code>の場合、それはそのフィールドが変更されるべきでないことを意味します。</li>
<li>フィールドが<code>Some(value)</code>の場合、それはそのフィールドが<code>value</code>に変更されるべきであることを意味します。</li>
</ul>
</blockquote>
<h2 id="exercise-84"><a class="header" href="#exercise-84">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/07_threads/10_patch"><code>07_threads/10_patch</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="locks-send-and-arcロックsendそしてarc"><a class="header" href="#locks-send-and-arcロックsendそしてarc">Locks, <code>Send</code> and <code>Arc</code>（ロック、SendそしてArc）</a></h1>
<p>The patching strategy you just implemented has a major drawback: it's racy.<br />
If two clients send patches for the same ticket roughly at same time, the server will apply them in an arbitrary order.
Whoever enqueues their patch last will overwrite the changes made by the other client.</p>
<blockquote>
<p>ちょうど実装したパッチ戦略は大きな欠点があります。それは際どいです。
2つのクライアントがほぼ同時に同じチケットにパッチを送信した場合、サーバーは任意の順序でそれらを適用します。
最後にそれらのパッチをキューに入れたクライアントが、他のクライアントによって行われた変更を上書きします。</p>
</blockquote>
<h2 id="version-numbersバージョン番号"><a class="header" href="#version-numbersバージョン番号">Version numbers（バージョン番号）</a></h2>
<p>We could try to fix this by using a <strong>version number</strong>.<br />
Each ticket gets assigned a version number upon creation, set to <code>0</code>.<br />
Whenever a client sends a patch, they must include the current version number of the ticket alongside the
desired changes. The server will only apply the patch if the version number matches the one it has stored.</p>
<blockquote>
<p><strong>バージョン番号</strong>を使用して、これを修正することを試みます。
それぞれのチケットは、作成時に<code>0</code>に設定されたバージョン番号を割り当てられます。
クライアントがパッチを送信したときはいつでも、それら（パッチ）は希望する変更と一緒に、チケットの現在のバージョン番号を含まなくてはなりません。
サーバーは、バージョン番号がそれ（サーバー）が保存したものと一致した場合にのみパッチを適用します。</p>
</blockquote>
<p>In the scenario described above, the server would reject the second patch, because the version number would
have been incremented by the first patch and thus wouldn't match the one sent by the second client.</p>
<blockquote>
<p>上記で説明したシナリオにおいて、バージョン番号は最初のパッチによってい増加されており、2番目のクライアントによって送信されたバージョン番号と一致しないため、サーバーは2番目のパッチを拒否します。</p>
</blockquote>
<p>This approach is fairly common in distributed systems (e.g. when client and servers don't share memory),
and it is known as <strong>optimistic concurrency control</strong>.<br />
The idea is that most of the time, conflicts won't happen, so we can optimize for the common case.
You know enough about Rust by now to implement this strategy on your own as a bonus exercise, if you want to.</p>
<blockquote>
<p>この方法は、例えばクライアントとサーバーがメモリを共有していないなどの分散システムでとても一般的で、<strong>楽観的同時実行制御</strong>として知られています。
そのアイデアは、ほとんどの時間で衝突が発生しないため、一般的なケースで最適化できます。
そろそろRustを十分に理解した頃であるため、希望する場合、ボーナスの演習として自身でこの戦略を実装してください。</p>
</blockquote>
<h2 id="lockingロック"><a class="header" href="#lockingロック">Locking（ロック）</a></h2>
<p>We can also fix the race condition by introducing a <strong>lock</strong>.<br />
Whenever a client wants to update a ticket, they must first acquire a lock on it. While the lock is active,
no other client can modify the ticket.</p>
<blockquote>
<p>また、<strong>ロック</strong>を導入することで、競合状態を修正することもできます。
クライアントがチケットを更新したいときはいつでも、それら（クライアント）は、最初にそれ（チケット）のロックを取得しなければなりません。
ロックが有効な間、他のクライアントはチケットを修正できません。</p>
</blockquote>
<p>Rust's standard library provides two different locking primitives: <code>Mutex&lt;T&gt;</code> and <code>RwLock&lt;T&gt;</code>.<br />
Let's start with <code>Mutex&lt;T&gt;</code>. It stands for <strong>mut</strong>ual <strong>ex</strong>clusion, and it's the simplest kind of lock:
it allows only one thread to access the data, no matter if it's for reading or writing.</p>
<blockquote>
<p>Rust標準ライブラリは、<code>Mutex&lt;T&gt;</code>と<code>RwLock&lt;T&gt;</code>の2つの異なるロックの構成要素を提供しています。
<code>Mutex&lt;T&gt;</code>から始めましょう。それは<strong>可変</strong>で<strong>排他</strong>を表していて、それは最も単純な種類のロックです。
それは、読み込みまたは書き込みに関わらず、データへのアクセスをたった1つのスレッドだけ許可します。</p>
</blockquote>
<p><code>Mutex&lt;T&gt;</code> wraps the data it protects, and it's therefore generic over the type of the data.<br />
You can't access the data directly: the type system forces you to acquire a lock first using either <code>Mutex::lock</code> or
<code>Mutex::try_lock</code>. The former blocks until the lock is acquired, the latter returns immediately with an error if the lock
can't be acquired.<br />
Both methods return a guard object that dereferences to the data, allowing you to modify it. The lock is released when
the guard is dropped.</p>
<blockquote>
<p><code>Mutex&lt;T&gt;</code>は、それが保護するデータをラップするため、それはデータ型に対してジェネリックです。
直接データにアクセスできません。型システムは、<code>Mutex::lock</code>または<code>Mutex::try_lock</code>のどちらかを使用して、最初にロックを獲得することを強制します。
前者はロックが獲得されるまでブロックして、後者はロックが獲得できない場合、即座にエラーを返します。
両方のメソッドは、データへの参照を外すガードオブジェクトを返し、それ（データ）を変更できるようにします。
ロックは、ガードがドロップされたときに、解放されます。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::Mutex;

// An integer protected by a mutex lock
// ミューテックスロックによって保護された整数です。
let lock = Mutex::new(0);

// Acquire a lock on the mutex
// ミューテックスのロックを獲得します。
let mut guard = lock.lock().unwrap();

// Modify the data through the guard,
// leveraging its `Deref` implementation
// ガードの`Deref`実装を利用して、ガードを介してデータを修正します。
*guard += 1;

// The lock is released when `data` goes out of scope
// This can be done explicitly by dropping the guard
// or happen implicitly when the guard goes out of scope
// `data`がスコープ外になったとき、ロックは解放されます。
// これは、ガードをドロップすることによって明示に行うか、ガードがスコープ外になったときに暗黙的に発生します。
drop(guard)
<span class="boring">}</span></code></pre></pre>
<h2 id="locking-granularityロックの粒度"><a class="header" href="#locking-granularityロックの粒度">Locking granularity（ロックの粒度）</a></h2>
<p>What should our <code>Mutex</code> wrap?<br />
The simplest option would be the wrap the entire <code>TicketStore</code> in a single <code>Mutex</code>.<br />
This would work, but it would severely limit the system's performance: you wouldn't be able to read tickets in parallel,
because every read would have to wait for the lock to be released.<br />
This is known as <strong>coarse-grained locking</strong>.</p>
<blockquote>
<p>何を<code>Mutex</code>でラップするべきでしょうか？
単純な選択肢は、<code>TicketStore</code>全体を単一の<code>Mutex</code>でラップすることです。
これは機能しますが、システムの性能を著しく制限します。
すべての読み込みはロックの解放を待たなければならないため、並列してチケットを読むことができなくなります。
これは、<strong>粗い粒度のロック</strong>として知られています。</p>
</blockquote>
<p>It would be better to use <strong>fine-grained locking</strong>, where each ticket is protected by its own lock.
This way, clients can keep working with tickets in parallel, as long as they aren't trying to access the same ticket.</p>
<blockquote>
<p>それぞれのチケットがそれ自身をロックすることによって保護する、<strong>適切な粒度のロック</strong>を使用したほうが良いです。
この方法では、クライアントは、同じチケットにアクセスすることを試みない限り、並列でチケットを操作し続けることができます。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// The new structure, with a lock for each ticket
// それぞれのチケットのロックを持つ新しい構造体です。
struct TicketStore {
    tickets: BTreeMap&lt;TicketId, Mutex&lt;Ticket&gt;&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>This approach is more efficient, but it has a downside: <code>TicketStore</code> has to become <strong>aware</strong> of the multithreaded
nature of the system; up until now, <code>TicketStore</code> has been blissfully ignoring the existence of threads.<br />
Let's go for it anyway.</p>
<blockquote>
<p>この方法はより効率的ですが欠点があります。
<code>TicketStore</code>はシステムのマルチスレッド性に<strong>気付く</strong>ようにならなくてはなりません。
これまで、<code>TicketStore</code>はスレッドの存在を穏やかに無視してきました。
とにかくそれをやってみましょう。</p>
</blockquote>
<h2 id="who-holds-the-lock誰がロックを保持するのか"><a class="header" href="#who-holds-the-lock誰がロックを保持するのか">Who holds the lock?（誰がロックを保持するのか？）</a></h2>
<p>For the whole scheme to work, the lock must be passed to the client that wants to modify the ticket.<br />
The client can then directly modify the ticket (as if they had a <code>&amp;mut Ticket</code>) and release the lock when they're done.</p>
<blockquote>
<p>全体のスキームが機能するために、ロックはそのチケットを修正したいクライアントに渡されなければなりません。
そして、クライアントは、<code>&amp;mut Ticket</code>を持っている場合、チケットを直接修正して、終了したときにロックを解放できます。</p>
</blockquote>
<p>This is a bit tricky.<br />
We can't send a <code>Mutex&lt;Ticket&gt;</code> over a channel, because <code>Mutex</code> is not <code>Clone</code> and
we can't move it out of the <code>TicketStore</code>. Could we send the <code>MutexGuard</code> instead?</p>
<blockquote>
<p>これは少しトリッキーです。
<code>Mutex</code>は<code>Clone</code>でなく、<code>TicketStore</code>の外に移動できないため、チャネルを介して<code>Mutex&lt;Ticket&gt;</code>を送信することができません。
代わりに<code>MutexGuard</code>を送信できるでしょうか？</p>
</blockquote>
<p>Let's test the idea with a small example:</p>
<blockquote>
<p>小さな例でそのアイデアをテストしましょう。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">use std::thread::spawn;
use std::sync::Mutex;
use std::sync::mpsc::sync_channel;

fn main() {
    let lock = Mutex::new(0);
    let (sender, receiver) = sync_channel(1);
    let guard = lock.lock().unwrap();

    spawn(move || {
        receiver.recv().unwrap();
    });

    // Try to send the guard over the channel
    // to another thread
    // チャネルを介して、他のスレッドにガードを送信することを試みます。
    sender.send(guard);
}</code></pre></pre>
<p>The compiler is not happy with this code:</p>
<blockquote>
<p>コンパイラーはこのコードに満足していません。</p>
</blockquote>
<pre><code class="language-text">error[E0277]: `MutexGuard&lt;'_, i32&gt;` cannot be sent between threads safely
   --&gt; src/main.rs:10:7
    |
10  |   spawn(move || {
    |  _-----_^
    | | |
    | | required by a bound introduced by this call
11  | |     receiver.recv().unwrap();
12  | | });
    | |_^ `MutexGuard&lt;'_, i32&gt;` cannot be sent between threads safely
    |
    = help: the trait `Send` is not implemented for `MutexGuard&lt;'_, i32&gt;`, which is required by `{closure@src/main.rs:10:7: 10:14}: Send`
    = note: required for `std::sync::mpsc::Receiver&lt;MutexGuard&lt;'_, i32&gt;&gt;` to implement `Send`
note: required because it's used within this closure
</code></pre>
<p><code>MutexGuard&lt;'_, i32&gt;</code> is not <code>Send</code>: what does it mean?</p>
<blockquote>
<p><code>MutexGuard&lt;'_, i32&gt;</code>は<code>Send</code>ではありません。それは何を意味するのでしょうか？</p>
</blockquote>
<h2 id="send"><a class="header" href="#send"><code>Send</code></a></h2>
<p><code>Send</code> is a marker trait that indicates that a type can be safely transferred from one thread to another.<br />
<code>Send</code> is also an auto-trait, just like <code>Sized</code>; it's automatically implemented (or not implemented) for your type
by the compiler, based on its definition.<br />
You can also implement <code>Send</code> manually for your types, but it requires <code>unsafe</code> since you have to guarantee that the
type is indeed safe to send between threads for reasons that the compiler can't automatically verify.</p>
<blockquote>
<p><code>Send</code>は、あるスレッドから他のスレッドに安全に転送できる型を示すマーカートレイトです。
また<code>Send</code>は、ちょうど<code>Sized</code>と同様に自動トレイトです。
それ（<code>Send</code>）は、その（型）の定義に基づいて、コンパイラーによって自動的に実装されます（または実装されません）。
また、型に手動で<code>Send</code>を実装することもできますが、コンパイラーは自動で検証できず、型が確実にスレッド間を安全に送信できることを保証しなくてはならないため、<code>unsafe</code>が要求されます。</p>
</blockquote>
<blockquote>
<p><code>Send</code>を実装した型は、スレッド間で安全に移動（ムーブ）できる。
また、<code>Sync</code>を実装した型は、複数のスレッドから安全に参照できる。</p>
<p>例えば、<code>&amp;T</code>が<code>Send</code>である場合、<code>T</code>は<code>Sync</code>である。例としては、<code>T</code>が不変な値な場合である。</p>
<p>型<code>T</code>が<code>Sync</code>である場合、複数のスレッドから安全に参照できるということは、<code>&amp;T</code>が<code>Send</code>であることを意味する。
そして、<code>&amp;T</code>が<code>Send</code>であれば、<code>&amp;T</code>はスレッド間を移動（ムーブ）できる。</p>
</blockquote>
<h3 id="channel-requirementsチャネルの要求事項"><a class="header" href="#channel-requirementsチャネルの要求事項">Channel requirements（チャネルの要求事項）</a></h3>
<p><code>Sender&lt;T&gt;</code>, <code>SyncSender&lt;T&gt;</code> and <code>Receiver&lt;T&gt;</code> are <code>Send</code> if and only if <code>T</code> is <code>Send</code>.<br />
That's because they are used to send values between threads, and if the value itself is not <code>Send</code>, it would be
unsafe to send it between threads.</p>
<blockquote>
<p><code>Sender&lt;T&gt;</code>、<code>SyncSender&lt;T&gt;</code>そして<code>Receive&lt;T&gt;</code>は<code>Send</code>で、かつ<code>T</code>が<code>Send</code>である場合のみ<code>Send</code>です。
それは、それらがスレッド間で値を送信するために使用されることが理由で、その値自身が<code>Send</code>でない場合、スレッド間でそれを安全に送信できないからです。</p>
</blockquote>
<h3 id="mutexguard"><a class="header" href="#mutexguard"><code>MutexGuard</code></a></h3>
<p><code>MutexGuard</code> is not <code>Send</code> because the underlying operating system primitives that <code>Mutex</code> uses to implement
the lock require (on some platforms) that the lock must be released by the same thread that acquired it.<br />
If we were to send a <code>MutexGuard</code> to another thread, the lock would be released by a different thread, which would
lead to undefined behavior.</p>
<blockquote>
<p><code>MutexGuard</code>は、
<code>Mutex</code>がロックを実装するために使用する基盤となるオペレーティングシステムの構成要素は、（いくつかのプラットフォームで）ロックがそれを獲得した同じスレッドによって解放されなくてはならないことを要求します。
他のスレッドに<code>MutexGuard</code>を送信した場合、ロックは異なるスレッドによって解放されることになり、それは未定義な動作を引き起こします。</p>
</blockquote>
<h2 id="our-challenges課題"><a class="header" href="#our-challenges課題">Our challenges（課題）</a></h2>
<p>Summing it up:</p>
<ul>
<li>We can't send a <code>MutexGuard</code> over a channel. So we can't lock on the server-side and then modify the ticket on the
client-side.</li>
<li>We can send a <code>Mutex</code> over a channel because it's <code>Send</code> as long as the data it protects is <code>Send</code>, which is the
case for <code>Ticket</code>.
At the same time, we can't move the <code>Mutex</code> out of the <code>TicketStore</code> nor clone it.</li>
</ul>
<blockquote>
<p>まとめると・・・</p>
<ul>
<li>チャネルを介して<code>MutexGuard</code>を送信できません。よって、サーバー側でロックして、クライアント側でチケットを修正できません。</li>
<li><code>Mutex</code>は、それが保護するデータが<code>Send</code>である限り<code>Send</code>で、それは<code>Ticket</code>の場合であり、チャネルを介して<code>Mutex</code>を送信できます。
同時に、<code>TicketStore</code>の外側に<code>Mutex</code>を移動できず、それをクローンすることもできません。</li>
</ul>
</blockquote>
<p>How can we solve this conundrum?<br />
We need to look at the problem from a different angle.
To lock a <code>Mutex</code>, we don't need an owned value. A shared reference is enough, since <code>Mutex</code> uses internal mutability:</p>
<blockquote>
<p>どのようにこの難問を解決できるでしょうか？
異なる角度から問題を眺める必要があります。
<code>Mutex</code>をロックするために、値を所有する必要はありません。<code>Mutex</code>は内部可変性を使用するため、共有参照で十分です。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; Mutex&lt;T&gt; {
    // `&amp;self`, not `self`!
    // `self`ではなく`&amp;self`です！
    pub fn lock(&amp;self) -&gt; LockResult&lt;MutexGuard&lt;'_, T&gt;&gt; {
        // Implementation details
    }
}
<span class="boring">}</span></code></pre></pre>
<p>It is therefore enough to send a shared reference to the client.<br />
We can't do that directly, though, because the reference would have to be <code>'static</code> and that's not the case.<br />
In a way, we need an "owned shared reference". It turns out that Rust has a type that fits the bill: <code>Arc</code>.</p>
<blockquote>
<p>よって、クライアントに共有参照を送信するだけで十分です。
それを直接行うことはできませんが、その参照は<code>'static</code>である必要があり、それはその場合ではありません。
ある意味で、「所有した共有参照」が必要です。それは、Rustがその要件を満たす型<code>Arc</code>を持っていることがわかります。</p>
</blockquote>
<h2 id="arc-to-the-rescue救うためのarc"><a class="header" href="#arc-to-the-rescue救うためのarc"><code>Arc</code> to the rescue（救うためのArc）</a></h2>
<p><code>Arc</code> stands for <strong>atomic reference counting</strong>.<br />
<code>Arc</code> wraps around a value and keeps track of how many references to the value exist.
When the last reference is dropped, the value is deallocated.<br />
The value wrapped in an <code>Arc</code> is immutable: you can only get shared references to it.</p>
<blockquote>
<p><code>Arc</code>は<strong>アトミックな参照カウンター</strong>を表しています。
<code>Arc</code>は値をラップして、値への参照がどれだけ存在するか追跡します。
最後の参照がドロップされたとき、その値はドロップされます。
<code>Arc</code>内にラップされた値は不変です。その共有参照のみ得られます。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::Arc;

let data: Arc&lt;u32&gt; = Arc::new(0);
let data_clone = Arc::clone(&amp;data);

// `Arc&lt;T&gt;` implements `Deref&lt;T&gt;`, so can convert
// a `&amp;Arc&lt;T&gt;` to a `&amp;T` using deref coercion
// `Arc&lt;T&gt;`は`Deref&lt;T&gt;`を実装しているため、参照外し型強制を使用して`&amp;Arc&lt;T&gt;`を`&amp;T`に変換できます。
let data_ref: &amp;u32 = &amp;data;
<span class="boring">}</span></code></pre></pre>
<p>If you're having a déjà vu moment, you're right: <code>Arc</code> sounds very similar to <code>Rc</code>, the reference-counted pointer we
introduced when talking about interior mutability. The difference is thread-safety: <code>Rc</code> is not <code>Send</code>, while <code>Arc</code> is.
It boils down to the way the reference count is implemented: <code>Rc</code> uses a "normal" integer, while <code>Arc</code> uses an
<strong>atomic</strong> integer, which can be safely shared and modified across threads.</p>
<blockquote>
<p>デジャブを感じた場合、それは正しいです。
<code>Arc</code>は<code>Rc</code>にとても似ているように聞こえて、<code>Rc</code>は内部可変性について話していたときに導入した参照カウンターのポインターです。
違いはスレッドセーフです。<code>Rc</code>は<code>Send</code>ではなく、<code>Arc</code>は<code>Send</code>です。
それは、参照カウンターを実装する方法を要約しています。
<code>Rc</code>は「普通の」整数を使用している一方で、<code>Arc</code>は<strong>アトミックな</strong>整数を使用していて、それはスレッドをまたいで安全に共有して変更できます。</p>
</blockquote>
<h2 id="arcmutext"><a class="header" href="#arcmutext"><code>Arc&lt;Mutex&lt;T&gt;&gt;</code></a></h2>
<p>If we pair <code>Arc</code> with <code>Mutex</code>, we finally get a type that:</p>
<ul>
<li>Can be sent between threads, because:
<ul>
<li><code>Arc</code> is <code>Send</code> if <code>T</code> is <code>Send</code>, and</li>
<li><code>Mutex</code> is <code>Send</code> if <code>T</code> is <code>Send</code>.</li>
<li><code>T</code> is <code>Ticket</code>, which is <code>Send</code>.</li>
</ul>
</li>
<li>Can be cloned, because <code>Arc</code> is <code>Clone</code> no matter what <code>T</code> is.
Cloning an <code>Arc</code> increments the reference count, the data is not copied.</li>
<li>Can be used to modify the data it wraps, because <code>Arc</code> lets you get a shared
reference to <code>Mutex&lt;T&gt;</code> which can in turn be used to acquire a lock.</li>
</ul>
<blockquote>
<p><code>Arc</code>と<code>Mutex</code>で組み合わせた場合、最終的に次の型が得られます。</p>
<ul>
<li>スレッド間で送信できます。なぜなら・・・
<ul>
<li><code>T</code>が<code>Send</code>である場合、<code>Arc</code>は<code>Send</code>で・・・</li>
<li><code>T</code>が<code>Send</code>である場合、<code>Mutex</code>は<code>Send</code>です。</li>
<li><code>T</code>は<code>Ticket</code>で、それは<code>Send</code>です。</li>
</ul>
</li>
<li><code>T</code>に関わらず、<code>Arc</code>は<code>Clone</code>であるため、クローンできます。
<code>Arc</code>のクローンは、参照カウンターを増やし、そのデータはコピーされません。</li>
<li>それ（<code>Arc</code>）がラップしたデータを変更できます。
なぜなら、<code>Arc</code>は<code>Mutex&lt;T&gt;</code>への共有参照を得られるようにして、次にそれ（<code>Mutex&lt;T&gt;</code>）はロックを獲得するために使用されます。</li>
</ul>
</blockquote>
<p>We have all the pieces we need to implement the locking strategy for our ticket store.</p>
<blockquote>
<p>チケットストア用にロック戦略を実装するために必要なすべての要素が揃いました。</p>
</blockquote>
<h2 id="further-reading参考資料-11"><a class="header" href="#further-reading参考資料-11">Further reading（参考資料）</a></h2>
<ul>
<li>We won't be covering the details of atomic operations in this course, but you can find more information
<a href="https://doc.rust-lang.org/std/sync/atomic/index.html">in the <code>std</code> documentation</a> as well as in the
<a href="https://marabos.nl/atomics/">"Rust atomics and locks" book</a>.</li>
</ul>
<h2 id="exercise-85"><a class="header" href="#exercise-85">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/07_threads/11_locks"><code>07_threads/11_locks</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="readers-and-writersリーダーとライター"><a class="header" href="#readers-and-writersリーダーとライター">Readers and writers（リーダーとライター）</a></h1>
<p>Our new <code>TicketStore</code> works, but its read performance is not great: there can only be one client at a time
reading a specific ticket, because <code>Mutex&lt;T&gt;</code> doesn't distinguish between readers and writers.</p>
<blockquote>
<p>新しい<code>TicketStore</code>は機能しますが、読み込み性能はあまり良くありません。
<code>Mutex&lt;T&gt;</code>はリーダーとライターを区別しないため、特定のチケットを読み込むクライアントは一度に1クライアントしかいません。</p>
</blockquote>
<p>We can solve the issue by using a different locking primitive: <code>RwLock&lt;T&gt;</code>.<br />
<code>RwLock&lt;T&gt;</code> stands for <strong>read-write lock</strong>. It allows <strong>multiple readers</strong> to access the data simultaneously,
but only one writer at a time.</p>
<blockquote>
<p>異なるロック構成要素の<code>RwLock&lt;T&gt;</code>を使用することで、その問題を解決できます。
<code>RwLock&lt;T&gt;</code>は、<strong>読み書きロック</strong>を表しています。
それは、同時に<strong>複数リーダー</strong>をデータにアクセスさせますが、一度に1つのライターのみアクセスさせます。</p>
</blockquote>
<p><code>RwLock&lt;T&gt;</code> has two methods to acquire a lock: <code>read</code> and <code>write</code>.<br />
<code>read</code> returns a guard that allows you to read the data, while <code>write</code> returns a guard that allows you to modify it.</p>
<blockquote>
<p><code>RwLock&lt;T&gt;</code>は、<code>read</code>と<code>write</code>の2つのロックを獲得するメソッドがあります。
<code>read</code>はデータを読み取りさせるガードを返し、<code>write</code>はそれを修正させるガードを返します。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::RwLock;

// An integer protected by a read-write lock
// 読み書きロックによって保護された整数です。
let lock = RwLock::new(0);

// Acquire a read lock on the RwLock
// RwLockの読み込み専用ロックを獲得します。
let guard1 = lock.read().unwrap();

// Acquire a **second** read lock
// while the first one is still active
// 最初の読み込み専用ロックが有効な間に、**2番目の**読み込み専用ロックを獲得します。
let guard2 = lock.read().unwrap();
<span class="boring">}</span></code></pre></pre>
<h2 id="trade-offs二律背反"><a class="header" href="#trade-offs二律背反">Trade-offs（二律背反）</a></h2>
<p>On the surface, <code>RwLock&lt;T&gt;</code> seems like a no-brainer: it provides a superset of the functionality of <code>Mutex&lt;T&gt;</code>.
Why would you ever use <code>Mutex&lt;T&gt;</code> if you can use <code>RwLock&lt;T&gt;</code> instead?</p>
<blockquote>
<p>表面上、<code>RwLock&lt;T&gt;</code>は考えるまでもないように見えます。それは<code>Mutex&lt;T&gt;</code>の機能のスーパーセットを提供します。
代わって<code>RwLock&lt;T&gt;</code>を使用できるのに、なぜ<code>Mutex&lt;T&gt;</code>をまだ使用するのでしょうか。</p>
</blockquote>
<p>There are two key reasons:</p>
<ul>
<li>Locking a <code>RwLock&lt;T&gt;</code> is more expensive than locking a <code>Mutex&lt;T&gt;</code>.<br />
This is because <code>RwLock&lt;T&gt;</code> has to keep track of the number of active readers and writers, while <code>Mutex&lt;T&gt;</code>
only has to keep track of whether the lock is held or not.
This performance overhead is not an issue if there are more readers than writers, but if the workload
is write-heavy <code>Mutex&lt;T&gt;</code> might be a better choice.</li>
<li><code>RwLock&lt;T&gt;</code> can cause <strong>writer starvation</strong>.<br />
If there are always readers waiting to acquire the lock, writers might never get a chance to run.<br />
<code>RwLock&lt;T&gt;</code> doesn't provide any guarantees about the order in which readers and writers are granted access to the lock.
It depends on the policy implemented by the underlying OS, which might not be fair to writers.</li>
</ul>
<blockquote>
<p>主に2つの理由があります。</p>
<ul>
<li><code>RwLock&lt;T&gt;</code>をロックすることは、<code>Mutex&lt;T&gt;</code>をロックするよりもコストが高いです。
これは、<code>RwLock&lt;T&gt;</code>は有効なリーダーとライターの数を追跡する一方で、<code>Mutex&lt;T&gt;</code>はロックが保持されているかどうかを追跡するだけだからです。
この性能のオーバーヘッドは、ライターよりもリーダーのほうが多い場合は問題になりませんが、ワークロードがライター重視の場合、<code>Mutex&lt;T&gt;</code>が良い選択かもしれません。</li>
<li><code>RwLock&lt;T&gt;</code>は<strong>ライターの飢餓</strong>を引き起こす可能性があります。
ロックを獲得するために常にリーダーが待機している場合、ライターは実行する機会を得られないかもしれません。
<code>RwLock&lt;T&gt;</code>は、リーダーとライターがロックにアクセスする権限を与える順序を保証しません。
それは、基盤となるOSによって実装された方針に依存して、ライターにとって公平でないかもしれません。</li>
</ul>
</blockquote>
<p>In our case, we can expect the workload to be read-heavy (since most clients will be reading tickets, not modifying them),
so <code>RwLock&lt;T&gt;</code> is a good choice.</p>
<blockquote>
<p>チケット管理システムの場合、ほとんどのクライアントはチケットを読み込み、チケットの修正はほとんどないため、ワークロードはリーダー重視であると期待できるため、<code>RwLock&lt;T&gt;</code>は良い選択です。</p>
</blockquote>
<h2 id="exercise-86"><a class="header" href="#exercise-86">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/07_threads/12_rw_lock"><code>07_threads/12_rw_lock</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="design-review設計レビュー"><a class="header" href="#design-review設計レビュー">Design review（設計レビュー）</a></h1>
<p>Let's take a moment to review the journey we've been through.</p>
<blockquote>
<p>少しの間、これまでの旅をレビューしてみましょう。</p>
</blockquote>
<h2 id="lockless-with-channel-serializationチャネルのシリアライゼーションを使用したロックレス"><a class="header" href="#lockless-with-channel-serializationチャネルのシリアライゼーションを使用したロックレス">Lockless with channel serialization（チャネルのシリアライゼーションを使用したロックレス）</a></h2>
<p>Our first implementation of a multithreaded ticket store used:</p>
<ul>
<li>a single long-lived thread (server), to hold the shared state</li>
<li>multiple clients sending requests to it via channels from their own threads.</li>
</ul>
<blockquote>
<p>マルチスレッドなチケットストアの最初の実装は、次を使用しました。</p>
<ul>
<li>共有された状態を保持する単一で長生きするスレッド（サーバー）</li>
<li>それぞれ自身のスレッドからチャネルを介してリクエストを送信する複数のクライアント</li>
</ul>
</blockquote>
<p>No locking of the state was necessary, since the server was the only one modifying the state. That's because
the "inbox" channel naturally <strong>serialized</strong> incoming requests: the server would process them one by one.<br />
We've already discussed the limitations of this approach when it comes to patching behaviour, but we didn't
discuss the performance implications of the original design: the server could only process one request at a time,
including reads.</p>
<blockquote>
<p>サーバーは状態を変更する唯一のものであったため、状態のロックは必要ありませんでした。
それは、「受信」チャネルが自然に入ってくるリクエストを<strong>シリアライズ</strong>したからです。サーバーはそれらを1つずつ処理しました。
パッチの振る舞いに来たとき、この振る舞いの制限をすでに議論しましたが、オリジナルの設計の性能の影響については議論しませんでした。
サーバーは、読み込みを含めて一度に1つのリクエストしか処理できません。</p>
</blockquote>
<h2 id="fine-grained-locking適切な粒度のロック"><a class="header" href="#fine-grained-locking適切な粒度のロック">Fine-grained locking（適切な粒度のロック）</a></h2>
<p>We then moved to a more sophisticated design, where each ticket was protected by its own lock and
clients could independently decide if they wanted to read or atomically modify a ticket, acquiring the appropriate lock.</p>
<blockquote>
<p>そして、より洗練された設計に移行して、それぞれのチケットがそれ自身のロックによって保護され、クライアントは独立で適切なロックを獲得して、チケットの読み込みかアトミックな修正かを決定できました。</p>
</blockquote>
<p>This design allows for better parallelism (i.e. multiple clients can read tickets at the same time), but it is
still fundamentally <strong>serial</strong>: the server processes commands one by one. In particular, it hands out locks to clients
one by one.</p>
<blockquote>
<p>例えば、複数クライアントが同時にチケットを読み込めれるように、この設計は良い並列処理を可能にしますが、それはまだ基本的に<strong>シリアル</strong>です。</p>
</blockquote>
<p>Could we remove the channels entirely and allow clients to directly access the <code>TicketStore</code>, relying exclusively on
locks to synchronize access?</p>
<blockquote>
<p>完全にチャネルを削除して、クライアントが直接<code>TicketStore</code>にアクセスして、同期的なアクセスをするために排他的なロックに依存することができるでしょうか？</p>
</blockquote>
<h2 id="removing-channelsチャネルの削除"><a class="header" href="#removing-channelsチャネルの削除">Removing channels（チャネルの削除）</a></h2>
<p>We have two problems to solve:</p>
<ul>
<li>Sharing <code>TicketStore</code> across threads</li>
<li>Synchronizing access to the store</li>
</ul>
<blockquote>
<p>解決するために問題が2つあります。</p>
<ul>
<li>スレッドをまたいで<code>TicketStore</code>を共有する</li>
<li>ストアへの同期アクセス</li>
</ul>
</blockquote>
<h3 id="sharing-ticketstore-across-threadsスレッドをまたいだticketstoreの共有"><a class="header" href="#sharing-ticketstore-across-threadsスレッドをまたいだticketstoreの共有">Sharing <code>TicketStore</code> across threads（スレッドをまたいだTicketStoreの共有）</a></h3>
<p>We want all threads to refer to the same state, otherwise we don't really have a multithreaded system—we're just
running multiple single-threaded systems in parallel.<br />
We've already encountered this problem when we tried to share a lock across threads: we can use an <code>Arc</code>.</p>
<blockquote>
<p>すべてのスレッドが同じ状態を参照できるようにしたいです。そうでないと、本物のマルチスレッドなシステムではありません。
単に並列で複数の単一スレッドなシステムを実行しているだけです。
スレッドをまたいでロックを共有することを試みたときに、この問題に遭遇しました。<code>Arc</code>を使用できます。</p>
</blockquote>
<h3 id="synchronizing-access-to-the-storeストアへの同期アクセス"><a class="header" href="#synchronizing-access-to-the-storeストアへの同期アクセス">Synchronizing access to the store（ストアへの同期アクセス）</a></h3>
<p>There is one interaction that's still lockless thanks to the serialization provided by the channels: inserting
(or removing) a ticket from the store.<br />
If we remove the channels, we need to introduce (another) lock to synchronize access to the <code>TicketStore</code> itself.</p>
<blockquote>
<p>チャネルによって提供されたシリアライゼーションのおかげで、まだロックレスな相互作用が1つあります。
それは、ストアにチケットを挿入（または削除）することです。
チャネルを削除する場合、<code>TicketStore</code>自身に同期アクセスするために他のロックを導入する必要があります。</p>
</blockquote>
<p>If we use a <code>Mutex</code>, then it makes no sense to use an additional <code>RwLock</code> for each ticket: the <code>Mutex</code> will
already serialize access to the entire store, so we wouldn't be able to read tickets in parallel anyway.<br />
If we use a <code>RwLock</code>, instead, we can read tickets in parallel. We just need to pause all reads while inserting
or removing a ticket.</p>
<blockquote>
<p><code>Mutex</code>を使用する場合、それぞれのチケットに対して追加の<code>RwLock</code>を使用する意味がありません。
<code>Mutex</code>は、すでにストア全体へのアクセスをシリアライズするため、並列でチケットを読み込むことができなくなります。
代わりに<code>RwLock</code>を使用した場合、並列でチケットを読み込むことができます。
チケットの挿入または削除の間、単にすべての読み込みを停止する必要があります。</p>
</blockquote>
<p>Let's go down this path and see where it leads us.</p>
<blockquote>
<p>この道を進んで、どこに導かれるか確認しましょう。</p>
</blockquote>
<h2 id="exercise-87"><a class="header" href="#exercise-87">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/07_threads/13_without_channels"><code>07_threads/13_without_channels</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sync"><a class="header" href="#sync"><code>Sync</code></a></h1>
<p>Before we wrap up this chapter, let's talk about another key trait in Rust's standard library: <code>Sync</code>.</p>
<blockquote>
<p>この章を仕上げる前に、Rust標準ライブラリにある他の主要なトレイトである<code>Sync</code>について話しましょう。</p>
</blockquote>
<p><code>Sync</code> is an auto trait, just like <code>Send</code>.<br />
It is automatically implemented by all types that can be safely <strong>shared</strong> between threads.</p>
<blockquote>
<p><code>Sync</code>は、ちょうど<code>Send</code>と同様に自動トレイトです。
それは、スレッド間で安全に<strong>共有</strong>できるすべての型に自動的に実装されます。</p>
</blockquote>
<p>In order words: <code>T: Sync</code> means that <code>&amp;T</code> is <code>Send</code>.</p>
<blockquote>
<p>言い換えれば、<code>T: Sync</code>は、<code>&amp;T</code>が<code>Send</code>であることを意味します。</p>
</blockquote>
<h2 id="sync-doesnt-imply-sendsyncはsendを暗に意味しない"><a class="header" href="#sync-doesnt-imply-sendsyncはsendを暗に意味しない"><code>Sync</code> doesn't imply <code>Send</code>（SyncはSendを暗に意味しない）</a></h2>
<p>It's important to note that <code>Sync</code> doesn't imply <code>Send</code>.<br />
For example: <code>MutexGuard</code> is not <code>Send</code>, but it is <code>Sync</code>.</p>
<blockquote>
<p><code>Sync</code>が<code>Send</code>を暗に意味しないことは重要な注意事項です。
例えば、<code>MutexGuard</code>は<code>Send</code>ではありませんが、<code>Sync</code>です。</p>
</blockquote>
<blockquote>
<p><code>&amp;MutexGuard</code>は<code>Send</code>であるが、<code>MutexGuard</code>は<code>Send</code>でない。</p>
</blockquote>
<p>It isn't <code>Send</code> because the lock must be released on the same thread that acquired it, therefore we don't
want <code>MutexGuard</code> to be dropped on a different thread.<br />
But it is <code>Sync</code>, because giving a <code>&amp;MutexGuard</code> to another thread has no impact on where the lock is released.</p>
<blockquote>
<p>ロックは、それを獲得した同じスレッドで解放されなければならないため、<code>MutexGuard</code>が異なるスレッドでドロップされることを望んでないため、<code>MutexGuard</code>は<code>Send</code>ではありません。
しかし、<code>MutexGuard</code>は<code>Sync</code>で、それは<code>&amp;MutexGuard</code>を他のスレッドに与えることは、ロックが解放される場所に影響を与えないからです。</p>
</blockquote>
<blockquote>
<p><code>MutexGuard</code>のロックを解放するためには、所有権または可変参照が必要になる。
よって、<code>&amp;MutexGuard</code>では、ロックを解放できない。</p>
</blockquote>
<h2 id="send-doesnt-imply-syncsendはsyncを暗に意味しない"><a class="header" href="#send-doesnt-imply-syncsendはsyncを暗に意味しない"><code>Send</code> doesn't imply <code>Sync</code>（SendはSyncを暗に意味しない）</a></h2>
<p>The opposite is also true: <code>Send</code> doesn't imply <code>Sync</code>.<br />
For example: <code>RefCell&lt;T&gt;</code> is <code>Send</code> (if <code>T</code> is <code>Send</code>), but it is not <code>Sync</code>.</p>
<blockquote>
<p>また反対も成立します。<code>Send</code>は<code>Sync</code>を暗に意味しません。</p>
</blockquote>
<p><code>RefCell&lt;T&gt;</code> performs runtime borrow checking, but the counters it uses to track borrows are not thread-safe.
Therefore, having multiple threads holding a <code>&amp;RefCell</code> would lead to a data race, with potentially
multiple threads obtaining mutable references to the same data. Hence <code>RefCell</code> is not <code>Sync</code>.<br />
<code>Send</code> is fine, instead, because when we send a <code>RefCell</code> to another thread we're not
leaving behind any references to the data it contains, hence no risk of concurrent mutable access.</p>
<blockquote>
<p><code>RefCell&lt;T&gt;</code>は、ラインタイムで借用チェックを行いますが、借用を追跡するためにそれが使用するカウンターはスレッドセーフではありません。
よって、<code>&amp;RefCell</code>を保持する複数のスレッドを持つことは、データ競合を引き起こし、潜在的に複数のスレッドが同じデータへの可変参照を取得する可能性があります。
よって、<code>RefCell</code>は<code>Sync</code>ではありません。
代わりに<code>Send</code>は問題ありません。なぜなら、他のスレッドに<code>RefCell</code>を送信したとき、それが含むデータへの参照を背後に残すことはないためで、並行な可変アクセスのリスクはありません。</p>
</blockquote>
<h2 id="exercise-88"><a class="header" href="#exercise-88">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/07_threads/14_sync"><code>07_threads/14_sync</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="async-rust非同期rust"><a class="header" href="#async-rust非同期rust">Async Rust（非同期Rust）</a></h1>
<p>Threads are not the only way to write concurrent programs in Rust.<br />
In this chapter we'll explore another approach: <strong>asynchronous programming</strong>.</p>
<blockquote>
<p>Rustにおいて、スレッドは同時並行プログラムを記述する唯一の方法ではありません。
この章において、<strong>非同期プログラミング</strong>という他の手法を探求します。</p>
</blockquote>
<p>In particular, you'll get an introduction to:</p>
<ul>
<li>The <code>async</code>/<code>.await</code> keywords, to write asynchronous code effortlessly</li>
<li>The <code>Future</code> trait, to represent computations that may not be complete yet</li>
<li><code>tokio</code>, the most popular runtime for running asynchronous code</li>
<li>The cooperative nature of Rust asynchronous model, and how this affects your code</li>
</ul>
<blockquote>
<p>特に、以下について紹介する予定です。</p>
<ul>
<li>苦労せずに非同期コードを記述するための<code>async</code>/<code>.await</code>キーワード</li>
<li>まだ完了していないかもしれない計算を表現する<code>Future</code>トレイト</li>
<li>非同期コードを実行する最も人気のあるランタイムである<code>tokio</code></li>
<li>Rustの非同期モデルの協調的な性質と、これがどのようにコードに影響を与えるか</li>
</ul>
</blockquote>
<h2 id="exercise-89"><a class="header" href="#exercise-89">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/08_futures/00_intro"><code>08_futures/00_intro</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="asynchronous-functions非同期関数"><a class="header" href="#asynchronous-functions非同期関数">Asynchronous functions（非同期関数）</a></h1>
<p>All the functions and methods you've written so far were eager.<br />
Nothing happened until you invoked them. But once you did, they ran to
completion: they did <strong>all</strong> their work, and then returned their output.</p>
<blockquote>
<p>これまで記述してきたすべての関数とメソッドは熱心でした。
それらを呼び出すまで何も起こりません。しかし、一旦、呼び出すと、それらは完了するまで実行しました。
それらは仕事を<strong>すべて</strong>行い、出力を返しました。</p>
</blockquote>
<p>Sometimes that's undesirable.<br />
For example, if you're writing an HTTP server, there might be a lot of
<strong>waiting</strong>: waiting for the request body to arrive, waiting for the
database to respond, waiting for a downstream service to reply, etc.</p>
<blockquote>
<p>時々、それは望ましくありません。
例えば、HTTPサーバーを記述している場合、リクエスト本体の到着を待つ、データベースの反応を待つ、下流サービスの応答を待つなど、多くの<strong>待機</strong>があるかもしれません。</p>
</blockquote>
<p>What if you could do something else while you're waiting?<br />
What if you could choose to give up midway through a computation?<br />
What if you could choose to prioritise another task over the current one?</p>
<blockquote>
<p>待っている間に他になにかすることができるとしたらどうでしょうか？
計算の途中で諦めることを選択できるとしたらどうでしょうか？
現在のタスクよりも他のタスクの優先することを選択できるとしたらどうでしょうか？</p>
</blockquote>
<p>That's where <strong>asynchronous functions</strong> come in.</p>
<blockquote>
<p>そこで<strong>非同期関数</strong>が登場します。</p>
</blockquote>
<h2 id="async-fn"><a class="header" href="#async-fn"><code>async fn</code></a></h2>
<p>You use the <code>async</code> keyword to define an asynchronous function:</p>
<blockquote>
<p>非同期関数を定義するために<code>async</code>キーワードを使用します。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tokio::net::TcpListener;

// This function is asynchronous
// この関数は非同期です。
async fn bind_random() -&gt; TcpListener {
    // [...]
}
<span class="boring">}</span></code></pre></pre>
<p>What happens if you call <code>bind_random</code> as you would a regular function?</p>
<blockquote>
<p>通常の関数のように<code>bind_random</code>を呼び出した場合、何が起こるでしょうか？</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn run() {
    // Invoke `bind_random`
    // `bind_random`を呼び出します。
    let listener = bind_random();
    // Now what?
    // ここで何が起こりますか？
}
<span class="boring">}</span></code></pre></pre>
<p>Nothing happens!<br />
Rust doesn't start executing <code>bind_random</code> when you call it,
not even as a background task (as you might expect based on your experience
with other languages).
Asynchronous functions in Rust are <strong>lazy</strong>: they don't do any work until you
explicitly ask them to.
Using Rust's terminology, we say that <code>bind_random</code> returns a <strong>future</strong>, a type
that represents a computation that may complete later. They're called futures
because they implement the <code>Future</code> trait, an interface that we'll examine in
detail later on in this chapter.</p>
<blockquote>
<p>何も起こりません！
Rustは、<code>bind_random</code>を呼び出したときに、それの実行を開始せず、他の言語の経験に基づいて予想したように、バックグラウンドタスクとしても開始しません。
Rustにおける非同期関数は<strong>怠惰</strong>です。
それらは、明示的にそれらに問い合わせするまで、何の作業も行いません。
Rustの専門用語を使用して、<code>bind_random</code>は<strong>フューチャー</strong>を返すといいます。
フューチャーは、後で完了するかもしれない計算を表現する方です。
それらは、<code>Future</code>トレイトを実装しているため、フューチャーと呼ばれます。
<code>Future</code>トレイトのインターフェイスは、この章の後半で詳しく調べる予定です。</p>
</blockquote>
<h2 id="await"><a class="header" href="#await"><code>.await</code></a></h2>
<p>The most common way to ask an asynchronous function to do some work is to use
the <code>.await</code> keyword:</p>
<blockquote>
<p>何らかの仕事をするために非同期関数に問い合わせする最も一般的な方法は、<code>.await</code>キーワードを使用することです。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tokio::net::TcpListener;

async fn bind_random() -&gt; TcpListener {
    // [...]
}

async fn run() {
    // Invoke `bind_random` and wait for it to complete
    // `bind_random`を呼び出し、それが完了するまで待機します。
    let listener = bind_random().await;
    // Now `listener` is ready
    // ここで、`lister`は準備できています。
}
<span class="boring">}</span></code></pre></pre>
<p><code>.await</code> doesn't return control to the caller until the asynchronous function
has run to completion—e.g. until the <code>TcpListener</code> has been created in the example above.</p>
<blockquote>
<p><code>.await</code>は、非同期関数が完了まで実行されるまで、呼び出し側に制御を返しません。
つまり、上記例において、<code>TcpListener</code>が作成されるまで制御を返しません。</p>
</blockquote>
<h2 id="runtimes"><a class="header" href="#runtimes">Runtimes</a></h2>
<p>If you're puzzled, you're right to be!<br />
We've just said that the perk of asynchronous functions
is that they don't do <strong>all</strong> their work at once. We then introduced <code>.await</code>, which
doesn't return until the asynchronous function has run to completion. Haven't we
just re-introduced the problem we were trying to solve? What's the point?</p>
<blockquote>
<p>もし戸惑っているなら、それは当然です！
非同期関数の利点は、それらが一度に<strong>すべて</strong>の仕事を行わないことだと言いました。
<code>.await</code>を導入したとき、それは非同期関数が完了まで実行されるまで戻りません。
解決しようとしていた問題を再度持ち出しただけでしょうか？
何がポイントなのでしょうか？</p>
</blockquote>
<p>Not quite! A lot happens behind the scenes when you call <code>.await</code>!<br />
You're yielding control to an <strong>async runtime</strong>, also known as an <strong>async executor</strong>.
Executors are where the magic happens: they are in charge of managing all your
ongoing asynchronous <strong>tasks</strong>. In particular, they balance two different goals:</p>
<ul>
<li><strong>Progress</strong>: they make sure that tasks make progress whenever they can.</li>
<li><strong>Efficiency</strong>: if a task is waiting for something, they try to make sure that
another task can run in the meantime, fully utilising the available resources.</li>
</ul>
<blockquote>
<p>全くそうではありません！<code>.await</code>を呼び出したとき、多くのことが背後で発生します！
<strong>非同期エグゼキューター</strong>として知られる、<strong>非同期ランタイム</strong>に制御を移譲しています。
エグゼキューターは、そこで魔法を起こします。
エグゼキューターは、実行中の非同期タスクをすべて管理する責任があります。
特に、2つの異なる目的のバランスを取ります。</p>
<ul>
<li><strong>進捗</strong>: エグゼキューターは、タスクが可能なときはいつでも、タスクを進めます。</li>
<li><strong>効率性</strong>: タスクが何かを待っている場合、エグゼキューターは、その間に他のタスクを実行することを試みて、利用可能な資源を十分に活用します。</li>
</ul>
</blockquote>
<h3 id="no-default-runtimeデフォルトランタイムはない"><a class="header" href="#no-default-runtimeデフォルトランタイムはない">No default runtime（デフォルトランタイムはない）</a></h3>
<p>Rust is fairly unique in its approach to asynchronous programing: there is
no default runtime. The standard library doesn't ship with one. You need to
bring your own!</p>
<blockquote>
<p>Rustは、非同期プログラミングへのアプローチがかなり独特です。
デフォルトのランタイムはありません。
標準ライブラリは、それを一緒に提供していません。
独自に持ってくる必要があります！</p>
</blockquote>
<p>In most cases, you'll choose one of the options available in the ecosystem.
Some runtimes are designed to be broadly applicable, a solid option for most applications.
<code>tokio</code> and <code>async-std</code> belong to this category. Other runtimes are optimised for
specific use cases—e.g. <code>embassy</code> for embedded systems.</p>
<blockquote>
<p>ほとんどの場合、エコシステムに存在する1つを選択します。
いくつかのランタイムは、広く適用できるように設計されており、ほとんどのアプリケーションにとって堅実な選択となります。
<code>tokio</code>と<code>async-std</code>は、このカテゴリに属しています。
例えば、<code>embassy</code>は組み込みシステム用であるなど、他のランタイムは特定のユースケースのために最適化されています。</p>
</blockquote>
<p>Throughout this course we'll rely on <code>tokio</code>, the most popular runtime for general-purpose
asynchronous programming in Rust.</p>
<blockquote>
<p>このコースは一貫として<code>tokio</code>に依存する予定で、Rustにおいて、それは一般的な目的の非同期プログラミングで、最も人気のあるランタイムです。</p>
</blockquote>
<h3 id="tokiomain"><a class="header" href="#tokiomain"><code>#[tokio::main]</code></a></h3>
<p>The entrypoint of your executable, the <code>main</code> function, must be a synchronous function.
That's where you're supposed to set up and launch your chosen async runtime.</p>
<blockquote>
<p>実行形式のエントリポイントは、<code>main</code>関数で、それは非同期関数でなくてはなりません。
それは、選択した非同期ランタイムを準備して起動することを支援されるところです。</p>
</blockquote>
<blockquote>
<p>「それは選択した非同期ランタイムが準備して起動することを支援します。」の誤り？</p>
</blockquote>
<p>Most runtimes provides a macro to make this easier. For <code>tokio</code>, it's <code>tokio::main</code>:</p>
<blockquote>
<p>ほとんどのランタイムは、これを簡単にするマクロを提供しています。<code>tokio</code>の場合、それは<code>tokio::main</code>です。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">#[tokio::main]
async fn main() {
    // Your async code goes here
    // 非同期コードがここに入ります。
}</code></pre></pre>
<p>which expands to:</p>
<blockquote>
<p>それは次のように展開されます。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let rt = tokio::runtime::Runtime::new().unwrap();
    rt.block_on(
        // Your async function goes here
        // [...]
    );
}</code></pre></pre>
<h3 id="tokiotest"><a class="header" href="#tokiotest"><code>#[tokio::test]</code></a></h3>
<p>The same goes for tests: they must be synchronous functions.<br />
Each test function is run in its own thread, and you're responsible for
setting up and launching an async runtime if you need to run async code
in your tests.<br />
<code>tokio</code> provides a <code>#[tokio::test]</code> macro to make this easier:</p>
<blockquote>
<p>テストについても同様です。それらは同期関数でなくてはなりません。
それぞれのテスト関数は、それ自身のスレッドで実行され、テスト内で非同期コードを実行する必要がある場合、開発者が非同期ランタイムを準備して起動する責任があります。
<code>tokio</code>はこれを簡単にするために<code>#[tokio::test]</code>マクロを提供しています。</p>
</blockquote>
<blockquote>
<p>「それらは<strong>非</strong>同期関数でなくてはなりません」の誤り？</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn my_test() {
    // Your async test code goes here
}
<span class="boring">}</span></code></pre></pre>
<h2 id="exercise-90"><a class="header" href="#exercise-90">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/08_futures/01_async_fn"><code>08_futures/01_async_fn</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="spawning-tasksタスクを生み出す"><a class="header" href="#spawning-tasksタスクを生み出す">Spawning tasks（タスクを生み出す）</a></h1>
<p>Your solution to the previous exercise should look something like this:</p>
<blockquote>
<p>前の演習の解答は次のようになるはずです。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub async fn echo(listener: TcpListener) -&gt; Result&lt;(), anyhow::Error&gt; {
    loop {
        let (mut socket, _) = listener.accept().await?;
        let (mut reader, mut writer) = socket.split();
        tokio::io::copy(&amp;mut reader, &amp;mut writer).await?;
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This is not bad!<br />
If a long time passes between two incoming connections, the <code>echo</code> function will be idle
(since <code>TcpListener::accept</code> is an asynchronous function), thus allowing the executor
to run other tasks in the meantime.</p>
<blockquote>
<p>それは悪くありません！
2つの着信接続の間で長い時間が経過すると、<code>TcpListener::accept</code>が非同期関数であるため、<code>echo</code>関数はアイドル状態になり、その間、エグゼキューターに他のタスクを実行させます。</p>
</blockquote>
<p>But how can we actually have multiple tasks running concurrently?<br />
If we always run our asynchronous functions until completion (by using <code>.await</code>), we'll never
have more than one task running at a time.</p>
<blockquote>
<p>しかし、実際、どのように複数のタスクを同時並行で実行するのでしょうか？
<code>.await</code>を使用して、常に完了するまで非同期関数を実行した場合、一度に1つのタスクしか実行できません。</p>
</blockquote>
<p>This is where the <code>tokio::spawn</code> function comes in.</p>
<blockquote>
<p>これが、<code>tokio::spawn</code>関数が登場します。</p>
</blockquote>
<h2 id="tokiospawn"><a class="header" href="#tokiospawn"><code>tokio::spawn</code></a></h2>
<p><code>tokio::spawn</code> allows you to hand off a task to the executor, <strong>without waiting for it to complete</strong>.<br />
Whenever you invoke <code>tokio::spawn</code>, you're telling <code>tokio</code> to continue running
the spawned task, in the background, <strong>concurrently</strong> with the task that spawned it.</p>
<blockquote>
<p><code>tokio::spawn</code>は、<strong>タスクが完了することを待たずに</strong>タスクをエグゼキューターに渡します。
<code>tokio::spawn</code>を呼び出すときはいつでも、生成されたタスクとそのタスクを生成したタスクを、<strong>同時並行</strong>でバックグラウンドで実行を継続するように<code>tokio</code>に伝えます。</p>
</blockquote>
<p>Here's how you can use it to process multiple connections concurrently:</p>
<blockquote>
<p>複数の接続を同時並行で処理するために、それ（<code>tokio::spawn</code>）を使用する方法を次に示します。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tokio::net::TcpListener;

pub async fn echo(listener: TcpListener) -&gt; Result&lt;(), anyhow::Error&gt; {
    loop {
        // `listener.accept().await?`により、`echo`関数は新しい接続を受け付けるまで、ここで待機する。
        // よって、この`loop`は、新しい接続が到着するたびに再開される。
        // リスナーの接続が切れた場合、`listener.accept().await?`はエラーを返すため、`echo`関数は終了する。
        let (mut socket, _) = listener.accept().await?;
        // Spawn a background task to handle the connection
        // thus allowing the main task to immediately start
        // accepting new connections
        // メインタスクにすぐに新しい接続の受付を開始させるために、接続を処理するバックグラウンドタスクを生み出します。
        tokio::spawn(async move {
            let (mut reader, mut writer) = socket.split();
            tokio::io::copy(&amp;mut reader, &amp;mut writer).await?;
        });
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="asynchronous-blocks非同期ブロック"><a class="header" href="#asynchronous-blocks非同期ブロック">Asynchronous blocks（非同期ブロック）</a></h3>
<p>In this example, we've passed an <strong>asynchronous block</strong> to <code>tokio::spawn</code>: <code>async move { /* */ }</code>
Asynchronous blocks are a quick way to mark a region of code as asynchronous without having
to define a separate async function.</p>
<blockquote>
<p>この例において、<code>tokio::spawn</code>に<code>async move { /* */ }</code>の<strong>非同期ブロック</strong>を渡しました。
非同期ブロックは、分離した非同期関数を定義する必要なく、非同期としてコード領域をマークする簡単な方法です。</p>
</blockquote>
<h3 id="joinhandle"><a class="header" href="#joinhandle"><code>JoinHandle</code></a></h3>
<p><code>tokio::spawn</code> returns a <code>JoinHandle</code>.<br />
You can use <code>JoinHandle</code> to <code>.await</code> the background task, in the same way
we used <code>join</code> for spawned threads.</p>
<blockquote>
<p><code>tokio::spawn</code>は<code>JoinHandle</code>を返します。
生み出したスレッドに対して<code>join</code>を使用した同じ方法で、バックグラウンドタスクを<code>.await</code>するために<code>JoinHandle</code>を使用できます。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 測定データをリモートサーバーに運搬して、その間に、自分の他の仕事をする。
// 自分の他の仕事が完了したら、リモートサーバーに測定データが運搬されるまで待機する。
pub async fn run() {
    // Spawn a background task to ship telemetry data
    // to a remote server
    // 測定データをリモートサーバーに運搬するために、バックグラウンドタスクを生み出します。
    let handle = tokio::spawn(emit_telemetry());
    // In the meantime, do some other useful work
    // その間、任意の他の有益な仕事をします。
    do_work().await;
    // But don't return to the caller until
    // the telemetry data has been successfully delivered
    // しかし、測定データが成功裏に配送されるまで、呼び出し側に戻らないでください。
    handle.await;
}

pub async fn emit_telemetry() {
    // [...]
}

pub async fn do_work() {
    // [...]
}
<span class="boring">}</span></code></pre></pre>
<h3 id="panic-boundaryパニック境界"><a class="header" href="#panic-boundaryパニック境界">Panic boundary（パニック境界）</a></h3>
<p>If a task spawned with <code>tokio::spawn</code> panics, the panic will be caught by the executor.<br />
If you don't <code>.await</code> the corresponding <code>JoinHandle</code>, the panic won't be propagated to the spawner.
Even if you do <code>.await</code> the <code>JoinHandle</code>, the panic won't be propagated automatically.
Awaiting a <code>JoinHandle</code> returns a <code>Result</code>, with <a href="https://docs.rs/tokio/latest/tokio/task/struct.JoinError.html"><code>JoinError</code></a>
as its error type. You can then check if the task panicked by calling <code>JoinError::is_panic</code> and
choose what to do with the panic—either log it, ignore it, or propagate it.</p>
<blockquote>
<p><code>tokio::spawn</code>で生み出されたタスクがパニックした場合、そのパニックはエグゼキューターによって受け取られます。
対応する<code>JoinHandle</code>を<code>.await</code>しない場合、そのパニックは（タスクの）生み出し元には伝播しません。
<code>JoinHandle</code>を<code>.await</code>したとしても、そのパニックは自動的に伝播しません。
<code>JoinHandle</code>を<code>.await</code>すると、そのエラー型として<code>JoinError</code>を持つ<code>Result</code>が返されます。
そして、<code>JoinError::is_panic</code>を呼び出すことで、タスクがパニックしたか確認して、それをログに記録するか、またはそれを伝播するか、パニックに対して行うことを選択できます。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tokio::task::JoinError;

pub async fn run() {
    let handle = tokio::spawn(work());
    if let Err(e) = handle.await {
        if let Ok(reason) = e.try_into_panic() {
            // The task has panicked
            // We resume unwinding the panic,
            // thus propagating it to the current task
            // タスクがパニックしました。
            // パニックの巻き戻しを再開して、現在のタスクにパニックを伝播しています。
            panic::resume_unwind(reason);
        }
    }
}

pub async fn work() {
    // [...]
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p><code>panic</code>を<code>unwind</code>するとは、<code>panic</code>が発生したスレッドのスタックフレームを巻き戻して、クリーンアップコードを実行して、リソースを適切に解放する処理を示す。</p>
</blockquote>
<h3 id="stdthreadspawn-vs-tokiospawnstdthreadspawnとtokiospawn"><a class="header" href="#stdthreadspawn-vs-tokiospawnstdthreadspawnとtokiospawn"><code>std::thread::spawn</code> vs <code>tokio::spawn</code>（std::thread::spawnとtokio::spawn）</a></h3>
<p>You can think of <code>tokio::spawn</code> as the asynchronous sibling of <code>std::thread::spawn</code>.</p>
<blockquote>
<p><code>tokio::spawn</code>を<code>std::thread::spawn</code>の非同期の兄弟と考えることができます。</p>
</blockquote>
<p>Notice a key difference: with <code>std::thread::spawn</code>, you're delegating control to the OS scheduler.
You're not in control of how threads are scheduled.</p>
<blockquote>
<p>重要な違いに注意してください: <code>std::thread::spawn</code>を使用すると、OSのスケジューラーに制御を移譲します。
スレッドがスケジュールされる方法を制御することはできません。</p>
</blockquote>
<p>With <code>tokio::spawn</code>, you're delegating to an async executor that runs entirely in
user space. The underlying OS scheduler is not involved in the decision of which task
to run next. We're in charge of that decision now, via the executor we chose to use.</p>
<blockquote>
<p><code>tokio::spawn</code>を使用すると、ユーザー空間で全体を実行する非同期エグゼキューターに（制御を）移譲します。
基盤となるOSスケジューラーは、次に実行するタスクの決定に関与しません。
現在、その決定の責任は、使用することを選択したエグゼキューターを介して、開発者にあります。</p>
</blockquote>
<h2 id="exercise-91"><a class="header" href="#exercise-91">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/08_futures/02_spawn"><code>08_futures/02_spawn</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="runtime-architectureライフタイムアーキテクチャー"><a class="header" href="#runtime-architectureライフタイムアーキテクチャー">Runtime architecture（ライフタイムアーキテクチャー）</a></h1>
<p>So far we've been talking about async runtimes as an abstract concept.
Let's dig a bit deeper into the way they are implemented—as you'll see soon enough,
it has an impact on our code.</p>
<blockquote>
<p>これまで、非同期ランタイムについて抽象化概念として話してきました。
それらが実装された方法を少し深堀りしましょう。すぐに十分理解できるように、それはコードに影響を与えます。</p>
</blockquote>
<h2 id="flavors風味づけ"><a class="header" href="#flavors風味づけ">Flavors（風味づけ）</a></h2>
<p><code>tokio</code> ships two different runtime <em>flavors</em>.</p>
<blockquote>
<p><code>tokio</code>は2つの異なるランタイム <em>フレーバー</em> を提供しています。</p>
</blockquote>
<p>You can configure your runtime via <code>tokio::runtime::Builder</code>:</p>
<ul>
<li><code>Builder::new_multi_thread</code> gives you a <strong>multithreaded <code>tokio</code> runtime</strong></li>
<li><code>Builder::new_current_thread</code> will instead rely on the <strong>current thread</strong> for execution.</li>
</ul>
<blockquote>
<p><code>tokio::runtime::Builder</code>を介してランタイムを構成できます。</p>
<ul>
<li><code>Builder::new_multi_thread</code>は、<strong>マルチスレッドな<code>tokio</code>ランタイム</strong>を提供します。</li>
<li><code>Builder::new_current_thread</code>は、代わりに<strong>現在のスレッド</strong>に依存して実行されます。</li>
</ul>
</blockquote>
<p><code>#[tokio::main]</code> returns a multithreaded runtime by default, while
<code>#[tokio::test]</code> uses a current thread runtime out of the box.</p>
<blockquote>
<p><code>#[tokio::main]</code>は、デフォルトでマルチスレッドなランタイムを返す一方で、<code>#[tokio::test]</code>は現在のスレッドを使用します。</p>
</blockquote>
<h3 id="current-thread-runtimeカレントスレッドランタイム"><a class="header" href="#current-thread-runtimeカレントスレッドランタイム">Current thread runtime（カレントスレッドランタイム）</a></h3>
<p>The current-thread runtime, as the name implies, relies exclusively on the OS thread
it was launched on to schedule and execute tasks.<br />
When using the current-thread runtime, you have <strong>concurrency</strong> but no <strong>parallelism</strong>:
asynchronous tasks will be interleaved, but there will always be at most one task running
at any given time.</p>
<blockquote>
<p>名前が暗に意味する通り、カレントスレッドランタイムは、タスクをスケジュールして実行するために起動されるOSスレッドのみに依存します。
カレントスレッドランタイムを使用したとき、<strong>同時並行性</strong>を得られますが、<strong>並列性</strong>は得られません。
非同期タスクは、間をおいて交互に実行されますが、常に特定の時間に最大1つのタスクしが実行していません。</p>
</blockquote>
<h3 id="multithreaded-runtimeマルチスレッドランタイム"><a class="header" href="#multithreaded-runtimeマルチスレッドランタイム">Multithreaded runtime（マルチスレッドランタイム）</a></h3>
<p>When using the multithreaded runtime, instead, there can up to <code>N</code> tasks running
<em>in parallel</em> at any given time, where <code>N</code> is the number of threads used by the
runtime. By default, <code>N</code> matches the number of available CPU cores.</p>
<blockquote>
<p>マルチスレッドランタイムを使用したとき、特定の時間に <em>並列で</em> 最大<code>N</code>個までのタスクを実行でき、<code>N</code>はランタイムで使用されるスレッドの数です。
デフォルトで、<code>N</code>は利用可能なCPUコアの数に一致します。</p>
</blockquote>
<p>There's more: <code>tokio</code> performs <strong>work-stealing</strong>.<br />
If a thread is idle, it won't wait around: it'll try to find a new task that's ready for
execution, either from a global queue or by stealing it from the local queue of another
thread.<br />
Work-stealing can have significant performance benefits, especially on tail latencies,
whenever your application is dealing with workloads that are not perfectly balanced
across threads.</p>
<blockquote>
<p>まだあります。<code>tokio</code>は<strong>ワークスチーリング</strong>を行います。
スレッドがアイドル状態になった場合、それ（<code>tokio</code>）は待機しません。
それ（<code>tokio</code>）は、グローバルキューまたは他のスレッドのローカルキューから盗むことで、実行の準備ができている新しいタスクを見つけることを試みます。
アプリケーションが、スレッド間で完全にバランスが取れていないワークロードを処理しているときはいつでも、ワークスチーリングは、特にテールレイテンシーに対して、大きな性能の利点をもたらす可能性があります。</p>
</blockquote>
<blockquote>
<p>テールレイテンシー（<code>tail latency</code>）とは、システムにおいて最も遅いリクエストの応答時間を指す。
具体的には、応答時間の分布における上位のパーセンタイル、例えば95パーセンタイルや99パーセンタイルの応答時間を示す。
応答時間の長いタスクがある場合、その長いタスクがアイドル状態になったときに、他のタスクを実行することで、全体の応答時間を短くすることができる。</p>
</blockquote>
<h2 id="implications関連事項"><a class="header" href="#implications関連事項">Implications（関連事項）</a></h2>
<p><code>tokio::spawn</code> is flavor-agnostic: it'll work no matter if you're running on the multithreaded
or current-thread runtime. The downside is that the signature assume the worst case
(i.e. multithreaded) and is constrained accordingly:</p>
<blockquote>
<p><code>tokio::spawn</code>はフレーバーに依存しません。
それは、マルチスレッドまたはカレントスレッドランタイムで実行されているかどうかに関わらず機能します。
その欠点は、シグネチャーが最悪のケース（つまりマルチスレッド）を仮定して、それに応じて制約されることです。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn spawn&lt;F&gt;(future: F) -&gt; JoinHandle&lt;F::Output&gt;
where
    F: Future + Send + 'static,
    F::Output: Send + 'static,
{ /* */ }
<span class="boring">}</span></code></pre></pre>
<p>Let's ignore the <code>Future</code> trait for now to focus on the rest.<br />
<code>spawn</code> is asking all its inputs to be <code>Send</code> and have a <code>'static</code> lifetime.</p>
<blockquote>
<p>現時点では、<code>Future</code>トレイトを無視して、残りに焦点を当てましょう。
<code>spawn</code>は、その入力に対して、<code>Send</code>であり、<code>'static</code>ライフタイムを持つことを要求しています。</p>
</blockquote>
<p>The <code>'static</code> constraint follows the same rationale of the <code>'static</code> constraint
on <code>std::thread::spawn</code>: the spawned task may outlive the context it was spawned
from, therefore it shouldn't depend on any local data that may be de-allocated
after the spawning context is destroyed.</p>
<blockquote>
<p><code>'static</code>制約は、<code>std::thread::spawn</code>の<code>'static</code>制約と同じ論理的根拠に従っています。
生み出されたタスクは、それが生み出されたコンテキストよりも長生きするかもしれず、そのため、それは生み出したコンテキストが破壊された後で、解放されてしまうかもしれない任意のローカルデータに依存するべきではありません。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn spawner() {
    let v = vec![1, 2, 3];
    // This won't work, since `&amp;v` doesn't
    // live long enough.
    // `&amp;v`は十分に長生きしないため、これは機能しません。
    tokio::spawn(async {
        for x in &amp;v {
            println!("{x}")
        }
    })
    // `spawn`したタスクが終了する前に、`spawner`関数が終了して、
    // `v`が解放される可能性があるため、Rustはこのコードをコンパイルさせない。
}
<span class="boring">}</span></code></pre></pre>
<p><code>Send</code>, on the other hand, is a direct consequence of <code>tokio</code>'s work-stealing strategy:
a task that was spawned on thread <code>A</code> may end up being moved to thread <code>B</code> if that's idle,
thus requiring a <code>Send</code> bound since we're crossing thread boundaries.</p>
<blockquote>
<p>一方、<code>Send</code>は<code>tokio</code>のワークスチール戦略の直接な結果です。
スレッド<code>A</code>で生み出されたタスクは、それがアイドル状態になった場合、最終的にスレッド<code>B</code>にムーブされるかもしれず、そのためスレッド境界を超えるために<code>Send</code>境界が要求されます。</p>
</blockquote>
<blockquote>
<p>スレッド<code>A</code>が生み出されたタスクが、IO待ちなどでブロックされた場合、そのタスクはキューに配置される。
スレッド<code>A</code>が他のタスクを実行している間、キューに入ったタスクが要求したIO処理が完了して、タスクを実行できる状態になる。
このとき、スレッド<code>A</code>がまだ他のタスクを実行していて、スレッド<code>B</code>が実行していたタスクがブロックまたは終了した場合、
スレッド<code>B</code>は、スレッド<code>A</code>のキューに入ったタスクを<strong>盗んで</strong>実行する。
ただし、これはスレッド自身が行うのではなく、ランタイムのエグゼキューターがタスクの割り当てを行う。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn spawner(input: Rc&lt;u64&gt;) {
    // This won't work either, because
    // `Rc` isn't `Send`.
    // `Rc`は`Send`でないため、これも機能しません。
    tokio::spawn(async move {
        println!("{}", input);
    })
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p><code>Rc</code>はそのスレッド間で共有できない。
<code>Rc</code>が持つ参照カウンターは<code>usize</code>型でアトミックに参照カウンターを増減できない。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(C)]
struct RcBox&lt;T: ?Sized&gt; {
    strong: Cell&lt;usize&gt;,
    weak: Cell&lt;usize&gt;,
    value: T,
}
<span class="boring">}</span></code></pre></pre>
<p>もし、<code>Rc</code>が<code>Send</code>な場合、クローンして別のスレッドに渡すことができ、このときそれぞれのスレッドで参照カウンターを増減することになる。
その場合、参照カウンターはアトミックな操作ができないため、参照カウンターは正しい値を保持できない。
よって、<code>Rc</code>は<code>Send</code>でない。</p>
</blockquote>
<h2 id="exercise-92"><a class="header" href="#exercise-92">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/08_futures/03_runtime"><code>08_futures/03_runtime</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-future-traitfutureトレイト"><a class="header" href="#the-future-traitfutureトレイト">The <code>Future</code> trait（Futureトレイト）</a></h1>
<h2 id="the-local-rc-problem-ローカルrc問題"><a class="header" href="#the-local-rc-problem-ローカルrc問題">The local <code>Rc</code> problem （ローカルRc問題）</a></h2>
<p>Let's go back to <code>tokio::spawn</code>'s signature:</p>
<blockquote>
<p><code>tokio::spawn</code>のシグネチャーに戻りましょう。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn spawn&lt;F&gt;(future: F) -&gt; JoinHandle&lt;F::Output&gt;
    where
        F: Future + Send + 'static,
        F::Output: Send + 'static,
{ /* */ }
<span class="boring">}</span></code></pre></pre>
<p>What does it <em>actually</em> mean for <code>F</code> to be <code>Send</code>?<br />
It implies, as we saw in the previous section, that whatever value it captures from the
spawning environment has to be <code>Send</code>. But it goes further than that.</p>
<blockquote>
<p><code>F</code>が<code>Send</code>であるとは <em>実際に</em> 何を意味しているのでしょうか？
それは、前の節で確認した通り、生み出した環境からキャプチャーされた値が<code>Send</code>でなければならないことを暗示しています。
しかし、それはそれ以上のことを意味しています。</p>
</blockquote>
<p>Any value that's <em>held across a .await point</em> has to be <code>Send</code>.<br />
Let's look at an example:</p>
<blockquote>
<p><em><code>.await</code>ポイントをまたがって保持される</em> 任意の値は、<code>Send</code>でなければなりません。
例を確認しましょう。</p>
</blockquote>
<blockquote>
<p>値はスレッド2を生み出すスレッド1で作成され、その後その値がスレッド2で作成され、生み出すスレッド1で生み出したスレッド2を<code>.await</code>した後に、その値を使用することは、スレッド間をまたがっているため、当然<code>Send</code>でなければならない。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::rc::Rc;
use tokio::task::yield_now;

fn spawner() {
    tokio::spawn(example());
}

async fn example() {
    // A value that's not `Send`,
    // created _inside_ the async function
    // 非同期関数内で作成されたその値は`Send`ではありません。
    let non_send = Rc::new(1);

    // A `.await` point that does nothing
    // 何もしない`.await`ポイントです。
    yield_now().await;

    // The local non-`Send` value is still needed
    // after the `.await`
    // `.await`の後も、ローカルな非`Send`の値が必要です。
    println!("{}", non_send);
}
<span class="boring">}</span></code></pre></pre>
<p>The compiler will reject this code:</p>
<blockquote>
<p>コンパイラーはこのコードを拒否します。</p>
</blockquote>
<pre><code class="language-text">error: future cannot be sent between threads safely
    |
5   |     tokio::spawn(example());
    |                  ^^^^^^^^^ future returned by `example` is not `Send`
    |
note: future is not `Send` as this value is used across an await
    |
11  |     let non_send = Rc::new(1);
    |         -------- has type `Rc&lt;i32&gt;` which is not `Send`
12  |     // A `.await` point
13  |     yield_now().await;
    |                 ^^^^^ await occurs here, with `non_send` maybe used later
note: required by a bound in `tokio::spawn`
    |
164 |     pub fn spawn&lt;F&gt;(future: F) -&gt; JoinHandle&lt;F::Output&gt;
    |            ----- required by a bound in this function
165 |     where
166 |         F: Future + Send + 'static,
    |                     ^^^^ required by this bound in `spawn`
</code></pre>
<p>To understand why that's the case, we need to refine our understanding of
Rust's asynchronous model.</p>
<blockquote>
<p>なぜ拒否されるかを理解するために、Rustの非同期モデルの理解を洗練させる必要があります。</p>
</blockquote>
<h2 id="the-future-traitfutureトレイト-1"><a class="header" href="#the-future-traitfutureトレイト-1">The <code>Future</code> trait（Futureトレイト）</a></h2>
<p>We stated early on that <code>async</code> functions return <strong>futures</strong>, types that implement
the <code>Future</code> trait. You can think of a future as a <strong>state machine</strong>.
It's in one of two states:</p>
<ul>
<li><strong>pending</strong>: the computation has not finished yet.</li>
<li><strong>ready</strong>: the computation has finished, here's the output.</li>
</ul>
<blockquote>
<p><code>async</code>関数が、<code>Future</code>トレイトを実装した型である<strong>フューチャー</strong>を返すと前に述べました。
フューチャーを<strong>状態マシン</strong>と考えることができます。
それは２つの状態を持ちます。</p>
<ul>
<li><strong>保留中</strong>: 計算はまだ終了していません。</li>
<li><strong>準備完了</strong>: 計算が終了して、ここに出力があります。</li>
</ul>
</blockquote>
<p>This is encoded in the trait definition:</p>
<blockquote>
<p>これは、トレイト定義内にエンコードされています。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Future {
    type Output;

    // Ignore `Pin` and `Context` for now
    // 現時点では`Pin`と`Context`を無視してください。
    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt;;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="poll"><a class="header" href="#poll"><code>poll</code></a></h3>
<p>The <code>poll</code> method is the heart of the <code>Future</code> trait.<br />
A future on its own doesn't do anything. It needs to be <strong>polled</strong> to make progress.<br />
When you call <code>poll</code>, you're asking the future to do some work.
<code>poll</code> tries to make progress, and then returns one of the following:</p>
<ul>
<li><code>Poll::Pending</code>: the future is not ready yet. You need to call <code>poll</code> again later.</li>
<li><code>Poll::Ready(value)</code>: the future has finished. <code>value</code> is the result of the computation,
of type <code>Self::Output</code>.</li>
</ul>
<blockquote>
<p><code>poll</code>メソッドは、<code>Future</code>トレイトの心臓です。
フューチャーそれ自身は、何もしません。それは進捗するために<strong>ポーリング</strong>される必要があります。
<code>poll</code>を呼び出したとき、何か作業を行うことをフューチャーに要求します。
<code>poll</code>は、進めようと試み、そして、次の1つを返します。</p>
<ul>
<li><code>Poll::Pending</code>: フューチャーはまだ準備できていません。後で再度<code>poll</code>を呼び出す必要があります。</li>
<li><code>Poll::Ready(value)</code>: フューチャーは完了しました。<code>value</code>は計算の結果で、型は<code>Self::Output</code>です。</li>
</ul>
</blockquote>
<p>Once <code>Future::poll</code> returns <code>Poll::Ready</code>, it should not be polled again: the future has
completed, there's nothing left to do.</p>
<blockquote>
<p>一旦、<code>Future::poll</code>が<code>Poll::Ready</code>を返すと、それは再度ポーリングされるべきではありません。そのフューチャーは完了しており、行うことは何も残っていません。</p>
</blockquote>
<h3 id="the-role-of-the-runtimeランタイムの役目"><a class="header" href="#the-role-of-the-runtimeランタイムの役目">The role of the runtime（ランタイムの役目）</a></h3>
<p>You'll rarely, if ever, be calling poll directly.<br />
That's the job of your async runtime: it has all the required information (the <code>Context</code>
in <code>poll</code>'s signature) to ensure that your futures are making progress whenever they can.</p>
<blockquote>
<p>ほとんど、または決して、直接ポーリングすることはありません。
それは、非同期ランタイムの仕事です。それは、フューチャーは可能なときはいつでも、フューチャーを進めることを確実にするために、<code>poll</code>のシグネチャー内の<code>Context</code>として、必要な情報をすべて持っています。</p>
</blockquote>
<h2 id="async-fn-and-futuresasync-fnとフューチャー"><a class="header" href="#async-fn-and-futuresasync-fnとフューチャー"><code>async fn</code> and futures（async fnとフューチャー）</a></h2>
<p>We've worked with the high-level interface, asynchronous functions.<br />
We've now looked at the low-level primitive, the <code>Future trait</code>.</p>
<blockquote>
<p>非同期関数の高水準なインターフェイスで作業をしてきました。
ここでは、<code>Future</code>トレイトの低水準な構成要素を確認しました。</p>
</blockquote>
<p>How are they related?</p>
<blockquote>
<p>それらはどのように関連しているのでしょうか？</p>
</blockquote>
<p>Every time you mark a function as asynchronous, that function will return a future.
The compiler will transform the body of your asynchronous function into a <strong>state machine</strong>:
one state for each <code>.await</code> point.</p>
<blockquote>
<p>非同期関数を作成するたびに、その関数はフューチャーを返します。
コンパイラーは、それぞれの<code>.await</code>ポイントに1つの状態があるような<strong>状態マシン</strong>に、非同期関数の本体を変換します。</p>
</blockquote>
<p>Going back to our <code>Rc</code> example:</p>
<blockquote>
<p><code>Rc</code>の例に戻りましょう。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::rc::Rc;
use tokio::task::yield_now;

async fn example() {
    let non_send = Rc::new(1);
    yield_now().await;
    println!("{}", non_send);
}
<span class="boring">}</span></code></pre></pre>
<p>The compiler would transform it into an enum that looks somewhat like this:</p>
<blockquote>
<p>コンパイラーは、それを次のように見える列挙型に変換します。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum ExampleFuture {
    NotStarted,
    YieldNow(Rc&lt;i32&gt;), // Rcを保持している。RcはSendでない。よってexampleはSendでない。
    Terminated,
}
<span class="boring">}</span></code></pre></pre>
<p>When <code>example</code> is called, it returns <code>ExampleFuture::NotStarted</code>. The future has never
been polled yet, so nothing has happened.<br />
When the runtime polls it the first time, <code>ExampleFuture</code> will advance until the next
<code>.await</code> point: it'll stop at the <code>ExampleFuture::YieldNow(Rc&lt;i32&gt;)</code> stage of the state
machine, returning <code>Poll::Pending</code>.<br />
When it's polled again, it'll execute the remaining code (<code>println!</code>) and
return <code>Poll::Ready(())</code>.</p>
<blockquote>
<p><code>example</code>が呼び出されたとき、それは<code>ExampleFuture::NotStarted</code>を返します。
フューチャーは、まだ決してポーリングされていないため、何も発生していません。
ランタイムが最初にそれをポーリングしたとき、<code>ExampleFuture</code>は次の<code>.await</code>ポイントまで進めます。
それは、状態マシンの<code>ExampleFuture::YieldNow(Rc&lt;i32&gt;)</code>ステージで停止して、<code>Poll::Pending</code>を返します。
再度ポーリングされたとき、それは残りのコードの<code>println!</code>を実行して、<code>Poll::Ready(())</code>を返します。</p>
</blockquote>
<p>When you look at its state machine representation, <code>ExampleFuture</code>,
it is now clear why <code>example</code> is not <code>Send</code>: it holds an <code>Rc</code>, therefore
it cannot be <code>Send</code>.</p>
<blockquote>
<p>その状態マシンを表現する<code>ExampleFuture</code>を確認したとき、<code>example</code>が<code>Send</code>でない理由を明確にしています。
それは<code>Rc</code>を保持しているため、それは<code>Send</code>になりません。</p>
</blockquote>
<h2 id="yield-points移譲ポイント"><a class="header" href="#yield-points移譲ポイント">Yield points（移譲ポイント）</a></h2>
<p>As you've just seen with <code>example</code>, every <code>.await</code> point creates a new intermediate
state in the lifecycle of a future.<br />
That's why <code>.await</code> points are also known as <strong>yield points</strong>: your future <em>yields control</em>
back to the runtime that was polling it, allowing the runtime to pause it and (if necessary)
schedule another task for execution, thus making progress on multiple fronts concurrently.</p>
<blockquote>
<p><code>example</code>で確認した通り、すべての<code>.await</code>ポイントはフューチャーのライフサイクル内に、新しい中間状態を作成します。
それが<code>.await</code>ポイントが<strong>移譲ポイント</strong>として知られる理由です。
フューチャーは、それ（フューチャー）をポーリングしていたランタイムに<strong>制御を移譲して</strong>、ランタイムがそれ（フューチャー）を停止して、さらに必要があれば他のタスクの実行をスケジュールできるようにします。
これにより、複数を同時並行で進めるようにします。</p>
</blockquote>
<p>We'll come back to the importance of yielding in a later section.</p>
<blockquote>
<p>後半の節で、移譲する重要性に戻ります。</p>
</blockquote>
<h2 id="exercise-93"><a class="header" href="#exercise-93">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/08_futures/04_future"><code>08_futures/04_future</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dont-block-the-runtimeランタイムをブロックしてはならない"><a class="header" href="#dont-block-the-runtimeランタイムをブロックしてはならない">Don't block the runtime（ランタイムをブロックしてはならない）</a></h1>
<p>Let's circle back to yield points.<br />
Unlike threads, <strong>Rust tasks cannot be preempted</strong>.</p>
<blockquote>
<p><code>移譲</code>ポイントにぐるっと戻りましょう。
スレッドと異なり、<strong>Rustのタスクは、プリエンプトできません</strong>。</p>
</blockquote>
<blockquote>
<p>プリエンプト: システムのスケジューリングにおいて、システムの応答性や効率性を高めるために、あるプロセスやタスクがCPUの制御を強制的に中断され、他のプロセスやタスクに制御が移されること。</p>
</blockquote>
<p><code>tokio</code> cannot, on its own, decide to pause a task and run another one in its place.
The control goes back to the executor <strong>exclusively</strong> when the task yields—i.e.
when <code>Future::poll</code> returns <code>Poll::Pending</code> or, in the case of <code>async fn</code>, when
you <code>.await</code> a future.</p>
<blockquote>
<p><code>tokio</code>自身は、タスクを停止して、その場所で他のタスクを実行することを決定できません。
その制御は、タスクが移譲するとき、<strong>排他的に</strong>エグゼキューターに戻ります。
例えば、<code>Future::poll</code>が<code>Poll::Pending</code>を返したとき、または<code>async fn</code>の場合はフューチャーを<code>.await</code>したときです。</p>
</blockquote>
<p>This exposes the runtime to a risk: if a task never yields, the runtime will never
be able to run another task. This is called <strong>blocking the runtime</strong>.</p>
<blockquote>
<p>これは、ランタイムがリスクをさらけ出すことになります。
タスクが決して移譲されない場合、ランタイムは決して他のタスクを実行できません。
これは<strong>ランタイムのブロッキング</strong>と呼ばれます。</p>
</blockquote>
<h2 id="what-is-blockingブロッキングとは何か"><a class="header" href="#what-is-blockingブロッキングとは何か">What is blocking?（ブロッキングとは何か？）</a></h2>
<p>How long is too long? How much time can a task spend without yielding before it
becomes a problem?</p>
<blockquote>
<p>どれくらいが長いのでしょうか？
問題になるまで、移譲しないタスクはどれくらいの時間を費やすことができるでしょうか？</p>
</blockquote>
<p>It depends on the runtime, the application, the number of in-flight tasks, and
many other factors. But, as a general rule of thumb, try to spend less than 100
microseconds between yield points.</p>
<blockquote>
<p>それはランタイム、アプリケーション、実行中のタスクの数、そして多くの他の要因に依存します。
しかし、一般的な経験則として、移譲ポイント間で100マイクロ秒より少ない時間を費やすようにしてください。</p>
</blockquote>
<h2 id="consequences結果"><a class="header" href="#consequences結果">Consequences（結果）</a></h2>
<p>Blocking the runtime can lead to:</p>
<ul>
<li><strong>Deadlocks</strong>: if the task that's not yielding is waiting for another task to
complete, and that task is waiting for the first one to yield, you have a deadlock.
No progress can be made, unless the runtime is able to schedule the other task on
a different thread.</li>
<li><strong>Starvation</strong>: other tasks might not be able to run, or might run after a long
delay, which can lead to poor performances (e.g. high tail latencies).</li>
</ul>
<blockquote>
<p>ランタイムのブロックは次を引き起こす可能性があります。</p>
<ul>
<li><strong>デッドロック</strong>: 移譲していないタスクが他のタスクが完了することを待っていて、またそのタスク（他のタスク）が最初のタスク（移譲していないタスク）が移譲するのを待っている場合、デッドロックになります。
ランタイムは異なるスレッドに他のタスクをスケジュールできるにも関わらず、何も進みません。</li>
<li><strong>飢餓</strong>: 他のタスクは実行できないか、長い遅延の後に実行されるかもしれない場合、それは性能の悪化を引き起こす可能性があります。例えばテールレイテンシーです。</li>
</ul>
</blockquote>
<h2 id="blocking-is-not-always-obviousブロッキングは常に明らかでない"><a class="header" href="#blocking-is-not-always-obviousブロッキングは常に明らかでない">Blocking is not always obvious（ブロッキングは常に明らかでない）</a></h2>
<p>Some types of operations should generally be avoided in async code, like:</p>
<ul>
<li>Synchronous I/O. You can't predict how long it will take, and it's likely to be
longer than 100 microseconds.</li>
<li>Expensive CPU-bound computations.</li>
</ul>
<blockquote>
<p>いくつかの種類の操作は、一般的に非同期コードでは避けられるべきです。次のように・・・</p>
<ul>
<li>同期I/O。それにかかる時間を予測できず、それは100マイクロ秒よりも長くなるかもしれません。</li>
<li>高いCPUバウンドの計算。</li>
</ul>
</blockquote>
<p>The latter category is not always obvious though. For example, sorting a vector with
a few elements is not a problem; that evaluation changes if the vector has billions
of entries.</p>
<blockquote>
<p>ただし、後者のカテゴリーは常に明らかではありません。
例えば、いくつかの要素を持つベクターをソートすることは問題になりません。
ベクターが数十億のエントリを持つ場合、評価は変わります。</p>
</blockquote>
<h2 id="how-to-avoid-blockingブロッキングを避ける方法"><a class="header" href="#how-to-avoid-blockingブロッキングを避ける方法">How to avoid blocking（ブロッキングを避ける方法）</a></h2>
<p>OK, so how do you avoid blocking the runtime assuming you <em>must</em> perform an operation
that qualifies or risks qualifying as blocking?<br />
You need to move the work to a different thread. You don't want to use the so-called
runtime threads, the ones used by <code>tokio</code> to run tasks.</p>
<blockquote>
<p>では、ブロッキングとして認識される、または認識されるリスクがある操作を実行 <em>しなければならない</em> 場合、どのようにランタイムのブロッキングを避けたらよいでしょうか？
異なるスレッドにその作業を移動する必要があります。
ランタイムスレッドと呼ばれるスレッドを使用しないでください。それは<code>tokio</code>がタスクを実行するために使用されます。</p>
</blockquote>
<p><code>tokio</code> provides a dedicated threadpool for this purpose, called the <strong>blocking pool</strong>.
You can spawn a synchronous operation on the blocking pool using the
<code>tokio::task::spawn_blocking</code> function. <code>spawn_blocking</code> returns a future that resolves
to the result of the operation when it completes.</p>
<blockquote>
<p><code>tokio</code>は、この目的のために<strong>ブロッキングプール</strong>と呼ばれる専用のスレッドプールを提供しています。
<code>tokio::task::spawn_blocking</code>関数を使用して、ブロッキングプール上で同期操作を生み出すことができます。
<code>spawn_blocking</code>は、それが完了したとき、操作の結果を解決するフューチャーを返します。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tokio::task;

fn expensive_computation() -&gt; u64 {
    // [...]
}

async fn run() {
    let handle = task::spawn_blocking(expensive_computation);

    // Do other stuff in the meantime
    // この間（上記の高コストな関数を実行している間）に他のことをします。

    // `spawn_blocking`はフューチャーを返すため、`await`して高コストな関数の結果が得られるまで`.await`します。
    let result = handle.await.unwrap();
}
<span class="boring">}</span></code></pre></pre>
<p>The blocking pool is long-lived. <code>spawn_blocking</code> should be faster
than creating a new thread directly via <code>std::thread::spawn</code>
because the cost of thread initialization is amortized over multiple calls.</p>
<blockquote>
<p>ブロッキングプールは長生きです。
<code>spawn_blocking</code>は、<code>std::thread::spawn</code>を介して直接新しいスレッドを作成するよりも早いはずです。
それは、スレッドの初期化のコストが、複数の呼び出しにわたって分割されるからです。</p>
</blockquote>
<h2 id="further-reading参考資料-12"><a class="header" href="#further-reading参考資料-12">Further reading（参考資料）</a></h2>
<ul>
<li>Check out <a href="https://ryhl.io/blog/async-what-is-blocking/">Alice Ryhl's blog post</a>
on the topic.</li>
</ul>
<h2 id="exercise-94"><a class="header" href="#exercise-94">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/08_futures/05_blocking"><code>08_futures/05_blocking</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="async-aware-primitives非同期を知っている構成要素"><a class="header" href="#async-aware-primitives非同期を知っている構成要素">Async-aware primitives（非同期を知っている構成要素）</a></h1>
<p>If you browse <code>tokio</code>'s documentation, you'll notice that it provides a lot of types
that "mirror" the ones in the standard library, but with an asynchronous twist:
locks, channels, timers, and more.</p>
<blockquote>
<p><code>tokio</code>ドキュメントを参照した場合、ロック、チャネル、タイマー、その他など、多くの標準ライブラリの型を「反映した」型が提供されていることに気付くでしょうが、非同期になっています。</p>
</blockquote>
<p>When working in an asynchronous context, you should prefer these asynchronous alternatives
to their synchronous counterparts.</p>
<blockquote>
<p>非同期コンテキストで作業するとき、それらの同期的な同等物ではなく、これら非同期の代替物を優先するべきです。</p>
</blockquote>
<p>To understand why, let's take a look at <code>Mutex</code>, the mutually exclusive lock we explored
in the previous chapter.</p>
<blockquote>
<p>理由を理解するために、前の章で探求した可変排他ロックである<code>Mutex</code>を確認しましょう。</p>
</blockquote>
<h2 id="case-study-mutex事例研究-mutex"><a class="header" href="#case-study-mutex事例研究-mutex">Case study: <code>Mutex</code>（事例研究: Mutex）</a></h2>
<p>Let's look at a simple example:</p>
<blockquote>
<p>単純な例を確認してください。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::{Arc, Mutex};

async fn run(m: Arc&lt;Mutex&lt;Vec&lt;u64&gt;&gt;&gt;) {
    let guard = m.lock().unwrap();
    http_call(&amp;guard).await;
    println!("Sent {:?} to the server", &amp;guard);
    // `guard` is dropped here
    // `guard`はここでドロップされます。
}

/// Use `v` as the body of an HTTP call.
/// HTTP呼び出しの本体として`v`を使用します。
async fn http_call(v: &amp;[u64]) {
  // [...]
}
<span class="boring">}</span></code></pre></pre>
<h3 id="stdsyncmutexguard-and-yield-pointsstdsyncmutexguardとyieldポイント"><a class="header" href="#stdsyncmutexguard-and-yield-pointsstdsyncmutexguardとyieldポイント"><code>std::sync::MutexGuard</code> and yield points（std::sync::MutexGuardとyieldポイント）</a></h3>
<p>This code will compile, but it's dangerous.</p>
<blockquote>
<p>このコードはコンパイルされますが、危険です。</p>
</blockquote>
<p>We try to acquire a lock over a <code>Mutex</code> from <code>std</code> in an asynchronous context.
We then hold on to the resulting <code>MutexGuard</code> across a yield point (the <code>.await</code> on
<code>http_call</code>).</p>
<blockquote>
<p><code>std</code>の非同期コンテキストの<code>Mutex</code>を介してロックを取得することを試みます。
そして、<code>http_call</code>を<code>.await</code>している移譲ポイントをまたいで<code>MutexGuard</code>を保持します。</p>
</blockquote>
<p>Let's imagine that there are two tasks executing <code>run</code>, concurrently, on a single-threaded
runtime. We observe the following sequence of scheduling events:</p>
<blockquote>
<p>単一スレッドなランタイムで、同時並行で<code>run</code>を実行する2つのタスクがある場合を想像してください。
イベントのスケジューリングの次のシーケンスを観察します。</p>
</blockquote>
<pre><code class="language-text">     Task A          Task B
        |
  Acquire lock
Yields to runtime
        |
        +--------------+
                       |
             Tries to acquire lock
</code></pre>
<p>We have a deadlock. Task B we'll never manage to acquire the lock, because the lock
is currently held by task A, which has yielded to the runtime before releasing the
lock and won't be scheduled again because the runtime cannot preempt task B.</p>
<blockquote>
<p>デッドロックが発生します。
タスクBは決してロックを取得できません。
現在、ロックはタスクAによって保持されており、タスクAはロックを解放する前にランタイムに移譲しますが、ランタイムはタスクBを実行できないため、再度スケジュールされることはありません。</p>
</blockquote>
<blockquote>
<p>タスクBがロックを取得しようとしても、タスクAがロックを取得しているため、タスクBは<code>let guard = m.lock().unwrap();</code>でブロックされる。</p>
</blockquote>
<h3 id="tokiosyncmutex"><a class="header" href="#tokiosyncmutex"><code>tokio::sync::Mutex</code></a></h3>
<p>You can solve the issue by switching to <code>tokio::sync::Mutex</code>:</p>
<blockquote>
<p><code>tokio::sync::Mutex</code>に切り替えることで、その問題を解決できます。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::Arc;
use tokio::sync::Mutex;

async fn run(m: Arc&lt;Mutex&lt;Vec&lt;u64&gt;&gt;&gt;) {
    let guard = m.lock().await;
    http_call(&amp;guard).await;
    println!("Sent {:?} to the server", &amp;guard);
    // `guard` is dropped here
}
<span class="boring">}</span></code></pre></pre>
<p>Acquiring the lock is now an asynchronous operation, which yields back to the runtime
if it can't make progress.<br />
Going back to the previous scenario, the following would happen:</p>
<blockquote>
<p>現在、ロックの取得は非同期操作で、それが進めることができない場合、（制御を）ランタイムに移譲します。
前のシナリオに戻ると、次が発生します。</p>
</blockquote>
<pre><code class="language-text">       Task A          Task B
          |
  Acquires the lock
  Starts `http_call`
  Yields to runtime
          |
          +--------------+
                         |
             Tries to acquire the lock
              Cannot acquire the lock
                 Yields to runtime
                         |
          +--------------+
          |
`http_call` completes
  Releases the lock
   Yield to runtime
          |
          +--------------+
                         |
                 Acquires the lock
                       [...]
</code></pre>
<p>All good!</p>
<blockquote>
<p>すべてがうまくいきます！</p>
</blockquote>
<h3 id="multithreaded-wont-save-youマルチスレッドは救いません"><a class="header" href="#multithreaded-wont-save-youマルチスレッドは救いません">Multithreaded won't save you（マルチスレッドは救いません）</a></h3>
<p>We've used a single-threaded runtime as the execution context in our
previous example, but the same risk persists even when using a multithreaded
runtime.<br />
The only difference is in the number of concurrent tasks required to create the deadlock:
in a single-threaded runtime, 2 are enough; in a multithreaded runtime, we
would need <code>N+1</code> tasks, where <code>N</code> is the number of runtime threads.</p>
<blockquote>
<p>前の例では実行コンテキストとして単一スレッドランタイムを使用しましたが、同じリスクはマルチスレッドランタイムを使用したときも残ります。
唯一の違いは、デッドロックを作成するために必要な同時並行タスクの数です。
単一スレッドランタイムでは2つで十分でした。
マルチスレッドランタイムでは、<code>N+1</code>のタスクが必要で、<code>N</code>はランタイムスレッドの数です。</p>
</blockquote>
<h3 id="downsides欠点-1"><a class="header" href="#downsides欠点-1">Downsides（欠点）</a></h3>
<p>Having an async-aware <code>Mutex</code> comes with a performance penalty.<br />
If you're confident that the lock isn't under significant contention
<em>and</em> you're careful to never hold it across a yield point, you can
still use <code>std::sync::Mutex</code> in an asynchronous context.</p>
<blockquote>
<p>非同期を理解している<code>Mutex</code>を使用することは、パフォーマンスの不利益を伴います。
ロックが競合状態でないことに自信があり、移譲ポイントをまたいでロックを決して保持しないように注意している場合、まだ非同期コンテキストで<code>std::sync::Mutex</code>を使用できます。</p>
</blockquote>
<p>But weigh the performance benefit against the liveness risk you
will incur.</p>
<blockquote>
<p>ただし、パフォーマンス上の利点と、発生する非生存リスクを比較検討してください。</p>
</blockquote>
<h2 id="other-primitivesほかの構成要素"><a class="header" href="#other-primitivesほかの構成要素">Other primitives（ほかの構成要素）</a></h2>
<p>We used <code>Mutex</code> as an example, but the same applies to <code>RwLock</code>, semaphores, etc.<br />
Prefer async-aware versions when working in an asynchronous context to minimise
the risk of issues.</p>
<blockquote>
<p>例として<code>Mutex</code>を使用しましたが、<code>RwLock</code>、セマフォなどにも同じことが適用されます。
問題のリスクを最小化するために非同期コンテキストで作業するときは、非同期を理解しているバージョンを優先してください。</p>
</blockquote>
<h2 id="exercise-95"><a class="header" href="#exercise-95">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/08_futures/06_async_aware_primitives"><code>08_futures/06_async_aware_primitives</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cancellationキャンセル"><a class="header" href="#cancellationキャンセル">Cancellation（キャンセル）</a></h1>
<p>What happens when a pending future is dropped?<br />
The runtime will no longer poll it, therefore it won't make any further progress.
In other words, its execution has been <strong>cancelled</strong>.</p>
<blockquote>
<p>保留中のフューチャーがドロップされたとき何が起こるでしょうか？
ランタイムをもはやそれをポーリングしないため、それ以上進みません。
言い換えれば、その実行は<strong>キャンセル</strong>されます。</p>
</blockquote>
<p>In the wild, this often happens when working with timeouts.
For example:</p>
<blockquote>
<p>実際に、これはタイムアウトを使用したときによく発生します。
例えば・・・</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tokio::time::timeout;
use tokio::sync::oneshot;
use std::time::Duration;

async fn http_call() {
    // [...]
}

async fn run() {
    // Wrap the future with a `Timeout` set to expire in 10 milliseconds.
    // 期限を10ミリ秒に設定した`Timeout`でフューチャーをラップします。
    let duration = Duration::from_millis(10);
    if let Err(_) = timeout(duration, http_call()).await {
        println!("Didn't receive a value within 10 ms");
    }
}
<span class="boring">}</span></code></pre></pre>
<p>When the timeout expires, the future returned by <code>http_call</code> will be cancelled.
Let's imagine that this is <code>http_call</code>'s body:</p>
<blockquote>
<p>時間切れになったとき、<code>http_call</code>によって返されたフューチャーはキャンセルされます。
次が<code>http_call</code>の本体であると想像しましょう。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::net::TcpStream;

async fn http_call() {
    let (stream, _) = TcpStream::connect(/* */).await.unwrap();
    let request: Vec&lt;u8&gt; = /* */;
    stream.write_all(&amp;request).await.unwrap();
}
<span class="boring">}</span></code></pre></pre>
<p>Each yield point becomes a <strong>cancellation point</strong>.<br />
<code>http_call</code> can't be preempted by the runtime, so it can only be discarded after
it has yielded control back to the executor via <code>.await</code>.
This applies recursively—e.g. <code>stream.write_all(&amp;request)</code> is likely to have multiple
yield points in its implementation. It is perfectly possible to see <code>http_call</code> pushing
a <em>partial</em> request before being cancelled, thus dropping the connection and never
finishing transmitting the body.</p>
<blockquote>
<p>それぞれの移譲ポイントは、<strong>キャンセルポイント</strong>になります。
<code>http_call</code>はランタイムによってプリエンプトされることはないため、それは<code>.await</code>を介してエグゼキューターに制御を移譲した後にのみ、破棄されるます。
これは、再帰的に適用されます。
例えば、<code>stream.write_all(&amp;request)</code>は、その実装内に複数の移譲ポイントを持つ可能性が高いです。
<code>http_call</code>がキャンセルされる前に <em>部分的な</em> リクエストを押入れ、接続が切断されて、本体の送信が終了しない可能性が十分にあります。</p>
</blockquote>
<blockquote>
<p><strong>プリエンプト</strong>: プロセスに与えられたCPU時間を消費したときに、そのプロセスの実行を中断して、他のプロセスにCPUを割り当てること。</p>
</blockquote>
<h2 id="clean-upクリーンアップ"><a class="header" href="#clean-upクリーンアップ">Clean up（クリーンアップ）</a></h2>
<p>Rust's cancellation mechanism is quite powerful—it allows the caller to cancel an ongoing task
without needing any form of cooperation from the task itself.<br />
At the same time, this can be quite dangerous. It may be desirable to perform a
<strong>graceful cancellation</strong>, to ensure that some clean-up tasks are performed
before aborting the operation.</p>
<blockquote>
<p>Rustのキャンセルのメカニズムはとても強力です。
それは、タスク自身からのいかなる形式の協力を必要としないで、呼び出し側に実行中のタスクをキャンセルできるようにします。
それと同時に、これはとても危険になる可能性があります。
それは、操作を中止する前に、いくつかのクリーンアップタスクを実行することを確実にするために、<strong>優雅なキャンセル</strong>を実行することが望ましいかもしれません。</p>
</blockquote>
<p>For example, consider this fictional API for a SQL transaction:</p>
<blockquote>
<p>例えば、SQLトランザクションのために、次の架空のAPIを考えます。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn transfer_money(
    connection: SqlConnection,
    payer_id: u64,
    payee_id: u64,
    amount: u64
) -&gt; Result&lt;(), anyhow::Error&gt; {
    let transaction = connection.begin_transaction().await?;
    update_balance(payer_id, amount, &amp;transaction).await?;
    decrease_balance(payee_id, amount, &amp;transaction).await?;
    transaction.commit().await?;
}
<span class="boring">}</span></code></pre></pre>
<p>On cancellation, it'd be ideal to explicitly abort the pending transaction rather
than leaving it hanging.
Rust, unfortunately, doesn't provide a bullet-proof mechanism for this kind of
<strong>asynchronous</strong> clean up operations.</p>
<blockquote>
<p>キャンセルする場合、保留中のトランザクションを明示的に中止することが、その応答がないまま残しておくよりも理想的です。
不運にも、Rustはこの種の<strong>非同期</strong>クリーンアップ操作を行うための強固なメカニズムを提供していません。</p>
</blockquote>
<p>The most common strategy is to rely on the <code>Drop</code> trait to schedule the required
clean-up work. This can be by:</p>
<ul>
<li>Spawning a new task on the runtime</li>
<li>Enqueueing a message on a channel</li>
<li>Spawning a background thread</li>
</ul>
<blockquote>
<p>最も一般的な戦略は、要求されるクリーンアップ作業をスケジュールするために<code>Drop</code>トレイトに依存することです。
これは、次によって行えます。</p>
<ul>
<li>ランタイム上で新しいタスクを生み出します。</li>
<li>チャネル上のメッセージをキューに入れます。</li>
<li>バックグラウンドスレッドを生み出します。</li>
</ul>
</blockquote>
<p>The optimal choice is contextual.</p>
<blockquote>
<p>最適な選択肢は、状況によって異なります。</p>
</blockquote>
<h2 id="cancelling-spawned-tasks生み出したタスクのキャンセル"><a class="header" href="#cancelling-spawned-tasks生み出したタスクのキャンセル">Cancelling spawned tasks（生み出したタスクのキャンセル）</a></h2>
<p>When you spawn a task using <code>tokio::spawn</code>, you can no longer drop it;
it belongs to the runtime.<br />
Nonetheless, you can use its <code>JoinHandle</code> to cancel it if needed:</p>
<blockquote>
<p><code>tokio::spawn</code>を使用してタスクを生み出したとき、もはやそれをドロップできません。
それはランタイムに属しています。
それにも関わらず、必要に応じて、それをキャンセルするために、その<code>JoinHandle</code>を使用できます。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn run() {
    let handle = tokio::spawn(/* some async task（何らかの非同期タスク） */);
    // Cancel the spawned task
    // 生み出したタスクをキャンセルします。
    handle.abort();
}
<span class="boring">}</span></code></pre></pre>
<h2 id="further-reading参考資料-13"><a class="header" href="#further-reading参考資料-13">Further reading（参考資料）</a></h2>
<ul>
<li>Be extremely careful when using <code>tokio</code>'s <code>select!</code> macro to "race" two different futures.
Retrying the same task in a loop is dangerous unless you can ensure <strong>cancellation safety</strong>.
Check out <a href="https://tokio.rs/tokio/tutorial/select"><code>select!</code>'s documentation</a> for more details.<br />
If you need to interleave two asynchronous streams of data (e.g. a socket and a channel), prefer using
<a href="https://docs.rs/tokio-stream/latest/tokio_stream/trait.StreamExt.html#method.merge"><code>StreamExt::merge</code></a> instead.</li>
<li>Rather than "abrupt" cancellation, it can be preferable to rely
on <a href="https://docs.rs/tokio-util/latest/tokio_util/sync/struct.CancellationToken.html"><code>CancellationToken</code></a>.</li>
</ul>
<blockquote>
<ul>
<li><code>tokio</code>の<code>select!</code>マクロを使用して2つの異なるフューチャーを「競合」させる場合は、細心の注意を払ってください。
<strong>キャンセルの安全性</strong>を確保できない限り、ループ内で同じタスクを再試行することは危険です。
詳細は<code>select!</code>のドキュメントを確認してください。
例えばソケットとチャネルなど、2つの非同期ストリームのデータを交互に処理する必要がある場合、代わりに<code>StreamExt::merge</code>を使用することを優先してください。</li>
<li>「突然の」キャンセルよりも、<code>CancellationToken</code>に依存することが好ましい場合があります。</li>
</ul>
</blockquote>
<h2 id="exercise-96"><a class="header" href="#exercise-96">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/08_futures/07_cancellation"><code>08_futures/07_cancellation</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="outro"><a class="header" href="#outro">Outro</a></h1>
<p>Rust's asynchronous model is quite powerful, but it does introduce additional
complexity. Take time to know your tools: dive deep into <code>tokio</code>'s documentation
and get familiar with its primitives to make the most out of it.</p>
<blockquote>
<p>Rustの非同期モデルはとても強力ですが、追加の複雑さを導入します。
ツールを理解する時間を取ってください。
<code>tokio</code>のドキュメントに深入りして、最大限に利用するためにその構成要素に慣れてください。</p>
</blockquote>
<p>Keep in mind, as well, that there is ongoing work at the language and <code>std</code> level
to streamline and "complete" Rust's asynchronous story. You may experience some
rough edges in your day-to-day work due to some of these missing pieces.</p>
<blockquote>
<p>同様に、Rustの非同期ストーリーを合理化して「完了」するための作業が、言語と<code>std</code>レベルで作業中であることに留意してください。
これらの欠落している部分のために、日々の作業でいくつかの不都合を経験するかもしれません。</p>
</blockquote>
<p>A few recommendations for a mostly-pain-free async experience:</p>
<ul>
<li><strong>Pick a runtime and stick to it.</strong><br />
Some primitives (e.g. timers, I/O) are not portable across runtimes. Trying to
mix runtimes is likely to cause you pain. Trying to write code that's runtime
agnostic can significantly increase the complexity of your codebase. Avoid it
if you can.</li>
<li><strong>There is no stable <code>Stream</code>/<code>AsyncIterator</code> interface yet.</strong><br />
An <code>AsyncIterator</code> is, conceptually, an iterator that yields new items
asynchronously. There is ongoing design work, but no consensus (yet).
If you're using <code>tokio</code>, refer to <a href="https://docs.rs/tokio-stream/latest/tokio_stream/"><code>tokio_stream</code></a>
as your go-to interface.</li>
<li><strong>Be careful with buffering.</strong><br />
It is often the cause of subtle bugs. Check out
<a href="https://rust-lang.github.io/wg-async/vision/submitted_stories/status_quo/barbara_battles_buffered_streams.html">"Barbara battles buffered streams"</a>
for more details.</li>
<li><strong>There is no equivalent of scoped threads for asynchronous tasks</strong>.<br />
Check out <a href="https://without.boats/blog/the-scoped-task-trilemma/">"The scoped task trilemma"</a>
for more details.</li>
</ul>
<blockquote>
<p>非同期体験をほとんど痛みなくするためのいくつかの推奨事項があります。</p>
<ul>
<li><strong>ランタイムを選択して、それに固執してください</strong>
タイマーやI/Oなどのいくつかの構成要素は、ランタイムをまたいで持ち運びできません。
ランタイムを混ぜることは、痛みを引き起こす可能性があります。
ランタイムを理解しないコードを記述することは、コードベースの複雑さを大幅に増加させる可能性があります。
可能であれば、それを避けてください。</li>
<li><strong>まだ安定した<code>Stream</code>/<code>AsyncIterator</code>インターフェイスはありません</strong>
概念的に<code>AsyncIterator</code>は、非同期で新しいアイテムを生み出すイテレーターです。
設計作業中ですが、いまだ合意が得られていません。
<code>tokio</code>を使用している場合、インターフェースとして<code>tokio_stream</code>を参照してください。</li>
<li><strong>バッファリングに注意してください</strong>
それはしばしば微妙なバグの原因になります。詳細は「Barbara battles buffered streams」を確認してください。</li>
<li><strong>非同期タスクにスコープが制限されたスレッドと同等なものはありません</strong>
詳細は「The scoped task trilemma」を確認してください。</li>
</ul>
</blockquote>
<p>Don't let these caveats scare you: asynchronous Rust is being used effectively
at <em>massive</em> scale (e.g. AWS, Meta) to power foundational services.<br />
You will have to master it if you're planning building networked applications
in Rust.</p>
<blockquote>
<p>これらの注意点に怯えないでください。
非同期Rustは、基盤となるサービスを強化するために、例えばAWS、Metaなどの <em>巨大な</em> スケールで効果的に使用されています。
Rustでネットワークアプリケーションの構築を計画している場合、それをマスターする必要があります。</p>
</blockquote>
<h2 id="exercise-97"><a class="header" href="#exercise-97">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/08_futures/08_outro"><code>08_futures/08_outro</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="epilogue"><a class="header" href="#epilogue">Epilogue</a></h1>
<p>Our tour of Rust ends here.<br />
It has been quite extensive, but by no means exhaustive: Rust is a language with
a large surface area, and an even larger ecosystem!<br />
Don't let this scare you, though: there's <strong>no need to learn everything</strong>.
You'll pick up whatever is necessary to be effective in the domain
(backend, embedded, CLIs, GUIs, etc.) <strong>while working on your projects</strong>.</p>
<p>In the end, there are no shortcuts: if you want to get good at something,
you need to do it, over and over again. Throughout this course you wrote a fair
amount of Rust, enough to get the language and its syntax flowing under your
fingers. It'll take many more lines of code to feel it "yours", but that moment
will come without a doubt if you keep practicing.</p>
<h2 id="going-further"><a class="header" href="#going-further">Going further</a></h2>
<p>Let's close with some pointers to additional resources that you might find
useful as you move forward in your journey with Rust.</p>
<h3 id="exercises"><a class="header" href="#exercises">Exercises</a></h3>
<p>You can find more exercises to practice Rust in the <a href="https://github.com/rust-lang/rustlings"><code>rustlings</code></a>
project and on <a href="https://exercism.io">exercism.io</a>'s Rust track.</p>
<h3 id="introductory-material"><a class="header" href="#introductory-material">Introductory material</a></h3>
<p>Check out <a href="https://doc.rust-lang.org/book/title-page.html">the Rust book</a> and
<a href="https://www.oreilly.com/library/view/programming-rust-2nd/9781492052586/">"Programming Rust"</a>
if you're looking for a different perspective on the same concepts we covered throughout this course.
You'll certainly learn something new since they don't cover exactly the same topics; Rust has a lot of surface area!</p>
<h3 id="advanced-material"><a class="header" href="#advanced-material">Advanced material</a></h3>
<p>If you want to dive deeper into the language, refer to the <a href="https://doc.rust-lang.org/nomicon/">Rustonomicon</a>
and <a href="https://nostarch.com/rust-rustaceans">"Rust for Rustaceans"</a>.<br />
The <a href="https://www.youtube.com/playlist?list=PLqbS7AVVErFirH9armw8yXlE6dacF-A6z">"Decrusted" series</a> is another excellent
resource to learn more about the internals of many of the most popular Rust libraries.</p>
<h3 id="domain-specific-material"><a class="header" href="#domain-specific-material">Domain-specific material</a></h3>
<p>If you want to use Rust for backend development,
check out <a href="https://zero2prod.com">"Zero to Production in Rust"</a>.<br />
If you want to use Rust for embedded development,
check out the <a href="https://docs.rust-embedded.org/book/">Embedded Rust book</a>.</p>
<h3 id="masterclasses"><a class="header" href="#masterclasses">Masterclasses</a></h3>
<p>You can then find resources on key topics that cut across domains.<br />
For testing, check out
<a href="https://github.com/mainmatter/rust-advanced-testing-workshop">"Advanced testing, going beyond the basics"</a>.<br />
For telemetry, check out <a href="https://github.com/mainmatter/rust-telemetry-workshop">"You can't fix what you can't see"</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
