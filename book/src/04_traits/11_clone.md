# Copying values, pt. 1（値をコピーする、その1）

In the previous chapter we introduced ownership and borrowing.\
We stated, in particular, that:

- Every value in Rust has a single owner at any given time.
- When a function takes ownership of a value ("it consumes it"), the caller can't use that value anymore.

> 前の章において、所有権と借用を証入しました。
> 特に、次のことを述べました。
>
> - Rustにおけるすべての値は、任意の時点で単独の所有者を持ちます。
> - 関数が値の所有権を得た時（「関数は値を消費します」）、呼び出し元はそれ以上値を使用できません。

These restrictions can be somewhat limiting.\
Sometimes we might have to call a function that takes ownership of a value, but we still need to use
that value afterward.

> これらの制約は、何らかの制限があります。
> 時々、値の所有権を得る関数を呼び出さなくてはなりませんが、その後も、まだその値を使用する必要があるかもしれません。

```rust
fn consumer(s: String) { /* */ }

fn example() {
     let mut s = String::from("hello");
     consumer(s);
     s.push_str(", world!"); // error: value borrowed here after move
                             // エラー: 移動後に、ここで値が借用されています。
}
```

That's where `Clone` comes in.

> それで、`Clone`が登場します。

## `Clone`

`Clone` is a trait defined in Rust's standard library:

> `Clone`は、Rust標準ライブラリ内に定義されたトレイトです。

```rust
pub trait Clone {
    fn clone(&self) -> Self;
}
```

Its method, `clone`, takes a reference to `self` and returns a new **owned** instance of the same type.

> そのメソッドの`Clone`は、`self`への参照を受け取り、同じ型の新しい**所有された**インスタンスを返します。

## In action（活動中）

Going back to the example above, we can use `clone` to create a new `String` instance before calling `consumer`:

> 上記例に戻り、`consumer`を呼び出す前に、新しい`String`インスタンスを作成するために`clone`を使用できます。

```rust
fn consumer(s: String) { /* */ }

fn example() {
     let mut s = String::from("hello");
     let t = s.clone();
     consumer(t);
     s.push_str(", world!"); // no error
                             // エラーなし
}
```

Instead of giving ownership of `s` to `consumer`, we create a new `String` (by cloning `s`) and give
that to `consumer` instead.\
`s` remains valid and usable after the call to `consumer`.

> `s`の所有権を`consumer`に与える代わりに、`s`をクローンして新しい`String`を作成して、`consumer`に代わりにそれを与えます。
> `s`は有効のままで、`consumer`の呼び出し後も使用できます。

## In memory（メモリ無い）

Let's look at what happened in memory in the example above.
When `let mut s: String::from("hello");` is executed, the memory looks like this:

> 上記例でメモリ内に何が起こっているか確認しましょう。
> `let mut s: String::from("hello");`が実行されたとき、メモリは次のようになります。

```text
                    s
      +---------+--------+----------+
Stack | pointer | length | capacity |
      |  |      |   5    |    5     |
      +--|------+--------+----------+
         |
         |
         v
       +---+---+---+---+---+
Heap:  | H | e | l | l | o |
       +---+---+---+---+---+
```

When `let t = s.clone()` is executed, a whole new region is allocated on the heap to store a copy of the data:

> `let t = s.clone()`が実行されると、データのコピーを保存するために、新しい領域全体がヒープ上に割り当てられます。

```text
                    s                                    t
      +---------+--------+----------+      +---------+--------+----------+
Stack | pointer | length | capacity |      | pointer | length | capacity |
      |  |      |   5    |    5     |      |  |      |   5    |    5     |
      +--|------+--------+----------+      +--|------+--------+----------+
         |                                    |
         |                                    |
         v                                    v
       +---+---+---+---+---+                +---+---+---+---+---+
Heap:  | H | e | l | l | o |                | H | e | l | l | o |
       +---+---+---+---+---+                +---+---+---+---+---+
```

If you're coming from a language like Java, you can think of `clone` as a way to create a deep copy of an object.

> Javaのような言語から来た場合、`clone`をオブジェクトのディープコピーを作成する方法のように考えることができます。

## Implementing `Clone`（Cloneの実装）

To make a type `Clone`-able, we have to implement the `Clone` trait for it.\
You almost always implement `Clone` by deriving it:

> 型を`Clone`可能にするために、`Cone`トレイトを実装しなければなりません。
> ほとんど常に、それの導出によって`Clone`を実装します。

```rust
#[derive(Clone)]
struct MyType {
    // fields
}
```

The compiler implements `Clone` for `MyType` as you would expect: it clones each field of `MyType` individually and
then constructs a new `MyType` instance using the cloned fields.\
Remember that you can use `cargo expand` (or your IDE) to explore the code generated by `derive` macros.

> コンパイラーは、期待する通りに`MyType`に対して`Clone`を実装します。
> それは、`MyType`のそれぞれのフィールドを個々にクローンして、クローンされたフィールドを使用して、新しい`MyType`インスタンスを構築します。
> `derive`マクロによって生成されたコードを探求するために、`cargo expand`（またはIDE）を使用できることを忘れないでください。
